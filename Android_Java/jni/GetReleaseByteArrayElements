原始数组
http://blog.csdn.net/nicebooks/article/details/17925521
--------------------------------------------------------------------------------

JNI提供了方法来方法数组对象的内容，但必须一次访问一个数组对象的数据。原始数组可以像C语言那样直接读和写。

为了使接口高效而且不受虚拟机实现的制约, Get<PrimitiveType>ArrayElements系列函数允许返回一个指向实际元素的指针, 或者分配一些内存来拷贝数据. 无论哪种方式, 返回的原始数据的指针在调用释放方法前是保证一直有效的(这意味着如果数据没有被拷贝, 这个对象数组将被限制在压缩堆数据时不能移动). 你必须自己释放每个你获取的数组. 同时如果Get方法失败的话,你的代码一定不能尝试释放一个NULL指针.

最有用的是, 你可以通过传一个非空指针作为isCopy的参数来决定是否拷贝数据.

那些释放方法有一个mode参数, 这个参数有3个值, 根据这个参数, 这个方法在运行时会根据指针是指向原始数据还是拷贝的数据有不同的表现.

•0

◦原始数据: 对象数组将不会被限制. 

◦拷贝数据: 数据将会拷贝回原始数据, 同时释放拷贝数据. 

•JNI_COMMIT

◦原始数据: 什么都不作. 

◦拷贝数据: 数据将会拷贝回原始数据, 不释放拷贝数据.

•JNI_ABORT

◦原始数据: 对象数组将不会被限制, 之前的数据操作有效.. 

◦拷贝数据: 释放拷贝数据, 之前的任何数据操作会丢弃. 

如果你对对象数组做了修改, 并且你有可能会根据对象数组的内容来决定是修改还是继续执行其他代码, 那么

检查isCopy参数是你是否需要用JNI_COMMIT来调用释放方法的一个理由, 你可以不做操作. 另一个可能的原因，检查该参数是为了使用JNI_ABORT的高效处理.例如, 你可能需要获得一个数组, 临时修改一下,然后将部分数据传给其他方法, 最后丢弃之前的修改. 如果你知道JNI是作了拷贝数据的Get, 那就不需要另外创建一份拷贝来修改. 但如果JNI是把原始数据传给你, 那么你需要自己拷贝一份数据来进行修改.

一个最容易犯的错误是如果isCopy是false, 有人以为可以不调用释放方法(这在例子代码中有很多这样的错误). 因为即使没有拷贝数据, 原始数据也是被限制不能回收的.所以要主动调用释放方法来释放.

同时要注意JNI_COMMIT标志不会释放数组, 你终究需要再次用另外一个标志来调用释放方法

librtmp.so:     file format elf32-littlearm


Disassembly of section .plt:

00004fd8 <__cxa_atexit@plt-0x14>:
    4fd8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    4fdc:	e59fe004 	ldr	lr, [pc, #4]	; 4fe8 <__cxa_atexit@plt-0x4>
    4fe0:	e08fe00e 	add	lr, pc, lr
    4fe4:	e5bef008 	ldr	pc, [lr, #8]!
    4fe8:	0001edd8 	ldrdeq	lr, [r1], -r8

00004fec <__cxa_atexit@plt>:
    4fec:	e28fc600 	add	ip, pc, #0, 12
    4ff0:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    4ff4:	e5bcfdd8 	ldr	pc, [ip, #3544]!	; 0xdd8

00004ff8 <__cxa_finalize@plt>:
    4ff8:	e28fc600 	add	ip, pc, #0, 12
    4ffc:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5000:	e5bcfdd0 	ldr	pc, [ip, #3536]!	; 0xdd0

00005004 <free@plt>:
    5004:	e28fc600 	add	ip, pc, #0, 12
    5008:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    500c:	e5bcfdc8 	ldr	pc, [ip, #3528]!	; 0xdc8

00005010 <__assert2@plt>:
    5010:	e28fc600 	add	ip, pc, #0, 12
    5014:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5018:	e5bcfdc0 	ldr	pc, [ip, #3520]!	; 0xdc0

0000501c <malloc@plt>:
    501c:	e28fc600 	add	ip, pc, #0, 12
    5020:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5024:	e5bcfdb8 	ldr	pc, [ip, #3512]!	; 0xdb8

00005028 <mpi_init_polarssl@plt>:
    5028:	e28fc600 	add	ip, pc, #0, 12
    502c:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5030:	e5bcfdb0 	ldr	pc, [ip, #3504]!	; 0xdb0

00005034 <mpi_lset_polarssl@plt>:
    5034:	e28fc600 	add	ip, pc, #0, 12
    5038:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    503c:	e5bcfda8 	ldr	pc, [ip, #3496]!	; 0xda8

00005040 <mpi_cmp_mpi_polarssl@plt>:
    5040:	e28fc600 	add	ip, pc, #0, 12
    5044:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5048:	e5bcfda0 	ldr	pc, [ip, #3488]!	; 0xda0

0000504c <mpi_copy_polarssl@plt>:
    504c:	e28fc600 	add	ip, pc, #0, 12
    5050:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5054:	e5bcfd98 	ldr	pc, [ip, #3480]!	; 0xd98

00005058 <mpi_sub_int_polarssl@plt>:
    5058:	e28fc600 	add	ip, pc, #0, 12
    505c:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5060:	e5bcfd90 	ldr	pc, [ip, #3472]!	; 0xd90

00005064 <mpi_exp_mod_polarssl@plt>:
    5064:	e28fc600 	add	ip, pc, #0, 12
    5068:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    506c:	e5bcfd88 	ldr	pc, [ip, #3464]!	; 0xd88

00005070 <mpi_cmp_int_polarssl@plt>:
    5070:	e28fc600 	add	ip, pc, #0, 12
    5074:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5078:	e5bcfd80 	ldr	pc, [ip, #3456]!	; 0xd80

0000507c <mpi_free_polarssl@plt>:
    507c:	e28fc600 	add	ip, pc, #0, 12
    5080:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5084:	e5bcfd78 	ldr	pc, [ip, #3448]!	; 0xd78

00005088 <dhm_make_public@plt>:
    5088:	e28fc600 	add	ip, pc, #0, 12
    508c:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5090:	e5bcfd70 	ldr	pc, [ip, #3440]!	; 0xd70

00005094 <mpi_read_string_polarssl@plt>:
    5094:	e28fc600 	add	ip, pc, #0, 12
    5098:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    509c:	e5bcfd68 	ldr	pc, [ip, #3432]!	; 0xd68

000050a0 <sha2_hmac_starts@plt>:
    50a0:	e28fc600 	add	ip, pc, #0, 12
    50a4:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    50a8:	e5bcfd60 	ldr	pc, [ip, #3424]!	; 0xd60

000050ac <sha2_hmac_update@plt>:
    50ac:	e28fc600 	add	ip, pc, #0, 12
    50b0:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    50b4:	e5bcfd58 	ldr	pc, [ip, #3416]!	; 0xd58

000050b8 <sha2_hmac_finish@plt>:
    50b8:	e28fc600 	add	ip, pc, #0, 12
    50bc:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    50c0:	e5bcfd50 	ldr	pc, [ip, #3408]!	; 0xd50

000050c4 <arc4_setup@plt>:
    50c4:	e28fc600 	add	ip, pc, #0, 12
    50c8:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    50cc:	e5bcfd48 	ldr	pc, [ip, #3400]!	; 0xd48

000050d0 <memset@plt>:
    50d0:	e28fc600 	add	ip, pc, #0, 12
    50d4:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    50d8:	e5bcfd40 	ldr	pc, [ip, #3392]!	; 0xd40

000050dc <snprintf@plt>:
    50dc:	e28fc600 	add	ip, pc, #0, 12
    50e0:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    50e4:	e5bcfd38 	ldr	pc, [ip, #3384]!	; 0xd38

000050e8 <strchr@plt>:
    50e8:	e28fc600 	add	ip, pc, #0, 12
    50ec:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    50f0:	e5bcfd30 	ldr	pc, [ip, #3376]!	; 0xd30

000050f4 <strdup@plt>:
    50f4:	e28fc600 	add	ip, pc, #0, 12
    50f8:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    50fc:	e5bcfd28 	ldr	pc, [ip, #3368]!	; 0xd28

00005100 <strlen@plt>:
    5100:	e28fc600 	add	ip, pc, #0, 12
    5104:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5108:	e5bcfd20 	ldr	pc, [ip, #3360]!	; 0xd20

0000510c <atoi@plt>:
    510c:	e28fc600 	add	ip, pc, #0, 12
    5110:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5114:	e5bcfd18 	ldr	pc, [ip, #3352]!	; 0xd18

00005118 <base64_encode@plt>:
    5118:	e28fc600 	add	ip, pc, #0, 12
    511c:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5120:	e5bcfd10 	ldr	pc, [ip, #3344]!	; 0xd10

00005124 <calloc@plt>:
    5124:	e28fc600 	add	ip, pc, #0, 12
    5128:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    512c:	e5bcfd08 	ldr	pc, [ip, #3336]!	; 0xd08

00005130 <dhm_free@plt>:
    5130:	e28fc600 	add	ip, pc, #0, 12
    5134:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5138:	e5bcfd00 	ldr	pc, [ip, #3328]!	; 0xd00

0000513c <mpi_size_polarssl@plt>:
    513c:	e28fc600 	add	ip, pc, #0, 12
    5140:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5144:	e5bcfcf8 	ldr	pc, [ip, #3320]!	; 0xcf8

00005148 <mpi_write_binary_polarssl@plt>:
    5148:	e28fc600 	add	ip, pc, #0, 12
    514c:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5150:	e5bcfcf0 	ldr	pc, [ip, #3312]!	; 0xcf0

00005154 <mpi_read_binary_polarssl@plt>:
    5154:	e28fc600 	add	ip, pc, #0, 12
    5158:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    515c:	e5bcfce8 	ldr	pc, [ip, #3304]!	; 0xce8

00005160 <dhm_calc_secret@plt>:
    5160:	e28fc600 	add	ip, pc, #0, 12
    5164:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5168:	e5bcfce0 	ldr	pc, [ip, #3296]!	; 0xce0

0000516c <sprintf@plt>:
    516c:	e28fc600 	add	ip, pc, #0, 12
    5170:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5174:	e5bcfcd8 	ldr	pc, [ip, #3288]!	; 0xcd8

00005178 <strstr@plt>:
    5178:	e28fc600 	add	ip, pc, #0, 12
    517c:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5180:	e5bcfcd0 	ldr	pc, [ip, #3280]!	; 0xcd0

00005184 <strncpy@plt>:
    5184:	e28fc600 	add	ip, pc, #0, 12
    5188:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    518c:	e5bcfcc8 	ldr	pc, [ip, #3272]!	; 0xcc8

00005190 <strcmp@plt>:
    5190:	e28fc600 	add	ip, pc, #0, 12
    5194:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5198:	e5bcfcc0 	ldr	pc, [ip, #3264]!	; 0xcc0

0000519c <md5_starts@plt>:
    519c:	e28fc600 	add	ip, pc, #0, 12
    51a0:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    51a4:	e5bcfcb8 	ldr	pc, [ip, #3256]!	; 0xcb8

000051a8 <md5_update_polarssl@plt>:
    51a8:	e28fc600 	add	ip, pc, #0, 12
    51ac:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    51b0:	e5bcfcb0 	ldr	pc, [ip, #3248]!	; 0xcb0

000051b4 <md5_finish_polarssl@plt>:
    51b4:	e28fc600 	add	ip, pc, #0, 12
    51b8:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    51bc:	e5bcfca8 	ldr	pc, [ip, #3240]!	; 0xca8

000051c0 <lrand48@plt>:
    51c0:	e28fc600 	add	ip, pc, #0, 12
    51c4:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    51c8:	e5bcfca0 	ldr	pc, [ip, #3232]!	; 0xca0

000051cc <memcpy@plt>:
    51cc:	e28fc600 	add	ip, pc, #0, 12
    51d0:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    51d4:	e5bcfc98 	ldr	pc, [ip, #3224]!	; 0xc98

000051d8 <memcmp@plt>:
    51d8:	e28fc600 	add	ip, pc, #0, 12
    51dc:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    51e0:	e5bcfc90 	ldr	pc, [ip, #3216]!	; 0xc90

000051e4 <time@plt>:
    51e4:	e28fc600 	add	ip, pc, #0, 12
    51e8:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    51ec:	e5bcfc88 	ldr	pc, [ip, #3208]!	; 0xc88

000051f0 <srand48@plt>:
    51f0:	e28fc600 	add	ip, pc, #0, 12
    51f4:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    51f8:	e5bcfc80 	ldr	pc, [ip, #3200]!	; 0xc80

000051fc <strcpy@plt>:
    51fc:	e28fc600 	add	ip, pc, #0, 12
    5200:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5204:	e5bcfc78 	ldr	pc, [ip, #3192]!	; 0xc78

00005208 <entropy_init@plt>:
    5208:	e28fc600 	add	ip, pc, #0, 12
    520c:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5210:	e5bcfc70 	ldr	pc, [ip, #3184]!	; 0xc70

00005214 <ctr_drbg_init@plt>:
    5214:	e28fc600 	add	ip, pc, #0, 12
    5218:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    521c:	e5bcfc68 	ldr	pc, [ip, #3176]!	; 0xc68

00005220 <rsa_init@plt>:
    5220:	e28fc600 	add	ip, pc, #0, 12
    5224:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5228:	e5bcfc60 	ldr	pc, [ip, #3168]!	; 0xc60

0000522c <mpi_msb_polarssl@plt>:
    522c:	e28fc600 	add	ip, pc, #0, 12
    5230:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5234:	e5bcfc58 	ldr	pc, [ip, #3160]!	; 0xc58

00005238 <rsa_pkcs1_encrypt@plt>:
    5238:	e28fc600 	add	ip, pc, #0, 12
    523c:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5240:	e5bcfc50 	ldr	pc, [ip, #3152]!	; 0xc50

00005244 <md5@plt>:
    5244:	e28fc600 	add	ip, pc, #0, 12
    5248:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    524c:	e5bcfc48 	ldr	pc, [ip, #3144]!	; 0xc48

00005250 <puts@plt>:
    5250:	e28fc600 	add	ip, pc, #0, 12
    5254:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5258:	e5bcfc40 	ldr	pc, [ip, #3136]!	; 0xc40

0000525c <pthread_mutex_lock@plt>:
    525c:	e28fc600 	add	ip, pc, #0, 12
    5260:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5264:	e5bcfc38 	ldr	pc, [ip, #3128]!	; 0xc38

00005268 <pthread_mutex_unlock@plt>:
    5268:	e28fc600 	add	ip, pc, #0, 12
    526c:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5270:	e5bcfc30 	ldr	pc, [ip, #3120]!	; 0xc30

00005274 <sysconf@plt>:
    5274:	e28fc600 	add	ip, pc, #0, 12
    5278:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    527c:	e5bcfc28 	ldr	pc, [ip, #3112]!	; 0xc28

00005280 <times@plt>:
    5280:	e28fc600 	add	ip, pc, #0, 12
    5284:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5288:	e5bcfc20 	ldr	pc, [ip, #3104]!	; 0xc20

0000528c <gettimeofday@plt>:
    528c:	e28fc600 	add	ip, pc, #0, 12
    5290:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5294:	e5bcfc18 	ldr	pc, [ip, #3096]!	; 0xc18

00005298 <__aeabi_uldivmod@plt>:
    5298:	e28fc600 	add	ip, pc, #0, 12
    529c:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    52a0:	e5bcfc10 	ldr	pc, [ip, #3088]!	; 0xc10

000052a4 <havege_init@plt>:
    52a4:	e28fc600 	add	ip, pc, #0, 12
    52a8:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    52ac:	e5bcfc08 	ldr	pc, [ip, #3080]!	; 0xc08

000052b0 <x509parse_crtfile_polarssl@plt>:
    52b0:	e28fc600 	add	ip, pc, #0, 12
    52b4:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    52b8:	e5bcfc00 	ldr	pc, [ip, #3072]!	; 0xc00

000052bc <x509parse_keyfile_polarssl@plt>:
    52bc:	e28fc600 	add	ip, pc, #0, 12
    52c0:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    52c4:	e5bcfbf8 	ldr	pc, [ip, #3064]!	; 0xbf8

000052c8 <x509_free_polarssl@plt>:
    52c8:	e28fc600 	add	ip, pc, #0, 12
    52cc:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    52d0:	e5bcfbf0 	ldr	pc, [ip, #3056]!	; 0xbf0

000052d4 <rsa_free@plt>:
    52d4:	e28fc600 	add	ip, pc, #0, 12
    52d8:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    52dc:	e5bcfbe8 	ldr	pc, [ip, #3048]!	; 0xbe8

000052e0 <strcasecmp@plt>:
    52e0:	e28fc600 	add	ip, pc, #0, 12
    52e4:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    52e8:	e5bcfbe0 	ldr	pc, [ip, #3040]!	; 0xbe0

000052ec <strtol@plt>:
    52ec:	e28fc600 	add	ip, pc, #0, 12
    52f0:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    52f4:	e5bcfbd8 	ldr	pc, [ip, #3032]!	; 0xbd8

000052f8 <strtod@plt>:
    52f8:	e28fc600 	add	ip, pc, #0, 12
    52fc:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5300:	e5bcfbd0 	ldr	pc, [ip, #3024]!	; 0xbd0

00005304 <printf@plt>:
    5304:	e28fc600 	add	ip, pc, #0, 12
    5308:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    530c:	e5bcfbc8 	ldr	pc, [ip, #3016]!	; 0xbc8

00005310 <sscanf@plt>:
    5310:	e28fc600 	add	ip, pc, #0, 12
    5314:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5318:	e5bcfbc0 	ldr	pc, [ip, #3008]!	; 0xbc0

0000531c <ssl_init@plt>:
    531c:	e28fc600 	add	ip, pc, #0, 12
    5320:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5324:	e5bcfbb8 	ldr	pc, [ip, #3000]!	; 0xbb8

00005328 <ssl_set_endpoint@plt>:
    5328:	e28fc600 	add	ip, pc, #0, 12
    532c:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5330:	e5bcfbb0 	ldr	pc, [ip, #2992]!	; 0xbb0

00005334 <ssl_set_authmode@plt>:
    5334:	e28fc600 	add	ip, pc, #0, 12
    5338:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    533c:	e5bcfba8 	ldr	pc, [ip, #2984]!	; 0xba8

00005340 <ssl_set_rng@plt>:
    5340:	e28fc600 	add	ip, pc, #0, 12
    5344:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5348:	e5bcfba0 	ldr	pc, [ip, #2976]!	; 0xba0

0000534c <ssl_set_ciphersuites@plt>:
    534c:	e28fc600 	add	ip, pc, #0, 12
    5350:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5354:	e5bcfb98 	ldr	pc, [ip, #2968]!	; 0xb98

00005358 <ssl_set_session@plt>:
    5358:	e28fc600 	add	ip, pc, #0, 12
    535c:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5360:	e5bcfb90 	ldr	pc, [ip, #2960]!	; 0xb90

00005364 <ssl_set_own_cert@plt>:
    5364:	e28fc600 	add	ip, pc, #0, 12
    5368:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    536c:	e5bcfb88 	ldr	pc, [ip, #2952]!	; 0xb88

00005370 <ssl_set_dh_param@plt>:
    5370:	e28fc600 	add	ip, pc, #0, 12
    5374:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5378:	e5bcfb80 	ldr	pc, [ip, #2944]!	; 0xb80

0000537c <ssl_set_bio@plt>:
    537c:	e28fc600 	add	ip, pc, #0, 12
    5380:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5384:	e5bcfb78 	ldr	pc, [ip, #2936]!	; 0xb78

00005388 <ssl_handshake@plt>:
    5388:	e28fc600 	add	ip, pc, #0, 12
    538c:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5390:	e5bcfb70 	ldr	pc, [ip, #2928]!	; 0xb70

00005394 <ssl_read@plt>:
    5394:	e28fc600 	add	ip, pc, #0, 12
    5398:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    539c:	e5bcfb68 	ldr	pc, [ip, #2920]!	; 0xb68

000053a0 <__errno@plt>:
    53a0:	e28fc600 	add	ip, pc, #0, 12
    53a4:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    53a8:	e5bcfb60 	ldr	pc, [ip, #2912]!	; 0xb60

000053ac <recv@plt>:
    53ac:	e28fc600 	add	ip, pc, #0, 12
    53b0:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    53b4:	e5bcfb58 	ldr	pc, [ip, #2904]!	; 0xb58

000053b8 <strncmp@plt>:
    53b8:	e28fc600 	add	ip, pc, #0, 12
    53bc:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    53c0:	e5bcfb50 	ldr	pc, [ip, #2896]!	; 0xb50

000053c4 <strncasecmp@plt>:
    53c4:	e28fc600 	add	ip, pc, #0, 12
    53c8:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    53cc:	e5bcfb48 	ldr	pc, [ip, #2888]!	; 0xb48

000053d0 <ssl_write@plt>:
    53d0:	e28fc600 	add	ip, pc, #0, 12
    53d4:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    53d8:	e5bcfb40 	ldr	pc, [ip, #2880]!	; 0xb40

000053dc <send@plt>:
    53dc:	e28fc600 	add	ip, pc, #0, 12
    53e0:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    53e4:	e5bcfb38 	ldr	pc, [ip, #2872]!	; 0xb38

000053e8 <ssl_close_notify@plt>:
    53e8:	e28fc600 	add	ip, pc, #0, 12
    53ec:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    53f0:	e5bcfb30 	ldr	pc, [ip, #2864]!	; 0xb30

000053f4 <ssl_free@plt>:
    53f4:	e28fc600 	add	ip, pc, #0, 12
    53f8:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    53fc:	e5bcfb28 	ldr	pc, [ip, #2856]!	; 0xb28

00005400 <close@plt>:
    5400:	e28fc600 	add	ip, pc, #0, 12
    5404:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5408:	e5bcfb20 	ldr	pc, [ip, #2848]!	; 0xb20

0000540c <strrchr@plt>:
    540c:	e28fc600 	add	ip, pc, #0, 12
    5410:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5414:	e5bcfb18 	ldr	pc, [ip, #2840]!	; 0xb18

00005418 <getaddrinfo@plt>:
    5418:	e28fc600 	add	ip, pc, #0, 12
    541c:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5420:	e5bcfb10 	ldr	pc, [ip, #2832]!	; 0xb10

00005424 <fcntl@plt>:
    5424:	e28fc600 	add	ip, pc, #0, 12
    5428:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    542c:	e5bcfb08 	ldr	pc, [ip, #2824]!	; 0xb08

00005430 <connect@plt>:
    5430:	e28fc600 	add	ip, pc, #0, 12
    5434:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5438:	e5bcfb00 	ldr	pc, [ip, #2816]!	; 0xb00

0000543c <socket@plt>:
    543c:	e28fc600 	add	ip, pc, #0, 12
    5440:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5444:	e5bcfaf8 	ldr	pc, [ip, #2808]!	; 0xaf8

00005448 <select@plt>:
    5448:	e28fc600 	add	ip, pc, #0, 12
    544c:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5450:	e5bcfaf0 	ldr	pc, [ip, #2800]!	; 0xaf0

00005454 <freeaddrinfo@plt>:
    5454:	e28fc600 	add	ip, pc, #0, 12
    5458:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    545c:	e5bcfae8 	ldr	pc, [ip, #2792]!	; 0xae8

00005460 <setsockopt@plt>:
    5460:	e28fc600 	add	ip, pc, #0, 12
    5464:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5468:	e5bcfae0 	ldr	pc, [ip, #2784]!	; 0xae0

0000546c <memchr@plt>:
    546c:	e28fc600 	add	ip, pc, #0, 12
    5470:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5474:	e5bcfad8 	ldr	pc, [ip, #2776]!	; 0xad8

00005478 <arc4_crypt@plt>:
    5478:	e28fc600 	add	ip, pc, #0, 12
    547c:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5480:	e5bcfad0 	ldr	pc, [ip, #2768]!	; 0xad0

00005484 <realloc@plt>:
    5484:	e28fc600 	add	ip, pc, #0, 12
    5488:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    548c:	e5bcfac8 	ldr	pc, [ip, #2760]!	; 0xac8

00005490 <sleep@plt>:
    5490:	e28fc600 	add	ip, pc, #0, 12
    5494:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5498:	e5bcfac0 	ldr	pc, [ip, #2752]!	; 0xac0

0000549c <__aeabi_uidivmod@plt>:
    549c:	e28fc600 	add	ip, pc, #0, 12
    54a0:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    54a4:	e5bcfab8 	ldr	pc, [ip, #2744]!	; 0xab8

000054a8 <inet_addr@plt>:
    54a8:	e28fc600 	add	ip, pc, #0, 12
    54ac:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    54b0:	e5bcfab0 	ldr	pc, [ip, #2736]!	; 0xab0

000054b4 <getsockopt@plt>:
    54b4:	e28fc600 	add	ip, pc, #0, 12
    54b8:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    54bc:	e5bcfaa8 	ldr	pc, [ip, #2728]!	; 0xaa8

000054c0 <inet_ntop@plt>:
    54c0:	e28fc600 	add	ip, pc, #0, 12
    54c4:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    54c8:	e5bcfaa0 	ldr	pc, [ip, #2720]!	; 0xaa0

000054cc <gethostbyname@plt>:
    54cc:	e28fc600 	add	ip, pc, #0, 12
    54d0:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    54d4:	e5bcfa98 	ldr	pc, [ip, #2712]!	; 0xa98

000054d8 <floor@plt>:
    54d8:	e28fc600 	add	ip, pc, #0, 12
    54dc:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    54e0:	e5bcfa90 	ldr	pc, [ip, #2704]!	; 0xa90

000054e4 <tolower@plt>:
    54e4:	e28fc600 	add	ip, pc, #0, 12
    54e8:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    54ec:	e5bcfa88 	ldr	pc, [ip, #2696]!	; 0xa88

000054f0 <pow@plt>:
    54f0:	e28fc600 	add	ip, pc, #0, 12
    54f4:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    54f8:	e5bcfa80 	ldr	pc, [ip, #2688]!	; 0xa80

000054fc <vsnprintf@plt>:
    54fc:	e28fc600 	add	ip, pc, #0, 12
    5500:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5504:	e5bcfa78 	ldr	pc, [ip, #2680]!	; 0xa78

00005508 <fprintf@plt>:
    5508:	e28fc600 	add	ip, pc, #0, 12
    550c:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5510:	e5bcfa70 	ldr	pc, [ip, #2672]!	; 0xa70

00005514 <putc@plt>:
    5514:	e28fc600 	add	ip, pc, #0, 12
    5518:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    551c:	e5bcfa68 	ldr	pc, [ip, #2664]!	; 0xa68

00005520 <isprint@plt>:
    5520:	e28fc600 	add	ip, pc, #0, 12
    5524:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5528:	e5bcfa60 	ldr	pc, [ip, #2656]!	; 0xa60

0000552c <fputs@plt>:
    552c:	e28fc600 	add	ip, pc, #0, 12
    5530:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5534:	e5bcfa58 	ldr	pc, [ip, #2648]!	; 0xa58

00005538 <fflush@plt>:
    5538:	e28fc600 	add	ip, pc, #0, 12
    553c:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5540:	e5bcfa50 	ldr	pc, [ip, #2640]!	; 0xa50

00005544 <inflate@plt>:
    5544:	e28fc600 	add	ip, pc, #0, 12
    5548:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    554c:	e5bcfa48 	ldr	pc, [ip, #2632]!	; 0xa48

00005550 <getenv@plt>:
    5550:	e28fc600 	add	ip, pc, #0, 12
    5554:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5558:	e5bcfa40 	ldr	pc, [ip, #2624]!	; 0xa40

0000555c <fopen@plt>:
    555c:	e28fc600 	add	ip, pc, #0, 12
    5560:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5564:	e5bcfa38 	ldr	pc, [ip, #2616]!	; 0xa38

00005568 <fgets@plt>:
    5568:	e28fc600 	add	ip, pc, #0, 12
    556c:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5570:	e5bcfa30 	ldr	pc, [ip, #2608]!	; 0xa30

00005574 <ftell@plt>:
    5574:	e28fc600 	add	ip, pc, #0, 12
    5578:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    557c:	e5bcfa28 	ldr	pc, [ip, #2600]!	; 0xa28

00005580 <fclose@plt>:
    5580:	e28fc600 	add	ip, pc, #0, 12
    5584:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5588:	e5bcfa20 	ldr	pc, [ip, #2592]!	; 0xa20

0000558c <inflateInit_@plt>:
    558c:	e28fc600 	add	ip, pc, #0, 12
    5590:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5594:	e5bcfa18 	ldr	pc, [ip, #2584]!	; 0xa18

00005598 <inflateEnd@plt>:
    5598:	e28fc600 	add	ip, pc, #0, 12
    559c:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    55a0:	e5bcfa10 	ldr	pc, [ip, #2576]!	; 0xa10

000055a4 <isspace@plt>:
    55a4:	e28fc600 	add	ip, pc, #0, 12
    55a8:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    55ac:	e5bcfa08 	ldr	pc, [ip, #2568]!	; 0xa08

000055b0 <mktime@plt>:
    55b0:	e28fc600 	add	ip, pc, #0, 12
    55b4:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    55b8:	e5bcfa00 	ldr	pc, [ip, #2560]!	; 0xa00

000055bc <fseek@plt>:
    55bc:	e28fc600 	add	ip, pc, #0, 12
    55c0:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    55c4:	e5bcf9f8 	ldr	pc, [ip, #2552]!	; 0x9f8

000055c8 <gmtime@plt>:
    55c8:	e28fc600 	add	ip, pc, #0, 12
    55cc:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    55d0:	e5bcf9f0 	ldr	pc, [ip, #2544]!	; 0x9f0

000055d4 <fwrite@plt>:
    55d4:	e28fc600 	add	ip, pc, #0, 12
    55d8:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    55dc:	e5bcf9e8 	ldr	pc, [ip, #2536]!	; 0x9e8

000055e0 <fputc@plt>:
    55e0:	e28fc600 	add	ip, pc, #0, 12
    55e4:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    55e8:	e5bcf9e0 	ldr	pc, [ip, #2528]!	; 0x9e0

000055ec <localtime@plt>:
    55ec:	e28fc600 	add	ip, pc, #0, 12
    55f0:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    55f4:	e5bcf9d8 	ldr	pc, [ip, #2520]!	; 0x9d8

000055f8 <strerror@plt>:
    55f8:	e28fc600 	add	ip, pc, #0, 12
    55fc:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5600:	e5bcf9d0 	ldr	pc, [ip, #2512]!	; 0x9d0

00005604 <usleep@plt>:
    5604:	e28fc600 	add	ip, pc, #0, 12
    5608:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    560c:	e5bcf9c8 	ldr	pc, [ip, #2504]!	; 0x9c8

00005610 <pthread_attr_init@plt>:
    5610:	e28fc600 	add	ip, pc, #0, 12
    5614:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5618:	e5bcf9c0 	ldr	pc, [ip, #2496]!	; 0x9c0

0000561c <pthread_attr_setdetachstate@plt>:
    561c:	e28fc600 	add	ip, pc, #0, 12
    5620:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5624:	e5bcf9b8 	ldr	pc, [ip, #2488]!	; 0x9b8

00005628 <pthread_create@plt>:
    5628:	e28fc600 	add	ip, pc, #0, 12
    562c:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5630:	e5bcf9b0 	ldr	pc, [ip, #2480]!	; 0x9b0

00005634 <pthread_mutexattr_init@plt>:
    5634:	e28fc600 	add	ip, pc, #0, 12
    5638:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    563c:	e5bcf9a8 	ldr	pc, [ip, #2472]!	; 0x9a8

00005640 <pthread_mutexattr_settype@plt>:
    5640:	e28fc600 	add	ip, pc, #0, 12
    5644:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5648:	e5bcf9a0 	ldr	pc, [ip, #2464]!	; 0x9a0

0000564c <pthread_mutex_init@plt>:
    564c:	e28fc600 	add	ip, pc, #0, 12
    5650:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5654:	e5bcf998 	ldr	pc, [ip, #2456]!	; 0x998

00005658 <pthread_mutexattr_destroy@plt>:
    5658:	e28fc600 	add	ip, pc, #0, 12
    565c:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5660:	e5bcf990 	ldr	pc, [ip, #2448]!	; 0x990

00005664 <pthread_mutex_destroy@plt>:
    5664:	e28fc600 	add	ip, pc, #0, 12
    5668:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    566c:	e5bcf988 	ldr	pc, [ip, #2440]!	; 0x988

00005670 <pthread_join@plt>:
    5670:	e28fc600 	add	ip, pc, #0, 12
    5674:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5678:	e5bcf980 	ldr	pc, [ip, #2432]!	; 0x980

0000567c <__aeabi_idiv0@plt>:
    567c:	e28fc600 	add	ip, pc, #0, 12
    5680:	e28cca1e 	add	ip, ip, #122880	; 0x1e000
    5684:	e5bcf978 	ldr	pc, [ip, #2424]!	; 0x978

Disassembly of section .text:

00005688 <__on_dlclose>:
    5688:	e59f0004 	ldr	r0, [pc, #4]	; 5694 <__on_dlclose+0xc>
    568c:	e08f0000 	add	r0, pc, r0
    5690:	eafffe58 	b	4ff8 <__cxa_finalize@plt>
    5694:	0001e96c 	.word	0x0001e96c

00005698 <__atexit_handler_wrapper>:
    5698:	e3500000 	cmp	r0, #0
    569c:	012fff1e 	bxeq	lr
    56a0:	e12fff10 	bx	r0

000056a4 <atexit>:
    56a4:	e1a01000 	mov	r1, r0
    56a8:	e59f200c 	ldr	r2, [pc, #12]	; 56bc <atexit+0x18>
    56ac:	e59f000c 	ldr	r0, [pc, #12]	; 56c0 <atexit+0x1c>
    56b0:	e08f2002 	add	r2, pc, r2
    56b4:	e08f0000 	add	r0, pc, r0
    56b8:	eafffe4b 	b	4fec <__cxa_atexit@plt>
    56bc:	0001e948 	.word	0x0001e948
    56c0:	ffffffdc 	.word	0xffffffdc

000056c4 <rtmpe8_sig>:

/* RTMPE type 8 uses XTEA on the regular signature
 * http://en.wikipedia.org/wiki/XTEA
 */
static void rtmpe8_sig(uint8_t *in, uint8_t *out, int keyid)
{
    56c4:	e92d40f0 	push	{r4, r5, r6, r7, lr}
  unsigned int i, num_rounds = 32;
  uint32_t v0, v1, sum=0, delta=0x9E3779B9;
  uint32_t const *k;

  v0 = in[0] | (in[1] << 8) | (in[2] << 16) | (in[3] << 24);
    56c8:	e5d04002 	ldrb	r4, [r0, #2]
  v1 = in[4] | (in[5] << 8) | (in[6] << 16) | (in[7] << 24);
    56cc:	e5d05006 	ldrb	r5, [r0, #6]
{
  unsigned int i, num_rounds = 32;
  uint32_t v0, v1, sum=0, delta=0x9E3779B9;
  uint32_t const *k;

  v0 = in[0] | (in[1] << 8) | (in[2] << 16) | (in[3] << 24);
    56d0:	e5d0c001 	ldrb	ip, [r0, #1]
  v1 = in[4] | (in[5] << 8) | (in[6] << 16) | (in[7] << 24);
    56d4:	e5d03005 	ldrb	r3, [r0, #5]
{
  unsigned int i, num_rounds = 32;
  uint32_t v0, v1, sum=0, delta=0x9E3779B9;
  uint32_t const *k;

  v0 = in[0] | (in[1] << 8) | (in[2] << 16) | (in[3] << 24);
    56d8:	e1a04804 	lsl	r4, r4, #16
    56dc:	e5d06000 	ldrb	r6, [r0]
  v1 = in[4] | (in[5] << 8) | (in[6] << 16) | (in[7] << 24);
    56e0:	e1a05805 	lsl	r5, r5, #16
    56e4:	e5d0e004 	ldrb	lr, [r0, #4]
    56e8:	e184c40c 	orr	ip, r4, ip, lsl #8
    56ec:	e5d07007 	ldrb	r7, [r0, #7]
{
  unsigned int i, num_rounds = 32;
  uint32_t v0, v1, sum=0, delta=0x9E3779B9;
  uint32_t const *k;

  v0 = in[0] | (in[1] << 8) | (in[2] << 16) | (in[3] << 24);
    56f0:	e5d04003 	ldrb	r4, [r0, #3]
  v1 = in[4] | (in[5] << 8) | (in[6] << 16) | (in[7] << 24);
  k = rtmpe8_keys[keyid];
    56f4:	e59f00b8 	ldr	r0, [pc, #184]	; 57b4 <rtmpe8_sig+0xf0>
    56f8:	e1853403 	orr	r3, r5, r3, lsl #8
  unsigned int i, num_rounds = 32;
  uint32_t v0, v1, sum=0, delta=0x9E3779B9;
  uint32_t const *k;

  v0 = in[0] | (in[1] << 8) | (in[2] << 16) | (in[3] << 24);
  v1 = in[4] | (in[5] << 8) | (in[6] << 16) | (in[7] << 24);
    56fc:	e183e00e 	orr	lr, r3, lr
  k = rtmpe8_keys[keyid];
    5700:	e08f0000 	add	r0, pc, r0
{
  unsigned int i, num_rounds = 32;
  uint32_t v0, v1, sum=0, delta=0x9E3779B9;
  uint32_t const *k;

  v0 = in[0] | (in[1] << 8) | (in[2] << 16) | (in[3] << 24);
    5704:	e18cc006 	orr	ip, ip, r6
  v1 = in[4] | (in[5] << 8) | (in[6] << 16) | (in[7] << 24);
  k = rtmpe8_keys[keyid];

  for (i=0; i < num_rounds; i++) {
    5708:	e59f50a8 	ldr	r5, [pc, #168]	; 57b8 <rtmpe8_sig+0xf4>
{
  unsigned int i, num_rounds = 32;
  uint32_t v0, v1, sum=0, delta=0x9E3779B9;
  uint32_t const *k;

  v0 = in[0] | (in[1] << 8) | (in[2] << 16) | (in[3] << 24);
    570c:	e18c4c04 	orr	r4, ip, r4, lsl #24
  v1 = in[4] | (in[5] << 8) | (in[6] << 16) | (in[7] << 24);
    5710:	e18eec07 	orr	lr, lr, r7, lsl #24
  k = rtmpe8_keys[keyid];
    5714:	e0802202 	add	r2, r0, r2, lsl #4
 * http://en.wikipedia.org/wiki/XTEA
 */
static void rtmpe8_sig(uint8_t *in, uint8_t *out, int keyid)
{
  unsigned int i, num_rounds = 32;
  uint32_t v0, v1, sum=0, delta=0x9E3779B9;
    5718:	e3a03000 	mov	r3, #0
  v0 = in[0] | (in[1] << 8) | (in[2] << 16) | (in[3] << 24);
  v1 = in[4] | (in[5] << 8) | (in[6] << 16) | (in[7] << 24);
  k = rtmpe8_keys[keyid];

  for (i=0; i < num_rounds; i++) {
    v0 += (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + k[sum & 3]);
    571c:	e2030003 	and	r0, r3, #3
    5720:	e792c100 	ldr	ip, [r2, r0, lsl #2]
    5724:	e1a0020e 	lsl	r0, lr, #4
    5728:	e083c00c 	add	ip, r3, ip
    sum += delta;
    572c:	e283349e 	add	r3, r3, #-1644167168	; 0x9e000000
    5730:	e28339dd 	add	r3, r3, #3620864	; 0x374000
  v0 = in[0] | (in[1] << 8) | (in[2] << 16) | (in[3] << 24);
  v1 = in[4] | (in[5] << 8) | (in[6] << 16) | (in[7] << 24);
  k = rtmpe8_keys[keyid];

  for (i=0; i < num_rounds; i++) {
    v0 += (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + k[sum & 3]);
    5734:	e02002ae 	eor	r0, r0, lr, lsr #5
    sum += delta;
    5738:	e2833de6 	add	r3, r3, #14720	; 0x3980
    573c:	e2833039 	add	r3, r3, #57	; 0x39
  v0 = in[0] | (in[1] << 8) | (in[2] << 16) | (in[3] << 24);
  v1 = in[4] | (in[5] << 8) | (in[6] << 16) | (in[7] << 24);
  k = rtmpe8_keys[keyid];

  for (i=0; i < num_rounds; i++) {
    v0 += (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + k[sum & 3]);
    5740:	e080000e 	add	r0, r0, lr
    5744:	e020000c 	eor	r0, r0, ip
    sum += delta;
    v1 += (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + k[(sum>>11) & 3]);
    5748:	e1a065a3 	lsr	r6, r3, #11
  v0 = in[0] | (in[1] << 8) | (in[2] << 16) | (in[3] << 24);
  v1 = in[4] | (in[5] << 8) | (in[6] << 16) | (in[7] << 24);
  k = rtmpe8_keys[keyid];

  for (i=0; i < num_rounds; i++) {
    v0 += (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + k[sum & 3]);
    574c:	e0844000 	add	r4, r4, r0
    sum += delta;
    v1 += (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + k[(sum>>11) & 3]);
    5750:	e2066003 	and	r6, r6, #3
    5754:	e1a0c204 	lsl	ip, r4, #4
    5758:	e7920106 	ldr	r0, [r2, r6, lsl #2]
    575c:	e02cc2a4 	eor	ip, ip, r4, lsr #5
    5760:	e08cc004 	add	ip, ip, r4
    5764:	e0830000 	add	r0, r3, r0
    5768:	e020000c 	eor	r0, r0, ip

  v0 = in[0] | (in[1] << 8) | (in[2] << 16) | (in[3] << 24);
  v1 = in[4] | (in[5] << 8) | (in[6] << 16) | (in[7] << 24);
  k = rtmpe8_keys[keyid];

  for (i=0; i < num_rounds; i++) {
    576c:	e1530005 	cmp	r3, r5
    v0 += (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + k[sum & 3]);
    sum += delta;
    v1 += (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + k[(sum>>11) & 3]);
    5770:	e08ee000 	add	lr, lr, r0

  v0 = in[0] | (in[1] << 8) | (in[2] << 16) | (in[3] << 24);
  v1 = in[4] | (in[5] << 8) | (in[6] << 16) | (in[7] << 24);
  k = rtmpe8_keys[keyid];

  for (i=0; i < num_rounds; i++) {
    5774:	1affffe8 	bne	571c <rtmpe8_sig+0x58>
    v0 += (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + k[sum & 3]);
    sum += delta;
    v1 += (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + k[(sum>>11) & 3]);
  }

  out[0] = v0; v0 >>= 8;
    5778:	e1a06424 	lsr	r6, r4, #8
  out[1] = v0; v0 >>= 8;
    577c:	e1a05824 	lsr	r5, r4, #16
  out[2] = v0; v0 >>= 8;
    5780:	e1a0cc24 	lsr	ip, r4, #24
  out[3] = v0;

  out[4] = v1; v1 >>= 8;
    5784:	e1a0042e 	lsr	r0, lr, #8
  out[5] = v1; v1 >>= 8;
    5788:	e1a0282e 	lsr	r2, lr, #16
  out[6] = v1; v1 >>= 8;
    578c:	e1a03c2e 	lsr	r3, lr, #24
    v0 += (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + k[sum & 3]);
    sum += delta;
    v1 += (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + k[(sum>>11) & 3]);
  }

  out[0] = v0; v0 >>= 8;
    5790:	e5c14000 	strb	r4, [r1]
  out[1] = v0; v0 >>= 8;
  out[2] = v0; v0 >>= 8;
  out[3] = v0;

  out[4] = v1; v1 >>= 8;
    5794:	e5c1e004 	strb	lr, [r1, #4]
    sum += delta;
    v1 += (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + k[(sum>>11) & 3]);
  }

  out[0] = v0; v0 >>= 8;
  out[1] = v0; v0 >>= 8;
    5798:	e5c16001 	strb	r6, [r1, #1]
  out[2] = v0; v0 >>= 8;
    579c:	e5c15002 	strb	r5, [r1, #2]
  out[3] = v0;
    57a0:	e5c1c003 	strb	ip, [r1, #3]

  out[4] = v1; v1 >>= 8;
  out[5] = v1; v1 >>= 8;
    57a4:	e5c10005 	strb	r0, [r1, #5]
  out[6] = v1; v1 >>= 8;
    57a8:	e5c12006 	strb	r2, [r1, #6]
  out[7] = v1;
    57ac:	e5c13007 	strb	r3, [r1, #7]
    57b0:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    57b4:	000170e8 	.word	0x000170e8
    57b8:	c6ef3720 	.word	0xc6ef3720

000057bc <bf_enc>:

#define	BF_ENC(X,S) \
	(((S[0][X>>24] + S[1][X>>16 & 0xff]) ^ S[2][(X>>8) & 0xff]) + S[3][X & 0xff])

static void bf_enc(uint32_t *x, bf_key *key)
{
    57bc:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    57c0:	e281eeff 	add	lr, r1, #4080	; 0xff0
    57c4:	e2816a01 	add	r6, r1, #4096	; 0x1000
  uint32_t  Xr;
  uint32_t  temp;
  int	i;

  Xl = x[0];
  Xr = x[1];
    57c8:	e8900018 	ldm	r0, {r3, r4}
    57cc:	e28ee00c 	add	lr, lr, #12
    57d0:	e286503c 	add	r5, r6, #60	; 0x3c

  for (i = 0; i < BF_ROUNDS; ++i) {
    Xl ^= key->p[i];
    57d4:	e5bec004 	ldr	ip, [lr, #4]!
    57d8:	e02cc003 	eor	ip, ip, r3
    Xr ^= BF_ENC(Xl,key->s);
    57dc:	e1a0382c 	lsr	r3, ip, #16
    57e0:	e20330ff 	and	r3, r3, #255	; 0xff
    57e4:	e1a0242c 	lsr	r2, ip, #8
    57e8:	e1a07c2c 	lsr	r7, ip, #24
    57ec:	e2833c01 	add	r3, r3, #256	; 0x100
    57f0:	e20220ff 	and	r2, r2, #255	; 0xff
    57f4:	e7918107 	ldr	r8, [r1, r7, lsl #2]
    57f8:	e7913103 	ldr	r3, [r1, r3, lsl #2]
    57fc:	e2822c02 	add	r2, r2, #512	; 0x200
    5800:	e20c70ff 	and	r7, ip, #255	; 0xff
    5804:	e7912102 	ldr	r2, [r1, r2, lsl #2]
    5808:	e2877c03 	add	r7, r7, #768	; 0x300
    580c:	e0833008 	add	r3, r3, r8
    5810:	e7917107 	ldr	r7, [r1, r7, lsl #2]
    5814:	e0233002 	eor	r3, r3, r2
    5818:	e0833007 	add	r3, r3, r7
  int	i;

  Xl = x[0];
  Xr = x[1];

  for (i = 0; i < BF_ROUNDS; ++i) {
    581c:	e15e0005 	cmp	lr, r5
    Xl ^= key->p[i];
    Xr ^= BF_ENC(Xl,key->s);
    5820:	e0233004 	eor	r3, r3, r4

  Xl = x[0];
  Xr = x[1];

  for (i = 0; i < BF_ROUNDS; ++i) {
    Xl ^= key->p[i];
    5824:	e1a0400c 	mov	r4, ip
  int	i;

  Xl = x[0];
  Xr = x[1];

  for (i = 0; i < BF_ROUNDS; ++i) {
    5828:	1affffe9 	bne	57d4 <bf_enc+0x18>
    temp = Xl;
    Xl = Xr;
    Xr = temp;
  }

  Xl ^= key->p[BF_ROUNDS];
    582c:	e5961040 	ldr	r1, [r6, #64]	; 0x40
  Xr ^= key->p[BF_ROUNDS + 1];
    5830:	e5962044 	ldr	r2, [r6, #68]	; 0x44
    temp = Xl;
    Xl = Xr;
    Xr = temp;
  }

  Xl ^= key->p[BF_ROUNDS];
    5834:	e0233001 	eor	r3, r3, r1
  Xr ^= key->p[BF_ROUNDS + 1];
    5838:	e0244002 	eor	r4, r4, r2

  x[0] = Xr;
  x[1] = Xl;
    583c:	e5803004 	str	r3, [r0, #4]
  }

  Xl ^= key->p[BF_ROUNDS];
  Xr ^= key->p[BF_ROUNDS + 1];

  x[0] = Xr;
    5840:	e5804000 	str	r4, [r0]
    5844:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

00005848 <AV_erase>:
    return RTMP_SendPacket(r, &packet, FALSE);
}

static void
AV_erase(RTMP_METHOD *vals, int *num, int i, int freeit)
{
    5848:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    if (freeit)
        free(vals[i].name.av_val);
    584c:	e1a04082 	lsl	r4, r2, #1
}

static void
AV_erase(RTMP_METHOD *vals, int *num, int i, int freeit)
{
    if (freeit)
    5850:	e3530000 	cmp	r3, #0
        free(vals[i].name.av_val);
    5854:	e0847002 	add	r7, r4, r2
    return RTMP_SendPacket(r, &packet, FALSE);
}

static void
AV_erase(RTMP_METHOD *vals, int *num, int i, int freeit)
{
    5858:	e1a08000 	mov	r8, r0
    585c:	e1a06001 	mov	r6, r1
    5860:	e1a05002 	mov	r5, r2
    5864:	00807107 	addeq	r7, r0, r7, lsl #2
    if (freeit)
    5868:	1a000015 	bne	58c4 <AV_erase+0x7c>
        free(vals[i].name.av_val);
    (*num)--;
    586c:	e5963000 	ldr	r3, [r6]
    5870:	e2433001 	sub	r3, r3, #1
    for (; i < *num; i++)
    5874:	e1550003 	cmp	r5, r3
static void
AV_erase(RTMP_METHOD *vals, int *num, int i, int freeit)
{
    if (freeit)
        free(vals[i].name.av_val);
    (*num)--;
    5878:	e5863000 	str	r3, [r6]
    for (; i < *num; i++)
    587c:	aa00000b 	bge	58b0 <AV_erase+0x68>
    5880:	e0844005 	add	r4, r4, r5
    5884:	e0883104 	add	r3, r8, r4, lsl #2
    {
        vals[i] = vals[i + 1];
    5888:	e283400c 	add	r4, r3, #12
    588c:	e8940007 	ldm	r4, {r0, r1, r2}
    5890:	e8830007 	stm	r3, {r0, r1, r2}
AV_erase(RTMP_METHOD *vals, int *num, int i, int freeit)
{
    if (freeit)
        free(vals[i].name.av_val);
    (*num)--;
    for (; i < *num; i++)
    5894:	e5963000 	ldr	r3, [r6]
    5898:	e2855001 	add	r5, r5, #1
    589c:	e1530005 	cmp	r3, r5
    58a0:	e1a03004 	mov	r3, r4
    58a4:	cafffff7 	bgt	5888 <AV_erase+0x40>
    58a8:	e0855085 	add	r5, r5, r5, lsl #1
    58ac:	e0887105 	add	r7, r8, r5, lsl #2
    {
        vals[i] = vals[i + 1];
    }
    vals[i].name.av_val = NULL;
    58b0:	e3a03000 	mov	r3, #0
    58b4:	e5873000 	str	r3, [r7]
    vals[i].name.av_len = 0;
    58b8:	e5873004 	str	r3, [r7, #4]
    vals[i].num = 0;
    58bc:	e5873008 	str	r3, [r7, #8]
    58c0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

static void
AV_erase(RTMP_METHOD *vals, int *num, int i, int freeit)
{
    if (freeit)
        free(vals[i].name.av_val);
    58c4:	e1a07107 	lsl	r7, r7, #2
    58c8:	e7900007 	ldr	r0, [r0, r7]
    58cc:	e0887007 	add	r7, r8, r7
    58d0:	ebfffdcb 	bl	5004 <free@plt>
    58d4:	eaffffe4 	b	586c <AV_erase+0x24>

000058d8 <GetDHOffset2>:
{
  unsigned int offset = 0;
  uint8_t *ptr = handshake + 768;
  unsigned int res;

  assert(RTMP_SIG_SIZE <= len);
    58d8:	e3510c06 	cmp	r1, #1536	; 0x600

typedef unsigned int (getoff)(uint8_t *buf, unsigned int len);

static unsigned int
GetDHOffset2(uint8_t *handshake, unsigned int len)
{
    58dc:	e92d4010 	push	{r4, lr}
    58e0:	e1a04000 	mov	r4, r0
  unsigned int offset = 0;
  uint8_t *ptr = handshake + 768;
  unsigned int res;

  assert(RTMP_SIG_SIZE <= len);
    58e4:	3a00000e 	bcc	5924 <GetDHOffset2+0x4c>

  offset += (*ptr);
  ptr++;
  offset += (*ptr);
    58e8:	e5d40301 	ldrb	r0, [r4, #769]	; 0x301
  uint8_t *ptr = handshake + 768;
  unsigned int res;

  assert(RTMP_SIG_SIZE <= len);

  offset += (*ptr);
    58ec:	e5d43300 	ldrb	r3, [r4, #768]	; 0x300
  ptr++;
  offset += (*ptr);
  ptr++;
  offset += (*ptr);
    58f0:	e5d42302 	ldrb	r2, [r4, #770]	; 0x302
  ptr++;
  offset += (*ptr);
    58f4:	e5d41303 	ldrb	r1, [r4, #771]	; 0x303

  assert(RTMP_SIG_SIZE <= len);

  offset += (*ptr);
  ptr++;
  offset += (*ptr);
    58f8:	e0803003 	add	r3, r0, r3
  ptr++;
  offset += (*ptr);
    58fc:	e0833002 	add	r3, r3, r2
  ptr++;
  offset += (*ptr);

  res = (offset % 632) + 8;
    5900:	e59f2044 	ldr	r2, [pc, #68]	; 594c <GetDHOffset2+0x74>
  ptr++;
  offset += (*ptr);
  ptr++;
  offset += (*ptr);
  ptr++;
  offset += (*ptr);
    5904:	e0833001 	add	r3, r3, r1

  res = (offset % 632) + 8;
    5908:	e0821293 	umull	r1, r2, r3, r2
    590c:	e3a00f9e 	mov	r0, #632	; 0x278
    5910:	e1a024a2 	lsr	r2, r2, #9
    5914:	e0000092 	mul	r0, r2, r0
    5918:	e0600003 	rsb	r0, r0, r3
	  "%s: Couldn't calculate correct DH offset (got %d), exiting!",
	  __FUNCTION__, res);
      exit(1);
    }
  return res;
}
    591c:	e2800008 	add	r0, r0, #8
    5920:	e8bd8010 	pop	{r4, pc}
{
  unsigned int offset = 0;
  uint8_t *ptr = handshake + 768;
  unsigned int res;

  assert(RTMP_SIG_SIZE <= len);
    5924:	e59f2024 	ldr	r2, [pc, #36]	; 5950 <GetDHOffset2+0x78>
    5928:	e59f0024 	ldr	r0, [pc, #36]	; 5954 <GetDHOffset2+0x7c>
    592c:	e59f3024 	ldr	r3, [pc, #36]	; 5958 <GetDHOffset2+0x80>
    5930:	e08f2002 	add	r2, pc, r2
    5934:	e08f0000 	add	r0, pc, r0
    5938:	e2822c01 	add	r2, r2, #256	; 0x100
    593c:	e3a01099 	mov	r1, #153	; 0x99
    5940:	e08f3003 	add	r3, pc, r3
    5944:	ebfffdb1 	bl	5010 <__assert2@plt>
    5948:	eaffffe6 	b	58e8 <GetDHOffset2+0x10>
    594c:	cf6474a9 	.word	0xcf6474a9
    5950:	00016eb8 	.word	0x00016eb8
    5954:	000184dc 	.word	0x000184dc
    5958:	000184dc 	.word	0x000184dc

0000595c <GetDHOffset1>:
{
  unsigned int offset = 0;
  uint8_t *ptr = handshake + 1532;
  unsigned int res;

  assert(RTMP_SIG_SIZE <= len);
    595c:	e3510c06 	cmp	r1, #1536	; 0x600
  return res;
}

static unsigned int
GetDHOffset1(uint8_t *handshake, unsigned int len)
{
    5960:	e92d4010 	push	{r4, lr}
    5964:	e1a04000 	mov	r4, r0
  unsigned int offset = 0;
  uint8_t *ptr = handshake + 1532;
  unsigned int res;

  assert(RTMP_SIG_SIZE <= len);
    5968:	3a00000e 	bcc	59a8 <GetDHOffset1+0x4c>

  offset += (*ptr);
  ptr++;
  offset += (*ptr);
    596c:	e5d405fd 	ldrb	r0, [r4, #1533]	; 0x5fd
  uint8_t *ptr = handshake + 1532;
  unsigned int res;

  assert(RTMP_SIG_SIZE <= len);

  offset += (*ptr);
    5970:	e5d435fc 	ldrb	r3, [r4, #1532]	; 0x5fc
  ptr++;
  offset += (*ptr);
  ptr++;
  offset += (*ptr);
    5974:	e5d425fe 	ldrb	r2, [r4, #1534]	; 0x5fe
  ptr++;
  offset += (*ptr);
    5978:	e5d415ff 	ldrb	r1, [r4, #1535]	; 0x5ff

  assert(RTMP_SIG_SIZE <= len);

  offset += (*ptr);
  ptr++;
  offset += (*ptr);
    597c:	e0803003 	add	r3, r0, r3
  ptr++;
  offset += (*ptr);
    5980:	e0833002 	add	r3, r3, r2
  ptr++;
  offset += (*ptr);

  res = (offset % 632) + 772;
    5984:	e59f2044 	ldr	r2, [pc, #68]	; 59d0 <GetDHOffset1+0x74>
  ptr++;
  offset += (*ptr);
  ptr++;
  offset += (*ptr);
  ptr++;
  offset += (*ptr);
    5988:	e0833001 	add	r3, r3, r1

  res = (offset % 632) + 772;
    598c:	e0821293 	umull	r1, r2, r3, r2
    5990:	e3a00f9e 	mov	r0, #632	; 0x278
    5994:	e1a024a2 	lsr	r2, r2, #9
    5998:	e0000092 	mul	r0, r2, r0
    599c:	e0600003 	rsb	r0, r0, r3
	  __FUNCTION__, res);
      exit(1);
    }

  return res;
}
    59a0:	e2800fc1 	add	r0, r0, #772	; 0x304
    59a4:	e8bd8010 	pop	{r4, pc}
{
  unsigned int offset = 0;
  uint8_t *ptr = handshake + 1532;
  unsigned int res;

  assert(RTMP_SIG_SIZE <= len);
    59a8:	e59f2024 	ldr	r2, [pc, #36]	; 59d4 <GetDHOffset1+0x78>
    59ac:	e59f0024 	ldr	r0, [pc, #36]	; 59d8 <GetDHOffset1+0x7c>
    59b0:	e59f3024 	ldr	r3, [pc, #36]	; 59dc <GetDHOffset1+0x80>
    59b4:	e08f2002 	add	r2, pc, r2
    59b8:	e08f0000 	add	r0, pc, r0
    59bc:	e2822e11 	add	r2, r2, #272	; 0x110
    59c0:	e3a010d1 	mov	r1, #209	; 0xd1
    59c4:	e08f3003 	add	r3, pc, r3
    59c8:	ebfffd90 	bl	5010 <__assert2@plt>
    59cc:	eaffffe6 	b	596c <GetDHOffset1+0x10>
    59d0:	cf6474a9 	.word	0xcf6474a9
    59d4:	00016e34 	.word	0x00016e34
    59d8:	00018458 	.word	0x00018458
    59dc:	00018458 	.word	0x00018458

000059e0 <GetDigestOffset2>:
{
  unsigned int offset = 0;
  uint8_t *ptr = handshake + 772;
  unsigned int res;

  offset += (*ptr);
    59e0:	e5d02304 	ldrb	r2, [r0, #772]	; 0x304
  ptr++;
  offset += (*ptr);
    59e4:	e5d03305 	ldrb	r3, [r0, #773]	; 0x305
  ptr++;
  offset += (*ptr);
    59e8:	e5d01306 	ldrb	r1, [r0, #774]	; 0x306
  uint8_t *ptr = handshake + 772;
  unsigned int res;

  offset += (*ptr);
  ptr++;
  offset += (*ptr);
    59ec:	e0833002 	add	r3, r3, r2
  ptr++;
  offset += (*ptr);
  ptr++;
  offset += (*ptr);
    59f0:	e5d02307 	ldrb	r2, [r0, #775]	; 0x307

  offset += (*ptr);
  ptr++;
  offset += (*ptr);
  ptr++;
  offset += (*ptr);
    59f4:	e0833001 	add	r3, r3, r1
  ptr++;
  offset += (*ptr);
    59f8:	e0833002 	add	r3, r3, r2

  res = (offset % 728) + 776;
    59fc:	e59f201c 	ldr	r2, [pc, #28]	; 5a20 <GetDigestOffset2+0x40>
    5a00:	e1a011a3 	lsr	r1, r3, #3
    5a04:	e0820291 	umull	r0, r2, r1, r2
    5a08:	e3a00fb6 	mov	r0, #728	; 0x2d8
    5a0c:	e1a021a2 	lsr	r2, r2, #3
    5a10:	e0000092 	mul	r0, r2, r0
    5a14:	e0600003 	rsb	r0, r0, r3
	  "%s: Couldn't calculate correct digest offset (got %d), exiting",
	  __FUNCTION__, res);
      exit(1);
    }
  return res;
}
    5a18:	e2800fc2 	add	r0, r0, #776	; 0x308
    5a1c:	e12fff1e 	bx	lr
    5a20:	16816817 	.word	0x16816817

00005a24 <GetDigestOffset1>:
{
  unsigned int offset = 0;
  uint8_t *ptr = handshake + 8;
  unsigned int res;

  assert(12 <= len);
    5a24:	e351000b 	cmp	r1, #11
  return res;
}

static unsigned int
GetDigestOffset1(uint8_t *handshake, unsigned int len)
{
    5a28:	e92d4010 	push	{r4, lr}
    5a2c:	e1a04000 	mov	r4, r0
  unsigned int offset = 0;
  uint8_t *ptr = handshake + 8;
  unsigned int res;

  assert(12 <= len);
    5a30:	9a00000f 	bls	5a74 <GetDigestOffset1+0x50>

  offset += (*ptr);
  ptr++;
  offset += (*ptr);
    5a34:	e5d40009 	ldrb	r0, [r4, #9]
  uint8_t *ptr = handshake + 8;
  unsigned int res;

  assert(12 <= len);

  offset += (*ptr);
    5a38:	e5d43008 	ldrb	r3, [r4, #8]
  ptr++;
  offset += (*ptr);
  ptr++;
  offset += (*ptr);
    5a3c:	e5d4100a 	ldrb	r1, [r4, #10]

  assert(12 <= len);

  offset += (*ptr);
  ptr++;
  offset += (*ptr);
    5a40:	e0803003 	add	r3, r0, r3
  ptr++;
  offset += (*ptr);
  ptr++;
  offset += (*ptr);
    5a44:	e5d4200b 	ldrb	r2, [r4, #11]

  offset += (*ptr);
  ptr++;
  offset += (*ptr);
  ptr++;
  offset += (*ptr);
    5a48:	e0833001 	add	r3, r3, r1
  ptr++;
  offset += (*ptr);
    5a4c:	e0833002 	add	r3, r3, r2

  res = (offset % 728) + 12;
    5a50:	e59f2044 	ldr	r2, [pc, #68]	; 5a9c <GetDigestOffset1+0x78>
    5a54:	e1a011a3 	lsr	r1, r3, #3
    5a58:	e0820291 	umull	r0, r2, r1, r2
    5a5c:	e3a00fb6 	mov	r0, #728	; 0x2d8
    5a60:	e1a021a2 	lsr	r2, r2, #3
    5a64:	e0000092 	mul	r0, r2, r0
    5a68:	e0600003 	rsb	r0, r0, r3
	  __FUNCTION__, res);
      exit(1);
    }

  return res;
}
    5a6c:	e280000c 	add	r0, r0, #12
    5a70:	e8bd8010 	pop	{r4, pc}
{
  unsigned int offset = 0;
  uint8_t *ptr = handshake + 8;
  unsigned int res;

  assert(12 <= len);
    5a74:	e59f2024 	ldr	r2, [pc, #36]	; 5aa0 <GetDigestOffset1+0x7c>
    5a78:	e59f0024 	ldr	r0, [pc, #36]	; 5aa4 <GetDigestOffset1+0x80>
    5a7c:	e59f3024 	ldr	r3, [pc, #36]	; 5aa8 <GetDigestOffset1+0x84>
    5a80:	e08f2002 	add	r2, pc, r2
    5a84:	e08f0000 	add	r0, pc, r0
    5a88:	e2822e12 	add	r2, r2, #288	; 0x120
    5a8c:	e3a010ee 	mov	r1, #238	; 0xee
    5a90:	e08f3003 	add	r3, pc, r3
    5a94:	ebfffd5d 	bl	5010 <__assert2@plt>
    5a98:	eaffffe5 	b	5a34 <GetDigestOffset1+0x10>
    5a9c:	16816817 	.word	0x16816817
    5aa0:	00016d68 	.word	0x00016d68
    5aa4:	0001838c 	.word	0x0001838c
    5aa8:	000183a4 	.word	0x000183a4

00005aac <isValidPublicKey>:
#include "dhgroups.h"

/* RFC 2631, Section 2.1.5, http://www.ietf.org/rfc/rfc2631.txt */
static int
isValidPublicKey(MP_t y, MP_t p, MP_t q)
{
    5aac:	e92d40f0 	push	{r4, r5, r6, r7, lr}
  int ret = TRUE;
  MP_t bn;
  assert(y);
    5ab0:	e2505000 	subs	r5, r0, #0
#include "dhgroups.h"

/* RFC 2631, Section 2.1.5, http://www.ietf.org/rfc/rfc2631.txt */
static int
isValidPublicKey(MP_t y, MP_t p, MP_t q)
{
    5ab4:	e24dd00c 	sub	sp, sp, #12
    5ab8:	e1a06001 	mov	r6, r1
    5abc:	e1a07002 	mov	r7, r2
  int ret = TRUE;
  MP_t bn;
  assert(y);
    5ac0:	0a00003f 	beq	5bc4 <isValidPublicKey+0x118>

  MP_new(bn);
    5ac4:	e3a0000c 	mov	r0, #12
    5ac8:	ebfffd53 	bl	501c <malloc@plt>
    5acc:	e1a04000 	mov	r4, r0
    5ad0:	ebfffd54 	bl	5028 <mpi_init_polarssl@plt>
  assert(bn);
    5ad4:	e3540000 	cmp	r4, #0
    5ad8:	0a000043 	beq	5bec <isValidPublicKey+0x140>

  /* y must lie in [2,p-1] */
  MP_set_w(bn, 1);
    5adc:	e3a01001 	mov	r1, #1
    5ae0:	e1a00004 	mov	r0, r4
    5ae4:	ebfffd52 	bl	5034 <mpi_lset_polarssl@plt>
  if (MP_cmp(y, bn) < 0)
    5ae8:	e1a00005 	mov	r0, r5
    5aec:	e1a01004 	mov	r1, r4
    5af0:	ebfffd52 	bl	5040 <mpi_cmp_mpi_polarssl@plt>
    5af4:	e3500000 	cmp	r0, #0
    5af8:	ba00002b 	blt	5bac <isValidPublicKey+0x100>
      ret = FALSE;
      goto failed;
    }

  /* bn = p-2 */
  MP_set(bn, p);
    5afc:	e1a01006 	mov	r1, r6
    5b00:	e1a00004 	mov	r0, r4
    5b04:	ebfffd50 	bl	504c <mpi_copy_polarssl@plt>
  MP_sub_w(bn, 1);
    5b08:	e1a01004 	mov	r1, r4
    5b0c:	e3a02001 	mov	r2, #1
    5b10:	e1a00004 	mov	r0, r4
    5b14:	ebfffd4f 	bl	5058 <mpi_sub_int_polarssl@plt>
  if (MP_cmp(y, bn) > 0)
    5b18:	e1a00005 	mov	r0, r5
    5b1c:	e1a01004 	mov	r1, r4
    5b20:	ebfffd46 	bl	5040 <mpi_cmp_mpi_polarssl@plt>
    5b24:	e3500000 	cmp	r0, #0
    5b28:	ca000019 	bgt	5b94 <isValidPublicKey+0xe8>
   *
   * This is a nice test to make sure the public key position is calculated
   * correctly. This test will fail in about 50% of the cases if applied to
   * random data.
   */
  if (q)
    5b2c:	e3570000 	cmp	r7, #0
    5b30:	0a00000f 	beq	5b74 <isValidPublicKey+0xc8>
    {
      /* y must fulfill y^q mod p = 1 */
      MP_modexp(bn, y, q, p);
    5b34:	e3a00000 	mov	r0, #0
    5b38:	e1a01005 	mov	r1, r5
    5b3c:	e1a02007 	mov	r2, r7
    5b40:	e1a03006 	mov	r3, r6
    5b44:	e58d0000 	str	r0, [sp]
    5b48:	e1a00004 	mov	r0, r4
    5b4c:	ebfffd44 	bl	5064 <mpi_exp_mod_polarssl@plt>

      if (MP_cmp_1(bn) != 0)
    5b50:	e1a00004 	mov	r0, r4
    5b54:	e3a01001 	mov	r1, #1
    5b58:	ebfffd44 	bl	5070 <mpi_cmp_int_polarssl@plt>
    5b5c:	e3500000 	cmp	r0, #0
    5b60:	0a000003 	beq	5b74 <isValidPublicKey+0xc8>
	{
	  RTMP_Log(RTMP_LOGWARNING, "DH public key does not fulfill y^q mod p = 1");
    5b64:	e59f10a8 	ldr	r1, [pc, #168]	; 5c14 <isValidPublicKey+0x168>
    5b68:	e3a00002 	mov	r0, #2
    5b6c:	e08f1001 	add	r1, pc, r1
    5b70:	eb003f8d 	bl	159ac <RTMP_Log>

/* RFC 2631, Section 2.1.5, http://www.ietf.org/rfc/rfc2631.txt */
static int
isValidPublicKey(MP_t y, MP_t p, MP_t q)
{
  int ret = TRUE;
    5b74:	e3a05001 	mov	r5, #1
	  RTMP_Log(RTMP_LOGWARNING, "DH public key does not fulfill y^q mod p = 1");
	}
    }

failed:
  MP_free(bn);
    5b78:	e1a00004 	mov	r0, r4
    5b7c:	ebfffd3e 	bl	507c <mpi_free_polarssl@plt>
    5b80:	e1a00004 	mov	r0, r4
    5b84:	ebfffd1e 	bl	5004 <free@plt>
  return ret;
}
    5b88:	e1a00005 	mov	r0, r5
    5b8c:	e28dd00c 	add	sp, sp, #12
    5b90:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
  /* bn = p-2 */
  MP_set(bn, p);
  MP_sub_w(bn, 1);
  if (MP_cmp(y, bn) > 0)
    {
      RTMP_Log(RTMP_LOGERROR, "DH public key must be at most p-2");
    5b94:	e59f107c 	ldr	r1, [pc, #124]	; 5c18 <isValidPublicKey+0x16c>
    5b98:	e3a00001 	mov	r0, #1
    5b9c:	e08f1001 	add	r1, pc, r1
    5ba0:	eb003f81 	bl	159ac <RTMP_Log>
      ret = FALSE;
    5ba4:	e3a05000 	mov	r5, #0
      goto failed;
    5ba8:	eafffff2 	b	5b78 <isValidPublicKey+0xcc>

  /* y must lie in [2,p-1] */
  MP_set_w(bn, 1);
  if (MP_cmp(y, bn) < 0)
    {
      RTMP_Log(RTMP_LOGERROR, "DH public key must be at least 2");
    5bac:	e59f1068 	ldr	r1, [pc, #104]	; 5c1c <isValidPublicKey+0x170>
    5bb0:	e3a00001 	mov	r0, #1
    5bb4:	e08f1001 	add	r1, pc, r1
    5bb8:	eb003f7b 	bl	159ac <RTMP_Log>
      ret = FALSE;
    5bbc:	e3a05000 	mov	r5, #0
      goto failed;
    5bc0:	eaffffec 	b	5b78 <isValidPublicKey+0xcc>
static int
isValidPublicKey(MP_t y, MP_t p, MP_t q)
{
  int ret = TRUE;
  MP_t bn;
  assert(y);
    5bc4:	e59f2054 	ldr	r2, [pc, #84]	; 5c20 <isValidPublicKey+0x174>
    5bc8:	e59f0054 	ldr	r0, [pc, #84]	; 5c24 <isValidPublicKey+0x178>
    5bcc:	e59f3054 	ldr	r3, [pc, #84]	; 5c28 <isValidPublicKey+0x17c>
    5bd0:	e08f2002 	add	r2, pc, r2
    5bd4:	e08f0000 	add	r0, pc, r0
    5bd8:	e2822f4d 	add	r2, r2, #308	; 0x134
    5bdc:	e3a010c9 	mov	r1, #201	; 0xc9
    5be0:	e08f3003 	add	r3, pc, r3
    5be4:	ebfffd09 	bl	5010 <__assert2@plt>
    5be8:	eaffffb5 	b	5ac4 <isValidPublicKey+0x18>

  MP_new(bn);
  assert(bn);
    5bec:	e59f2038 	ldr	r2, [pc, #56]	; 5c2c <isValidPublicKey+0x180>
    5bf0:	e59f0038 	ldr	r0, [pc, #56]	; 5c30 <isValidPublicKey+0x184>
    5bf4:	e59f3038 	ldr	r3, [pc, #56]	; 5c34 <isValidPublicKey+0x188>
    5bf8:	e08f2002 	add	r2, pc, r2
    5bfc:	e08f0000 	add	r0, pc, r0
    5c00:	e2822f4d 	add	r2, r2, #308	; 0x134
    5c04:	e3a010cc 	mov	r1, #204	; 0xcc
    5c08:	e08f3003 	add	r3, pc, r3
    5c0c:	ebfffcff 	bl	5010 <__assert2@plt>
    5c10:	eaffffb1 	b	5adc <isValidPublicKey+0x30>
    5c14:	0001832c 	.word	0x0001832c
    5c18:	000182d8 	.word	0x000182d8
    5c1c:	0001829c 	.word	0x0001829c
    5c20:	00016c18 	.word	0x00016c18
    5c24:	0001826c 	.word	0x0001826c
    5c28:	00018268 	.word	0x00018268
    5c2c:	00016bf0 	.word	0x00016bf0
    5c30:	00018244 	.word	0x00018244
    5c34:	00018244 	.word	0x00018244

00005c38 <DHGenerateKey>:

static int
DHGenerateKey(MDH *dh)
{
  size_t res = 0;
  if (!dh)
    5c38:	e3500000 	cmp	r0, #0
    5c3c:	012fff1e 	bxeq	lr

      if (!MDH_generate_key(dh))
	return 0;

      MP_gethex(q1, Q1024, res);
      assert(res);
    5c40:	e59f3198 	ldr	r3, [pc, #408]	; 5de0 <DHGenerateKey+0x1a8>
    5c44:	e59f2198 	ldr	r2, [pc, #408]	; 5de4 <DHGenerateKey+0x1ac>
    5c48:	e08f3003 	add	r3, pc, r3
  return 0;
}

static int
DHGenerateKey(MDH *dh)
{
    5c4c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}

      if (!MDH_generate_key(dh))
	return 0;

      MP_gethex(q1, Q1024, res);
      assert(res);
    5c50:	e08f2002 	add	r2, pc, r2
  return 0;
}

static int
DHGenerateKey(MDH *dh)
{
    5c54:	e24dd034 	sub	sp, sp, #52	; 0x34

      if (!MDH_generate_key(dh))
	return 0;

      MP_gethex(q1, Q1024, res);
      assert(res);
    5c58:	e2833f52 	add	r3, r3, #328	; 0x148
    5c5c:	e59f7184 	ldr	r7, [pc, #388]	; 5de8 <DHGenerateKey+0x1b0>
    5c60:	e59f6184 	ldr	r6, [pc, #388]	; 5dec <DHGenerateKey+0x1b4>
      MP_t q1 = NULL;

      if (!MDH_generate_key(dh))
	return 0;

      MP_gethex(q1, Q1024, res);
    5c64:	e59fb184 	ldr	fp, [pc, #388]	; 5df0 <DHGenerateKey+0x1b8>
      assert(res);
    5c68:	e58d201c 	str	r2, [sp, #28]
    5c6c:	e58d3020 	str	r3, [sp, #32]
    5c70:	e59f217c 	ldr	r2, [pc, #380]	; 5df4 <DHGenerateKey+0x1bc>
    5c74:	e2803014 	add	r3, r0, #20
    5c78:	e58d3010 	str	r3, [sp, #16]
    5c7c:	e79f7007 	ldr	r7, [pc, r7]
    5c80:	e280303c 	add	r3, r0, #60	; 0x3c
    5c84:	e79f6006 	ldr	r6, [pc, r6]
    5c88:	e08f2002 	add	r2, pc, r2
    5c8c:	e58d300c 	str	r3, [sp, #12]
    5c90:	e1a04000 	mov	r4, r0
    5c94:	e2803030 	add	r3, r0, #48	; 0x30
      MP_t q1 = NULL;

      if (!MDH_generate_key(dh))
	return 0;

      MP_gethex(q1, Q1024, res);
    5c98:	e08fb00b 	add	fp, pc, fp
    5c9c:	e280a018 	add	sl, r0, #24
    5ca0:	e2809024 	add	r9, r0, #36	; 0x24
    5ca4:	e28d802c 	add	r8, sp, #44	; 0x2c
      assert(res);
    5ca8:	e58d2024 	str	r2, [sp, #36]	; 0x24
    5cac:	e58d3014 	str	r3, [sp, #20]
#define MDH_free(vp)	{MDH *_dh = vp; dhm_free(&_dh->ctx); MP_free(_dh->p); MP_free(_dh->g); MP_free(_dh->pub_key); MP_free(_dh->priv_key); free(_dh);}

static int MDH_generate_key(MDH *dh)
{
  unsigned char out[2];
  MP_set(&dh->ctx.P, dh->p);
    5cb0:	e5941000 	ldr	r1, [r4]
    5cb4:	e1a0000a 	mov	r0, sl
    5cb8:	ebfffce3 	bl	504c <mpi_copy_polarssl@plt>
  MP_set(&dh->ctx.G, dh->g);
    5cbc:	e5941004 	ldr	r1, [r4, #4]
    5cc0:	e1a00009 	mov	r0, r9
    5cc4:	ebfffce0 	bl	504c <mpi_copy_polarssl@plt>
  dh->ctx.len = 128;
    5cc8:	e3a03080 	mov	r3, #128	; 0x80
    5ccc:	e5843014 	str	r3, [r4, #20]
  dhm_make_public(&dh->ctx, 1024, out, 1, havege_random, &RTMP_TLS_ctx->hs);
    5cd0:	e58d7000 	str	r7, [sp]
    5cd4:	e5963000 	ldr	r3, [r6]
    5cd8:	e1a02008 	mov	r2, r8
    5cdc:	e3a01b01 	mov	r1, #1024	; 0x400
    5ce0:	e58d3004 	str	r3, [sp, #4]
    5ce4:	e59d0010 	ldr	r0, [sp, #16]
    5ce8:	e3a03001 	mov	r3, #1
    5cec:	ebfffce5 	bl	5088 <dhm_make_public@plt>
  MP_new(dh->pub_key);
    5cf0:	e3a0000c 	mov	r0, #12
    5cf4:	ebfffcc8 	bl	501c <malloc@plt>
    5cf8:	e5840008 	str	r0, [r4, #8]
    5cfc:	ebfffcc9 	bl	5028 <mpi_init_polarssl@plt>
  MP_new(dh->priv_key);
    5d00:	e3a0000c 	mov	r0, #12
    5d04:	ebfffcc4 	bl	501c <malloc@plt>
    5d08:	e584000c 	str	r0, [r4, #12]
    5d0c:	ebfffcc5 	bl	5028 <mpi_init_polarssl@plt>
  MP_set(dh->pub_key, &dh->ctx.GX);
    5d10:	e59d100c 	ldr	r1, [sp, #12]
    5d14:	e5940008 	ldr	r0, [r4, #8]
    5d18:	ebfffccb 	bl	504c <mpi_copy_polarssl@plt>
  MP_set(dh->priv_key, &dh->ctx.X);
    5d1c:	e59d1014 	ldr	r1, [sp, #20]
    5d20:	e594000c 	ldr	r0, [r4, #12]
    5d24:	ebfffcc8 	bl	504c <mpi_copy_polarssl@plt>
      MP_t q1 = NULL;

      if (!MDH_generate_key(dh))
	return 0;

      MP_gethex(q1, Q1024, res);
    5d28:	e3a0000c 	mov	r0, #12
    5d2c:	ebfffcba 	bl	501c <malloc@plt>
    5d30:	e1a05000 	mov	r5, r0
    5d34:	ebfffcbb 	bl	5028 <mpi_init_polarssl@plt>
    5d38:	e1a00005 	mov	r0, r5
    5d3c:	e3a01010 	mov	r1, #16
    5d40:	e1a0200b 	mov	r2, fp
    5d44:	ebfffcd2 	bl	5094 <mpi_read_string_polarssl@plt>
      assert(res);
    5d48:	e3500000 	cmp	r0, #0
    5d4c:	1a00000c 	bne	5d84 <DHGenerateKey+0x14c>

      res = isValidPublicKey(dh->pub_key, dh->p, q1);
    5d50:	e5940008 	ldr	r0, [r4, #8]
    5d54:	e5941000 	ldr	r1, [r4]
    5d58:	e1a02005 	mov	r2, r5
    5d5c:	ebffff52 	bl	5aac <isValidPublicKey>
      if (!res)
    5d60:	e2503000 	subs	r3, r0, #0
    5d64:	0a00000c 	beq	5d9c <DHGenerateKey+0x164>
	  MP_free(dh->pub_key);
	  MP_free(dh->priv_key);
	  dh->pub_key = dh->priv_key = 0;
	}

      MP_free(q1);
    5d68:	e1a00005 	mov	r0, r5
    5d6c:	ebfffcc2 	bl	507c <mpi_free_polarssl@plt>
    5d70:	e1a00005 	mov	r0, r5
    5d74:	ebfffca2 	bl	5004 <free@plt>
    }
  return 1;
    5d78:	e3a00001 	mov	r0, #1
}
    5d7c:	e28dd034 	add	sp, sp, #52	; 0x34
    5d80:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

      if (!MDH_generate_key(dh))
	return 0;

      MP_gethex(q1, Q1024, res);
      assert(res);
    5d84:	e59d001c 	ldr	r0, [sp, #28]
    5d88:	e59f1068 	ldr	r1, [pc, #104]	; 5df8 <DHGenerateKey+0x1c0>
    5d8c:	e59d2020 	ldr	r2, [sp, #32]
    5d90:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    5d94:	ebfffc9d 	bl	5010 <__assert2@plt>
    5d98:	eaffffec 	b	5d50 <DHGenerateKey+0x118>

      res = isValidPublicKey(dh->pub_key, dh->p, q1);
      if (!res)
	{
	  MP_free(dh->pub_key);
    5d9c:	e5940008 	ldr	r0, [r4, #8]
    5da0:	e58d3018 	str	r3, [sp, #24]
    5da4:	ebfffcb4 	bl	507c <mpi_free_polarssl@plt>
    5da8:	e5940008 	ldr	r0, [r4, #8]
    5dac:	ebfffc94 	bl	5004 <free@plt>
	  MP_free(dh->priv_key);
    5db0:	e594000c 	ldr	r0, [r4, #12]
    5db4:	ebfffcb0 	bl	507c <mpi_free_polarssl@plt>
    5db8:	e594000c 	ldr	r0, [r4, #12]
    5dbc:	ebfffc90 	bl	5004 <free@plt>
	  dh->pub_key = dh->priv_key = 0;
    5dc0:	e59d3018 	ldr	r3, [sp, #24]
	}

      MP_free(q1);
    5dc4:	e1a00005 	mov	r0, r5
      res = isValidPublicKey(dh->pub_key, dh->p, q1);
      if (!res)
	{
	  MP_free(dh->pub_key);
	  MP_free(dh->priv_key);
	  dh->pub_key = dh->priv_key = 0;
    5dc8:	e584300c 	str	r3, [r4, #12]
    5dcc:	e5843008 	str	r3, [r4, #8]
	}

      MP_free(q1);
    5dd0:	ebfffca9 	bl	507c <mpi_free_polarssl@plt>
    5dd4:	e1a00005 	mov	r0, r5
    5dd8:	ebfffc89 	bl	5004 <free@plt>
    5ddc:	eaffffb3 	b	5cb0 <DHGenerateKey+0x78>
    5de0:	00016ba0 	.word	0x00016ba0
    5de4:	000181f0 	.word	0x000181f0
    5de8:	0001e0ec 	.word	0x0001e0ec
    5dec:	0001e0e8 	.word	0x0001e0e8
    5df0:	00018230 	.word	0x00018230
    5df4:	00018344 	.word	0x00018344
    5df8:	00000126 	.word	0x00000126

00005dfc <HMACsha256>:
static getoff *dhoff[] = {GetDHOffset1, GetDHOffset2};

static void
HMACsha256(const uint8_t *message, size_t messageLen, const uint8_t *key,
	   size_t keylen, uint8_t *digest)
{
    5dfc:	e92d4070 	push	{r4, r5, r6, lr}
    5e00:	e24dd0f0 	sub	sp, sp, #240	; 0xf0
  unsigned int digestLen;
  HMAC_CTX ctx;

  HMAC_setup(ctx, key, keylen);
    5e04:	e28d4004 	add	r4, sp, #4
static getoff *dhoff[] = {GetDHOffset1, GetDHOffset2};

static void
HMACsha256(const uint8_t *message, size_t messageLen, const uint8_t *key,
	   size_t keylen, uint8_t *digest)
{
    5e08:	e1a05001 	mov	r5, r1
    5e0c:	e1a06000 	mov	r6, r0
  unsigned int digestLen;
  HMAC_CTX ctx;

  HMAC_setup(ctx, key, keylen);
    5e10:	e1a01002 	mov	r1, r2
    5e14:	e1a00004 	mov	r0, r4
    5e18:	e1a02003 	mov	r2, r3
    5e1c:	e3a03000 	mov	r3, #0
    5e20:	ebfffc9e 	bl	50a0 <sha2_hmac_starts@plt>
  HMAC_crunch(ctx, message, messageLen);
    5e24:	e1a00004 	mov	r0, r4
    5e28:	e1a01006 	mov	r1, r6
    5e2c:	e1a02005 	mov	r2, r5
    5e30:	ebfffc9d 	bl	50ac <sha2_hmac_update@plt>
  HMAC_finish(ctx, digest, digestLen);
    5e34:	e1a00004 	mov	r0, r4
    5e38:	e59d1100 	ldr	r1, [sp, #256]	; 0x100
    5e3c:	ebfffc9d 	bl	50b8 <sha2_hmac_finish@plt>

  assert(digestLen == 32);
}
    5e40:	e28dd0f0 	add	sp, sp, #240	; 0xf0
    5e44:	e8bd8070 	pop	{r4, r5, r6, pc}

00005e48 <InitRC4Encryption>:

static void InitRC4Encryption
  (uint8_t * secretKey,
   uint8_t * pubKeyIn,
   uint8_t * pubKeyOut, RC4_handle *rc4keyIn, RC4_handle *rc4keyOut)
{
    5e48:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
    5e4c:	e1a07000 	mov	r7, r0
    5e50:	e24ddf45 	sub	sp, sp, #276	; 0x114
  uint8_t digest[SHA256_DIGEST_LENGTH];
  unsigned int digestLen = 0;
  HMAC_CTX ctx;

  RC4_alloc(rc4keyIn);
    5e54:	e3a00f42 	mov	r0, #264	; 0x108

static void InitRC4Encryption
  (uint8_t * secretKey,
   uint8_t * pubKeyIn,
   uint8_t * pubKeyOut, RC4_handle *rc4keyIn, RC4_handle *rc4keyOut)
{
    5e58:	e1a06003 	mov	r6, r3
    5e5c:	e1a04001 	mov	r4, r1
    5e60:	e1a09002 	mov	r9, r2
    5e64:	e59d8130 	ldr	r8, [sp, #304]	; 0x130
  uint8_t digest[SHA256_DIGEST_LENGTH];
  unsigned int digestLen = 0;
  HMAC_CTX ctx;

  RC4_alloc(rc4keyIn);
    5e68:	ebfffc6b 	bl	501c <malloc@plt>
  RC4_alloc(rc4keyOut);

  HMAC_setup(ctx, secretKey, 128);
    5e6c:	e28d5024 	add	r5, sp, #36	; 0x24
{
  uint8_t digest[SHA256_DIGEST_LENGTH];
  unsigned int digestLen = 0;
  HMAC_CTX ctx;

  RC4_alloc(rc4keyIn);
    5e70:	e5860000 	str	r0, [r6]
  RC4_alloc(rc4keyOut);
    5e74:	e3a00f42 	mov	r0, #264	; 0x108
    5e78:	ebfffc67 	bl	501c <malloc@plt>

  HMAC_setup(ctx, secretKey, 128);
    5e7c:	e3a03000 	mov	r3, #0
    5e80:	e1a01007 	mov	r1, r7
    5e84:	e3a02080 	mov	r2, #128	; 0x80
  uint8_t digest[SHA256_DIGEST_LENGTH];
  unsigned int digestLen = 0;
  HMAC_CTX ctx;

  RC4_alloc(rc4keyIn);
  RC4_alloc(rc4keyOut);
    5e88:	e5880000 	str	r0, [r8]

  HMAC_setup(ctx, secretKey, 128);
    5e8c:	e1a00005 	mov	r0, r5
    5e90:	ebfffc82 	bl	50a0 <sha2_hmac_starts@plt>
  HMAC_crunch(ctx, pubKeyIn, 128);
    5e94:	e3a02080 	mov	r2, #128	; 0x80
    5e98:	e1a00005 	mov	r0, r5
    5e9c:	e1a01004 	mov	r1, r4
  HMAC_finish(ctx, digest, digestLen);
    5ea0:	e28d4004 	add	r4, sp, #4

  RC4_alloc(rc4keyIn);
  RC4_alloc(rc4keyOut);

  HMAC_setup(ctx, secretKey, 128);
  HMAC_crunch(ctx, pubKeyIn, 128);
    5ea4:	ebfffc80 	bl	50ac <sha2_hmac_update@plt>
  HMAC_finish(ctx, digest, digestLen);
    5ea8:	e1a00005 	mov	r0, r5
    5eac:	e1a01004 	mov	r1, r4
    5eb0:	ebfffc80 	bl	50b8 <sha2_hmac_finish@plt>

  RTMP_Log(RTMP_LOGDEBUG, "RC4 Out Key: ");
    5eb4:	e59f1090 	ldr	r1, [pc, #144]	; 5f4c <InitRC4Encryption+0x104>
    5eb8:	e3a00004 	mov	r0, #4
    5ebc:	e08f1001 	add	r1, pc, r1
    5ec0:	eb003eb9 	bl	159ac <RTMP_Log>
  RTMP_LogHex(RTMP_LOGDEBUG, digest, 16);
    5ec4:	e1a01004 	mov	r1, r4
    5ec8:	e3a00004 	mov	r0, #4
    5ecc:	e3a02010 	mov	r2, #16
    5ed0:	eb003ec5 	bl	159ec <RTMP_LogHex>

  RC4_setkey(*rc4keyOut, 16, digest);
    5ed4:	e5980000 	ldr	r0, [r8]
    5ed8:	e1a01004 	mov	r1, r4
    5edc:	e3a02010 	mov	r2, #16
    5ee0:	ebfffc77 	bl	50c4 <arc4_setup@plt>

  HMAC_setup(ctx, secretKey, 128);
    5ee4:	e3a03000 	mov	r3, #0
    5ee8:	e1a00005 	mov	r0, r5
    5eec:	e1a01007 	mov	r1, r7
    5ef0:	e3a02080 	mov	r2, #128	; 0x80
    5ef4:	ebfffc69 	bl	50a0 <sha2_hmac_starts@plt>
  HMAC_crunch(ctx, pubKeyOut, 128);
    5ef8:	e3a02080 	mov	r2, #128	; 0x80
    5efc:	e1a00005 	mov	r0, r5
    5f00:	e1a01009 	mov	r1, r9
    5f04:	ebfffc68 	bl	50ac <sha2_hmac_update@plt>
  HMAC_finish(ctx, digest, digestLen);
    5f08:	e1a00005 	mov	r0, r5
    5f0c:	e1a01004 	mov	r1, r4
    5f10:	ebfffc68 	bl	50b8 <sha2_hmac_finish@plt>

  RTMP_Log(RTMP_LOGDEBUG, "RC4 In Key: ");
    5f14:	e59f1034 	ldr	r1, [pc, #52]	; 5f50 <InitRC4Encryption+0x108>
    5f18:	e3a00004 	mov	r0, #4
    5f1c:	e08f1001 	add	r1, pc, r1
    5f20:	eb003ea1 	bl	159ac <RTMP_Log>
  RTMP_LogHex(RTMP_LOGDEBUG, digest, 16);
    5f24:	e1a01004 	mov	r1, r4
    5f28:	e3a00004 	mov	r0, #4
    5f2c:	e3a02010 	mov	r2, #16
    5f30:	eb003ead 	bl	159ec <RTMP_LogHex>

  RC4_setkey(*rc4keyIn, 16, digest);
    5f34:	e5960000 	ldr	r0, [r6]
    5f38:	e1a01004 	mov	r1, r4
    5f3c:	e3a02010 	mov	r2, #16
    5f40:	ebfffc5f 	bl	50c4 <arc4_setup@plt>
}
    5f44:	e28ddf45 	add	sp, sp, #276	; 0x114
    5f48:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
    5f4c:	00018114 	.word	0x00018114
    5f50:	000180c4 	.word	0x000180c4

00005f54 <DumpMetaData>:
static int
DumpMetaData(AMFObject *obj)
{
    AMFObjectProperty *prop;
    int n, len;
    for (n = 0; n < obj->o_num; n++)
    5f54:	e5903000 	ldr	r3, [r0]
    5f58:	e3530000 	cmp	r3, #0
    5f5c:	da00007f 	ble	6160 <DumpMetaData+0x20c>
    return FALSE;
}

static int
DumpMetaData(AMFObject *obj)
{
    5f60:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
                break;
            case AMF_STRING:
                //RTMP_Log(RTMP_LOGINFO,"metadata string val_len:%d \n",prop->p_vu.p_aval.av_len);
                if(prop->p_vu.p_aval.av_len<256)
                {
                    len = snprintf(str, 255, "%.*s", prop->p_vu.p_aval.av_len,
    5f64:	e59f31fc 	ldr	r3, [pc, #508]	; 6168 <DumpMetaData+0x214>
                break;
            case AMF_DATE:
                snprintf(str, 255, "timestamp:%.2f", prop->p_vu.p_number);
                break;
            default:
                snprintf(str, 255, "INVALID TYPE 0x%02x",
    5f68:	e59f91fc 	ldr	r9, [pc, #508]	; 616c <DumpMetaData+0x218>
                    if (len >= 1 && str[len-1] == '\n')
                        str[len-1] = '\0';
                }
                break;
            case AMF_DATE:
                snprintf(str, 255, "timestamp:%.2f", prop->p_vu.p_number);
    5f6c:	e59f81fc 	ldr	r8, [pc, #508]	; 6170 <DumpMetaData+0x21c>
                break;
            case AMF_NUMBER:
                snprintf(str, 255, "%.2f", prop->p_vu.p_number);
                break;
            case AMF_BOOLEAN:
                snprintf(str, 255, "%s",
    5f70:	e59f71fc 	ldr	r7, [pc, #508]	; 6174 <DumpMetaData+0x220>
    5f74:	e59fa1fc 	ldr	sl, [pc, #508]	; 6178 <DumpMetaData+0x224>
    return FALSE;
}

static int
DumpMetaData(AMFObject *obj)
{
    5f78:	e24ddf45 	sub	sp, sp, #276	; 0x114
                break;
            case AMF_STRING:
                //RTMP_Log(RTMP_LOGINFO,"metadata string val_len:%d \n",prop->p_vu.p_aval.av_len);
                if(prop->p_vu.p_aval.av_len<256)
                {
                    len = snprintf(str, 255, "%.*s", prop->p_vu.p_aval.av_len,
    5f7c:	e08f3003 	add	r3, pc, r3
    5f80:	e1a05000 	mov	r5, r0
                break;
            case AMF_DATE:
                snprintf(str, 255, "timestamp:%.2f", prop->p_vu.p_number);
                break;
            default:
                snprintf(str, 255, "INVALID TYPE 0x%02x",
    5f84:	e08f9009 	add	r9, pc, r9
                    if (len >= 1 && str[len-1] == '\n')
                        str[len-1] = '\0';
                }
                break;
            case AMF_DATE:
                snprintf(str, 255, "timestamp:%.2f", prop->p_vu.p_number);
    5f88:	e08f8008 	add	r8, pc, r8
                break;
            case AMF_NUMBER:
                snprintf(str, 255, "%.2f", prop->p_vu.p_number);
                break;
            case AMF_BOOLEAN:
                snprintf(str, 255, "%s",
    5f8c:	e08f7007 	add	r7, pc, r7
    5f90:	e08fa00a 	add	sl, pc, sl
static int
DumpMetaData(AMFObject *obj)
{
    AMFObjectProperty *prop;
    int n, len;
    for (n = 0; n < obj->o_num; n++)
    5f94:	e3a04000 	mov	r4, #0
    5f98:	e28d6014 	add	r6, sp, #20
                break;
            case AMF_STRING:
                //RTMP_Log(RTMP_LOGINFO,"metadata string val_len:%d \n",prop->p_vu.p_aval.av_len);
                if(prop->p_vu.p_aval.av_len<256)
                {
                    len = snprintf(str, 255, "%.*s", prop->p_vu.p_aval.av_len,
    5f9c:	e58d300c 	str	r3, [sp, #12]
{
    AMFObjectProperty *prop;
    int n, len;
    for (n = 0; n < obj->o_num; n++)
    {
        char str[256] = "";
    5fa0:	e3a0b000 	mov	fp, #0
    5fa4:	e1a0100b 	mov	r1, fp
    5fa8:	e3a020fc 	mov	r2, #252	; 0xfc
    5fac:	e1a00006 	mov	r0, r6
    5fb0:	e58db010 	str	fp, [sp, #16]
    5fb4:	ebfffc45 	bl	50d0 <memset@plt>
        prop = AMF_GetProp(obj, NULL, n);
    5fb8:	e1a0100b 	mov	r1, fp
    5fbc:	e1a00005 	mov	r0, r5
    5fc0:	e1a02004 	mov	r2, r4
    5fc4:	eb004211 	bl	16810 <AMF_GetProp>
        switch (prop->p_type)
    5fc8:	e5903008 	ldr	r3, [r0, #8]
    AMFObjectProperty *prop;
    int n, len;
    for (n = 0; n < obj->o_num; n++)
    {
        char str[256] = "";
        prop = AMF_GetProp(obj, NULL, n);
    5fcc:	e1a0b000 	mov	fp, r0
        switch (prop->p_type)
    5fd0:	e353000b 	cmp	r3, #11
    5fd4:	908ff103 	addls	pc, pc, r3, lsl #2
    5fd8:	ea00004c 	b	6110 <DumpMetaData+0x1bc>
    5fdc:	ea000043 	b	60f0 <DumpMetaData+0x19c>
    5fe0:	ea000035 	b	60bc <DumpMetaData+0x168>
    5fe4:	ea000021 	b	6070 <DumpMetaData+0x11c>
    5fe8:	ea00001a 	b	6058 <DumpMetaData+0x104>
    5fec:	ea000047 	b	6110 <DumpMetaData+0x1bc>
    5ff0:	ea000046 	b	6110 <DumpMetaData+0x1bc>
    5ff4:	ea000045 	b	6110 <DumpMetaData+0x1bc>
    5ff8:	ea000044 	b	6110 <DumpMetaData+0x1bc>
    5ffc:	ea000015 	b	6058 <DumpMetaData+0x104>
    6000:	ea000042 	b	6110 <DumpMetaData+0x1bc>
    6004:	ea000013 	b	6058 <DumpMetaData+0x104>
    6008:	eaffffff 	b	600c <DumpMetaData+0xb8>
                    if (len >= 1 && str[len-1] == '\n')
                        str[len-1] = '\0';
                }
                break;
            case AMF_DATE:
                snprintf(str, 255, "timestamp:%.2f", prop->p_vu.p_number);
    600c:	e1c021d0 	ldrd	r2, [r0, #16]
    6010:	e3a010ff 	mov	r1, #255	; 0xff
    6014:	e1cd20f0 	strd	r2, [sp]
    6018:	e28d0010 	add	r0, sp, #16
    601c:	e1a02008 	mov	r2, r8
    6020:	ebfffc2d 	bl	50dc <snprintf@plt>
                break;
            default:
                snprintf(str, 255, "INVALID TYPE 0x%02x",
                         (unsigned char)prop->p_type);
        }
        if (str[0] && prop->p_name.av_len)
    6024:	e5dd3010 	ldrb	r3, [sp, #16]
    6028:	e3530000 	cmp	r3, #0
    602c:	0a000002 	beq	603c <DumpMetaData+0xe8>
    6030:	e59b2004 	ldr	r2, [fp, #4]
    6034:	e3520000 	cmp	r2, #0
    6038:	1a00003a 	bne	6128 <DumpMetaData+0x1d4>
static int
DumpMetaData(AMFObject *obj)
{
    AMFObjectProperty *prop;
    int n, len;
    for (n = 0; n < obj->o_num; n++)
    603c:	e5953000 	ldr	r3, [r5]
    6040:	e2844001 	add	r4, r4, #1
    6044:	e1530004 	cmp	r3, r4
    6048:	caffffd4 	bgt	5fa0 <DumpMetaData+0x4c>
            RTMP_Log(RTMP_LOGINFO, "  %-22.*s%s", prop->p_name.av_len,
                     prop->p_name.av_val, str);
        }
    }
    return FALSE;
}
    604c:	e3a00000 	mov	r0, #0
    6050:	e28ddf45 	add	sp, sp, #276	; 0x114
    6054:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        switch (prop->p_type)
        {
            case AMF_OBJECT:
            case AMF_ECMA_ARRAY:
            case AMF_STRICT_ARRAY:
                if (prop->p_name.av_len)
    6058:	e5902004 	ldr	r2, [r0, #4]
    605c:	e3520000 	cmp	r2, #0
    6060:	1a000038 	bne	6148 <DumpMetaData+0x1f4>
                    RTMP_Log(RTMP_LOGINFO, "%.*s:", prop->p_name.av_len, prop->p_name.av_val);
                DumpMetaData(&prop->p_vu.p_object);
    6064:	e28b0010 	add	r0, fp, #16
    6068:	ebffffb9 	bl	5f54 <DumpMetaData>
                break;
    606c:	eaffffec 	b	6024 <DumpMetaData+0xd0>
                snprintf(str, 255, "%s",
                         prop->p_vu.p_number != 0. ? "TRUE" : "FALSE");
                break;
            case AMF_STRING:
                //RTMP_Log(RTMP_LOGINFO,"metadata string val_len:%d \n",prop->p_vu.p_aval.av_len);
                if(prop->p_vu.p_aval.av_len<256)
    6070:	e5903014 	ldr	r3, [r0, #20]
    6074:	e35300ff 	cmp	r3, #255	; 0xff
    6078:	caffffe9 	bgt	6024 <DumpMetaData+0xd0>
                {
                    len = snprintf(str, 255, "%.*s", prop->p_vu.p_aval.av_len,
    607c:	e5902010 	ldr	r2, [r0, #16]
    6080:	e58d2000 	str	r2, [sp]
    6084:	e28d0010 	add	r0, sp, #16
    6088:	e3a010ff 	mov	r1, #255	; 0xff
    608c:	e59d200c 	ldr	r2, [sp, #12]
    6090:	ebfffc11 	bl	50dc <snprintf@plt>
                                   prop->p_vu.p_aval.av_val);
                    if (len >= 1 && str[len-1] == '\n')
    6094:	e3500000 	cmp	r0, #0
    6098:	daffffe1 	ble	6024 <DumpMetaData+0xd0>
    609c:	e28d3e11 	add	r3, sp, #272	; 0x110
    60a0:	e2400001 	sub	r0, r0, #1
    60a4:	e0830000 	add	r0, r3, r0
    60a8:	e5503100 	ldrb	r3, [r0, #-256]	; 0xffffff00
    60ac:	e353000a 	cmp	r3, #10
                        str[len-1] = '\0';
    60b0:	03a03000 	moveq	r3, #0
    60b4:	05403100 	strbeq	r3, [r0, #-256]	; 0xffffff00
    60b8:	eaffffd9 	b	6024 <DumpMetaData+0xd0>
                break;
            case AMF_NUMBER:
                snprintf(str, 255, "%.2f", prop->p_vu.p_number);
                break;
            case AMF_BOOLEAN:
                snprintf(str, 255, "%s",
    60bc:	e1c001d0 	ldrd	r0, [r0, #16]
    60c0:	e3a02000 	mov	r2, #0
    60c4:	e3a03000 	mov	r3, #0
    60c8:	eb0058c4 	bl	1c3e0 <__aeabi_dcmpeq>
    60cc:	e59f30a8 	ldr	r3, [pc, #168]	; 617c <DumpMetaData+0x228>
    60d0:	e3a010ff 	mov	r1, #255	; 0xff
    60d4:	e08f3003 	add	r3, pc, r3
    60d8:	e1a02007 	mov	r2, r7
    60dc:	e3500000 	cmp	r0, #0
    60e0:	01a0300a 	moveq	r3, sl
    60e4:	e28d0010 	add	r0, sp, #16
    60e8:	ebfffbfb 	bl	50dc <snprintf@plt>
                         prop->p_vu.p_number != 0. ? "TRUE" : "FALSE");
                break;
    60ec:	eaffffcc 	b	6024 <DumpMetaData+0xd0>
                if (prop->p_name.av_len)
                    RTMP_Log(RTMP_LOGINFO, "%.*s:", prop->p_name.av_len, prop->p_name.av_val);
                DumpMetaData(&prop->p_vu.p_object);
                break;
            case AMF_NUMBER:
                snprintf(str, 255, "%.2f", prop->p_vu.p_number);
    60f0:	e1c021d0 	ldrd	r2, [r0, #16]
    60f4:	e3a010ff 	mov	r1, #255	; 0xff
    60f8:	e1cd20f0 	strd	r2, [sp]
    60fc:	e59f207c 	ldr	r2, [pc, #124]	; 6180 <DumpMetaData+0x22c>
    6100:	e28d0010 	add	r0, sp, #16
    6104:	e08f2002 	add	r2, pc, r2
    6108:	ebfffbf3 	bl	50dc <snprintf@plt>
                break;
    610c:	eaffffc4 	b	6024 <DumpMetaData+0xd0>
    6110:	e20330ff 	and	r3, r3, #255	; 0xff
                break;
            case AMF_DATE:
                snprintf(str, 255, "timestamp:%.2f", prop->p_vu.p_number);
                break;
            default:
                snprintf(str, 255, "INVALID TYPE 0x%02x",
    6114:	e28d0010 	add	r0, sp, #16
    6118:	e3a010ff 	mov	r1, #255	; 0xff
    611c:	e1a02009 	mov	r2, r9
    6120:	ebfffbed 	bl	50dc <snprintf@plt>
    6124:	eaffffbe 	b	6024 <DumpMetaData+0xd0>
                         (unsigned char)prop->p_type);
        }
        if (str[0] && prop->p_name.av_len)
        {
            RTMP_Log(RTMP_LOGINFO, "  %-22.*s%s", prop->p_name.av_len,
    6128:	e28d1010 	add	r1, sp, #16
    612c:	e59b3000 	ldr	r3, [fp]
    6130:	e58d1000 	str	r1, [sp]
    6134:	e59f1048 	ldr	r1, [pc, #72]	; 6184 <DumpMetaData+0x230>
    6138:	e3a00003 	mov	r0, #3
    613c:	e08f1001 	add	r1, pc, r1
    6140:	eb003e19 	bl	159ac <RTMP_Log>
    6144:	eaffffbc 	b	603c <DumpMetaData+0xe8>
        {
            case AMF_OBJECT:
            case AMF_ECMA_ARRAY:
            case AMF_STRICT_ARRAY:
                if (prop->p_name.av_len)
                    RTMP_Log(RTMP_LOGINFO, "%.*s:", prop->p_name.av_len, prop->p_name.av_val);
    6148:	e59f1038 	ldr	r1, [pc, #56]	; 6188 <DumpMetaData+0x234>
    614c:	e3a00003 	mov	r0, #3
    6150:	e08f1001 	add	r1, pc, r1
    6154:	e59b3000 	ldr	r3, [fp]
    6158:	eb003e13 	bl	159ac <RTMP_Log>
    615c:	eaffffc0 	b	6064 <DumpMetaData+0x110>
            RTMP_Log(RTMP_LOGINFO, "  %-22.*s%s", prop->p_name.av_len,
                     prop->p_name.av_val, str);
        }
    }
    return FALSE;
}
    6160:	e3a00000 	mov	r0, #0
    6164:	e12fff1e 	bx	lr
    6168:	00018098 	.word	0x00018098
    616c:	000180a8 	.word	0x000180a8
    6170:	00018094 	.word	0x00018094
    6174:	00018084 	.word	0x00018084
    6178:	00018060 	.word	0x00018060
    617c:	00017f24 	.word	0x00017f24
    6180:	00017f04 	.word	0x00017f04
    6184:	00017f04 	.word	0x00017f04
    6188:	00017eb0 	.word	0x00017eb0

0000618c <SocksSetup.part.2>:
static const char DEFAULT_FLASH_VER[] = DEF_VERSTR;
const AVal RTMP_DefaultFlashVer =
{ (char *)DEFAULT_FLASH_VER, sizeof(DEFAULT_FLASH_VER) - 1 };

static void
SocksSetup(RTMP *r, AVal *sockshost)
    618c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
{
    if (sockshost->av_len)
    {
        const char *socksport = strchr(sockshost->av_val, ':');
    6190:	e5915000 	ldr	r5, [r1]
static const char DEFAULT_FLASH_VER[] = DEF_VERSTR;
const AVal RTMP_DefaultFlashVer =
{ (char *)DEFAULT_FLASH_VER, sizeof(DEFAULT_FLASH_VER) - 1 };

static void
SocksSetup(RTMP *r, AVal *sockshost)
    6194:	e1a04000 	mov	r4, r0
{
    if (sockshost->av_len)
    {
        const char *socksport = strchr(sockshost->av_val, ':');
    6198:	e3a0103a 	mov	r1, #58	; 0x3a
    619c:	e1a00005 	mov	r0, r5
    61a0:	ebfffbd0 	bl	50e8 <strchr@plt>
        char *hostname = strdup(sockshost->av_val);
        
        if (socksport)
            hostname[socksport - sockshost->av_val] = '\0';
        r->Link.sockshost.av_val = hostname;
    61a4:	e2844901 	add	r4, r4, #16384	; 0x4000
static void
SocksSetup(RTMP *r, AVal *sockshost)
{
    if (sockshost->av_len)
    {
        const char *socksport = strchr(sockshost->av_val, ':');
    61a8:	e1a07000 	mov	r7, r0
        char *hostname = strdup(sockshost->av_val);
    61ac:	e1a00005 	mov	r0, r5
    61b0:	ebfffbcf 	bl	50f4 <strdup@plt>
        
        if (socksport)
    61b4:	e3570000 	cmp	r7, #0
SocksSetup(RTMP *r, AVal *sockshost)
{
    if (sockshost->av_len)
    {
        const char *socksport = strchr(sockshost->av_val, ':');
        char *hostname = strdup(sockshost->av_val);
    61b8:	e1a06000 	mov	r6, r0
        
        if (socksport)
            hostname[socksport - sockshost->av_val] = '\0';
        r->Link.sockshost.av_val = hostname;
    61bc:	e58400fc 	str	r0, [r4, #252]	; 0xfc
    if (sockshost->av_len)
    {
        const char *socksport = strchr(sockshost->av_val, ':');
        char *hostname = strdup(sockshost->av_val);
        
        if (socksport)
    61c0:	0a000011 	beq	620c <SocksSetup.part.2+0x80>
            hostname[socksport - sockshost->av_val] = '\0';
    61c4:	e3a03000 	mov	r3, #0
    61c8:	e0655007 	rsb	r5, r5, r7
    61cc:	e7c03005 	strb	r3, [r0, r5]
        r->Link.sockshost.av_val = hostname;
        r->Link.sockshost.av_len = strlen(hostname);
    61d0:	ebfffbca 	bl	5100 <strlen@plt>
    61d4:	e5840100 	str	r0, [r4, #256]	; 0x100
        
        r->Link.socksport = socksport ? atoi(socksport + 1) : 1080;
    61d8:	e2870001 	add	r0, r7, #1
    61dc:	ebfffbca 	bl	510c <atoi@plt>
    61e0:	e59420fc 	ldr	r2, [r4, #252]	; 0xfc
    61e4:	e1a00800 	lsl	r0, r0, #16
    61e8:	e1a01820 	lsr	r1, r0, #16
    61ec:	e1a03001 	mov	r3, r1
    61f0:	e2844f65 	add	r4, r4, #404	; 0x194
    61f4:	e1c410b0 	strh	r1, [r4]
        RTMP_Log(RTMP_LOGDEBUG, "Connecting via SOCKS proxy: %s:%d", r->Link.sockshost.av_val,
    61f8:	e59f1024 	ldr	r1, [pc, #36]	; 6224 <SocksSetup.part.2+0x98>
    61fc:	e3a00004 	mov	r0, #4
    6200:	e08f1001 	add	r1, pc, r1
    {
        r->Link.sockshost.av_val = NULL;
        r->Link.sockshost.av_len = 0;
        r->Link.socksport = 0;
    }
}
    6204:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
            hostname[socksport - sockshost->av_val] = '\0';
        r->Link.sockshost.av_val = hostname;
        r->Link.sockshost.av_len = strlen(hostname);
        
        r->Link.socksport = socksport ? atoi(socksport + 1) : 1080;
        RTMP_Log(RTMP_LOGDEBUG, "Connecting via SOCKS proxy: %s:%d", r->Link.sockshost.av_val,
    6208:	ea003de7 	b	159ac <RTMP_Log>
        char *hostname = strdup(sockshost->av_val);
        
        if (socksport)
            hostname[socksport - sockshost->av_val] = '\0';
        r->Link.sockshost.av_val = hostname;
        r->Link.sockshost.av_len = strlen(hostname);
    620c:	ebfffbbb 	bl	5100 <strlen@plt>
    6210:	e59f3010 	ldr	r3, [pc, #16]	; 6228 <SocksSetup.part.2+0x9c>
    6214:	e1a02006 	mov	r2, r6
        
        r->Link.socksport = socksport ? atoi(socksport + 1) : 1080;
    6218:	e1a01003 	mov	r1, r3
        char *hostname = strdup(sockshost->av_val);
        
        if (socksport)
            hostname[socksport - sockshost->av_val] = '\0';
        r->Link.sockshost.av_val = hostname;
        r->Link.sockshost.av_len = strlen(hostname);
    621c:	e5840100 	str	r0, [r4, #256]	; 0x100
    6220:	eafffff2 	b	61f0 <SocksSetup.part.2+0x64>
    6224:	00017e4c 	.word	0x00017e4c
    6228:	00000438 	.word	0x00000438

0000622c <b64enc>:


#ifdef CRYPTO
static int
b64enc(const unsigned char *input, int length, char *output, int maxsize)
{
    622c:	e92d4010 	push	{r4, lr}
    6230:	e24dd008 	sub	sp, sp, #8
    6234:	e1a0c001 	mov	ip, r1
    6238:	e1a04002 	mov	r4, r2
#ifdef USE_POLARSSL
    size_t buf_size = maxsize;
    623c:	e28d1008 	add	r1, sp, #8
    if(base64_encode((unsigned char *) output, &buf_size, input, length) == 0)
    6240:	e1a02000 	mov	r2, r0
#ifdef CRYPTO
static int
b64enc(const unsigned char *input, int length, char *output, int maxsize)
{
#ifdef USE_POLARSSL
    size_t buf_size = maxsize;
    6244:	e5213004 	str	r3, [r1, #-4]!
    if(base64_encode((unsigned char *) output, &buf_size, input, length) == 0)
    6248:	e1a00004 	mov	r0, r4
    624c:	e1a0300c 	mov	r3, ip
    6250:	ebfffbb0 	bl	5118 <base64_encode@plt>
    6254:	e2503000 	subs	r3, r0, #0
    6258:	1a000004 	bne	6270 <b64enc+0x44>
    {
        output[buf_size] = '\0';
    625c:	e59d2004 	ldr	r2, [sp, #4]
        return 1;
    6260:	e3a00001 	mov	r0, #1
{
#ifdef USE_POLARSSL
    size_t buf_size = maxsize;
    if(base64_encode((unsigned char *) output, &buf_size, input, length) == 0)
    {
        output[buf_size] = '\0';
    6264:	e7c43002 	strb	r3, [r4, r2]
        return 0;
    }
    BIO_free_all(b64);
#endif
    return 1;
}
    6268:	e28dd008 	add	sp, sp, #8
    626c:	e8bd8010 	pop	{r4, pc}
        output[buf_size] = '\0';
        return 1;
    }
    else
    {
        RTMP_Log(RTMP_LOGDEBUG, "%s, error", __FUNCTION__);
    6270:	e59f2020 	ldr	r2, [pc, #32]	; 6298 <b64enc+0x6c>
    6274:	e59f1020 	ldr	r1, [pc, #32]	; 629c <b64enc+0x70>
    6278:	e08f2002 	add	r2, pc, r2
    627c:	e3a00004 	mov	r0, #4
    6280:	e2822f56 	add	r2, r2, #344	; 0x158
    6284:	e08f1001 	add	r1, pc, r1
    6288:	eb003dc7 	bl	159ac <RTMP_Log>
    628c:	e3a00000 	mov	r0, #0
        return 0;
    }
    BIO_free_all(b64);
#endif
    return 1;
}
    6290:	e28dd008 	add	sp, sp, #8
    6294:	e8bd8010 	pop	{r4, pc}
    6298:	00016570 	.word	0x00016570
    629c:	00017dec 	.word	0x00017dec

000062a0 <DHInit.constprop.14>:
  MP_free(bn);
  return ret;
}

static MDH *
DHInit(int nKeyBits)
    62a0:	e92d4010 	push	{r4, lr}
{
  size_t res;
  MDH *dh = MDH_new();
    62a4:	e3a00001 	mov	r0, #1
    62a8:	e3a0106c 	mov	r1, #108	; 0x6c
    62ac:	ebfffb9c 	bl	5124 <calloc@plt>

  if (!dh)
    62b0:	e2504000 	subs	r4, r0, #0
    62b4:	0a000027 	beq	6358 <DHInit.constprop.14+0xb8>
    goto failed;

  MP_new(dh->g);
    62b8:	e3a0000c 	mov	r0, #12
    62bc:	ebfffb56 	bl	501c <malloc@plt>
    62c0:	e5840004 	str	r0, [r4, #4]
    62c4:	ebfffb57 	bl	5028 <mpi_init_polarssl@plt>

  if (!dh->g)
    62c8:	e5943004 	ldr	r3, [r4, #4]
    62cc:	e3530000 	cmp	r3, #0
    62d0:	0a00000a 	beq	6300 <DHInit.constprop.14+0x60>
    goto failed;

  MP_gethex(dh->p, P1024, res);	/* prime P1024, see dhgroups.h */
    62d4:	e3a0000c 	mov	r0, #12
    62d8:	ebfffb4f 	bl	501c <malloc@plt>
    62dc:	e5840000 	str	r0, [r4]
    62e0:	ebfffb50 	bl	5028 <mpi_init_polarssl@plt>
    62e4:	e59f2090 	ldr	r2, [pc, #144]	; 637c <DHInit.constprop.14+0xdc>
    62e8:	e5940000 	ldr	r0, [r4]
    62ec:	e3a01010 	mov	r1, #16
    62f0:	e08f2002 	add	r2, pc, r2
    62f4:	ebfffb66 	bl	5094 <mpi_read_string_polarssl@plt>
  if (!res)
    62f8:	e3500000 	cmp	r0, #0
    62fc:	0a000017 	beq	6360 <DHInit.constprop.14+0xc0>
  dh->length = nKeyBits;
  return dh;

failed:
  if (dh)
    MDH_free(dh);
    6300:	e2840014 	add	r0, r4, #20
    6304:	ebfffb89 	bl	5130 <dhm_free@plt>
    6308:	e5940000 	ldr	r0, [r4]
    630c:	ebfffb5a 	bl	507c <mpi_free_polarssl@plt>
    6310:	e5940000 	ldr	r0, [r4]
    6314:	ebfffb3a 	bl	5004 <free@plt>
    6318:	e5940004 	ldr	r0, [r4, #4]
    631c:	ebfffb56 	bl	507c <mpi_free_polarssl@plt>
    6320:	e5940004 	ldr	r0, [r4, #4]
    6324:	ebfffb36 	bl	5004 <free@plt>
    6328:	e5940008 	ldr	r0, [r4, #8]
    632c:	ebfffb52 	bl	507c <mpi_free_polarssl@plt>
    6330:	e5940008 	ldr	r0, [r4, #8]
    6334:	ebfffb32 	bl	5004 <free@plt>
    6338:	e594000c 	ldr	r0, [r4, #12]
    633c:	ebfffb4e 	bl	507c <mpi_free_polarssl@plt>
    6340:	e594000c 	ldr	r0, [r4, #12]
    6344:	ebfffb2e 	bl	5004 <free@plt>
    6348:	e1a00004 	mov	r0, r4
    634c:	ebfffb2c 	bl	5004 <free@plt>

  return 0;
    6350:	e3a00000 	mov	r0, #0
}
    6354:	e8bd8010 	pop	{r4, pc}

failed:
  if (dh)
    MDH_free(dh);

  return 0;
    6358:	e1a00004 	mov	r0, r4
    635c:	e8bd8010 	pop	{r4, pc}
  if (!res)
    {
      goto failed;
    }

  MP_set_w(dh->g, 2);	/* base 2 */
    6360:	e5940004 	ldr	r0, [r4, #4]
    6364:	e3a01002 	mov	r1, #2
    6368:	ebfffb31 	bl	5034 <mpi_lset_polarssl@plt>

  dh->length = nKeyBits;
    636c:	e3a03b01 	mov	r3, #1024	; 0x400
    6370:	e5843010 	str	r3, [r4, #16]
    6374:	e1a00004 	mov	r0, r4
    6378:	e8bd8010 	pop	{r4, pc}
    637c:	00017d8c 	.word	0x00017d8c

00006380 <DHGetPublicKey.constprop.15>:

static int
DHGetPublicKey(MDH *dh, uint8_t *pubkey, size_t nPubkeyLen)
{
  int len;
  if (!dh || !dh->pub_key)
    6380:	e2503000 	subs	r3, r0, #0
    6384:	0a000017 	beq	63e8 <DHGetPublicKey.constprop.15+0x68>
    6388:	e5930008 	ldr	r0, [r3, #8]
    638c:	e3500000 	cmp	r0, #0
    6390:	0a000014 	beq	63e8 <DHGetPublicKey.constprop.15+0x68>
/* fill pubkey with the public key in BIG ENDIAN order
 * 00 00 00 00 00 x1 x2 x3 .....
 */

static int
DHGetPublicKey(MDH *dh, uint8_t *pubkey, size_t nPubkeyLen)
    6394:	e92d4070 	push	{r4, r5, r6, lr}
    6398:	e1a04003 	mov	r4, r3
    639c:	e1a05001 	mov	r5, r1
{
  int len;
  if (!dh || !dh->pub_key)
    return 0;

  len = MP_bytes(dh->pub_key);
    63a0:	ebfffb65 	bl	513c <mpi_size_polarssl@plt>
  if (len <= 0 || len > (int) nPubkeyLen)
    63a4:	e2403001 	sub	r3, r0, #1
    63a8:	e353007f 	cmp	r3, #127	; 0x7f
{
  int len;
  if (!dh || !dh->pub_key)
    return 0;

  len = MP_bytes(dh->pub_key);
    63ac:	e1a06000 	mov	r6, r0
  if (len <= 0 || len > (int) nPubkeyLen)
    63b0:	9a000001 	bls	63bc <DHGetPublicKey.constprop.15+0x3c>
static int
DHGetPublicKey(MDH *dh, uint8_t *pubkey, size_t nPubkeyLen)
{
  int len;
  if (!dh || !dh->pub_key)
    return 0;
    63b4:	e3a00000 	mov	r0, #0
    63b8:	e8bd8070 	pop	{r4, r5, r6, pc}

  len = MP_bytes(dh->pub_key);
  if (len <= 0 || len > (int) nPubkeyLen)
    return 0;

  memset(pubkey, 0, nPubkeyLen);
    63bc:	e1a00005 	mov	r0, r5
    63c0:	e3a01000 	mov	r1, #0
    63c4:	e3a02080 	mov	r2, #128	; 0x80
    63c8:	ebfffb40 	bl	50d0 <memset@plt>
  MP_setbin(dh->pub_key, pubkey + (nPubkeyLen - len), len);
    63cc:	e2661080 	rsb	r1, r6, #128	; 0x80
    63d0:	e5940008 	ldr	r0, [r4, #8]
    63d4:	e0851001 	add	r1, r5, r1
    63d8:	e1a02006 	mov	r2, r6
    63dc:	ebfffb59 	bl	5148 <mpi_write_binary_polarssl@plt>
  return 1;
    63e0:	e3a00001 	mov	r0, #1
}
    63e4:	e8bd8070 	pop	{r4, r5, r6, pc}
static int
DHGetPublicKey(MDH *dh, uint8_t *pubkey, size_t nPubkeyLen)
{
  int len;
  if (!dh || !dh->pub_key)
    return 0;
    63e8:	e3a00000 	mov	r0, #0
    return 0;

  memset(pubkey, 0, nPubkeyLen);
  MP_setbin(dh->pub_key, pubkey + (nPubkeyLen - len), len);
  return 1;
}
    63ec:	e12fff1e 	bx	lr

000063f0 <DHComputeSharedSecretKey.constprop.16>:
{
  MP_t q1 = NULL, pubkeyBn = NULL;
  size_t len;
  int res;

  if (!dh || !secret || nPubkeyLen >= INT_MAX)
    63f0:	e3520000 	cmp	r2, #0
    63f4:	13500000 	cmpne	r0, #0
    63f8:	0a000041 	beq	6504 <DHComputeSharedSecretKey.constprop.16+0x114>

/* computes the shared secret key from the private MDH value and the
 * other party's public key (pubkey)
 */
static int
DHComputeSharedSecretKey(MDH *dh, uint8_t *pubkey, size_t nPubkeyLen,
    63fc:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    6400:	e1a06000 	mov	r6, r0
    6404:	e24dd008 	sub	sp, sp, #8
  int res;

  if (!dh || !secret || nPubkeyLen >= INT_MAX)
    return -1;

  MP_getbin(pubkeyBn, pubkey, nPubkeyLen);
    6408:	e3a0000c 	mov	r0, #12
    640c:	e1a07002 	mov	r7, r2
    6410:	e1a05001 	mov	r5, r1
    6414:	ebfffb00 	bl	501c <malloc@plt>
    6418:	e1a04000 	mov	r4, r0
    641c:	ebfffb01 	bl	5028 <mpi_init_polarssl@plt>
    6420:	e1a00004 	mov	r0, r4
    6424:	e1a01005 	mov	r1, r5
    6428:	e3a02080 	mov	r2, #128	; 0x80
    642c:	ebfffb48 	bl	5154 <mpi_read_binary_polarssl@plt>
  if (!pubkeyBn)
    6430:	e3540000 	cmp	r4, #0
    6434:	0a000034 	beq	650c <DHComputeSharedSecretKey.constprop.16+0x11c>
    return -1;

  MP_gethex(q1, Q1024, len);
    6438:	e3a0000c 	mov	r0, #12
    643c:	ebfffaf6 	bl	501c <malloc@plt>
    6440:	e1a05000 	mov	r5, r0
    6444:	ebfffaf7 	bl	5028 <mpi_init_polarssl@plt>
    6448:	e59f20c4 	ldr	r2, [pc, #196]	; 6514 <DHComputeSharedSecretKey.constprop.16+0x124>
    644c:	e1a00005 	mov	r0, r5
    6450:	e3a01010 	mov	r1, #16
    6454:	e08f2002 	add	r2, pc, r2
    6458:	ebfffb0d 	bl	5094 <mpi_read_string_polarssl@plt>
  assert(len);
    645c:	e3500000 	cmp	r0, #0
    6460:	1a000011 	bne	64ac <DHComputeSharedSecretKey.constprop.16+0xbc>

  if (isValidPublicKey(pubkeyBn, dh->p, q1))
    6464:	e5961000 	ldr	r1, [r6]
    6468:	e1a00004 	mov	r0, r4
    646c:	e1a02005 	mov	r2, r5
    6470:	ebfffd8d 	bl	5aac <isValidPublicKey>
    6474:	e3500000 	cmp	r0, #0
    res = MDH_compute_key(secret, nPubkeyLen, pubkeyBn, dh);
  else
    res = -1;
    6478:	03e06000 	mvneq	r6, #0
    return -1;

  MP_gethex(q1, Q1024, len);
  assert(len);

  if (isValidPublicKey(pubkeyBn, dh->p, q1))
    647c:	1a000014 	bne	64d4 <DHComputeSharedSecretKey.constprop.16+0xe4>
    res = MDH_compute_key(secret, nPubkeyLen, pubkeyBn, dh);
  else
    res = -1;

  MP_free(q1);
    6480:	e1a00005 	mov	r0, r5
    6484:	ebfffafc 	bl	507c <mpi_free_polarssl@plt>
    6488:	e1a00005 	mov	r0, r5
    648c:	ebfffadc 	bl	5004 <free@plt>
  MP_free(pubkeyBn);
    6490:	e1a00004 	mov	r0, r4
    6494:	ebfffaf8 	bl	507c <mpi_free_polarssl@plt>
    6498:	e1a00004 	mov	r0, r4
    649c:	ebfffad8 	bl	5004 <free@plt>

  return res;
    64a0:	e1a00006 	mov	r0, r6
}
    64a4:	e28dd008 	add	sp, sp, #8
    64a8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  MP_getbin(pubkeyBn, pubkey, nPubkeyLen);
  if (!pubkeyBn)
    return -1;

  MP_gethex(q1, Q1024, len);
  assert(len);
    64ac:	e59f2064 	ldr	r2, [pc, #100]	; 6518 <DHComputeSharedSecretKey.constprop.16+0x128>
    64b0:	e59f0064 	ldr	r0, [pc, #100]	; 651c <DHComputeSharedSecretKey.constprop.16+0x12c>
    64b4:	e59f3064 	ldr	r3, [pc, #100]	; 6520 <DHComputeSharedSecretKey.constprop.16+0x130>
    64b8:	e08f2002 	add	r2, pc, r2
    64bc:	e08f0000 	add	r0, pc, r0
    64c0:	e2822e16 	add	r2, r2, #352	; 0x160
    64c4:	e59f1058 	ldr	r1, [pc, #88]	; 6524 <DHComputeSharedSecretKey.constprop.16+0x134>
    64c8:	e08f3003 	add	r3, pc, r3
    64cc:	ebfffacf 	bl	5010 <__assert2@plt>
    64d0:	eaffffe3 	b	6464 <DHComputeSharedSecretKey.constprop.16+0x74>
    64d4:	e3a03080 	mov	r3, #128	; 0x80
    64d8:	e28d8008 	add	r8, sp, #8
  return 1;
}

static int MDH_compute_key(uint8_t *secret, size_t len, MP_t pub, MDH *dh)
{
  MP_set(&dh->ctx.GY, pub);
    64dc:	e2860048 	add	r0, r6, #72	; 0x48
    64e0:	e1a01004 	mov	r1, r4
    64e4:	e5283004 	str	r3, [r8, #-4]!
    64e8:	ebfffad7 	bl	504c <mpi_copy_polarssl@plt>
  dhm_calc_secret(&dh->ctx, secret, &len);
    64ec:	e2860014 	add	r0, r6, #20
    64f0:	e1a02008 	mov	r2, r8
    64f4:	e1a01007 	mov	r1, r7
    64f8:	ebfffb18 	bl	5160 <dhm_calc_secret@plt>

  MP_gethex(q1, Q1024, len);
  assert(len);

  if (isValidPublicKey(pubkeyBn, dh->p, q1))
    res = MDH_compute_key(secret, nPubkeyLen, pubkeyBn, dh);
    64fc:	e3a06000 	mov	r6, #0
    6500:	eaffffde 	b	6480 <DHComputeSharedSecretKey.constprop.16+0x90>
  MP_t q1 = NULL, pubkeyBn = NULL;
  size_t len;
  int res;

  if (!dh || !secret || nPubkeyLen >= INT_MAX)
    return -1;
    6504:	e3e00000 	mvn	r0, #0

  MP_free(q1);
  MP_free(pubkeyBn);

  return res;
}
    6508:	e12fff1e 	bx	lr
  MP_t q1 = NULL, pubkeyBn = NULL;
  size_t len;
  int res;

  if (!dh || !secret || nPubkeyLen >= INT_MAX)
    return -1;
    650c:	e3e00000 	mvn	r0, #0
    6510:	eaffffe3 	b	64a4 <DHComputeSharedSecretKey.constprop.16+0xb4>
    6514:	00017a74 	.word	0x00017a74
    6518:	00016330 	.word	0x00016330
    651c:	00017984 	.word	0x00017984
    6520:	00017cb8 	.word	0x00017cb8
    6524:	0000016d 	.word	0x0000016d

00006528 <hexenc.constprop.18>:
#endif

static const AVal av_authmod_adobe = AVC("authmod=adobe");
static const AVal av_authmod_llnw  = AVC("authmod=llnw");

static void hexenc(unsigned char *inbuf, int len, char *dst)
    6528:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
{
    char *ptr = dst;
    while(len--) {
        sprintf(ptr, "%02x", *inbuf++);
    652c:	e59f7038 	ldr	r7, [pc, #56]	; 656c <hexenc.constprop.18+0x44>
#endif

static const AVal av_authmod_adobe = AVC("authmod=adobe");
static const AVal av_authmod_llnw  = AVC("authmod=llnw");

static void hexenc(unsigned char *inbuf, int len, char *dst)
    6530:	e1a04000 	mov	r4, r0
    6534:	e1a08001 	mov	r8, r1
{
    char *ptr = dst;
    while(len--) {
        sprintf(ptr, "%02x", *inbuf++);
    6538:	e08f7007 	add	r7, pc, r7
    653c:	e2806010 	add	r6, r0, #16
static const AVal av_authmod_adobe = AVC("authmod=adobe");
static const AVal av_authmod_llnw  = AVC("authmod=llnw");

static void hexenc(unsigned char *inbuf, int len, char *dst)
{
    char *ptr = dst;
    6540:	e1a05001 	mov	r5, r1
    while(len--) {
        sprintf(ptr, "%02x", *inbuf++);
    6544:	e4d42001 	ldrb	r2, [r4], #1
    6548:	e1a00005 	mov	r0, r5
    654c:	e1a01007 	mov	r1, r7
    6550:	ebfffb05 	bl	516c <sprintf@plt>
static const AVal av_authmod_llnw  = AVC("authmod=llnw");

static void hexenc(unsigned char *inbuf, int len, char *dst)
{
    char *ptr = dst;
    while(len--) {
    6554:	e1540006 	cmp	r4, r6
        sprintf(ptr, "%02x", *inbuf++);
        ptr += 2;
    6558:	e2855002 	add	r5, r5, #2
static const AVal av_authmod_llnw  = AVC("authmod=llnw");

static void hexenc(unsigned char *inbuf, int len, char *dst)
{
    char *ptr = dst;
    while(len--) {
    655c:	1afffff8 	bne	6544 <hexenc.constprop.18+0x1c>
        sprintf(ptr, "%02x", *inbuf++);
        ptr += 2;
    }
    *ptr = '\0';
    6560:	e3a03000 	mov	r3, #0
    6564:	e5c83020 	strb	r3, [r8, #32]
    6568:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    656c:	00017c4c 	.word	0x00017c4c

00006570 <PublisherAuth.isra.7>:
            return &av->av_val[i];
    return NULL;
}

static int
PublisherAuth(RTMP *r, AVal *description)
    6570:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    char response[RESPONSE_LEN];
    char challenge2[CHALLENGE2_LEN];
    char salted2[SALTED2_LEN];
    AVal pubToken;
    
    if (strstr(description->av_val, av_authmod_adobe.av_val) != NULL)
    6574:	e59f6ed4 	ldr	r6, [pc, #3796]	; 7450 <PublisherAuth.isra.7+0xee0>
            return &av->av_val[i];
    return NULL;
}

static int
PublisherAuth(RTMP *r, AVal *description)
    6578:	e1a05001 	mov	r5, r1
    char response[RESPONSE_LEN];
    char challenge2[CHALLENGE2_LEN];
    char salted2[SALTED2_LEN];
    AVal pubToken;
    
    if (strstr(description->av_val, av_authmod_adobe.av_val) != NULL)
    657c:	e08f6006 	add	r6, pc, r6
            return &av->av_val[i];
    return NULL;
}

static int
PublisherAuth(RTMP *r, AVal *description)
    6580:	e24ddf79 	sub	sp, sp, #484	; 0x1e4
    6584:	e1a04000 	mov	r4, r0
    char response[RESPONSE_LEN];
    char challenge2[CHALLENGE2_LEN];
    char salted2[SALTED2_LEN];
    AVal pubToken;
    
    if (strstr(description->av_val, av_authmod_adobe.av_val) != NULL)
    6588:	e1a01006 	mov	r1, r6
    658c:	e1a00005 	mov	r0, r5
    6590:	ebfffaf8 	bl	5178 <strstr@plt>
    6594:	e3500000 	cmp	r0, #0
    6598:	0a000072 	beq	6768 <PublisherAuth.isra.7+0x1f8>
    {
        if(strstr(description->av_val, "code=403 need auth") != NULL)
    659c:	e59f1eb0 	ldr	r1, [pc, #3760]	; 7454 <PublisherAuth.isra.7+0xee4>
    65a0:	e1a00005 	mov	r0, r5
    65a4:	e08f1001 	add	r1, pc, r1
    65a8:	ebfffaf2 	bl	5178 <strstr@plt>
    65ac:	e2509000 	subs	r9, r0, #0
    65b0:	0a0000cd 	beq	68ec <PublisherAuth.isra.7+0x37c>
        {
            if (strstr(r->Link.app.av_val, av_authmod_adobe.av_val) != NULL) {
    65b4:	e284b901 	add	fp, r4, #16384	; 0x4000
    65b8:	e59b012c 	ldr	r0, [fp, #300]	; 0x12c
    65bc:	e1a01006 	mov	r1, r6
    65c0:	ebfffaec 	bl	5178 <strstr@plt>
    65c4:	e3500000 	cmp	r0, #0
    65c8:	0a000009 	beq	65f4 <PublisherAuth.isra.7+0x84>
                RTMP_Log(RTMP_LOGERROR, "%s, wrong pubUser & pubPasswd for publisher auth", __FUNCTION__);
    65cc:	e59f2e84 	ldr	r2, [pc, #3716]	; 7458 <PublisherAuth.isra.7+0xee8>
    65d0:	e59f1e84 	ldr	r1, [pc, #3716]	; 745c <PublisherAuth.isra.7+0xeec>
    65d4:	e08f2002 	add	r2, pc, r2
    65d8:	e3a00001 	mov	r0, #1
    65dc:	e2822f5f 	add	r2, r2, #380	; 0x17c
    65e0:	e08f1001 	add	r1, pc, r1
    65e4:	eb003cf0 	bl	159ac <RTMP_Log>
                return 0;
    65e8:	e3a00000 	mov	r0, #0
    else
    {
        return 0;
    }
    return 1;
}
    65ec:	e28ddf79 	add	sp, sp, #484	; 0x1e4
    65f0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(strstr(description->av_val, "code=403 need auth") != NULL)
        {
            if (strstr(r->Link.app.av_val, av_authmod_adobe.av_val) != NULL) {
                RTMP_Log(RTMP_LOGERROR, "%s, wrong pubUser & pubPasswd for publisher auth", __FUNCTION__);
                return 0;
            } else if(r->Link.pubUser.av_len && r->Link.pubPasswd.av_len) {
    65f4:	e59b0160 	ldr	r0, [fp, #352]	; 0x160
    65f8:	e3500000 	cmp	r0, #0
    65fc:	0a000002 	beq	660c <PublisherAuth.isra.7+0x9c>
    6600:	e59b3168 	ldr	r3, [fp, #360]	; 0x168
    6604:	e3530000 	cmp	r3, #0
    6608:	1a000009 	bne	6634 <PublisherAuth.isra.7+0xc4>
                pubToken.av_len = sprintf(pubToken.av_val, "?%s&user=%s",
                                          av_authmod_adobe.av_val,
                                          r->Link.pubUser.av_val);
                RTMP_Log(RTMP_LOGDEBUG, "%s, pubToken1: %s", __FUNCTION__, pubToken.av_val);
            } else {
                RTMP_Log(RTMP_LOGERROR, "%s, need to set pubUser & pubPasswd for publisher auth", __FUNCTION__);
    660c:	e59f2e4c 	ldr	r2, [pc, #3660]	; 7460 <PublisherAuth.isra.7+0xef0>
    6610:	e59f1e4c 	ldr	r1, [pc, #3660]	; 7464 <PublisherAuth.isra.7+0xef4>
    6614:	e08f2002 	add	r2, pc, r2
    6618:	e3a00001 	mov	r0, #1
    661c:	e2822f5f 	add	r2, r2, #380	; 0x17c
    6620:	e08f1001 	add	r1, pc, r1
    6624:	eb003ce0 	bl	159ac <RTMP_Log>
                return 0;
    6628:	e3a00000 	mov	r0, #0
    else
    {
        return 0;
    }
    return 1;
}
    662c:	e28ddf79 	add	sp, sp, #484	; 0x1e4
    6630:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        {
            if (strstr(r->Link.app.av_val, av_authmod_adobe.av_val) != NULL) {
                RTMP_Log(RTMP_LOGERROR, "%s, wrong pubUser & pubPasswd for publisher auth", __FUNCTION__);
                return 0;
            } else if(r->Link.pubUser.av_len && r->Link.pubPasswd.av_len) {
                pubToken.av_val = malloc(r->Link.pubUser.av_len + av_authmod_adobe.av_len + 8);
    6634:	e2800015 	add	r0, r0, #21
    6638:	ebfffa77 	bl	501c <malloc@plt>
                pubToken.av_len = sprintf(pubToken.av_val, "?%s&user=%s",
    663c:	e59f1e24 	ldr	r1, [pc, #3620]	; 7468 <PublisherAuth.isra.7+0xef8>
    6640:	e1a02006 	mov	r2, r6
    6644:	e08f1001 	add	r1, pc, r1
    6648:	e59b315c 	ldr	r3, [fp, #348]	; 0x15c
        {
            if (strstr(r->Link.app.av_val, av_authmod_adobe.av_val) != NULL) {
                RTMP_Log(RTMP_LOGERROR, "%s, wrong pubUser & pubPasswd for publisher auth", __FUNCTION__);
                return 0;
            } else if(r->Link.pubUser.av_len && r->Link.pubPasswd.av_len) {
                pubToken.av_val = malloc(r->Link.pubUser.av_len + av_authmod_adobe.av_len + 8);
    664c:	e1a07000 	mov	r7, r0
                pubToken.av_len = sprintf(pubToken.av_val, "?%s&user=%s",
    6650:	ebfffac5 	bl	516c <sprintf@plt>
                                          av_authmod_adobe.av_val,
                                          r->Link.pubUser.av_val);
                RTMP_Log(RTMP_LOGDEBUG, "%s, pubToken1: %s", __FUNCTION__, pubToken.av_val);
    6654:	e59f2e10 	ldr	r2, [pc, #3600]	; 746c <PublisherAuth.isra.7+0xefc>
    6658:	e59f1e10 	ldr	r1, [pc, #3600]	; 7470 <PublisherAuth.isra.7+0xf00>
    665c:	e08f2002 	add	r2, pc, r2
    6660:	e1a03007 	mov	r3, r7
    6664:	e2822f5f 	add	r2, r2, #380	; 0x17c
    6668:	e08f1001 	add	r1, pc, r1
            if (strstr(r->Link.app.av_val, av_authmod_adobe.av_val) != NULL) {
                RTMP_Log(RTMP_LOGERROR, "%s, wrong pubUser & pubPasswd for publisher auth", __FUNCTION__);
                return 0;
            } else if(r->Link.pubUser.av_len && r->Link.pubPasswd.av_len) {
                pubToken.av_val = malloc(r->Link.pubUser.av_len + av_authmod_adobe.av_len + 8);
                pubToken.av_len = sprintf(pubToken.av_val, "?%s&user=%s",
    666c:	e1a06000 	mov	r6, r0
                                          av_authmod_adobe.av_val,
                                          r->Link.pubUser.av_val);
                RTMP_Log(RTMP_LOGDEBUG, "%s, pubToken1: %s", __FUNCTION__, pubToken.av_val);
    6670:	e3a00004 	mov	r0, #4
    6674:	eb003ccc 	bl	159ac <RTMP_Log>
            RTMP_Log(RTMP_LOGERROR, "%s, Authentication failed: unknown auth mode: %s",
                     __FUNCTION__, description->av_val);
            return 0;
        }
        
        ptr = malloc(r->Link.app.av_len + pubToken.av_len);
    6678:	e59b4130 	ldr	r4, [fp, #304]	; 0x130
    667c:	e0848006 	add	r8, r4, r6
    6680:	e1a00008 	mov	r0, r8
    6684:	ebfffa64 	bl	501c <malloc@plt>
        strncpy(ptr, r->Link.app.av_val, r->Link.app.av_len);
    6688:	e59b912c 	ldr	r9, [fp, #300]	; 0x12c
    668c:	e1a02004 	mov	r2, r4
    6690:	e1a01009 	mov	r1, r9
            RTMP_Log(RTMP_LOGERROR, "%s, Authentication failed: unknown auth mode: %s",
                     __FUNCTION__, description->av_val);
            return 0;
        }
        
        ptr = malloc(r->Link.app.av_len + pubToken.av_len);
    6694:	e1a05000 	mov	r5, r0
        strncpy(ptr, r->Link.app.av_val, r->Link.app.av_len);
    6698:	ebfffab9 	bl	5184 <strncpy@plt>
        strncpy(ptr + r->Link.app.av_len, pubToken.av_val, pubToken.av_len);
    669c:	e0850004 	add	r0, r5, r4
    66a0:	e1a01007 	mov	r1, r7
    66a4:	e1a02006 	mov	r2, r6
    66a8:	ebfffab5 	bl	5184 <strncpy@plt>
        r->Link.app.av_len += pubToken.av_len;
        if(r->Link.lFlags & RTMP_LF_FAPU)
    66ac:	e59b4180 	ldr	r4, [fp, #384]	; 0x180
        }
        
        ptr = malloc(r->Link.app.av_len + pubToken.av_len);
        strncpy(ptr, r->Link.app.av_val, r->Link.app.av_len);
        strncpy(ptr + r->Link.app.av_len, pubToken.av_val, pubToken.av_len);
        r->Link.app.av_len += pubToken.av_len;
    66b0:	e58b8130 	str	r8, [fp, #304]	; 0x130
        if(r->Link.lFlags & RTMP_LF_FAPU)
    66b4:	e3140040 	tst	r4, #64	; 0x40
    66b8:	1a000175 	bne	6c94 <PublisherAuth.isra.7+0x724>
            free(r->Link.app.av_val);
        r->Link.app.av_val = ptr;
        
        ptr = malloc(r->Link.tcUrl.av_len + pubToken.av_len);
    66bc:	e59ba118 	ldr	sl, [fp, #280]	; 0x118
        strncpy(ptr, r->Link.app.av_val, r->Link.app.av_len);
        strncpy(ptr + r->Link.app.av_len, pubToken.av_val, pubToken.av_len);
        r->Link.app.av_len += pubToken.av_len;
        if(r->Link.lFlags & RTMP_LF_FAPU)
            free(r->Link.app.av_val);
        r->Link.app.av_val = ptr;
    66c0:	e58b512c 	str	r5, [fp, #300]	; 0x12c
        
        ptr = malloc(r->Link.tcUrl.av_len + pubToken.av_len);
    66c4:	e086800a 	add	r8, r6, sl
    66c8:	e1a00008 	mov	r0, r8
    66cc:	ebfffa52 	bl	501c <malloc@plt>
        strncpy(ptr, r->Link.tcUrl.av_val, r->Link.tcUrl.av_len);
    66d0:	e59b3114 	ldr	r3, [fp, #276]	; 0x114
    66d4:	e1a0200a 	mov	r2, sl
    66d8:	e1a01003 	mov	r1, r3
    66dc:	e58d3018 	str	r3, [sp, #24]
        r->Link.app.av_len += pubToken.av_len;
        if(r->Link.lFlags & RTMP_LF_FAPU)
            free(r->Link.app.av_val);
        r->Link.app.av_val = ptr;
        
        ptr = malloc(r->Link.tcUrl.av_len + pubToken.av_len);
    66e0:	e1a09000 	mov	r9, r0
        strncpy(ptr, r->Link.tcUrl.av_val, r->Link.tcUrl.av_len);
    66e4:	ebfffaa6 	bl	5184 <strncpy@plt>
        strncpy(ptr + r->Link.tcUrl.av_len, pubToken.av_val, pubToken.av_len);
    66e8:	e089000a 	add	r0, r9, sl
    66ec:	e1a02006 	mov	r2, r6
    66f0:	e1a01007 	mov	r1, r7
    66f4:	ebfffaa2 	bl	5184 <strncpy@plt>
        r->Link.tcUrl.av_len += pubToken.av_len;
        if(r->Link.lFlags & RTMP_LF_FTCU)
    66f8:	e3140020 	tst	r4, #32
        r->Link.app.av_val = ptr;
        
        ptr = malloc(r->Link.tcUrl.av_len + pubToken.av_len);
        strncpy(ptr, r->Link.tcUrl.av_val, r->Link.tcUrl.av_len);
        strncpy(ptr + r->Link.tcUrl.av_len, pubToken.av_val, pubToken.av_len);
        r->Link.tcUrl.av_len += pubToken.av_len;
    66fc:	e58b8118 	str	r8, [fp, #280]	; 0x118
        if(r->Link.lFlags & RTMP_LF_FTCU)
    6700:	e59d3018 	ldr	r3, [sp, #24]
    6704:	0a000004 	beq	671c <PublisherAuth.isra.7+0x1ac>
            free(r->Link.tcUrl.av_val);
    6708:	e1a00003 	mov	r0, r3
    670c:	ebfffa3c 	bl	5004 <free@plt>
    6710:	e59b4180 	ldr	r4, [fp, #384]	; 0x180
    6714:	e59b512c 	ldr	r5, [fp, #300]	; 0x12c
    6718:	e59b8118 	ldr	r8, [fp, #280]	; 0x118
        r->Link.tcUrl.av_val = ptr;
        
        free(pubToken.av_val);
    671c:	e1a00007 	mov	r0, r7
        strncpy(ptr, r->Link.tcUrl.av_val, r->Link.tcUrl.av_len);
        strncpy(ptr + r->Link.tcUrl.av_len, pubToken.av_val, pubToken.av_len);
        r->Link.tcUrl.av_len += pubToken.av_len;
        if(r->Link.lFlags & RTMP_LF_FTCU)
            free(r->Link.tcUrl.av_val);
        r->Link.tcUrl.av_val = ptr;
    6720:	e58b9114 	str	r9, [fp, #276]	; 0x114
        
        free(pubToken.av_val);
    6724:	ebfffa36 	bl	5004 <free@plt>
        r->Link.lFlags |= RTMP_LF_FTCU | RTMP_LF_FAPU;
    6728:	e3844060 	orr	r4, r4, #96	; 0x60
        
        RTMP_Log(RTMP_LOGDEBUG, "%s, new app: %.*s tcUrl: %.*s playpath: %s", __FUNCTION__,
    672c:	e59b110c 	ldr	r1, [fp, #268]	; 0x10c
    6730:	e59f2d3c 	ldr	r2, [pc, #3388]	; 7474 <PublisherAuth.isra.7+0xf04>
    6734:	e59b3130 	ldr	r3, [fp, #304]	; 0x130
        if(r->Link.lFlags & RTMP_LF_FTCU)
            free(r->Link.tcUrl.av_val);
        r->Link.tcUrl.av_val = ptr;
        
        free(pubToken.av_val);
        r->Link.lFlags |= RTMP_LF_FTCU | RTMP_LF_FAPU;
    6738:	e58b4180 	str	r4, [fp, #384]	; 0x180
        
        RTMP_Log(RTMP_LOGDEBUG, "%s, new app: %.*s tcUrl: %.*s playpath: %s", __FUNCTION__,
    673c:	e58d100c 	str	r1, [sp, #12]
    6740:	e59f1d30 	ldr	r1, [pc, #3376]	; 7478 <PublisherAuth.isra.7+0xf08>
    6744:	e08f2002 	add	r2, pc, r2
    6748:	e88d0320 	stm	sp, {r5, r8, r9}
    674c:	e2822f5f 	add	r2, r2, #380	; 0x17c
    6750:	e3a00004 	mov	r0, #4
    6754:	e08f1001 	add	r1, pc, r1
    6758:	eb003c93 	bl	159ac <RTMP_Log>
    }
    else
    {
        return 0;
    }
    return 1;
    675c:	e3a00001 	mov	r0, #1
}
    6760:	e28ddf79 	add	sp, sp, #484	; 0x1e4
    6764:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        RTMP_Log(RTMP_LOGDEBUG, "%s, new app: %.*s tcUrl: %.*s playpath: %s", __FUNCTION__,
                 r->Link.app.av_len, r->Link.app.av_val,
                 r->Link.tcUrl.av_len, r->Link.tcUrl.av_val,
                 r->Link.playpath.av_val);
    }
    else if (strstr(description->av_val, av_authmod_llnw.av_val) != NULL)
    6768:	e59f7d0c 	ldr	r7, [pc, #3340]	; 747c <PublisherAuth.isra.7+0xf0c>
    676c:	e1a00005 	mov	r0, r5
    6770:	e08f7007 	add	r7, pc, r7
    6774:	e1a01007 	mov	r1, r7
    6778:	ebfffa7e 	bl	5178 <strstr@plt>
    677c:	e3500000 	cmp	r0, #0
    6780:	0affff99 	beq	65ec <PublisherAuth.isra.7+0x7c>
    {
        if(strstr(description->av_val, "code=403 need auth") != NULL)
    6784:	e59f1cf4 	ldr	r1, [pc, #3316]	; 7480 <PublisherAuth.isra.7+0xf10>
    6788:	e1a00005 	mov	r0, r5
    678c:	e08f1001 	add	r1, pc, r1
    6790:	ebfffa78 	bl	5178 <strstr@plt>
    6794:	e2508000 	subs	r8, r0, #0
    6798:	0a00017b 	beq	6d8c <PublisherAuth.isra.7+0x81c>
        {
            /* This part seems to be the same for llnw and adobe */
            
            if (strstr(r->Link.app.av_val, av_authmod_llnw.av_val) != NULL) {
    679c:	e284b901 	add	fp, r4, #16384	; 0x4000
    67a0:	e59b012c 	ldr	r0, [fp, #300]	; 0x12c
    67a4:	e1a01007 	mov	r1, r7
    67a8:	ebfffa72 	bl	5178 <strstr@plt>
    67ac:	e3500000 	cmp	r0, #0
    67b0:	1affff85 	bne	65cc <PublisherAuth.isra.7+0x5c>
                RTMP_Log(RTMP_LOGERROR, "%s, wrong pubUser & pubPasswd for publisher auth", __FUNCTION__);
                return 0;
            } else if(r->Link.pubUser.av_len && r->Link.pubPasswd.av_len) {
    67b4:	e59b0160 	ldr	r0, [fp, #352]	; 0x160
    67b8:	e3500000 	cmp	r0, #0
    67bc:	0affff92 	beq	660c <PublisherAuth.isra.7+0x9c>
    67c0:	e59b3168 	ldr	r3, [fp, #360]	; 0x168
    67c4:	e3530000 	cmp	r3, #0
    67c8:	0affff8f 	beq	660c <PublisherAuth.isra.7+0x9c>
                pubToken.av_val = malloc(r->Link.pubUser.av_len + av_authmod_llnw.av_len + 8);
    67cc:	e2800014 	add	r0, r0, #20
    67d0:	ebfffa11 	bl	501c <malloc@plt>
                pubToken.av_len = sprintf(pubToken.av_val, "?%s&user=%s",
    67d4:	e59f1ca8 	ldr	r1, [pc, #3240]	; 7484 <PublisherAuth.isra.7+0xf14>
    67d8:	e1a02007 	mov	r2, r7
    67dc:	e08f1001 	add	r1, pc, r1
    67e0:	e59b315c 	ldr	r3, [fp, #348]	; 0x15c
            
            if (strstr(r->Link.app.av_val, av_authmod_llnw.av_val) != NULL) {
                RTMP_Log(RTMP_LOGERROR, "%s, wrong pubUser & pubPasswd for publisher auth", __FUNCTION__);
                return 0;
            } else if(r->Link.pubUser.av_len && r->Link.pubPasswd.av_len) {
                pubToken.av_val = malloc(r->Link.pubUser.av_len + av_authmod_llnw.av_len + 8);
    67e4:	e1a04000 	mov	r4, r0
                pubToken.av_len = sprintf(pubToken.av_val, "?%s&user=%s",
    67e8:	ebfffa5f 	bl	516c <sprintf@plt>
                                          av_authmod_llnw.av_val,
                                          r->Link.pubUser.av_val);
                RTMP_Log(RTMP_LOGDEBUG, "%s, pubToken1: %s", __FUNCTION__, pubToken.av_val);
    67ec:	e59f2c94 	ldr	r2, [pc, #3220]	; 7488 <PublisherAuth.isra.7+0xf18>
    67f0:	e59f1c94 	ldr	r1, [pc, #3220]	; 748c <PublisherAuth.isra.7+0xf1c>
    67f4:	e08f2002 	add	r2, pc, r2
    67f8:	e1a03004 	mov	r3, r4
    67fc:	e2822f5f 	add	r2, r2, #380	; 0x17c
    6800:	e08f1001 	add	r1, pc, r1
            if (strstr(r->Link.app.av_val, av_authmod_llnw.av_val) != NULL) {
                RTMP_Log(RTMP_LOGERROR, "%s, wrong pubUser & pubPasswd for publisher auth", __FUNCTION__);
                return 0;
            } else if(r->Link.pubUser.av_len && r->Link.pubPasswd.av_len) {
                pubToken.av_val = malloc(r->Link.pubUser.av_len + av_authmod_llnw.av_len + 8);
                pubToken.av_len = sprintf(pubToken.av_val, "?%s&user=%s",
    6804:	e1a07000 	mov	r7, r0
                                          av_authmod_llnw.av_val,
                                          r->Link.pubUser.av_val);
                RTMP_Log(RTMP_LOGDEBUG, "%s, pubToken1: %s", __FUNCTION__, pubToken.av_val);
    6808:	e3a00004 	mov	r0, #4
    680c:	eb003c66 	bl	159ac <RTMP_Log>
            RTMP_Log(RTMP_LOGERROR, "%s, Authentication failed: unknown auth mode: %s",
                     __FUNCTION__, description->av_val);
            return 0;
        }
        
        ptr = malloc(r->Link.app.av_len + pubToken.av_len);
    6810:	e59b5130 	ldr	r5, [fp, #304]	; 0x130
    6814:	e0858007 	add	r8, r5, r7
    6818:	e1a00008 	mov	r0, r8
    681c:	ebfff9fe 	bl	501c <malloc@plt>
        strncpy(ptr, r->Link.app.av_val, r->Link.app.av_len);
    6820:	e59b912c 	ldr	r9, [fp, #300]	; 0x12c
    6824:	e1a02005 	mov	r2, r5
    6828:	e1a01009 	mov	r1, r9
            RTMP_Log(RTMP_LOGERROR, "%s, Authentication failed: unknown auth mode: %s",
                     __FUNCTION__, description->av_val);
            return 0;
        }
        
        ptr = malloc(r->Link.app.av_len + pubToken.av_len);
    682c:	e1a06000 	mov	r6, r0
        strncpy(ptr, r->Link.app.av_val, r->Link.app.av_len);
    6830:	ebfffa53 	bl	5184 <strncpy@plt>
        strncpy(ptr + r->Link.app.av_len, pubToken.av_val, pubToken.av_len);
    6834:	e0860005 	add	r0, r6, r5
    6838:	e1a01004 	mov	r1, r4
    683c:	e1a02007 	mov	r2, r7
    6840:	ebfffa4f 	bl	5184 <strncpy@plt>
        r->Link.app.av_len += pubToken.av_len;
        if(r->Link.lFlags & RTMP_LF_FAPU)
    6844:	e59b5180 	ldr	r5, [fp, #384]	; 0x180
        }
        
        ptr = malloc(r->Link.app.av_len + pubToken.av_len);
        strncpy(ptr, r->Link.app.av_val, r->Link.app.av_len);
        strncpy(ptr + r->Link.app.av_len, pubToken.av_val, pubToken.av_len);
        r->Link.app.av_len += pubToken.av_len;
    6848:	e58b8130 	str	r8, [fp, #304]	; 0x130
        if(r->Link.lFlags & RTMP_LF_FAPU)
    684c:	e3150040 	tst	r5, #64	; 0x40
    6850:	1a0002d6 	bne	73b0 <PublisherAuth.isra.7+0xe40>
            free(r->Link.app.av_val);
        r->Link.app.av_val = ptr;
        
        ptr = malloc(r->Link.tcUrl.av_len + pubToken.av_len);
    6854:	e59ba118 	ldr	sl, [fp, #280]	; 0x118
        strncpy(ptr, r->Link.app.av_val, r->Link.app.av_len);
        strncpy(ptr + r->Link.app.av_len, pubToken.av_val, pubToken.av_len);
        r->Link.app.av_len += pubToken.av_len;
        if(r->Link.lFlags & RTMP_LF_FAPU)
            free(r->Link.app.av_val);
        r->Link.app.av_val = ptr;
    6858:	e58b612c 	str	r6, [fp, #300]	; 0x12c
        
        ptr = malloc(r->Link.tcUrl.av_len + pubToken.av_len);
    685c:	e087900a 	add	r9, r7, sl
    6860:	e1a00009 	mov	r0, r9
    6864:	ebfff9ec 	bl	501c <malloc@plt>
        strncpy(ptr, r->Link.tcUrl.av_val, r->Link.tcUrl.av_len);
    6868:	e59b3114 	ldr	r3, [fp, #276]	; 0x114
    686c:	e1a0200a 	mov	r2, sl
    6870:	e1a01003 	mov	r1, r3
    6874:	e58d3018 	str	r3, [sp, #24]
        r->Link.app.av_len += pubToken.av_len;
        if(r->Link.lFlags & RTMP_LF_FAPU)
            free(r->Link.app.av_val);
        r->Link.app.av_val = ptr;
        
        ptr = malloc(r->Link.tcUrl.av_len + pubToken.av_len);
    6878:	e1a08000 	mov	r8, r0
        strncpy(ptr, r->Link.tcUrl.av_val, r->Link.tcUrl.av_len);
    687c:	ebfffa40 	bl	5184 <strncpy@plt>
        strncpy(ptr + r->Link.tcUrl.av_len, pubToken.av_val, pubToken.av_len);
    6880:	e088000a 	add	r0, r8, sl
    6884:	e1a02007 	mov	r2, r7
    6888:	e1a01004 	mov	r1, r4
    688c:	ebfffa3c 	bl	5184 <strncpy@plt>
        r->Link.tcUrl.av_len += pubToken.av_len;
        if(r->Link.lFlags & RTMP_LF_FTCU)
    6890:	e3150020 	tst	r5, #32
        r->Link.app.av_val = ptr;
        
        ptr = malloc(r->Link.tcUrl.av_len + pubToken.av_len);
        strncpy(ptr, r->Link.tcUrl.av_val, r->Link.tcUrl.av_len);
        strncpy(ptr + r->Link.tcUrl.av_len, pubToken.av_val, pubToken.av_len);
        r->Link.tcUrl.av_len += pubToken.av_len;
    6894:	e58b9118 	str	r9, [fp, #280]	; 0x118
        if(r->Link.lFlags & RTMP_LF_FTCU)
    6898:	e59d3018 	ldr	r3, [sp, #24]
    689c:	1a0002bd 	bne	7398 <PublisherAuth.isra.7+0xe28>
            free(r->Link.tcUrl.av_val);
        r->Link.tcUrl.av_val = ptr;
        
        free(pubToken.av_val);
    68a0:	e1a00004 	mov	r0, r4
        strncpy(ptr, r->Link.tcUrl.av_val, r->Link.tcUrl.av_len);
        strncpy(ptr + r->Link.tcUrl.av_len, pubToken.av_val, pubToken.av_len);
        r->Link.tcUrl.av_len += pubToken.av_len;
        if(r->Link.lFlags & RTMP_LF_FTCU)
            free(r->Link.tcUrl.av_val);
        r->Link.tcUrl.av_val = ptr;
    68a4:	e58b8114 	str	r8, [fp, #276]	; 0x114
        
        free(pubToken.av_val);
    68a8:	ebfff9d5 	bl	5004 <free@plt>
        r->Link.lFlags |= RTMP_LF_FTCU | RTMP_LF_FAPU;
    68ac:	e3855060 	orr	r5, r5, #96	; 0x60
        
        RTMP_Log(RTMP_LOGDEBUG, "%s, new app: %.*s tcUrl: %.*s playpath: %s", __FUNCTION__,
    68b0:	e59b110c 	ldr	r1, [fp, #268]	; 0x10c
    68b4:	e59f2bd4 	ldr	r2, [pc, #3028]	; 7490 <PublisherAuth.isra.7+0xf20>
    68b8:	e59b3130 	ldr	r3, [fp, #304]	; 0x130
        if(r->Link.lFlags & RTMP_LF_FTCU)
            free(r->Link.tcUrl.av_val);
        r->Link.tcUrl.av_val = ptr;
        
        free(pubToken.av_val);
        r->Link.lFlags |= RTMP_LF_FTCU | RTMP_LF_FAPU;
    68bc:	e58b5180 	str	r5, [fp, #384]	; 0x180
        
        RTMP_Log(RTMP_LOGDEBUG, "%s, new app: %.*s tcUrl: %.*s playpath: %s", __FUNCTION__,
    68c0:	e58d100c 	str	r1, [sp, #12]
    68c4:	e59f1bc8 	ldr	r1, [pc, #3016]	; 7494 <PublisherAuth.isra.7+0xf24>
    68c8:	e08f2002 	add	r2, pc, r2
    68cc:	e3a00004 	mov	r0, #4
    68d0:	e88d0240 	stm	sp, {r6, r9}
    68d4:	e58d8008 	str	r8, [sp, #8]
    68d8:	e2822f5f 	add	r2, r2, #380	; 0x17c
    68dc:	e08f1001 	add	r1, pc, r1
    68e0:	eb003c31 	bl	159ac <RTMP_Log>
    }
    else
    {
        return 0;
    }
    return 1;
    68e4:	e3a00001 	mov	r0, #1
    68e8:	eaffff3f 	b	65ec <PublisherAuth.isra.7+0x7c>
            } else {
                RTMP_Log(RTMP_LOGERROR, "%s, need to set pubUser & pubPasswd for publisher auth", __FUNCTION__);
                return 0;
            }
        }
        else if((token_in = strstr(description->av_val, "?reason=needauth")) != NULL)
    68ec:	e59f1ba4 	ldr	r1, [pc, #2980]	; 7498 <PublisherAuth.isra.7+0xf28>
    68f0:	e1a00005 	mov	r0, r5
    68f4:	e08f1001 	add	r1, pc, r1
    68f8:	ebfffa1e 	bl	5178 <strstr@plt>
    68fc:	e2507000 	subs	r7, r0, #0
    6900:	0a000112 	beq	6d50 <PublisherAuth.isra.7+0x7e0>
        {
            char *par, *val = NULL, *orig_ptr;
            AVal user, salt, opaque, challenge, *aptr = NULL;
            opaque.av_len = 0;
    6904:	e58d9060 	str	r9, [sp, #96]	; 0x60
            challenge.av_len = 0;
    6908:	e58d906c 	str	r9, [sp, #108]	; 0x6c
            
            ptr = orig_ptr = strdup(token_in);
    690c:	ebfff9f8 	bl	50f4 <strdup@plt>
            while (ptr)
    6910:	e2503000 	subs	r3, r0, #0
    6914:	e58d3020 	str	r3, [sp, #32]
    6918:	0a0002a8 	beq	73c0 <PublisherAuth.isra.7+0xe50>
                    user.av_val = val;
                    aptr = &user;
                } else if (strcmp(par, "salt") == 0){
                    salt.av_val = val;
                    aptr = &salt;
                } else if (strcmp(par, "opaque") == 0){
    691c:	e59f2b78 	ldr	r2, [pc, #2936]	; 749c <PublisherAuth.isra.7+0xf2c>
                } else if (strcmp(par, "challenge") == 0){
                    challenge.av_val = val;
                    aptr = &challenge;
                }
                
                RTMP_Log(RTMP_LOGDEBUG, "%s, par:\"%s\" = val:\"%s\"", __FUNCTION__, par, val);
    6920:	e59f8b78 	ldr	r8, [pc, #2936]	; 74a0 <PublisherAuth.isra.7+0xf30>
                    user.av_val = val;
                    aptr = &user;
                } else if (strcmp(par, "salt") == 0){
                    salt.av_val = val;
                    aptr = &salt;
                } else if (strcmp(par, "opaque") == 0){
    6924:	e08f2002 	add	r2, pc, r2
            AVal user, salt, opaque, challenge, *aptr = NULL;
            opaque.av_len = 0;
            challenge.av_len = 0;
            
            ptr = orig_ptr = strdup(token_in);
            while (ptr)
    6928:	e1a05003 	mov	r5, r3
                    user.av_val = val;
                    aptr = &user;
                } else if (strcmp(par, "salt") == 0){
                    salt.av_val = val;
                    aptr = &salt;
                } else if (strcmp(par, "opaque") == 0){
    692c:	e58d2018 	str	r2, [sp, #24]
                    aptr = NULL;
                }
                if (strcmp(par, "user") == 0){
                    user.av_val = val;
                    aptr = &user;
                } else if (strcmp(par, "salt") == 0){
    6930:	e59f3b6c 	ldr	r3, [pc, #2924]	; 74a4 <PublisherAuth.isra.7+0xf34>
                    salt.av_val = val;
                    aptr = &salt;
                } else if (strcmp(par, "opaque") == 0){
                    opaque.av_val = val;
                    aptr = &opaque;
                } else if (strcmp(par, "challenge") == 0){
    6934:	e59f2b6c 	ldr	r2, [pc, #2924]	; 74a8 <PublisherAuth.isra.7+0xf38>
            AVal user, salt, opaque, challenge, *aptr = NULL;
            opaque.av_len = 0;
            challenge.av_len = 0;
            
            ptr = orig_ptr = strdup(token_in);
            while (ptr)
    6938:	e1a0b009 	mov	fp, r9
                
                if (aptr) {
                    aptr->av_len = par - aptr->av_val - 1;
                    aptr = NULL;
                }
                if (strcmp(par, "user") == 0){
    693c:	e59fab68 	ldr	sl, [pc, #2920]	; 74ac <PublisherAuth.isra.7+0xf3c>
                } else if (strcmp(par, "challenge") == 0){
                    challenge.av_val = val;
                    aptr = &challenge;
                }
                
                RTMP_Log(RTMP_LOGDEBUG, "%s, par:\"%s\" = val:\"%s\"", __FUNCTION__, par, val);
    6940:	e59f9b68 	ldr	r9, [pc, #2920]	; 74b0 <PublisherAuth.isra.7+0xf40>
    6944:	e08f8008 	add	r8, pc, r8
                    aptr = NULL;
                }
                if (strcmp(par, "user") == 0){
                    user.av_val = val;
                    aptr = &user;
                } else if (strcmp(par, "salt") == 0){
    6948:	e08f3003 	add	r3, pc, r3
                    salt.av_val = val;
                    aptr = &salt;
                } else if (strcmp(par, "opaque") == 0){
                    opaque.av_val = val;
                    aptr = &opaque;
                } else if (strcmp(par, "challenge") == 0){
    694c:	e08f2002 	add	r2, pc, r2
    6950:	e58d4024 	str	r4, [sp, #36]	; 0x24
                    challenge.av_val = val;
                    aptr = &challenge;
                }
                
                RTMP_Log(RTMP_LOGDEBUG, "%s, par:\"%s\" = val:\"%s\"", __FUNCTION__, par, val);
    6954:	e2888f5f 	add	r8, r8, #380	; 0x17c
                
                if (aptr) {
                    aptr->av_len = par - aptr->av_val - 1;
                    aptr = NULL;
                }
                if (strcmp(par, "user") == 0){
    6958:	e08fa00a 	add	sl, pc, sl
                    salt.av_val = val;
                    aptr = &salt;
                } else if (strcmp(par, "opaque") == 0){
                    opaque.av_val = val;
                    aptr = &opaque;
                } else if (strcmp(par, "challenge") == 0){
    695c:	e58d201c 	str	r2, [sp, #28]
                    challenge.av_val = val;
                    aptr = &challenge;
                }
                
                RTMP_Log(RTMP_LOGDEBUG, "%s, par:\"%s\" = val:\"%s\"", __FUNCTION__, par, val);
    6960:	e08f9009 	add	r9, pc, r9
    6964:	e1a04003 	mov	r4, r3
    6968:	ea000000 	b	6970 <PublisherAuth.isra.7+0x400>
            AVal user, salt, opaque, challenge, *aptr = NULL;
            opaque.av_len = 0;
            challenge.av_len = 0;
            
            ptr = orig_ptr = strdup(token_in);
            while (ptr)
    696c:	e1a05007 	mov	r5, r7
            {
                par = ptr;
                ptr = strchr(par, '&');
    6970:	e3a01026 	mov	r1, #38	; 0x26
    6974:	e1a00005 	mov	r0, r5
    6978:	ebfff9da 	bl	50e8 <strchr@plt>
                if(ptr)
                    *ptr++ = '\0';
                
                val =  strchr(par, '=');
    697c:	e3a0103d 	mov	r1, #61	; 0x3d
            ptr = orig_ptr = strdup(token_in);
            while (ptr)
            {
                par = ptr;
                ptr = strchr(par, '&');
                if(ptr)
    6980:	e3500000 	cmp	r0, #0
                    *ptr++ = '\0';
    6984:	13a03000 	movne	r3, #0
    6988:	15c03000 	strbne	r3, [r0]
    698c:	12807001 	addne	r7, r0, #1
            ptr = orig_ptr = strdup(token_in);
            while (ptr)
            {
                par = ptr;
                ptr = strchr(par, '&');
                if(ptr)
    6990:	01a07000 	moveq	r7, r0
                    *ptr++ = '\0';
                
                val =  strchr(par, '=');
    6994:	e1a00005 	mov	r0, r5
    6998:	ebfff9d2 	bl	50e8 <strchr@plt>
                
                if (aptr) {
                    aptr->av_len = par - aptr->av_val - 1;
                    aptr = NULL;
                }
                if (strcmp(par, "user") == 0){
    699c:	e1a0100a 	mov	r1, sl
                ptr = strchr(par, '&');
                if(ptr)
                    *ptr++ = '\0';
                
                val =  strchr(par, '=');
                if(val)
    69a0:	e3500000 	cmp	r0, #0
                    *val++ = '\0';
    69a4:	13a03000 	movne	r3, #0
    69a8:	15c03000 	strbne	r3, [r0]
                ptr = strchr(par, '&');
                if(ptr)
                    *ptr++ = '\0';
                
                val =  strchr(par, '=');
                if(val)
    69ac:	01a06000 	moveq	r6, r0
                    *val++ = '\0';
    69b0:	12806001 	addne	r6, r0, #1
                
                if (aptr) {
    69b4:	e35b0000 	cmp	fp, #0
                    aptr->av_len = par - aptr->av_val - 1;
    69b8:	159b3000 	ldrne	r3, [fp]
                    aptr = NULL;
                }
                if (strcmp(par, "user") == 0){
    69bc:	e1a00005 	mov	r0, r5
                val =  strchr(par, '=');
                if(val)
                    *val++ = '\0';
                
                if (aptr) {
                    aptr->av_len = par - aptr->av_val - 1;
    69c0:	10633005 	rsbne	r3, r3, r5
    69c4:	12433001 	subne	r3, r3, #1
    69c8:	158b3004 	strne	r3, [fp, #4]
                    aptr = NULL;
                }
                if (strcmp(par, "user") == 0){
    69cc:	ebfff9ef 	bl	5190 <strcmp@plt>
    69d0:	e3500000 	cmp	r0, #0
                    user.av_val = val;
    69d4:	028dbe1e 	addeq	fp, sp, #480	; 0x1e0
    69d8:	052b6194 	streq	r6, [fp, #-404]!	; 0xfffffe6c
                
                if (aptr) {
                    aptr->av_len = par - aptr->av_val - 1;
                    aptr = NULL;
                }
                if (strcmp(par, "user") == 0){
    69dc:	0a000014 	beq	6a34 <PublisherAuth.isra.7+0x4c4>
                    user.av_val = val;
                    aptr = &user;
                } else if (strcmp(par, "salt") == 0){
    69e0:	e1a00005 	mov	r0, r5
    69e4:	e1a01004 	mov	r1, r4
    69e8:	ebfff9e8 	bl	5190 <strcmp@plt>
    69ec:	e3500000 	cmp	r0, #0
                    salt.av_val = val;
    69f0:	028dbe1e 	addeq	fp, sp, #480	; 0x1e0
    69f4:	052b618c 	streq	r6, [fp, #-396]!	; 0xfffffe74
                    aptr = NULL;
                }
                if (strcmp(par, "user") == 0){
                    user.av_val = val;
                    aptr = &user;
                } else if (strcmp(par, "salt") == 0){
    69f8:	0a00000d 	beq	6a34 <PublisherAuth.isra.7+0x4c4>
                    salt.av_val = val;
                    aptr = &salt;
                } else if (strcmp(par, "opaque") == 0){
    69fc:	e1a00005 	mov	r0, r5
    6a00:	e59d1018 	ldr	r1, [sp, #24]
    6a04:	ebfff9e1 	bl	5190 <strcmp@plt>
    6a08:	e3500000 	cmp	r0, #0
                    opaque.av_val = val;
    6a0c:	028dbe1e 	addeq	fp, sp, #480	; 0x1e0
    6a10:	052b6184 	streq	r6, [fp, #-388]!	; 0xfffffe7c
                    user.av_val = val;
                    aptr = &user;
                } else if (strcmp(par, "salt") == 0){
                    salt.av_val = val;
                    aptr = &salt;
                } else if (strcmp(par, "opaque") == 0){
    6a14:	0a000006 	beq	6a34 <PublisherAuth.isra.7+0x4c4>
                    opaque.av_val = val;
                    aptr = &opaque;
                } else if (strcmp(par, "challenge") == 0){
    6a18:	e1a00005 	mov	r0, r5
    6a1c:	e59d101c 	ldr	r1, [sp, #28]
    6a20:	ebfff9da 	bl	5190 <strcmp@plt>
    6a24:	e3500000 	cmp	r0, #0
                    challenge.av_val = val;
    6a28:	028dbe1e 	addeq	fp, sp, #480	; 0x1e0
                    salt.av_val = val;
                    aptr = &salt;
                } else if (strcmp(par, "opaque") == 0){
                    opaque.av_val = val;
                    aptr = &opaque;
                } else if (strcmp(par, "challenge") == 0){
    6a2c:	13a0b000 	movne	fp, #0
                    challenge.av_val = val;
    6a30:	052b6178 	streq	r6, [fp, #-376]!	; 0xfffffe88
                    aptr = &challenge;
                }
                
                RTMP_Log(RTMP_LOGDEBUG, "%s, par:\"%s\" = val:\"%s\"", __FUNCTION__, par, val);
    6a34:	e58d6000 	str	r6, [sp]
    6a38:	e1a03005 	mov	r3, r5
    6a3c:	e3a00004 	mov	r0, #4
    6a40:	e1a01009 	mov	r1, r9
    6a44:	e1a02008 	mov	r2, r8
    6a48:	eb003bd7 	bl	159ac <RTMP_Log>
            AVal user, salt, opaque, challenge, *aptr = NULL;
            opaque.av_len = 0;
            challenge.av_len = 0;
            
            ptr = orig_ptr = strdup(token_in);
            while (ptr)
    6a4c:	e3570000 	cmp	r7, #0
    6a50:	1affffc5 	bne	696c <PublisherAuth.isra.7+0x3fc>
                    aptr = &challenge;
                }
                
                RTMP_Log(RTMP_LOGDEBUG, "%s, par:\"%s\" = val:\"%s\"", __FUNCTION__, par, val);
            }
            if (aptr)
    6a54:	e35b0000 	cmp	fp, #0
    6a58:	e59d4024 	ldr	r4, [sp, #36]	; 0x24
    6a5c:	0a000002 	beq	6a6c <PublisherAuth.isra.7+0x4fc>
                aptr->av_len = strlen(aptr->av_val);
    6a60:	e59b0000 	ldr	r0, [fp]
    6a64:	ebfff9a5 	bl	5100 <strlen@plt>
    6a68:	e58b0004 	str	r0, [fp, #4]
    6a6c:	e59da060 	ldr	sl, [sp, #96]	; 0x60
            
            /* hash1 = base64enc(md5(user + _aodbeAuthSalt + password)) */
            MD5_Init(&md5ctx);
    6a70:	e28d5f42 	add	r5, sp, #264	; 0x108
    6a74:	e1a00005 	mov	r0, r5
    6a78:	ebfff9c7 	bl	519c <md5_starts@plt>
            MD5_Update(&md5ctx, user.av_val, user.av_len);
    6a7c:	e59d804c 	ldr	r8, [sp, #76]	; 0x4c
    6a80:	e1a00005 	mov	r0, r5
    6a84:	e1a01008 	mov	r1, r8
    6a88:	e59d2050 	ldr	r2, [sp, #80]	; 0x50
    6a8c:	ebfff9c5 	bl	51a8 <md5_update_polarssl@plt>
            MD5_Update(&md5ctx, salt.av_val, salt.av_len);
    6a90:	e59d9054 	ldr	r9, [sp, #84]	; 0x54
            MD5_Update(&md5ctx, r->Link.pubPasswd.av_val, r->Link.pubPasswd.av_len);
    6a94:	e284b901 	add	fp, r4, #16384	; 0x4000
                aptr->av_len = strlen(aptr->av_val);
            
            /* hash1 = base64enc(md5(user + _aodbeAuthSalt + password)) */
            MD5_Init(&md5ctx);
            MD5_Update(&md5ctx, user.av_val, user.av_len);
            MD5_Update(&md5ctx, salt.av_val, salt.av_len);
    6a98:	e1a01009 	mov	r1, r9
    6a9c:	e1a00005 	mov	r0, r5
    6aa0:	e59d2058 	ldr	r2, [sp, #88]	; 0x58
    6aa4:	ebfff9bf 	bl	51a8 <md5_update_polarssl@plt>
            MD5_Update(&md5ctx, r->Link.pubPasswd.av_val, r->Link.pubPasswd.av_len);
            MD5_Final(md5sum_val, &md5ctx);
    6aa8:	e28d6074 	add	r6, sp, #116	; 0x74
            
            /* hash1 = base64enc(md5(user + _aodbeAuthSalt + password)) */
            MD5_Init(&md5ctx);
            MD5_Update(&md5ctx, user.av_val, user.av_len);
            MD5_Update(&md5ctx, salt.av_val, salt.av_len);
            MD5_Update(&md5ctx, r->Link.pubPasswd.av_val, r->Link.pubPasswd.av_len);
    6aac:	e59b2168 	ldr	r2, [fp, #360]	; 0x168
    6ab0:	e1a00005 	mov	r0, r5
    6ab4:	e59b1164 	ldr	r1, [fp, #356]	; 0x164
    6ab8:	ebfff9ba 	bl	51a8 <md5_update_polarssl@plt>
            MD5_Final(md5sum_val, &md5ctx);
            RTMP_Log(RTMP_LOGDEBUG, "%s, md5(%s%s%s) =>", __FUNCTION__,
    6abc:	e59f79f0 	ldr	r7, [pc, #2544]	; 74b4 <PublisherAuth.isra.7+0xf44>
            /* hash1 = base64enc(md5(user + _aodbeAuthSalt + password)) */
            MD5_Init(&md5ctx);
            MD5_Update(&md5ctx, user.av_val, user.av_len);
            MD5_Update(&md5ctx, salt.av_val, salt.av_len);
            MD5_Update(&md5ctx, r->Link.pubPasswd.av_val, r->Link.pubPasswd.av_len);
            MD5_Final(md5sum_val, &md5ctx);
    6ac0:	e1a00005 	mov	r0, r5
    6ac4:	e1a01006 	mov	r1, r6
    6ac8:	ebfff9b9 	bl	51b4 <md5_finish_polarssl@plt>
            RTMP_Log(RTMP_LOGDEBUG, "%s, md5(%s%s%s) =>", __FUNCTION__,
    6acc:	e59f39e4 	ldr	r3, [pc, #2532]	; 74b8 <PublisherAuth.isra.7+0xf48>
    6ad0:	e08f7007 	add	r7, pc, r7
    6ad4:	e59b2164 	ldr	r2, [fp, #356]	; 0x164
    6ad8:	e08f3003 	add	r3, pc, r3
    6adc:	e2877f5f 	add	r7, r7, #380	; 0x17c
    6ae0:	e1a01003 	mov	r1, r3
    6ae4:	e58d3018 	str	r3, [sp, #24]
    6ae8:	e58d9000 	str	r9, [sp]
    6aec:	e1a03008 	mov	r3, r8
    6af0:	e58d2004 	str	r2, [sp, #4]
    6af4:	e3a00004 	mov	r0, #4
    6af8:	e1a02007 	mov	r2, r7
    6afc:	eb003baa 	bl	159ac <RTMP_Log>
                     user.av_val, salt.av_val, r->Link.pubPasswd.av_val);
            RTMP_LogHexString(RTMP_LOGDEBUG, md5sum_val, MD5_DIGEST_LENGTH);
            
            b64enc(md5sum_val, MD5_DIGEST_LENGTH, salted2, SALTED2_LEN);
    6b00:	e28d90d0 	add	r9, sp, #208	; 0xd0
            MD5_Update(&md5ctx, salt.av_val, salt.av_len);
            MD5_Update(&md5ctx, r->Link.pubPasswd.av_val, r->Link.pubPasswd.av_len);
            MD5_Final(md5sum_val, &md5ctx);
            RTMP_Log(RTMP_LOGDEBUG, "%s, md5(%s%s%s) =>", __FUNCTION__,
                     user.av_val, salt.av_val, r->Link.pubPasswd.av_val);
            RTMP_LogHexString(RTMP_LOGDEBUG, md5sum_val, MD5_DIGEST_LENGTH);
    6b04:	e1a01006 	mov	r1, r6
    6b08:	e3a00004 	mov	r0, #4
    6b0c:	e3a02010 	mov	r2, #16
    6b10:	eb003bf3 	bl	15ae4 <RTMP_LogHexString>
            
            b64enc(md5sum_val, MD5_DIGEST_LENGTH, salted2, SALTED2_LEN);
    6b14:	e1a02009 	mov	r2, r9
    6b18:	e3a01010 	mov	r1, #16
    6b1c:	e3a03038 	mov	r3, #56	; 0x38
    6b20:	e1a00006 	mov	r0, r6
    6b24:	ebfffdc0 	bl	622c <b64enc>
            RTMP_Log(RTMP_LOGDEBUG, "%s, b64(md5_1) = %s", __FUNCTION__, salted2);
    6b28:	e59f198c 	ldr	r1, [pc, #2444]	; 74bc <PublisherAuth.isra.7+0xf4c>
    6b2c:	e1a02007 	mov	r2, r7
    6b30:	e1a03009 	mov	r3, r9
    6b34:	e08f1001 	add	r1, pc, r1
    6b38:	e3a00004 	mov	r0, #4
    6b3c:	eb003b9a 	bl	159ac <RTMP_Log>
extern void arc4random_stir(void);
extern void arc4random_addrandom(unsigned char *, int);

#define RAND_MAX 0x7fffffff
static __inline__ int rand(void) {
    return (int)lrand48();
    6b40:	ebfff99e 	bl	51c0 <lrand48@plt>
            
            challenge2_data = rand();
            
            b64enc((unsigned char *) &challenge2_data, sizeof(int), challenge2, CHALLENGE2_LEN);
    6b44:	e28d4088 	add	r4, sp, #136	; 0x88
            RTMP_LogHexString(RTMP_LOGDEBUG, md5sum_val, MD5_DIGEST_LENGTH);
            
            b64enc(md5sum_val, MD5_DIGEST_LENGTH, salted2, SALTED2_LEN);
            RTMP_Log(RTMP_LOGDEBUG, "%s, b64(md5_1) = %s", __FUNCTION__, salted2);
            
            challenge2_data = rand();
    6b48:	e28dee1e 	add	lr, sp, #480	; 0x1e0
            
            b64enc((unsigned char *) &challenge2_data, sizeof(int), challenge2, CHALLENGE2_LEN);
    6b4c:	e1a02004 	mov	r2, r4
    6b50:	e3a01004 	mov	r1, #4
    6b54:	e3a03010 	mov	r3, #16
            RTMP_LogHexString(RTMP_LOGDEBUG, md5sum_val, MD5_DIGEST_LENGTH);
            
            b64enc(md5sum_val, MD5_DIGEST_LENGTH, salted2, SALTED2_LEN);
            RTMP_Log(RTMP_LOGDEBUG, "%s, b64(md5_1) = %s", __FUNCTION__, salted2);
            
            challenge2_data = rand();
    6b58:	e52e019c 	str	r0, [lr, #-412]!	; 0xfffffe64
            
            b64enc((unsigned char *) &challenge2_data, sizeof(int), challenge2, CHALLENGE2_LEN);
    6b5c:	e1a0000e 	mov	r0, lr
    6b60:	ebfffdb1 	bl	622c <b64enc>
            RTMP_Log(RTMP_LOGDEBUG, "%s, b64(%d) = %s", __FUNCTION__, challenge2_data, challenge2);
    6b64:	e59f1954 	ldr	r1, [pc, #2388]	; 74c0 <PublisherAuth.isra.7+0xf50>
    6b68:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
    6b6c:	e1a02007 	mov	r2, r7
    6b70:	e08f1001 	add	r1, pc, r1
    6b74:	e3a00004 	mov	r0, #4
    6b78:	e58d4000 	str	r4, [sp]
    6b7c:	eb003b8a 	bl	159ac <RTMP_Log>
            
            MD5_Init(&md5ctx);
    6b80:	e1a00005 	mov	r0, r5
    6b84:	ebfff984 	bl	519c <md5_starts@plt>
            MD5_Update(&md5ctx, salted2, B64DIGEST_LEN);
    6b88:	e1a00005 	mov	r0, r5
    6b8c:	e1a01009 	mov	r1, r9
    6b90:	e3a02018 	mov	r2, #24
    6b94:	ebfff983 	bl	51a8 <md5_update_polarssl@plt>
            /* response = base64enc(md5(hash1 + opaque + challenge2)) */
            if (opaque.av_len)
    6b98:	e35a0000 	cmp	sl, #0
    6b9c:	1a000044 	bne	6cb4 <PublisherAuth.isra.7+0x744>
                MD5_Update(&md5ctx, opaque.av_val, opaque.av_len);
            else if (challenge.av_len)
    6ba0:	e59d206c 	ldr	r2, [sp, #108]	; 0x6c
    6ba4:	e3520000 	cmp	r2, #0
    6ba8:	1a00003d 	bne	6ca4 <PublisherAuth.isra.7+0x734>
                MD5_Update(&md5ctx, challenge.av_val, challenge.av_len);
            MD5_Update(&md5ctx, challenge2, B64INT_LEN);
    6bac:	e1a00005 	mov	r0, r5
    6bb0:	e3a02008 	mov	r2, #8
    6bb4:	e1a01004 	mov	r1, r4
    6bb8:	ebfff97a 	bl	51a8 <md5_update_polarssl@plt>
            MD5_Final(md5sum_val, &md5ctx);
    6bbc:	e1a00005 	mov	r0, r5
            
            RTMP_Log(RTMP_LOGDEBUG, "%s, md5(%s%s%s) =>", __FUNCTION__,
    6bc0:	e59f58fc 	ldr	r5, [pc, #2300]	; 74c4 <PublisherAuth.isra.7+0xf54>
            if (opaque.av_len)
                MD5_Update(&md5ctx, opaque.av_val, opaque.av_len);
            else if (challenge.av_len)
                MD5_Update(&md5ctx, challenge.av_val, challenge.av_len);
            MD5_Update(&md5ctx, challenge2, B64INT_LEN);
            MD5_Final(md5sum_val, &md5ctx);
    6bc4:	e1a01006 	mov	r1, r6
            
            RTMP_Log(RTMP_LOGDEBUG, "%s, md5(%s%s%s) =>", __FUNCTION__,
    6bc8:	e59f88f8 	ldr	r8, [pc, #2296]	; 74c8 <PublisherAuth.isra.7+0xf58>
            if (opaque.av_len)
                MD5_Update(&md5ctx, opaque.av_val, opaque.av_len);
            else if (challenge.av_len)
                MD5_Update(&md5ctx, challenge.av_val, challenge.av_len);
            MD5_Update(&md5ctx, challenge2, B64INT_LEN);
            MD5_Final(md5sum_val, &md5ctx);
    6bcc:	ebfff978 	bl	51b4 <md5_finish_polarssl@plt>
            
            RTMP_Log(RTMP_LOGDEBUG, "%s, md5(%s%s%s) =>", __FUNCTION__,
    6bd0:	e08f5005 	add	r5, pc, r5
    6bd4:	e59f18f0 	ldr	r1, [pc, #2288]	; 74cc <PublisherAuth.isra.7+0xf5c>
    6bd8:	e2857f5f 	add	r7, r5, #380	; 0x17c
    6bdc:	e08f8008 	add	r8, pc, r8
    6be0:	e1a03009 	mov	r3, r9
    6be4:	e1a02007 	mov	r2, r7
    6be8:	e3a00004 	mov	r0, #4
    6bec:	e08f1001 	add	r1, pc, r1
    6bf0:	e58d4004 	str	r4, [sp, #4]
    6bf4:	e58d8000 	str	r8, [sp]
    6bf8:	eb003b6b 	bl	159ac <RTMP_Log>
                     salted2, opaque.av_len ? opaque.av_val : "", challenge2);
            RTMP_LogHexString(RTMP_LOGDEBUG, md5sum_val, MD5_DIGEST_LENGTH);
            
            b64enc(md5sum_val, MD5_DIGEST_LENGTH, response, RESPONSE_LEN);
    6bfc:	e28d50ac 	add	r5, sp, #172	; 0xac
            MD5_Update(&md5ctx, challenge2, B64INT_LEN);
            MD5_Final(md5sum_val, &md5ctx);
            
            RTMP_Log(RTMP_LOGDEBUG, "%s, md5(%s%s%s) =>", __FUNCTION__,
                     salted2, opaque.av_len ? opaque.av_val : "", challenge2);
            RTMP_LogHexString(RTMP_LOGDEBUG, md5sum_val, MD5_DIGEST_LENGTH);
    6c00:	e3a00004 	mov	r0, #4
    6c04:	e1a01006 	mov	r1, r6
    6c08:	e3a02010 	mov	r2, #16
    6c0c:	eb003bb4 	bl	15ae4 <RTMP_LogHexString>
            
            b64enc(md5sum_val, MD5_DIGEST_LENGTH, response, RESPONSE_LEN);
    6c10:	e1a02005 	mov	r2, r5
    6c14:	e3a01010 	mov	r1, #16
    6c18:	e3a03020 	mov	r3, #32
    6c1c:	e1a00006 	mov	r0, r6
    6c20:	ebfffd81 	bl	622c <b64enc>
            RTMP_Log(RTMP_LOGDEBUG, "%s, b64(md5_2) = %s", __FUNCTION__, response);
    6c24:	e59f18a4 	ldr	r1, [pc, #2212]	; 74d0 <PublisherAuth.isra.7+0xf60>
    6c28:	e1a02007 	mov	r2, r7
    6c2c:	e1a03005 	mov	r3, r5
    6c30:	e3a00004 	mov	r0, #4
    6c34:	e08f1001 	add	r1, pc, r1
    6c38:	eb003b5b 	bl	159ac <RTMP_Log>
            
            /* have all hashes, create auth token for the end of app */
            pubToken.av_val = malloc(32 + B64INT_LEN + B64DIGEST_LEN + opaque.av_len);
    6c3c:	e3a00040 	mov	r0, #64	; 0x40
    6c40:	ebfff8f5 	bl	501c <malloc@plt>
    6c44:	e1a07000 	mov	r7, r0
            pubToken.av_len = sprintf(pubToken.av_val,
    6c48:	e59f1884 	ldr	r1, [pc, #2180]	; 74d4 <PublisherAuth.isra.7+0xf64>
    6c4c:	e1a02004 	mov	r2, r4
    6c50:	e1a03005 	mov	r3, r5
    6c54:	e58d8000 	str	r8, [sp]
    6c58:	e1a00007 	mov	r0, r7
    6c5c:	e08f1001 	add	r1, pc, r1
    6c60:	ebfff941 	bl	516c <sprintf@plt>
                                      "&challenge=%s&response=%s&opaque=%s",
                                      challenge2,
                                      response,
                                      opaque.av_len ? opaque.av_val : "");
            RTMP_Log(RTMP_LOGDEBUG, "%s, pubToken2: %s", __FUNCTION__, pubToken.av_val);
    6c64:	e59f286c 	ldr	r2, [pc, #2156]	; 74d8 <PublisherAuth.isra.7+0xf68>
    6c68:	e59f186c 	ldr	r1, [pc, #2156]	; 74dc <PublisherAuth.isra.7+0xf6c>
    6c6c:	e08f2002 	add	r2, pc, r2
    6c70:	e2822f5f 	add	r2, r2, #380	; 0x17c
    6c74:	e08f1001 	add	r1, pc, r1
    6c78:	e1a03007 	mov	r3, r7
            b64enc(md5sum_val, MD5_DIGEST_LENGTH, response, RESPONSE_LEN);
            RTMP_Log(RTMP_LOGDEBUG, "%s, b64(md5_2) = %s", __FUNCTION__, response);
            
            /* have all hashes, create auth token for the end of app */
            pubToken.av_val = malloc(32 + B64INT_LEN + B64DIGEST_LEN + opaque.av_len);
            pubToken.av_len = sprintf(pubToken.av_val,
    6c7c:	e1a06000 	mov	r6, r0
                                      "&challenge=%s&response=%s&opaque=%s",
                                      challenge2,
                                      response,
                                      opaque.av_len ? opaque.av_val : "");
            RTMP_Log(RTMP_LOGDEBUG, "%s, pubToken2: %s", __FUNCTION__, pubToken.av_val);
    6c80:	e3a00004 	mov	r0, #4
    6c84:	eb003b48 	bl	159ac <RTMP_Log>
            free(orig_ptr);
    6c88:	e59d0020 	ldr	r0, [sp, #32]
    6c8c:	ebfff8dc 	bl	5004 <free@plt>
    6c90:	eafffe78 	b	6678 <PublisherAuth.isra.7+0x108>
        ptr = malloc(r->Link.app.av_len + pubToken.av_len);
        strncpy(ptr, r->Link.app.av_val, r->Link.app.av_len);
        strncpy(ptr + r->Link.app.av_len, pubToken.av_val, pubToken.av_len);
        r->Link.app.av_len += pubToken.av_len;
        if(r->Link.lFlags & RTMP_LF_FAPU)
            free(r->Link.app.av_val);
    6c94:	e1a00009 	mov	r0, r9
    6c98:	ebfff8d9 	bl	5004 <free@plt>
    6c9c:	e59b4180 	ldr	r4, [fp, #384]	; 0x180
    6ca0:	eafffe85 	b	66bc <PublisherAuth.isra.7+0x14c>
            MD5_Update(&md5ctx, salted2, B64DIGEST_LEN);
            /* response = base64enc(md5(hash1 + opaque + challenge2)) */
            if (opaque.av_len)
                MD5_Update(&md5ctx, opaque.av_val, opaque.av_len);
            else if (challenge.av_len)
                MD5_Update(&md5ctx, challenge.av_val, challenge.av_len);
    6ca4:	e1a00005 	mov	r0, r5
    6ca8:	e59d1068 	ldr	r1, [sp, #104]	; 0x68
    6cac:	ebfff93d 	bl	51a8 <md5_update_polarssl@plt>
    6cb0:	eaffffbd 	b	6bac <PublisherAuth.isra.7+0x63c>
            
            MD5_Init(&md5ctx);
            MD5_Update(&md5ctx, salted2, B64DIGEST_LEN);
            /* response = base64enc(md5(hash1 + opaque + challenge2)) */
            if (opaque.av_len)
                MD5_Update(&md5ctx, opaque.av_val, opaque.av_len);
    6cb4:	e59d805c 	ldr	r8, [sp, #92]	; 0x5c
    6cb8:	e1a00005 	mov	r0, r5
    6cbc:	e1a01008 	mov	r1, r8
    6cc0:	e1a0200a 	mov	r2, sl
    6cc4:	ebfff937 	bl	51a8 <md5_update_polarssl@plt>
            else if (challenge.av_len)
                MD5_Update(&md5ctx, challenge.av_val, challenge.av_len);
            MD5_Update(&md5ctx, challenge2, B64INT_LEN);
    6cc8:	e1a00005 	mov	r0, r5
    6ccc:	e3a02008 	mov	r2, #8
    6cd0:	e1a01004 	mov	r1, r4
    6cd4:	ebfff933 	bl	51a8 <md5_update_polarssl@plt>
            MD5_Final(md5sum_val, &md5ctx);
    6cd8:	e1a00005 	mov	r0, r5
    6cdc:	e1a01006 	mov	r1, r6
    6ce0:	ebfff933 	bl	51b4 <md5_finish_polarssl@plt>
            
            RTMP_Log(RTMP_LOGDEBUG, "%s, md5(%s%s%s) =>", __FUNCTION__,
    6ce4:	e1a03009 	mov	r3, r9
    6ce8:	e1a02007 	mov	r2, r7
    6cec:	e59d1018 	ldr	r1, [sp, #24]
    6cf0:	e3a00004 	mov	r0, #4
    6cf4:	e58d8000 	str	r8, [sp]
    6cf8:	e58d4004 	str	r4, [sp, #4]
    6cfc:	eb003b2a 	bl	159ac <RTMP_Log>
                     salted2, opaque.av_len ? opaque.av_val : "", challenge2);
            RTMP_LogHexString(RTMP_LOGDEBUG, md5sum_val, MD5_DIGEST_LENGTH);
            
            b64enc(md5sum_val, MD5_DIGEST_LENGTH, response, RESPONSE_LEN);
    6d00:	e28d50ac 	add	r5, sp, #172	; 0xac
            MD5_Update(&md5ctx, challenge2, B64INT_LEN);
            MD5_Final(md5sum_val, &md5ctx);
            
            RTMP_Log(RTMP_LOGDEBUG, "%s, md5(%s%s%s) =>", __FUNCTION__,
                     salted2, opaque.av_len ? opaque.av_val : "", challenge2);
            RTMP_LogHexString(RTMP_LOGDEBUG, md5sum_val, MD5_DIGEST_LENGTH);
    6d04:	e3a00004 	mov	r0, #4
    6d08:	e1a01006 	mov	r1, r6
    6d0c:	e3a02010 	mov	r2, #16
    6d10:	eb003b73 	bl	15ae4 <RTMP_LogHexString>
            
            b64enc(md5sum_val, MD5_DIGEST_LENGTH, response, RESPONSE_LEN);
    6d14:	e1a02005 	mov	r2, r5
    6d18:	e3a01010 	mov	r1, #16
    6d1c:	e3a03020 	mov	r3, #32
    6d20:	e1a00006 	mov	r0, r6
    6d24:	ebfffd40 	bl	622c <b64enc>
            RTMP_Log(RTMP_LOGDEBUG, "%s, b64(md5_2) = %s", __FUNCTION__, response);
    6d28:	e59f17b0 	ldr	r1, [pc, #1968]	; 74e0 <PublisherAuth.isra.7+0xf70>
    6d2c:	e1a02007 	mov	r2, r7
    6d30:	e1a03005 	mov	r3, r5
    6d34:	e3a00004 	mov	r0, #4
    6d38:	e08f1001 	add	r1, pc, r1
    6d3c:	eb003b1a 	bl	159ac <RTMP_Log>
            
            /* have all hashes, create auth token for the end of app */
            pubToken.av_val = malloc(32 + B64INT_LEN + B64DIGEST_LEN + opaque.av_len);
    6d40:	e28a0040 	add	r0, sl, #64	; 0x40
    6d44:	ebfff8b4 	bl	501c <malloc@plt>
    6d48:	e1a07000 	mov	r7, r0
    6d4c:	eaffffbd 	b	6c48 <PublisherAuth.isra.7+0x6d8>
                                      response,
                                      opaque.av_len ? opaque.av_val : "");
            RTMP_Log(RTMP_LOGDEBUG, "%s, pubToken2: %s", __FUNCTION__, pubToken.av_val);
            free(orig_ptr);
        }
        else if(strstr(description->av_val, "?reason=authfailed") != NULL)
    6d50:	e59f178c 	ldr	r1, [pc, #1932]	; 74e4 <PublisherAuth.isra.7+0xf74>
    6d54:	e1a00005 	mov	r0, r5
    6d58:	e08f1001 	add	r1, pc, r1
    6d5c:	ebfff905 	bl	5178 <strstr@plt>
    6d60:	e3500000 	cmp	r0, #0
    6d64:	0a00015b 	beq	72d8 <PublisherAuth.isra.7+0xd68>
        {
            RTMP_Log(RTMP_LOGERROR, "%s, Authentication failed: wrong password", __FUNCTION__);
    6d68:	e59f2778 	ldr	r2, [pc, #1912]	; 74e8 <PublisherAuth.isra.7+0xf78>
    6d6c:	e59f1778 	ldr	r1, [pc, #1912]	; 74ec <PublisherAuth.isra.7+0xf7c>
    6d70:	e08f2002 	add	r2, pc, r2
    6d74:	e3a00001 	mov	r0, #1
    6d78:	e2822f5f 	add	r2, r2, #380	; 0x17c
    6d7c:	e08f1001 	add	r1, pc, r1
    6d80:	eb003b09 	bl	159ac <RTMP_Log>
            return 0;
    6d84:	e1a00007 	mov	r0, r7
    6d88:	eafffe17 	b	65ec <PublisherAuth.isra.7+0x7c>
            } else {
                RTMP_Log(RTMP_LOGERROR, "%s, need to set pubUser & pubPasswd for publisher auth", __FUNCTION__);
                return 0;
            }
        }
        else if((token_in = strstr(description->av_val, "?reason=needauth")) != NULL)
    6d8c:	e59f175c 	ldr	r1, [pc, #1884]	; 74f0 <PublisherAuth.isra.7+0xf80>
    6d90:	e1a00005 	mov	r0, r5
    6d94:	e08f1001 	add	r1, pc, r1
    6d98:	ebfff8f6 	bl	5178 <strstr@plt>
    6d9c:	e2506000 	subs	r6, r0, #0
    6da0:	0a000188 	beq	73c8 <PublisherAuth.isra.7+0xe58>
             *    http://tools.ietf.org/html/rfc2617
             *    http://en.wikipedia.org/wiki/Digest_access_authentication
             */
            
            const char authmod[] = "llnw";
            const char realm[] = "live";
    6da4:	e59f3748 	ldr	r3, [pc, #1864]	; 74f4 <PublisherAuth.isra.7+0xf84>
            const char method[] = "publish";
    6da8:	e59f2748 	ldr	r2, [pc, #1864]	; 74f8 <PublisherAuth.isra.7+0xf88>
             *    http://tools.ietf.org/html/rfc2617
             *    http://en.wikipedia.org/wiki/Digest_access_authentication
             */
            
            const char authmod[] = "llnw";
            const char realm[] = "live";
    6dac:	e08f3003 	add	r3, pc, r3
    6db0:	e8930003 	ldm	r3, {r0, r1}
            const char method[] = "publish";
    6db4:	e08f2002 	add	r2, pc, r2
            const char qop[] = "auth";
    6db8:	e59f373c 	ldr	r3, [pc, #1852]	; 74fc <PublisherAuth.isra.7+0xf8c>
             *    http://tools.ietf.org/html/rfc2617
             *    http://en.wikipedia.org/wiki/Digest_access_authentication
             */
            
            const char authmod[] = "llnw";
            const char realm[] = "live";
    6dbc:	e58d0034 	str	r0, [sp, #52]	; 0x34
    6dc0:	e5cd1038 	strb	r1, [sp, #56]	; 0x38
            const char method[] = "publish";
    6dc4:	e8920003 	ldm	r2, {r0, r1}
            const char qop[] = "auth";
    6dc8:	e08f3003 	add	r3, pc, r3
             *    http://en.wikipedia.org/wiki/Digest_access_authentication
             */
            
            const char authmod[] = "llnw";
            const char realm[] = "live";
            const char method[] = "publish";
    6dcc:	e28d2054 	add	r2, sp, #84	; 0x54
    6dd0:	e8820003 	stm	r2, {r0, r1}
            const char qop[] = "auth";
    6dd4:	e8930003 	ldm	r3, {r0, r1}
             *    http://en.wikipedia.org/wiki/Digest_access_authentication
             */
            
            const char authmod[] = "llnw";
            const char realm[] = "live";
            const char method[] = "publish";
    6dd8:	e58d201c 	str	r2, [sp, #28]
            const char qop[] = "auth";
    6ddc:	e58d003c 	str	r0, [sp, #60]	; 0x3c
            /* nchex = hexenc(nc) (8 hex digits according to RFC 2617) */
            char nchex[9];
            /* cnonce = hexenc(4 random bytes) (initialized on first connection) */
            char cnonce[9];
            
            ptr = orig_ptr = strdup(token_in);
    6de0:	e1a00006 	mov	r0, r6
             */
            
            const char authmod[] = "llnw";
            const char realm[] = "live";
            const char method[] = "publish";
            const char qop[] = "auth";
    6de4:	e5cd1040 	strb	r1, [sp, #64]	; 0x40
            /* nchex = hexenc(nc) (8 hex digits according to RFC 2617) */
            char nchex[9];
            /* cnonce = hexenc(4 random bytes) (initialized on first connection) */
            char cnonce[9];
            
            ptr = orig_ptr = strdup(token_in);
    6de8:	ebfff8c1 	bl	50f4 <strdup@plt>
            /* Extract parameters (we need user and nonce) */
            while (ptr)
    6dec:	e2503000 	subs	r3, r0, #0
    6df0:	e58d3020 	str	r3, [sp, #32]
    6df4:	0a00003f 	beq	6ef8 <PublisherAuth.isra.7+0x988>
    6df8:	e1a05003 	mov	r5, r3
                    aptr = NULL;
                }
                if (strcmp(par, "user") == 0){
                    user.av_val = val;
                    aptr = &user;
                } else if (strcmp(par, "nonce") == 0){
    6dfc:	e59f36fc 	ldr	r3, [pc, #1788]	; 7500 <PublisherAuth.isra.7+0xf90>
                    nonce.av_val = val;
                    aptr = &nonce;
                }
                
                RTMP_Log(RTMP_LOGDEBUG, "%s, par:\"%s\" = val:\"%s\"", __FUNCTION__, par, val);
    6e00:	e59f96fc 	ldr	r9, [pc, #1788]	; 7504 <PublisherAuth.isra.7+0xf94>
                    aptr = NULL;
                }
                if (strcmp(par, "user") == 0){
                    user.av_val = val;
                    aptr = &user;
                } else if (strcmp(par, "nonce") == 0){
    6e04:	e08f3003 	add	r3, pc, r3
    6e08:	e58d3018 	str	r3, [sp, #24]
                    nonce.av_val = val;
                    aptr = &nonce;
                }
                
                RTMP_Log(RTMP_LOGDEBUG, "%s, par:\"%s\" = val:\"%s\"", __FUNCTION__, par, val);
    6e0c:	e59f36f4 	ldr	r3, [pc, #1780]	; 7508 <PublisherAuth.isra.7+0xf98>
    6e10:	e08f9009 	add	r9, pc, r9
                
                if (aptr) {
                    aptr->av_len = par - aptr->av_val - 1;
                    aptr = NULL;
                }
                if (strcmp(par, "user") == 0){
    6e14:	e59fb6f0 	ldr	fp, [pc, #1776]	; 750c <PublisherAuth.isra.7+0xf9c>
                } else if (strcmp(par, "nonce") == 0){
                    nonce.av_val = val;
                    aptr = &nonce;
                }
                
                RTMP_Log(RTMP_LOGDEBUG, "%s, par:\"%s\" = val:\"%s\"", __FUNCTION__, par, val);
    6e18:	e2899f5f 	add	r9, r9, #380	; 0x17c
    6e1c:	e08f3003 	add	r3, pc, r3
    6e20:	e58d4024 	str	r4, [sp, #36]	; 0x24
            /* cnonce = hexenc(4 random bytes) (initialized on first connection) */
            char cnonce[9];
            
            ptr = orig_ptr = strdup(token_in);
            /* Extract parameters (we need user and nonce) */
            while (ptr)
    6e24:	e1a0a008 	mov	sl, r8
    6e28:	e1a04009 	mov	r4, r9
                
                if (aptr) {
                    aptr->av_len = par - aptr->av_val - 1;
                    aptr = NULL;
                }
                if (strcmp(par, "user") == 0){
    6e2c:	e08fb00b 	add	fp, pc, fp
    6e30:	e1a09003 	mov	r9, r3
    6e34:	ea000000 	b	6e3c <PublisherAuth.isra.7+0x8cc>
            /* cnonce = hexenc(4 random bytes) (initialized on first connection) */
            char cnonce[9];
            
            ptr = orig_ptr = strdup(token_in);
            /* Extract parameters (we need user and nonce) */
            while (ptr)
    6e38:	e1a05006 	mov	r5, r6
            {
                par = ptr;
                ptr = strchr(par, '&');
    6e3c:	e3a01026 	mov	r1, #38	; 0x26
    6e40:	e1a00005 	mov	r0, r5
    6e44:	ebfff8a7 	bl	50e8 <strchr@plt>
                if(ptr)
                    *ptr++ = '\0';
                
                val =  strchr(par, '=');
    6e48:	e3a0103d 	mov	r1, #61	; 0x3d
            /* Extract parameters (we need user and nonce) */
            while (ptr)
            {
                par = ptr;
                ptr = strchr(par, '&');
                if(ptr)
    6e4c:	e3500000 	cmp	r0, #0
                    *ptr++ = '\0';
    6e50:	15c08000 	strbne	r8, [r0]
    6e54:	12806001 	addne	r6, r0, #1
            /* Extract parameters (we need user and nonce) */
            while (ptr)
            {
                par = ptr;
                ptr = strchr(par, '&');
                if(ptr)
    6e58:	01a06000 	moveq	r6, r0
                    *ptr++ = '\0';
                
                val =  strchr(par, '=');
    6e5c:	e1a00005 	mov	r0, r5
    6e60:	ebfff8a0 	bl	50e8 <strchr@plt>
                
                if (aptr) {
                    aptr->av_len = par - aptr->av_val - 1;
                    aptr = NULL;
                }
                if (strcmp(par, "user") == 0){
    6e64:	e1a0100b 	mov	r1, fp
                ptr = strchr(par, '&');
                if(ptr)
                    *ptr++ = '\0';
                
                val =  strchr(par, '=');
                if(val)
    6e68:	e3500000 	cmp	r0, #0
                    *val++ = '\0';
    6e6c:	15c08000 	strbne	r8, [r0]
                ptr = strchr(par, '&');
                if(ptr)
                    *ptr++ = '\0';
                
                val =  strchr(par, '=');
                if(val)
    6e70:	01a07000 	moveq	r7, r0
                    *val++ = '\0';
    6e74:	12807001 	addne	r7, r0, #1
                
                if (aptr) {
    6e78:	e35a0000 	cmp	sl, #0
                    aptr->av_len = par - aptr->av_val - 1;
    6e7c:	159a3000 	ldrne	r3, [sl]
                    aptr = NULL;
                }
                if (strcmp(par, "user") == 0){
    6e80:	e1a00005 	mov	r0, r5
                val =  strchr(par, '=');
                if(val)
                    *val++ = '\0';
                
                if (aptr) {
                    aptr->av_len = par - aptr->av_val - 1;
    6e84:	10633005 	rsbne	r3, r3, r5
    6e88:	12433001 	subne	r3, r3, #1
    6e8c:	158a3004 	strne	r3, [sl, #4]
                    aptr = NULL;
                }
                if (strcmp(par, "user") == 0){
    6e90:	ebfff8be 	bl	5190 <strcmp@plt>
    6e94:	e3500000 	cmp	r0, #0
                    user.av_val = val;
    6e98:	028dae1e 	addeq	sl, sp, #480	; 0x1e0
    6e9c:	052a719c 	streq	r7, [sl, #-412]!	; 0xfffffe64
                
                if (aptr) {
                    aptr->av_len = par - aptr->av_val - 1;
                    aptr = NULL;
                }
                if (strcmp(par, "user") == 0){
    6ea0:	0a000006 	beq	6ec0 <PublisherAuth.isra.7+0x950>
                    user.av_val = val;
                    aptr = &user;
                } else if (strcmp(par, "nonce") == 0){
    6ea4:	e1a00005 	mov	r0, r5
    6ea8:	e59d1018 	ldr	r1, [sp, #24]
    6eac:	ebfff8b7 	bl	5190 <strcmp@plt>
    6eb0:	e3500000 	cmp	r0, #0
                    nonce.av_val = val;
    6eb4:	028dae1e 	addeq	sl, sp, #480	; 0x1e0
                    aptr = NULL;
                }
                if (strcmp(par, "user") == 0){
                    user.av_val = val;
                    aptr = &user;
                } else if (strcmp(par, "nonce") == 0){
    6eb8:	13a0a000 	movne	sl, #0
                    nonce.av_val = val;
    6ebc:	052a7194 	streq	r7, [sl, #-404]!	; 0xfffffe6c
                    aptr = &nonce;
                }
                
                RTMP_Log(RTMP_LOGDEBUG, "%s, par:\"%s\" = val:\"%s\"", __FUNCTION__, par, val);
    6ec0:	e58d7000 	str	r7, [sp]
    6ec4:	e1a03005 	mov	r3, r5
    6ec8:	e3a00004 	mov	r0, #4
    6ecc:	e1a01009 	mov	r1, r9
    6ed0:	e1a02004 	mov	r2, r4
    6ed4:	eb003ab4 	bl	159ac <RTMP_Log>
            /* cnonce = hexenc(4 random bytes) (initialized on first connection) */
            char cnonce[9];
            
            ptr = orig_ptr = strdup(token_in);
            /* Extract parameters (we need user and nonce) */
            while (ptr)
    6ed8:	e3560000 	cmp	r6, #0
    6edc:	1affffd5 	bne	6e38 <PublisherAuth.isra.7+0x8c8>
                    aptr = &nonce;
                }
                
                RTMP_Log(RTMP_LOGDEBUG, "%s, par:\"%s\" = val:\"%s\"", __FUNCTION__, par, val);
            }
            if (aptr)
    6ee0:	e35a0000 	cmp	sl, #0
    6ee4:	e59d4024 	ldr	r4, [sp, #36]	; 0x24
    6ee8:	0a000002 	beq	6ef8 <PublisherAuth.isra.7+0x988>
                aptr->av_len = strlen(aptr->av_val);
    6eec:	e59a0000 	ldr	r0, [sl]
    6ef0:	ebfff882 	bl	5100 <strlen@plt>
    6ef4:	e58a0004 	str	r0, [sl, #4]
            
            /* FIXME: handle case where user==NULL or nonce==NULL */
            
            sprintf(nchex, "%08x", nc);
    6ef8:	e59f5610 	ldr	r5, [pc, #1552]	; 7510 <PublisherAuth.isra.7+0xfa0>
    6efc:	e28d705c 	add	r7, sp, #92	; 0x5c
    6f00:	e08f5005 	add	r5, pc, r5
    6f04:	e1a01005 	mov	r1, r5
    6f08:	e3a02001 	mov	r2, #1
    6f0c:	e1a00007 	mov	r0, r7
    6f10:	ebfff895 	bl	516c <sprintf@plt>
    6f14:	ebfff8a9 	bl	51c0 <lrand48@plt>
            sprintf(cnonce, "%08x", rand());
    6f18:	e28d8068 	add	r8, sp, #104	; 0x68
    6f1c:	e1a01005 	mov	r1, r5
            
            /* hash1 = hexenc(md5(user + ":" + realm + ":" + password)) */
            MD5_Init(&md5ctx);
    6f20:	e28d5f42 	add	r5, sp, #264	; 0x108
            MD5_Update(&md5ctx, user.av_val, user.av_len);
            MD5_Update(&md5ctx, ":", 1);
    6f24:	e59f65e8 	ldr	r6, [pc, #1512]	; 7514 <PublisherAuth.isra.7+0xfa4>
            MD5_Update(&md5ctx, realm, sizeof(realm)-1);
    6f28:	e28d9034 	add	r9, sp, #52	; 0x34
            sprintf(cnonce, "%08x", rand());
            
            /* hash1 = hexenc(md5(user + ":" + realm + ":" + password)) */
            MD5_Init(&md5ctx);
            MD5_Update(&md5ctx, user.av_val, user.av_len);
            MD5_Update(&md5ctx, ":", 1);
    6f2c:	e08f6006 	add	r6, pc, r6
            MD5_Update(&md5ctx, realm, sizeof(realm)-1);
            MD5_Update(&md5ctx, ":", 1);
            MD5_Update(&md5ctx, r->Link.pubPasswd.av_val, r->Link.pubPasswd.av_len);
    6f30:	e284b901 	add	fp, r4, #16384	; 0x4000
            MD5_Final(md5sum_val, &md5ctx);
            RTMP_Log(RTMP_LOGDEBUG, "%s, md5(%s:%s:%s) =>", __FUNCTION__,
                     user.av_val, realm, r->Link.pubPasswd.av_val);
            RTMP_LogHexString(RTMP_LOGDEBUG, md5sum_val, MD5_DIGEST_LENGTH);
            hexenc(md5sum_val, MD5_DIGEST_LENGTH, hash1);
    6f34:	e28d4088 	add	r4, sp, #136	; 0x88
    6f38:	e1a02000 	mov	r2, r0
                aptr->av_len = strlen(aptr->av_val);
            
            /* FIXME: handle case where user==NULL or nonce==NULL */
            
            sprintf(nchex, "%08x", nc);
            sprintf(cnonce, "%08x", rand());
    6f3c:	e1a00008 	mov	r0, r8
    6f40:	ebfff889 	bl	516c <sprintf@plt>
            
            /* hash1 = hexenc(md5(user + ":" + realm + ":" + password)) */
            MD5_Init(&md5ctx);
    6f44:	e1a00005 	mov	r0, r5
    6f48:	ebfff893 	bl	519c <md5_starts@plt>
            MD5_Update(&md5ctx, user.av_val, user.av_len);
    6f4c:	e59d3048 	ldr	r3, [sp, #72]	; 0x48
    6f50:	e59da044 	ldr	sl, [sp, #68]	; 0x44
    6f54:	e1a02003 	mov	r2, r3
    6f58:	e1a0100a 	mov	r1, sl
    6f5c:	e1a00005 	mov	r0, r5
    6f60:	e58d3024 	str	r3, [sp, #36]	; 0x24
    6f64:	ebfff88f 	bl	51a8 <md5_update_polarssl@plt>
            MD5_Update(&md5ctx, ":", 1);
    6f68:	e1a01006 	mov	r1, r6
    6f6c:	e1a00005 	mov	r0, r5
    6f70:	e3a02001 	mov	r2, #1
    6f74:	ebfff88b 	bl	51a8 <md5_update_polarssl@plt>
            MD5_Update(&md5ctx, realm, sizeof(realm)-1);
    6f78:	e1a00005 	mov	r0, r5
    6f7c:	e1a01009 	mov	r1, r9
    6f80:	e3a02004 	mov	r2, #4
    6f84:	ebfff887 	bl	51a8 <md5_update_polarssl@plt>
            MD5_Update(&md5ctx, ":", 1);
    6f88:	e1a01006 	mov	r1, r6
    6f8c:	e1a00005 	mov	r0, r5
    6f90:	e3a02001 	mov	r2, #1
    6f94:	ebfff883 	bl	51a8 <md5_update_polarssl@plt>
            MD5_Update(&md5ctx, r->Link.pubPasswd.av_val, r->Link.pubPasswd.av_len);
            MD5_Final(md5sum_val, &md5ctx);
    6f98:	e28d6074 	add	r6, sp, #116	; 0x74
            MD5_Init(&md5ctx);
            MD5_Update(&md5ctx, user.av_val, user.av_len);
            MD5_Update(&md5ctx, ":", 1);
            MD5_Update(&md5ctx, realm, sizeof(realm)-1);
            MD5_Update(&md5ctx, ":", 1);
            MD5_Update(&md5ctx, r->Link.pubPasswd.av_val, r->Link.pubPasswd.av_len);
    6f9c:	e59b2168 	ldr	r2, [fp, #360]	; 0x168
    6fa0:	e1a00005 	mov	r0, r5
    6fa4:	e59b1164 	ldr	r1, [fp, #356]	; 0x164
    6fa8:	ebfff87e 	bl	51a8 <md5_update_polarssl@plt>
            MD5_Final(md5sum_val, &md5ctx);
    6fac:	e1a00005 	mov	r0, r5
    6fb0:	e1a01006 	mov	r1, r6
    6fb4:	ebfff87e 	bl	51b4 <md5_finish_polarssl@plt>
            RTMP_Log(RTMP_LOGDEBUG, "%s, md5(%s:%s:%s) =>", __FUNCTION__,
    6fb8:	e59b1164 	ldr	r1, [fp, #356]	; 0x164
    6fbc:	e59f2554 	ldr	r2, [pc, #1364]	; 7518 <PublisherAuth.isra.7+0xfa8>
    6fc0:	e58d1004 	str	r1, [sp, #4]
    6fc4:	e59f1550 	ldr	r1, [pc, #1360]	; 751c <PublisherAuth.isra.7+0xfac>
    6fc8:	e08f2002 	add	r2, pc, r2
    6fcc:	e1a0300a 	mov	r3, sl
    6fd0:	e2822f5f 	add	r2, r2, #380	; 0x17c
    6fd4:	e3a00004 	mov	r0, #4
    6fd8:	e08f1001 	add	r1, pc, r1
    6fdc:	e58d9000 	str	r9, [sp]
    6fe0:	eb003a71 	bl	159ac <RTMP_Log>
                     user.av_val, realm, r->Link.pubPasswd.av_val);
            RTMP_LogHexString(RTMP_LOGDEBUG, md5sum_val, MD5_DIGEST_LENGTH);
    6fe4:	e1a01006 	mov	r1, r6
    6fe8:	e3a00004 	mov	r0, #4
    6fec:	e3a02010 	mov	r2, #16
    6ff0:	eb003abb 	bl	15ae4 <RTMP_LogHexString>
            hexenc(md5sum_val, MD5_DIGEST_LENGTH, hash1);
    6ff4:	e1a00006 	mov	r0, r6
    6ff8:	e1a01004 	mov	r1, r4
    6ffc:	ebfffd49 	bl	6528 <hexenc.constprop.18>
            
            /* hash2 = hexenc(md5(method + ":/" + app + "/" + appInstance)) */
            /* Extract appname + appinstance without query parameters */
            apptmp = r->Link.app;
    7000:	e59bc130 	ldr	ip, [fp, #304]	; 0x130
    7004:	e59ba12c 	ldr	sl, [fp, #300]	; 0x12c

static char *
AValChr(AVal *av, char c)
{
    int i;
    for (i = 0; i < av->av_len; i++)
    7008:	e35c0000 	cmp	ip, #0
    700c:	da0000fc 	ble	7404 <PublisherAuth.isra.7+0xe94>
        if (av->av_val[i] == c)
    7010:	e5da3000 	ldrb	r3, [sl]
    7014:	e353003f 	cmp	r3, #63	; 0x3f
    7018:	128a3001 	addne	r3, sl, #1
    701c:	108a000c 	addne	r0, sl, ip
    7020:	1a000004 	bne	7038 <PublisherAuth.isra.7+0xac8>
    7024:	ea0000c4 	b	733c <PublisherAuth.isra.7+0xdcc>
    7028:	e5d21000 	ldrb	r1, [r2]
    702c:	e2833001 	add	r3, r3, #1
    7030:	e351003f 	cmp	r1, #63	; 0x3f
    7034:	0a0000c1 	beq	7340 <PublisherAuth.isra.7+0xdd0>

static char *
AValChr(AVal *av, char c)
{
    int i;
    for (i = 0; i < av->av_len; i++)
    7038:	e1530000 	cmp	r3, r0
        if (av->av_val[i] == c)
    703c:	e1a02003 	mov	r2, r3

static char *
AValChr(AVal *av, char c)
{
    int i;
    for (i = 0; i < av->av_len; i++)
    7040:	1afffff8 	bne	7028 <PublisherAuth.isra.7+0xab8>
            apptmp = r->Link.app;
            ptr = AValChr(&apptmp, '?');
            if (ptr)
                apptmp.av_len = ptr - apptmp.av_val;
            
            MD5_Init(&md5ctx);
    7044:	e1a00005 	mov	r0, r5
    7048:	e58dc018 	str	ip, [sp, #24]
    704c:	ebfff852 	bl	519c <md5_starts@plt>
            MD5_Update(&md5ctx, method, sizeof(method)-1);
    7050:	e1a00005 	mov	r0, r5
    7054:	e59d101c 	ldr	r1, [sp, #28]
    7058:	e3a02007 	mov	r2, #7
    705c:	ebfff851 	bl	51a8 <md5_update_polarssl@plt>
            MD5_Update(&md5ctx, ":/", 2);
    7060:	e59f14b8 	ldr	r1, [pc, #1208]	; 7520 <PublisherAuth.isra.7+0xfb0>
    7064:	e1a00005 	mov	r0, r5
    7068:	e08f1001 	add	r1, pc, r1
    706c:	e3a02002 	mov	r2, #2
    7070:	ebfff84c 	bl	51a8 <md5_update_polarssl@plt>
            MD5_Update(&md5ctx, apptmp.av_val, apptmp.av_len);
    7074:	e59dc018 	ldr	ip, [sp, #24]
    7078:	e1a00005 	mov	r0, r5
    707c:	e1a0200c 	mov	r2, ip
    7080:	e1a0100a 	mov	r1, sl
    7084:	ebfff847 	bl	51a8 <md5_update_polarssl@plt>
    7088:	e59dc018 	ldr	ip, [sp, #24]
static char *
AValChr(AVal *av, char c)
{
    int i;
    for (i = 0; i < av->av_len; i++)
        if (av->av_val[i] == c)
    708c:	e5da3000 	ldrb	r3, [sl]
    7090:	e353002f 	cmp	r3, #47	; 0x2f
    7094:	0a00000f 	beq	70d8 <PublisherAuth.isra.7+0xb68>
    7098:	e1a0200a 	mov	r2, sl
    709c:	e3a03000 	mov	r3, #0
    70a0:	ea000002 	b	70b0 <PublisherAuth.isra.7+0xb40>
    70a4:	e5f21001 	ldrb	r1, [r2, #1]!
    70a8:	e351002f 	cmp	r1, #47	; 0x2f
    70ac:	0a000009 	beq	70d8 <PublisherAuth.isra.7+0xb68>

static char *
AValChr(AVal *av, char c)
{
    int i;
    for (i = 0; i < av->av_len; i++)
    70b0:	e2833001 	add	r3, r3, #1
    70b4:	e153000c 	cmp	r3, ip
    70b8:	bafffff9 	blt	70a4 <PublisherAuth.isra.7+0xb34>
            MD5_Init(&md5ctx);
            MD5_Update(&md5ctx, method, sizeof(method)-1);
            MD5_Update(&md5ctx, ":/", 2);
            MD5_Update(&md5ctx, apptmp.av_val, apptmp.av_len);
            if (!AValChr(&apptmp, '/'))
                MD5_Update(&md5ctx, "/_definst_", sizeof("/_definst_") - 1);
    70bc:	e59f1460 	ldr	r1, [pc, #1120]	; 7524 <PublisherAuth.isra.7+0xfb4>
    70c0:	e1a00005 	mov	r0, r5
    70c4:	e08f1001 	add	r1, pc, r1
    70c8:	e3a0200a 	mov	r2, #10
    70cc:	e58dc018 	str	ip, [sp, #24]
    70d0:	ebfff834 	bl	51a8 <md5_update_polarssl@plt>
    70d4:	e59dc018 	ldr	ip, [sp, #24]
            MD5_Final(md5sum_val, &md5ctx);
            RTMP_Log(RTMP_LOGDEBUG, "%s, md5(%s:/%.*s) =>", __FUNCTION__,
    70d8:	e59f9448 	ldr	r9, [pc, #1096]	; 7528 <PublisherAuth.isra.7+0xfb8>
            MD5_Update(&md5ctx, method, sizeof(method)-1);
            MD5_Update(&md5ctx, ":/", 2);
            MD5_Update(&md5ctx, apptmp.av_val, apptmp.av_len);
            if (!AValChr(&apptmp, '/'))
                MD5_Update(&md5ctx, "/_definst_", sizeof("/_definst_") - 1);
            MD5_Final(md5sum_val, &md5ctx);
    70dc:	e1a00005 	mov	r0, r5
    70e0:	e1a01006 	mov	r1, r6
    70e4:	e58dc018 	str	ip, [sp, #24]
            RTMP_Log(RTMP_LOGDEBUG, "%s, md5(%s:/%.*s) =>", __FUNCTION__,
    70e8:	e08f9009 	add	r9, pc, r9
            MD5_Update(&md5ctx, method, sizeof(method)-1);
            MD5_Update(&md5ctx, ":/", 2);
            MD5_Update(&md5ctx, apptmp.av_val, apptmp.av_len);
            if (!AValChr(&apptmp, '/'))
                MD5_Update(&md5ctx, "/_definst_", sizeof("/_definst_") - 1);
            MD5_Final(md5sum_val, &md5ctx);
    70ec:	ebfff830 	bl	51b4 <md5_finish_polarssl@plt>
            RTMP_Log(RTMP_LOGDEBUG, "%s, md5(%s:/%.*s) =>", __FUNCTION__,
    70f0:	e59f1434 	ldr	r1, [pc, #1076]	; 752c <PublisherAuth.isra.7+0xfbc>
    70f4:	e59dc018 	ldr	ip, [sp, #24]
    70f8:	e2899f5f 	add	r9, r9, #380	; 0x17c
    70fc:	e58dc000 	str	ip, [sp]
    7100:	e59d301c 	ldr	r3, [sp, #28]
    7104:	e58da004 	str	sl, [sp, #4]
    7108:	e1a02009 	mov	r2, r9
    710c:	e3a00004 	mov	r0, #4
    7110:	e08f1001 	add	r1, pc, r1
    7114:	eb003a24 	bl	159ac <RTMP_Log>
                     method, apptmp.av_len, apptmp.av_val);
            RTMP_LogHexString(RTMP_LOGDEBUG, md5sum_val, MD5_DIGEST_LENGTH);
    7118:	e3a02010 	mov	r2, #16
    711c:	e1a01006 	mov	r1, r6
    7120:	e3a00004 	mov	r0, #4
    7124:	eb003a6e 	bl	15ae4 <RTMP_LogHexString>
            hexenc(md5sum_val, MD5_DIGEST_LENGTH, hash2);
    7128:	e28d30ac 	add	r3, sp, #172	; 0xac
    712c:	e1a01003 	mov	r1, r3
    7130:	e1a00006 	mov	r0, r6
            
            /* hash3 = hexenc(md5(hash1 + ":" + nonce + ":" + nchex + ":" + cnonce + ":" + qop + ":" + hash2)) */
            MD5_Init(&md5ctx);
            MD5_Update(&md5ctx, hash1, HEXHASH_LEN);
            MD5_Update(&md5ctx, ":", 1);
    7134:	e59fa3f4 	ldr	sl, [pc, #1012]	; 7530 <PublisherAuth.isra.7+0xfc0>
                MD5_Update(&md5ctx, "/_definst_", sizeof("/_definst_") - 1);
            MD5_Final(md5sum_val, &md5ctx);
            RTMP_Log(RTMP_LOGDEBUG, "%s, md5(%s:/%.*s) =>", __FUNCTION__,
                     method, apptmp.av_len, apptmp.av_val);
            RTMP_LogHexString(RTMP_LOGDEBUG, md5sum_val, MD5_DIGEST_LENGTH);
            hexenc(md5sum_val, MD5_DIGEST_LENGTH, hash2);
    7138:	e58d301c 	str	r3, [sp, #28]
    713c:	ebfffcf9 	bl	6528 <hexenc.constprop.18>
            
            /* hash3 = hexenc(md5(hash1 + ":" + nonce + ":" + nchex + ":" + cnonce + ":" + qop + ":" + hash2)) */
            MD5_Init(&md5ctx);
    7140:	e1a00005 	mov	r0, r5
    7144:	ebfff814 	bl	519c <md5_starts@plt>
            MD5_Update(&md5ctx, hash1, HEXHASH_LEN);
            MD5_Update(&md5ctx, ":", 1);
    7148:	e08fa00a 	add	sl, pc, sl
            RTMP_LogHexString(RTMP_LOGDEBUG, md5sum_val, MD5_DIGEST_LENGTH);
            hexenc(md5sum_val, MD5_DIGEST_LENGTH, hash2);
            
            /* hash3 = hexenc(md5(hash1 + ":" + nonce + ":" + nchex + ":" + cnonce + ":" + qop + ":" + hash2)) */
            MD5_Init(&md5ctx);
            MD5_Update(&md5ctx, hash1, HEXHASH_LEN);
    714c:	e1a00005 	mov	r0, r5
    7150:	e1a01004 	mov	r1, r4
    7154:	e3a02020 	mov	r2, #32
    7158:	ebfff812 	bl	51a8 <md5_update_polarssl@plt>
            MD5_Update(&md5ctx, ":", 1);
    715c:	e1a0100a 	mov	r1, sl
    7160:	e1a00005 	mov	r0, r5
    7164:	e3a02001 	mov	r2, #1
    7168:	ebfff80e 	bl	51a8 <md5_update_polarssl@plt>
            MD5_Update(&md5ctx, nonce.av_val, nonce.av_len);
    716c:	e59dc050 	ldr	ip, [sp, #80]	; 0x50
    7170:	e59d204c 	ldr	r2, [sp, #76]	; 0x4c
    7174:	e58d2018 	str	r2, [sp, #24]
    7178:	e1a01002 	mov	r1, r2
    717c:	e1a00005 	mov	r0, r5
    7180:	e1a0200c 	mov	r2, ip
    7184:	e58dc02c 	str	ip, [sp, #44]	; 0x2c
    7188:	ebfff806 	bl	51a8 <md5_update_polarssl@plt>
            MD5_Update(&md5ctx, ":", 1);
    718c:	e1a00005 	mov	r0, r5
    7190:	e1a0100a 	mov	r1, sl
    7194:	e3a02001 	mov	r2, #1
    7198:	ebfff802 	bl	51a8 <md5_update_polarssl@plt>
            MD5_Update(&md5ctx, nchex, sizeof(nchex)-1);
    719c:	e1a00005 	mov	r0, r5
    71a0:	e1a01007 	mov	r1, r7
    71a4:	e3a02008 	mov	r2, #8
    71a8:	ebfff7fe 	bl	51a8 <md5_update_polarssl@plt>
            MD5_Update(&md5ctx, ":", 1);
    71ac:	e1a00005 	mov	r0, r5
    71b0:	e1a0100a 	mov	r1, sl
    71b4:	e3a02001 	mov	r2, #1
    71b8:	ebfff7fa 	bl	51a8 <md5_update_polarssl@plt>
            MD5_Update(&md5ctx, cnonce, sizeof(cnonce)-1);
    71bc:	e1a00005 	mov	r0, r5
    71c0:	e1a01008 	mov	r1, r8
    71c4:	e3a02008 	mov	r2, #8
    71c8:	ebfff7f6 	bl	51a8 <md5_update_polarssl@plt>
            MD5_Update(&md5ctx, ":", 1);
    71cc:	e1a00005 	mov	r0, r5
    71d0:	e1a0100a 	mov	r1, sl
    71d4:	e3a02001 	mov	r2, #1
    71d8:	ebfff7f2 	bl	51a8 <md5_update_polarssl@plt>
            MD5_Update(&md5ctx, qop, sizeof(qop)-1);
    71dc:	e28d303c 	add	r3, sp, #60	; 0x3c
    71e0:	e1a01003 	mov	r1, r3
    71e4:	e1a00005 	mov	r0, r5
    71e8:	e3a02004 	mov	r2, #4
    71ec:	e58d3028 	str	r3, [sp, #40]	; 0x28
    71f0:	ebfff7ec 	bl	51a8 <md5_update_polarssl@plt>
            MD5_Update(&md5ctx, ":", 1);
    71f4:	e1a00005 	mov	r0, r5
    71f8:	e1a0100a 	mov	r1, sl
    71fc:	e3a02001 	mov	r2, #1
    7200:	ebfff7e8 	bl	51a8 <md5_update_polarssl@plt>
            MD5_Update(&md5ctx, hash2, HEXHASH_LEN);
    7204:	e59da01c 	ldr	sl, [sp, #28]
    7208:	e1a00005 	mov	r0, r5
    720c:	e1a0100a 	mov	r1, sl
    7210:	e3a02020 	mov	r2, #32
    7214:	ebfff7e3 	bl	51a8 <md5_update_polarssl@plt>
            MD5_Final(md5sum_val, &md5ctx);
    7218:	e1a00005 	mov	r0, r5
    721c:	e1a01006 	mov	r1, r6
    7220:	ebfff7e3 	bl	51b4 <md5_finish_polarssl@plt>
            RTMP_Log(RTMP_LOGDEBUG, "%s, md5(%s:%s:%s:%s:%s:%s) =>", __FUNCTION__,
    7224:	e59f1308 	ldr	r1, [pc, #776]	; 7534 <PublisherAuth.isra.7+0xfc4>
    7228:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
    722c:	e59d2018 	ldr	r2, [sp, #24]
    7230:	e58d300c 	str	r3, [sp, #12]
    7234:	e58d2000 	str	r2, [sp]
    7238:	e1a03004 	mov	r3, r4
    723c:	e98d0180 	stmib	sp, {r7, r8}
    7240:	e1a02009 	mov	r2, r9
    7244:	e58da010 	str	sl, [sp, #16]
    7248:	e3a00004 	mov	r0, #4
    724c:	e08f1001 	add	r1, pc, r1
    7250:	eb0039d5 	bl	159ac <RTMP_Log>
                     hash1, nonce.av_val, nchex, cnonce, qop, hash2);
            RTMP_LogHexString(RTMP_LOGDEBUG, md5sum_val, MD5_DIGEST_LENGTH);
            hexenc(md5sum_val, MD5_DIGEST_LENGTH, hash3);
    7254:	e28d50d0 	add	r5, sp, #208	; 0xd0
            MD5_Update(&md5ctx, ":", 1);
            MD5_Update(&md5ctx, hash2, HEXHASH_LEN);
            MD5_Final(md5sum_val, &md5ctx);
            RTMP_Log(RTMP_LOGDEBUG, "%s, md5(%s:%s:%s:%s:%s:%s) =>", __FUNCTION__,
                     hash1, nonce.av_val, nchex, cnonce, qop, hash2);
            RTMP_LogHexString(RTMP_LOGDEBUG, md5sum_val, MD5_DIGEST_LENGTH);
    7258:	e3a02010 	mov	r2, #16
    725c:	e1a01006 	mov	r1, r6
    7260:	e3a00004 	mov	r0, #4
    7264:	eb003a1e 	bl	15ae4 <RTMP_LogHexString>
            hexenc(md5sum_val, MD5_DIGEST_LENGTH, hash3);
    7268:	e1a01005 	mov	r1, r5
    726c:	e1a00006 	mov	r0, r6
    7270:	ebfffcac 	bl	6528 <hexenc.constprop.18>
            
            /* pubToken = &authmod=<authmod>&user=<username>&nonce=<nonce>&cnonce=<cnonce>&nc=<nchex>&response=<hash3> */
            /* Append nonces and response to query string which already contains
             * user + authmod */
            pubToken.av_val = malloc(64 + sizeof(authmod)-1 + user.av_len + nonce.av_len + sizeof(cnonce)-1 + sizeof(nchex)-1 + HEXHASH_LEN);
    7274:	e59dc02c 	ldr	ip, [sp, #44]	; 0x2c
    7278:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    727c:	e083000c 	add	r0, r3, ip
    7280:	e2800074 	add	r0, r0, #116	; 0x74
    7284:	ebfff764 	bl	501c <malloc@plt>
            sprintf(pubToken.av_val,
    7288:	e59f12a8 	ldr	r1, [pc, #680]	; 7538 <PublisherAuth.isra.7+0xfc8>
    728c:	e59d2018 	ldr	r2, [sp, #24]
    7290:	e1a03008 	mov	r3, r8
    7294:	e58d7000 	str	r7, [sp]
    7298:	e08f1001 	add	r1, pc, r1
    729c:	e58d5004 	str	r5, [sp, #4]
            hexenc(md5sum_val, MD5_DIGEST_LENGTH, hash3);
            
            /* pubToken = &authmod=<authmod>&user=<username>&nonce=<nonce>&cnonce=<cnonce>&nc=<nchex>&response=<hash3> */
            /* Append nonces and response to query string which already contains
             * user + authmod */
            pubToken.av_val = malloc(64 + sizeof(authmod)-1 + user.av_len + nonce.av_len + sizeof(cnonce)-1 + sizeof(nchex)-1 + HEXHASH_LEN);
    72a0:	e1a04000 	mov	r4, r0
            sprintf(pubToken.av_val,
    72a4:	ebfff7b0 	bl	516c <sprintf@plt>
                    "&nonce=%s&cnonce=%s&nc=%s&response=%s",
                    nonce.av_val, cnonce, nchex, hash3);
            pubToken.av_len = strlen(pubToken.av_val);
    72a8:	e1a00004 	mov	r0, r4
    72ac:	ebfff793 	bl	5100 <strlen@plt>
            RTMP_Log(RTMP_LOGDEBUG, "%s, pubToken2: %s", __FUNCTION__, pubToken.av_val);
    72b0:	e59f1284 	ldr	r1, [pc, #644]	; 753c <PublisherAuth.isra.7+0xfcc>
    72b4:	e1a02009 	mov	r2, r9
    72b8:	e1a03004 	mov	r3, r4
    72bc:	e08f1001 	add	r1, pc, r1
             * user + authmod */
            pubToken.av_val = malloc(64 + sizeof(authmod)-1 + user.av_len + nonce.av_len + sizeof(cnonce)-1 + sizeof(nchex)-1 + HEXHASH_LEN);
            sprintf(pubToken.av_val,
                    "&nonce=%s&cnonce=%s&nc=%s&response=%s",
                    nonce.av_val, cnonce, nchex, hash3);
            pubToken.av_len = strlen(pubToken.av_val);
    72c0:	e1a07000 	mov	r7, r0
            RTMP_Log(RTMP_LOGDEBUG, "%s, pubToken2: %s", __FUNCTION__, pubToken.av_val);
    72c4:	e3a00004 	mov	r0, #4
    72c8:	eb0039b7 	bl	159ac <RTMP_Log>
            
            free(orig_ptr);
    72cc:	e59d0020 	ldr	r0, [sp, #32]
    72d0:	ebfff74b 	bl	5004 <free@plt>
    72d4:	eafffd4d 	b	6810 <PublisherAuth.isra.7+0x2a0>
        else if(strstr(description->av_val, "?reason=authfailed") != NULL)
        {
            RTMP_Log(RTMP_LOGERROR, "%s, Authentication failed: wrong password", __FUNCTION__);
            return 0;
        }
        else if(strstr(description->av_val, "?reason=nosuchuser") != NULL)
    72d8:	e59f1260 	ldr	r1, [pc, #608]	; 7540 <PublisherAuth.isra.7+0xfd0>
    72dc:	e1a00005 	mov	r0, r5
    72e0:	e08f1001 	add	r1, pc, r1
    72e4:	ebfff7a3 	bl	5178 <strstr@plt>
    72e8:	e2506000 	subs	r6, r0, #0
    72ec:	1a000009 	bne	7318 <PublisherAuth.isra.7+0xda8>
            RTMP_Log(RTMP_LOGERROR, "%s, Authentication failed: no such user", __FUNCTION__);
            return 0;
        }
        else
        {
            RTMP_Log(RTMP_LOGERROR, "%s, Authentication failed: unknown auth mode: %s",
    72f0:	e59f224c 	ldr	r2, [pc, #588]	; 7544 <PublisherAuth.isra.7+0xfd4>
    72f4:	e59f124c 	ldr	r1, [pc, #588]	; 7548 <PublisherAuth.isra.7+0xfd8>
    72f8:	e08f2002 	add	r2, pc, r2
    72fc:	e3a00001 	mov	r0, #1
    7300:	e1a03005 	mov	r3, r5
    7304:	e2822f5f 	add	r2, r2, #380	; 0x17c
    7308:	e08f1001 	add	r1, pc, r1
    730c:	eb0039a6 	bl	159ac <RTMP_Log>
                     __FUNCTION__, description->av_val);
            return 0;
    7310:	e1a00006 	mov	r0, r6
    7314:	eafffcb4 	b	65ec <PublisherAuth.isra.7+0x7c>
            RTMP_Log(RTMP_LOGERROR, "%s, Authentication failed: wrong password", __FUNCTION__);
            return 0;
        }
        else if(strstr(description->av_val, "?reason=nosuchuser") != NULL)
        {
            RTMP_Log(RTMP_LOGERROR, "%s, Authentication failed: no such user", __FUNCTION__);
    7318:	e59f222c 	ldr	r2, [pc, #556]	; 754c <PublisherAuth.isra.7+0xfdc>
    731c:	e59f122c 	ldr	r1, [pc, #556]	; 7550 <PublisherAuth.isra.7+0xfe0>
    7320:	e08f2002 	add	r2, pc, r2
    7324:	e3a00001 	mov	r0, #1
    7328:	e2822f5f 	add	r2, r2, #380	; 0x17c
    732c:	e08f1001 	add	r1, pc, r1
    7330:	eb00399d 	bl	159ac <RTMP_Log>
            return 0;
    7334:	e3a00000 	mov	r0, #0
    7338:	eafffcab 	b	65ec <PublisherAuth.isra.7+0x7c>
static char *
AValChr(AVal *av, char c)
{
    int i;
    for (i = 0; i < av->av_len; i++)
        if (av->av_val[i] == c)
    733c:	e1a0200a 	mov	r2, sl
            /* hash2 = hexenc(md5(method + ":/" + app + "/" + appInstance)) */
            /* Extract appname + appinstance without query parameters */
            apptmp = r->Link.app;
            ptr = AValChr(&apptmp, '?');
            if (ptr)
                apptmp.av_len = ptr - apptmp.av_val;
    7340:	e06ac002 	rsb	ip, sl, r2
            
            MD5_Init(&md5ctx);
    7344:	e1a00005 	mov	r0, r5
            /* hash2 = hexenc(md5(method + ":/" + app + "/" + appInstance)) */
            /* Extract appname + appinstance without query parameters */
            apptmp = r->Link.app;
            ptr = AValChr(&apptmp, '?');
            if (ptr)
                apptmp.av_len = ptr - apptmp.av_val;
    7348:	e58dc018 	str	ip, [sp, #24]
            
            MD5_Init(&md5ctx);
    734c:	ebfff792 	bl	519c <md5_starts@plt>
            MD5_Update(&md5ctx, method, sizeof(method)-1);
    7350:	e1a00005 	mov	r0, r5
    7354:	e59d101c 	ldr	r1, [sp, #28]
    7358:	e3a02007 	mov	r2, #7
    735c:	ebfff791 	bl	51a8 <md5_update_polarssl@plt>
            MD5_Update(&md5ctx, ":/", 2);
    7360:	e59f11ec 	ldr	r1, [pc, #492]	; 7554 <PublisherAuth.isra.7+0xfe4>
    7364:	e1a00005 	mov	r0, r5
    7368:	e08f1001 	add	r1, pc, r1
    736c:	e3a02002 	mov	r2, #2
    7370:	ebfff78c 	bl	51a8 <md5_update_polarssl@plt>
            MD5_Update(&md5ctx, apptmp.av_val, apptmp.av_len);
    7374:	e59dc018 	ldr	ip, [sp, #24]
    7378:	e1a00005 	mov	r0, r5
    737c:	e1a0200c 	mov	r2, ip
    7380:	e1a0100a 	mov	r1, sl
    7384:	ebfff787 	bl	51a8 <md5_update_polarssl@plt>

static char *
AValChr(AVal *av, char c)
{
    int i;
    for (i = 0; i < av->av_len; i++)
    7388:	e59dc018 	ldr	ip, [sp, #24]
    738c:	e35c0000 	cmp	ip, #0
    7390:	caffff3d 	bgt	708c <PublisherAuth.isra.7+0xb1c>
    7394:	eaffff48 	b	70bc <PublisherAuth.isra.7+0xb4c>
        ptr = malloc(r->Link.tcUrl.av_len + pubToken.av_len);
        strncpy(ptr, r->Link.tcUrl.av_val, r->Link.tcUrl.av_len);
        strncpy(ptr + r->Link.tcUrl.av_len, pubToken.av_val, pubToken.av_len);
        r->Link.tcUrl.av_len += pubToken.av_len;
        if(r->Link.lFlags & RTMP_LF_FTCU)
            free(r->Link.tcUrl.av_val);
    7398:	e1a00003 	mov	r0, r3
    739c:	ebfff718 	bl	5004 <free@plt>
    73a0:	e59b5180 	ldr	r5, [fp, #384]	; 0x180
    73a4:	e59b612c 	ldr	r6, [fp, #300]	; 0x12c
    73a8:	e59b9118 	ldr	r9, [fp, #280]	; 0x118
    73ac:	eafffd3b 	b	68a0 <PublisherAuth.isra.7+0x330>
        ptr = malloc(r->Link.app.av_len + pubToken.av_len);
        strncpy(ptr, r->Link.app.av_val, r->Link.app.av_len);
        strncpy(ptr + r->Link.app.av_len, pubToken.av_val, pubToken.av_len);
        r->Link.app.av_len += pubToken.av_len;
        if(r->Link.lFlags & RTMP_LF_FAPU)
            free(r->Link.app.av_val);
    73b0:	e1a00009 	mov	r0, r9
    73b4:	ebfff712 	bl	5004 <free@plt>
    73b8:	e59b5180 	ldr	r5, [fp, #384]	; 0x180
    73bc:	eafffd24 	b	6854 <PublisherAuth.isra.7+0x2e4>
            AVal user, salt, opaque, challenge, *aptr = NULL;
            opaque.av_len = 0;
            challenge.av_len = 0;
            
            ptr = orig_ptr = strdup(token_in);
            while (ptr)
    73c0:	e59da020 	ldr	sl, [sp, #32]
    73c4:	eafffda9 	b	6a70 <PublisherAuth.isra.7+0x500>
            pubToken.av_len = strlen(pubToken.av_val);
            RTMP_Log(RTMP_LOGDEBUG, "%s, pubToken2: %s", __FUNCTION__, pubToken.av_val);
            
            free(orig_ptr);
        }
        else if(strstr(description->av_val, "?reason=authfail") != NULL)
    73c8:	e59f1188 	ldr	r1, [pc, #392]	; 7558 <PublisherAuth.isra.7+0xfe8>
    73cc:	e1a00005 	mov	r0, r5
    73d0:	e08f1001 	add	r1, pc, r1
    73d4:	ebfff767 	bl	5178 <strstr@plt>
    73d8:	e3500000 	cmp	r0, #0
    73dc:	0affffbd 	beq	72d8 <PublisherAuth.isra.7+0xd68>
        {
            RTMP_Log(RTMP_LOGERROR, "%s, Authentication failed", __FUNCTION__);
    73e0:	e59f2174 	ldr	r2, [pc, #372]	; 755c <PublisherAuth.isra.7+0xfec>
    73e4:	e59f1174 	ldr	r1, [pc, #372]	; 7560 <PublisherAuth.isra.7+0xff0>
    73e8:	e08f2002 	add	r2, pc, r2
    73ec:	e3a00001 	mov	r0, #1
    73f0:	e2822f5f 	add	r2, r2, #380	; 0x17c
    73f4:	e08f1001 	add	r1, pc, r1
    73f8:	eb00396b 	bl	159ac <RTMP_Log>
            return 0;
    73fc:	e1a00006 	mov	r0, r6
    7400:	eafffc79 	b	65ec <PublisherAuth.isra.7+0x7c>
            apptmp = r->Link.app;
            ptr = AValChr(&apptmp, '?');
            if (ptr)
                apptmp.av_len = ptr - apptmp.av_val;
            
            MD5_Init(&md5ctx);
    7404:	e1a00005 	mov	r0, r5
    7408:	e58dc018 	str	ip, [sp, #24]
    740c:	ebfff762 	bl	519c <md5_starts@plt>
            MD5_Update(&md5ctx, method, sizeof(method)-1);
    7410:	e1a00005 	mov	r0, r5
    7414:	e59d101c 	ldr	r1, [sp, #28]
    7418:	e3a02007 	mov	r2, #7
    741c:	ebfff761 	bl	51a8 <md5_update_polarssl@plt>
            MD5_Update(&md5ctx, ":/", 2);
    7420:	e59f113c 	ldr	r1, [pc, #316]	; 7564 <PublisherAuth.isra.7+0xff4>
    7424:	e1a00005 	mov	r0, r5
    7428:	e08f1001 	add	r1, pc, r1
    742c:	e3a02002 	mov	r2, #2
    7430:	ebfff75c 	bl	51a8 <md5_update_polarssl@plt>
            MD5_Update(&md5ctx, apptmp.av_val, apptmp.av_len);
    7434:	e59dc018 	ldr	ip, [sp, #24]
    7438:	e1a00005 	mov	r0, r5
    743c:	e1a0200c 	mov	r2, ip
    7440:	e1a0100a 	mov	r1, sl
    7444:	ebfff757 	bl	51a8 <md5_update_polarssl@plt>
    7448:	e59dc018 	ldr	ip, [sp, #24]
    744c:	eaffff1a 	b	70bc <PublisherAuth.isra.7+0xb4c>
    7450:	00017c10 	.word	0x00017c10
    7454:	00017bf8 	.word	0x00017bf8
    7458:	00016214 	.word	0x00016214
    745c:	00017bd0 	.word	0x00017bd0
    7460:	000161d4 	.word	0x000161d4
    7464:	00017be4 	.word	0x00017be4
    7468:	00017ba0 	.word	0x00017ba0
    746c:	0001618c 	.word	0x0001618c
    7470:	00017b88 	.word	0x00017b88
    7474:	000160a4 	.word	0x000160a4
    7478:	00017c70 	.word	0x00017c70
    747c:	00017c80 	.word	0x00017c80
    7480:	00017a10 	.word	0x00017a10
    7484:	00017a08 	.word	0x00017a08
    7488:	00015ff4 	.word	0x00015ff4
    748c:	000179f0 	.word	0x000179f0
    7490:	00015f20 	.word	0x00015f20
    7494:	00017ae8 	.word	0x00017ae8
    7498:	00017948 	.word	0x00017948
    749c:	0001793c 	.word	0x0001793c
    74a0:	00015ea4 	.word	0x00015ea4
    74a4:	00017910 	.word	0x00017910
    74a8:	0001791c 	.word	0x0001791c
    74ac:	000178f8 	.word	0x000178f8
    74b0:	00017914 	.word	0x00017914
    74b4:	00015d18 	.word	0x00015d18
    74b8:	000177b4 	.word	0x000177b4
    74bc:	0001776c 	.word	0x0001776c
    74c0:	00017744 	.word	0x00017744
    74c4:	00015c18 	.word	0x00015c18
    74c8:	00017255 	.word	0x00017255
    74cc:	000176a0 	.word	0x000176a0
    74d0:	00017694 	.word	0x00017694
    74d4:	00017680 	.word	0x00017680
    74d8:	00015b7c 	.word	0x00015b7c
    74dc:	0001768c 	.word	0x0001768c
    74e0:	00017590 	.word	0x00017590
    74e4:	000175bc 	.word	0x000175bc
    74e8:	00015a78 	.word	0x00015a78
    74ec:	000175ac 	.word	0x000175ac
    74f0:	000174a8 	.word	0x000174a8
    74f4:	00017720 	.word	0x00017720
    74f8:	00017720 	.word	0x00017720
    74fc:	00017714 	.word	0x00017714
    7500:	000175fc 	.word	0x000175fc
    7504:	000159d8 	.word	0x000159d8
    7508:	00017458 	.word	0x00017458
    750c:	00017424 	.word	0x00017424
    7510:	00017508 	.word	0x00017508
    7514:	000174e4 	.word	0x000174e4
    7518:	00015820 	.word	0x00015820
    751c:	0001743c 	.word	0x0001743c
    7520:	000173c4 	.word	0x000173c4
    7524:	000173fc 	.word	0x000173fc
    7528:	00015700 	.word	0x00015700
    752c:	00017320 	.word	0x00017320
    7530:	000172c8 	.word	0x000172c8
    7534:	000171fc 	.word	0x000171fc
    7538:	000171d0 	.word	0x000171d0
    753c:	00017044 	.word	0x00017044
    7540:	00017074 	.word	0x00017074
    7544:	000154f0 	.word	0x000154f0
    7548:	00017088 	.word	0x00017088
    754c:	000154c8 	.word	0x000154c8
    7550:	0001703c 	.word	0x0001703c
    7554:	000170c4 	.word	0x000170c4
    7558:	000170c0 	.word	0x000170c0
    755c:	00015400 	.word	0x00015400
    7560:	000170b0 	.word	0x000170b0
    7564:	00017004 	.word	0x00017004

00007568 <CalculateDigest>:
}

static void
CalculateDigest(unsigned int digestPos, uint8_t *handshakeMessage,
		const uint8_t *key, size_t keyLen, uint8_t *digest)
{
    7568:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    756c:	e24dde6d 	sub	sp, sp, #1744	; 0x6d0
    7570:	e1a04000 	mov	r4, r0
  const int messageLen = RTMP_SIG_SIZE - SHA256_DIGEST_LENGTH;
  uint8_t message[RTMP_SIG_SIZE - SHA256_DIGEST_LENGTH];

  memcpy(message, handshakeMessage, digestPos);
    7574:	e28d50f0 	add	r5, sp, #240	; 0xf0
}

static void
CalculateDigest(unsigned int digestPos, uint8_t *handshakeMessage,
		const uint8_t *key, size_t keyLen, uint8_t *digest)
{
    7578:	e1a07002 	mov	r7, r2
  const int messageLen = RTMP_SIG_SIZE - SHA256_DIGEST_LENGTH;
  uint8_t message[RTMP_SIG_SIZE - SHA256_DIGEST_LENGTH];

  memcpy(message, handshakeMessage, digestPos);
    757c:	e1a00005 	mov	r0, r5
    7580:	e1a02004 	mov	r2, r4
}

static void
CalculateDigest(unsigned int digestPos, uint8_t *handshakeMessage,
		const uint8_t *key, size_t keyLen, uint8_t *digest)
{
    7584:	e1a06003 	mov	r6, r3
    7588:	e1a08001 	mov	r8, r1
  const int messageLen = RTMP_SIG_SIZE - SHA256_DIGEST_LENGTH;
  uint8_t message[RTMP_SIG_SIZE - SHA256_DIGEST_LENGTH];

  memcpy(message, handshakeMessage, digestPos);
    758c:	ebfff70e 	bl	51cc <memcpy@plt>
  memcpy(message + digestPos,
	 &handshakeMessage[digestPos + SHA256_DIGEST_LENGTH],
    7590:	e2841020 	add	r1, r4, #32
{
  const int messageLen = RTMP_SIG_SIZE - SHA256_DIGEST_LENGTH;
  uint8_t message[RTMP_SIG_SIZE - SHA256_DIGEST_LENGTH];

  memcpy(message, handshakeMessage, digestPos);
  memcpy(message + digestPos,
    7594:	e0881001 	add	r1, r8, r1
    7598:	e0850004 	add	r0, r5, r4
    759c:	e2642e5e 	rsb	r2, r4, #1504	; 0x5e0
	   size_t keylen, uint8_t *digest)
{
  unsigned int digestLen;
  HMAC_CTX ctx;

  HMAC_setup(ctx, key, keylen);
    75a0:	e28d4004 	add	r4, sp, #4
{
  const int messageLen = RTMP_SIG_SIZE - SHA256_DIGEST_LENGTH;
  uint8_t message[RTMP_SIG_SIZE - SHA256_DIGEST_LENGTH];

  memcpy(message, handshakeMessage, digestPos);
  memcpy(message + digestPos,
    75a4:	ebfff708 	bl	51cc <memcpy@plt>
	   size_t keylen, uint8_t *digest)
{
  unsigned int digestLen;
  HMAC_CTX ctx;

  HMAC_setup(ctx, key, keylen);
    75a8:	e3a03000 	mov	r3, #0
    75ac:	e1a01007 	mov	r1, r7
    75b0:	e1a02006 	mov	r2, r6
    75b4:	e1a00004 	mov	r0, r4
    75b8:	ebfff6b8 	bl	50a0 <sha2_hmac_starts@plt>
  HMAC_crunch(ctx, message, messageLen);
    75bc:	e1a00004 	mov	r0, r4
    75c0:	e1a01005 	mov	r1, r5
    75c4:	e3a02e5e 	mov	r2, #1504	; 0x5e0
    75c8:	ebfff6b7 	bl	50ac <sha2_hmac_update@plt>
  HMAC_finish(ctx, digest, digestLen);
    75cc:	e1a00004 	mov	r0, r4
    75d0:	e59d16e8 	ldr	r1, [sp, #1768]	; 0x6e8
    75d4:	ebfff6b7 	bl	50b8 <sha2_hmac_finish@plt>
  memcpy(message + digestPos,
	 &handshakeMessage[digestPos + SHA256_DIGEST_LENGTH],
	 messageLen - digestPos);

  HMACsha256(message, messageLen, key, keyLen, digest);
}
    75d8:	e28dde6d 	add	sp, sp, #1744	; 0x6d0
    75dc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

000075e0 <VerifyDigest>:

static int
VerifyDigest(unsigned int digestPos, uint8_t *handshakeMessage, const uint8_t *key,
	     size_t keyLen)
{
    75e0:	e92d4070 	push	{r4, r5, r6, lr}
    75e4:	e24dd028 	sub	sp, sp, #40	; 0x28
  uint8_t calcDigest[SHA256_DIGEST_LENGTH];

  CalculateDigest(digestPos, handshakeMessage, key, keyLen, calcDigest);
    75e8:	e28d4008 	add	r4, sp, #8
}

static int
VerifyDigest(unsigned int digestPos, uint8_t *handshakeMessage, const uint8_t *key,
	     size_t keyLen)
{
    75ec:	e1a06001 	mov	r6, r1
    75f0:	e1a05000 	mov	r5, r0
  uint8_t calcDigest[SHA256_DIGEST_LENGTH];

  CalculateDigest(digestPos, handshakeMessage, key, keyLen, calcDigest);
    75f4:	e58d4000 	str	r4, [sp]
    75f8:	ebffffda 	bl	7568 <CalculateDigest>

  return memcmp(&handshakeMessage[digestPos], calcDigest,
    75fc:	e0860005 	add	r0, r6, r5
    7600:	e1a01004 	mov	r1, r4
    7604:	e3a02020 	mov	r2, #32
    7608:	ebfff6f2 	bl	51d8 <memcmp@plt>
		SHA256_DIGEST_LENGTH) == 0;
}
    760c:	e16f0f10 	clz	r0, r0
    7610:	e1a002a0 	lsr	r0, r0, #5
    7614:	e28dd028 	add	sp, sp, #40	; 0x28
    7618:	e8bd8070 	pop	{r4, r5, r6, pc}

0000761c <rtmpe9_sig>:
	}
  }
}

static void rtmpe9_sig(uint8_t *in, uint8_t *out, int keyid)
{
    761c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t d[2];
  bf_key key;

  bf_setkey(rtmpe9_keys[keyid], KEYBYTES, &key);
    7620:	e59f3264 	ldr	r3, [pc, #612]	; 788c <rtmpe9_sig+0x270>
	}
  }
}

static void rtmpe9_sig(uint8_t *in, uint8_t *out, int keyid)
{
    7624:	e24ddd41 	sub	sp, sp, #4160	; 0x1040
    7628:	e24dd024 	sub	sp, sp, #36	; 0x24
  uint32_t d[2];
  bf_key key;

  bf_setkey(rtmpe9_keys[keyid], KEYBYTES, &key);
    762c:	e08f3003 	add	r3, pc, r3
	}
  }
}

static void rtmpe9_sig(uint8_t *in, uint8_t *out, int keyid)
{
    7630:	e1a07000 	mov	r7, r0
  int          j;
  int          k;
  uint32_t  data;
  uint32_t  d[2];

  memcpy(key->p, bf_pinit, sizeof(key->p));
    7634:	e28d0a01 	add	r0, sp, #4096	; 0x1000
static void rtmpe9_sig(uint8_t *in, uint8_t *out, int keyid)
{
  uint32_t d[2];
  bf_key key;

  bf_setkey(rtmpe9_keys[keyid], KEYBYTES, &key);
    7638:	e1a05003 	mov	r5, r3
    763c:	e283cf63 	add	ip, r3, #396	; 0x18c
	}
  }
}

static void rtmpe9_sig(uint8_t *in, uint8_t *out, int keyid)
{
    7640:	e58d100c 	str	r1, [sp, #12]
  uint32_t d[2];
  bf_key key;

  bf_setkey(rtmpe9_keys[keyid], KEYBYTES, &key);
    7644:	e0828082 	add	r8, r2, r2, lsl #1
  int          j;
  int          k;
  uint32_t  data;
  uint32_t  d[2];

  memcpy(key->p, bf_pinit, sizeof(key->p));
    7648:	e2831fc3 	add	r1, r3, #780	; 0x30c
    764c:	e3a02048 	mov	r2, #72	; 0x48
    7650:	e2800018 	add	r0, r0, #24
    7654:	e28d4060 	add	r4, sp, #96	; 0x60
static void rtmpe9_sig(uint8_t *in, uint8_t *out, int keyid)
{
  uint32_t d[2];
  bf_key key;

  bf_setkey(rtmpe9_keys[keyid], KEYBYTES, &key);
    7658:	e08c8188 	add	r8, ip, r8, lsl #3
  int          j;
  int          k;
  uint32_t  data;
  uint32_t  d[2];

  memcpy(key->p, bf_pinit, sizeof(key->p));
    765c:	ebfff6da 	bl	51cc <memcpy@plt>
  memcpy(key->s, bf_sinit, sizeof(key->s));
    7660:	e2851fd5 	add	r1, r5, #852	; 0x354
    7664:	e2440048 	sub	r0, r4, #72	; 0x48
    7668:	e3a02a01 	mov	r2, #4096	; 0x1000
    766c:	ebfff6d6 	bl	51cc <memcpy@plt>
    7670:	e28d3018 	add	r3, sp, #24
    7674:	e2835a01 	add	r5, r3, #4096	; 0x1000
    7678:	e2836d41 	add	r6, r3, #4160	; 0x1040
    767c:	e1a00005 	mov	r0, r5
    7680:	e2866008 	add	r6, r6, #8

  j = 0;
    7684:	e3a01000 	mov	r1, #0
    7688:	e58d3000 	str	r3, [sp]
  for (i = 0; i < BF_ROUNDS + 2; ++i) {
    data = 0x00000000;
	for (k = 0; k < 4; ++k) {
	  data = (data << 8) | kp[j];
	  j = j + 1;
    768c:	e2812001 	add	r2, r1, #1
    7690:	e3520017 	cmp	r2, #23
    7694:	c3a02000 	movgt	r2, #0
    7698:	e2823001 	add	r3, r2, #1
    769c:	e3530017 	cmp	r3, #23
    76a0:	c3a03000 	movgt	r3, #0

  j = 0;
  for (i = 0; i < BF_ROUNDS + 2; ++i) {
    data = 0x00000000;
	for (k = 0; k < 4; ++k) {
	  data = (data << 8) | kp[j];
    76a4:	e7d8e001 	ldrb	lr, [r8, r1]
	  j = j + 1;
    76a8:	e2831001 	add	r1, r3, #1

  j = 0;
  for (i = 0; i < BF_ROUNDS + 2; ++i) {
    data = 0x00000000;
	for (k = 0; k < 4; ++k) {
	  data = (data << 8) | kp[j];
    76ac:	e7d8c002 	ldrb	ip, [r8, r2]
    76b0:	e3510017 	cmp	r1, #23
    76b4:	e7d82003 	ldrb	r2, [r8, r3]
    76b8:	c3a01000 	movgt	r1, #0
    76bc:	e7d83001 	ldrb	r3, [r8, r1]
    76c0:	e18cc40e 	orr	ip, ip, lr, lsl #8
    76c4:	e182240c 	orr	r2, r2, ip, lsl #8
	  j = j + 1;
	  if (j >= keybytes) {
	    j = 0;
	  }
	}
	key->p[i] ^= data;
    76c8:	e590c000 	ldr	ip, [r0]
  j = 0;
  for (i = 0; i < BF_ROUNDS + 2; ++i) {
    data = 0x00000000;
	for (k = 0; k < 4; ++k) {
	  data = (data << 8) | kp[j];
	  j = j + 1;
    76cc:	e2811001 	add	r1, r1, #1

  j = 0;
  for (i = 0; i < BF_ROUNDS + 2; ++i) {
    data = 0x00000000;
	for (k = 0; k < 4; ++k) {
	  data = (data << 8) | kp[j];
    76d0:	e1833402 	orr	r3, r3, r2, lsl #8
    76d4:	e3510017 	cmp	r1, #23
	  j = j + 1;
	  if (j >= keybytes) {
	    j = 0;
	  }
	}
	key->p[i] ^= data;
    76d8:	e023300c 	eor	r3, r3, ip
    76dc:	c3a01000 	movgt	r1, #0
    76e0:	e4803004 	str	r3, [r0], #4

  memcpy(key->p, bf_pinit, sizeof(key->p));
  memcpy(key->s, bf_sinit, sizeof(key->s));

  j = 0;
  for (i = 0; i < BF_ROUNDS + 2; ++i) {
    76e4:	e1500006 	cmp	r0, r6
    76e8:	1affffe7 	bne	768c <rtmpe9_sig+0x70>
	  }
	}
	key->p[i] ^= data;
  }

  d[0] = 0x00000000;
    76ec:	e3a03000 	mov	r3, #0
    76f0:	e28d2010 	add	r2, sp, #16
    76f4:	e58d2004 	str	r2, [sp, #4]
    76f8:	e5043050 	str	r3, [r4, #-80]	; 0xffffffb0
  d[1] = 0x00000000;
    76fc:	e504304c 	str	r3, [r4, #-76]	; 0xffffffb4

  for (i = 0; i < BF_ROUNDS + 2; i += 2) {
    bf_enc(d, key);
    7700:	e59d0004 	ldr	r0, [sp, #4]
    7704:	e59d1000 	ldr	r1, [sp]
    7708:	ebfff82b 	bl	57bc <bf_enc>

	key->p[i] = d[0];
    770c:	e5140050 	ldr	r0, [r4, #-80]	; 0xffffffb0
	key->p[i + 1] = d[1];
    7710:	e514304c 	ldr	r3, [r4, #-76]	; 0xffffffb4
    7714:	e8850009 	stm	r5, {r0, r3}
    7718:	e2855008 	add	r5, r5, #8
  }

  d[0] = 0x00000000;
  d[1] = 0x00000000;

  for (i = 0; i < BF_ROUNDS + 2; i += 2) {
    771c:	e1560005 	cmp	r6, r5
    7720:	1afffff6 	bne	7700 <rtmpe9_sig+0xe4>
    7724:	e28d2a01 	add	r2, sp, #4096	; 0x1000
    7728:	e28d9a01 	add	r9, sp, #4096	; 0x1000
    772c:	e28d5d41 	add	r5, sp, #4160	; 0x1040
    7730:	e594bff8 	ldr	fp, [r4, #4088]	; 0xff8
    7734:	e594affc 	ldr	sl, [r4, #4092]	; 0xffc
    7738:	e59d6000 	ldr	r6, [sp]
    773c:	e2822018 	add	r2, r2, #24
    7740:	e1a0c003 	mov	ip, r3
    7744:	e2899008 	add	r9, r9, #8
    7748:	e2855014 	add	r5, r5, #20
    774c:	e1a03000 	mov	r3, r0
    7750:	e58d2008 	str	r2, [sp, #8]
    7754:	e286eb01 	add	lr, r6, #1024	; 0x400
    7758:	e289000c 	add	r0, r9, #12

  Xl = x[0];
  Xr = x[1];

  for (i = 0; i < BF_ROUNDS; ++i) {
    Xl ^= key->p[i];
    775c:	e5b02004 	ldr	r2, [r0, #4]!
    7760:	e0222003 	eor	r2, r2, r3
    Xr ^= BF_ENC(Xl,key->s);
    7764:	e1a08822 	lsr	r8, r2, #16
    7768:	e20880ff 	and	r8, r8, #255	; 0xff
    776c:	e1a03c22 	lsr	r3, r2, #24
    7770:	e0848108 	add	r8, r4, r8, lsl #2
    7774:	e0843103 	add	r3, r4, r3, lsl #2
    7778:	e59883b8 	ldr	r8, [r8, #952]	; 0x3b8
    777c:	e1a01422 	lsr	r1, r2, #8
    7780:	e5133048 	ldr	r3, [r3, #-72]	; 0xffffffb8
    7784:	e20110ff 	and	r1, r1, #255	; 0xff
    7788:	e0883003 	add	r3, r8, r3
    778c:	e0841101 	add	r1, r4, r1, lsl #2
    7790:	e20280ff 	and	r8, r2, #255	; 0xff
    7794:	e59117b8 	ldr	r1, [r1, #1976]	; 0x7b8
    7798:	e0848108 	add	r8, r4, r8, lsl #2
    779c:	e5988bb8 	ldr	r8, [r8, #3000]	; 0xbb8
    77a0:	e0233001 	eor	r3, r3, r1
    77a4:	e0833008 	add	r3, r3, r8
  int	i;

  Xl = x[0];
  Xr = x[1];

  for (i = 0; i < BF_ROUNDS; ++i) {
    77a8:	e1500005 	cmp	r0, r5
    Xl ^= key->p[i];
    Xr ^= BF_ENC(Xl,key->s);
    77ac:	e023300c 	eor	r3, r3, ip

  Xl = x[0];
  Xr = x[1];

  for (i = 0; i < BF_ROUNDS; ++i) {
    Xl ^= key->p[i];
    77b0:	e1a0c002 	mov	ip, r2
  int	i;

  Xl = x[0];
  Xr = x[1];

  for (i = 0; i < BF_ROUNDS; ++i) {
    77b4:	1affffe8 	bne	775c <rtmpe9_sig+0x140>
    temp = Xl;
    Xl = Xr;
    Xr = temp;
  }

  Xl ^= key->p[BF_ROUNDS];
    77b8:	e023200b 	eor	r2, r3, fp
  Xr ^= key->p[BF_ROUNDS + 1];
    77bc:	e02c300a 	eor	r3, ip, sl
	for (j = 0; j < 256; j += 2) {

	  bf_enc(d, key);

	  key->s[i][j] = d[0];
	  key->s[i][j + 1] = d[1];
    77c0:	e5862004 	str	r2, [r6, #4]
  for (i = 0; i < 4; ++i) {
	for (j = 0; j < 256; j += 2) {

	  bf_enc(d, key);

	  key->s[i][j] = d[0];
    77c4:	e5863000 	str	r3, [r6]
    77c8:	e2866008 	add	r6, r6, #8
	key->p[i] = d[0];
	key->p[i + 1] = d[1];
  }

  for (i = 0; i < 4; ++i) {
	for (j = 0; j < 256; j += 2) {
    77cc:	e15e0006 	cmp	lr, r6
    temp = Xl;
    Xl = Xr;
    Xr = temp;
  }

  Xl ^= key->p[BF_ROUNDS];
    77d0:	e1a0c002 	mov	ip, r2
	key->p[i] = d[0];
	key->p[i + 1] = d[1];
  }

  for (i = 0; i < 4; ++i) {
	for (j = 0; j < 256; j += 2) {
    77d4:	1affffdf 	bne	7758 <rtmpe9_sig+0x13c>

	key->p[i] = d[0];
	key->p[i + 1] = d[1];
  }

  for (i = 0; i < 4; ++i) {
    77d8:	e59d2008 	ldr	r2, [sp, #8]
    77dc:	e1a0600e 	mov	r6, lr
    77e0:	e15e0002 	cmp	lr, r2
    77e4:	1affffda 	bne	7754 <rtmpe9_sig+0x138>
  bf_key key;

  bf_setkey(rtmpe9_keys[keyid], KEYBYTES, &key);

  /* input is little-endian */
  d[0] = in[0] | (in[1] << 8) | (in[2] << 16) | (in[3] << 24);
    77e8:	e5d70002 	ldrb	r0, [r7, #2]
  d[1] = in[4] | (in[5] << 8) | (in[6] << 16) | (in[7] << 24);
    77ec:	e5d71006 	ldrb	r1, [r7, #6]
  bf_key key;

  bf_setkey(rtmpe9_keys[keyid], KEYBYTES, &key);

  /* input is little-endian */
  d[0] = in[0] | (in[1] << 8) | (in[2] << 16) | (in[3] << 24);
    77f0:	e5d75001 	ldrb	r5, [r7, #1]
  d[1] = in[4] | (in[5] << 8) | (in[6] << 16) | (in[7] << 24);
    77f4:	e5d7e005 	ldrb	lr, [r7, #5]
  bf_key key;

  bf_setkey(rtmpe9_keys[keyid], KEYBYTES, &key);

  /* input is little-endian */
  d[0] = in[0] | (in[1] << 8) | (in[2] << 16) | (in[3] << 24);
    77f8:	e5d72000 	ldrb	r2, [r7]
  d[1] = in[4] | (in[5] << 8) | (in[6] << 16) | (in[7] << 24);
    77fc:	e5d73004 	ldrb	r3, [r7, #4]
  bf_key key;

  bf_setkey(rtmpe9_keys[keyid], KEYBYTES, &key);

  /* input is little-endian */
  d[0] = in[0] | (in[1] << 8) | (in[2] << 16) | (in[3] << 24);
    7800:	e1a00800 	lsl	r0, r0, #16
  d[1] = in[4] | (in[5] << 8) | (in[6] << 16) | (in[7] << 24);
    7804:	e1a01801 	lsl	r1, r1, #16
  bf_key key;

  bf_setkey(rtmpe9_keys[keyid], KEYBYTES, &key);

  /* input is little-endian */
  d[0] = in[0] | (in[1] << 8) | (in[2] << 16) | (in[3] << 24);
    7808:	e5d7c003 	ldrb	ip, [r7, #3]
    780c:	e1800405 	orr	r0, r0, r5, lsl #8
    7810:	e181140e 	orr	r1, r1, lr, lsl #8
  d[1] = in[4] | (in[5] << 8) | (in[6] << 16) | (in[7] << 24);
    7814:	e5d7e007 	ldrb	lr, [r7, #7]
  bf_key key;

  bf_setkey(rtmpe9_keys[keyid], KEYBYTES, &key);

  /* input is little-endian */
  d[0] = in[0] | (in[1] << 8) | (in[2] << 16) | (in[3] << 24);
    7818:	e1802002 	orr	r2, r0, r2
  d[1] = in[4] | (in[5] << 8) | (in[6] << 16) | (in[7] << 24);
    781c:	e1813003 	orr	r3, r1, r3
  bf_key key;

  bf_setkey(rtmpe9_keys[keyid], KEYBYTES, &key);

  /* input is little-endian */
  d[0] = in[0] | (in[1] << 8) | (in[2] << 16) | (in[3] << 24);
    7820:	e1822c0c 	orr	r2, r2, ip, lsl #24
  d[1] = in[4] | (in[5] << 8) | (in[6] << 16) | (in[7] << 24);
    7824:	e1833c0e 	orr	r3, r3, lr, lsl #24
  bf_enc(d, &key);
    7828:	e59d0004 	ldr	r0, [sp, #4]
    782c:	e59d1000 	ldr	r1, [sp]
  bf_key key;

  bf_setkey(rtmpe9_keys[keyid], KEYBYTES, &key);

  /* input is little-endian */
  d[0] = in[0] | (in[1] << 8) | (in[2] << 16) | (in[3] << 24);
    7830:	e5042050 	str	r2, [r4, #-80]	; 0xffffffb0
  d[1] = in[4] | (in[5] << 8) | (in[6] << 16) | (in[7] << 24);
    7834:	e504304c 	str	r3, [r4, #-76]	; 0xffffffb4
  bf_enc(d, &key);
    7838:	ebfff7df 	bl	57bc <bf_enc>
  out[0] = d[0] & 0xff;
  out[1] = (d[0] >> 8) & 0xff;
  out[2] = (d[0] >> 16) & 0xff;
  out[3] = (d[0] >> 24) & 0xff;
  out[4] = d[1] & 0xff;
    783c:	e514304c 	ldr	r3, [r4, #-76]	; 0xffffffb4

  /* input is little-endian */
  d[0] = in[0] | (in[1] << 8) | (in[2] << 16) | (in[3] << 24);
  d[1] = in[4] | (in[5] << 8) | (in[6] << 16) | (in[7] << 24);
  bf_enc(d, &key);
  out[0] = d[0] & 0xff;
    7840:	e5142050 	ldr	r2, [r4, #-80]	; 0xffffffb0
    7844:	e59d600c 	ldr	r6, [sp, #12]
  out[1] = (d[0] >> 8) & 0xff;
    7848:	e1a05422 	lsr	r5, r2, #8
  out[2] = (d[0] >> 16) & 0xff;
    784c:	e1a04822 	lsr	r4, r2, #16
  out[3] = (d[0] >> 24) & 0xff;
    7850:	e1a0ec22 	lsr	lr, r2, #24
  out[4] = d[1] & 0xff;
  out[5] = (d[1] >> 8) & 0xff;
    7854:	e1a0c423 	lsr	ip, r3, #8
  out[6] = (d[1] >> 16) & 0xff;
    7858:	e1a00823 	lsr	r0, r3, #16
  out[7] = (d[1] >> 24) & 0xff;
    785c:	e1a01c23 	lsr	r1, r3, #24

  /* input is little-endian */
  d[0] = in[0] | (in[1] << 8) | (in[2] << 16) | (in[3] << 24);
  d[1] = in[4] | (in[5] << 8) | (in[6] << 16) | (in[7] << 24);
  bf_enc(d, &key);
  out[0] = d[0] & 0xff;
    7860:	e5c62000 	strb	r2, [r6]
  out[1] = (d[0] >> 8) & 0xff;
  out[2] = (d[0] >> 16) & 0xff;
  out[3] = (d[0] >> 24) & 0xff;
  out[4] = d[1] & 0xff;
    7864:	e5c63004 	strb	r3, [r6, #4]
  /* input is little-endian */
  d[0] = in[0] | (in[1] << 8) | (in[2] << 16) | (in[3] << 24);
  d[1] = in[4] | (in[5] << 8) | (in[6] << 16) | (in[7] << 24);
  bf_enc(d, &key);
  out[0] = d[0] & 0xff;
  out[1] = (d[0] >> 8) & 0xff;
    7868:	e5c65001 	strb	r5, [r6, #1]
  out[2] = (d[0] >> 16) & 0xff;
    786c:	e5c64002 	strb	r4, [r6, #2]
  out[3] = (d[0] >> 24) & 0xff;
    7870:	e5c6e003 	strb	lr, [r6, #3]
  out[4] = d[1] & 0xff;
  out[5] = (d[1] >> 8) & 0xff;
    7874:	e5c6c005 	strb	ip, [r6, #5]
  out[6] = (d[1] >> 16) & 0xff;
    7878:	e5c60006 	strb	r0, [r6, #6]
  out[7] = (d[1] >> 24) & 0xff;
    787c:	e5c61007 	strb	r1, [r6, #7]
}
    7880:	e28ddd41 	add	sp, sp, #4160	; 0x1040
    7884:	e28dd024 	add	sp, sp, #36	; 0x24
    7888:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    788c:	000151bc 	.word	0x000151bc

00007890 <Get_Seed>:
extern char *(* g_func_rtmpGetProc)(char *);
extern void (*g_func_rtmpSetStatValue)(char *, char *);


void Get_Seed(char * guid)
{
    7890:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    7894:	e1a07000 	mov	r7, r0
    char *str = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    srand((unsigned)time(NULL));
    7898:	e3a00000 	mov	r0, #0
    789c:	ebfff650 	bl	51e4 <time@plt>
}
static __inline__ void srand(unsigned int __s) {
    srand48(__s);
    78a0:	ebfff652 	bl	51f0 <srand48@plt>
    int i = 0;
    for (i = 0; i < 32; i++)
    {
        guid[i] = str[rand() % 62];
    78a4:	e59f5058 	ldr	r5, [pc, #88]	; 7904 <Get_Seed+0x74>
    78a8:	e59f6058 	ldr	r6, [pc, #88]	; 7908 <Get_Seed+0x78>
    78ac:	e08f5005 	add	r5, pc, r5
    78b0:	e2478001 	sub	r8, r7, #1
    78b4:	e287401f 	add	r4, r7, #31
extern void arc4random_stir(void);
extern void arc4random_addrandom(unsigned char *, int);

#define RAND_MAX 0x7fffffff
static __inline__ int rand(void) {
    return (int)lrand48();
    78b8:	ebfff640 	bl	51c0 <lrand48@plt>
    78bc:	e0c32096 	smull	r2, r3, r6, r0
    78c0:	e1a02fc0 	asr	r2, r0, #31
    78c4:	e0833000 	add	r3, r3, r0
    78c8:	e06232c3 	rsb	r3, r2, r3, asr #5
    78cc:	e0633283 	rsb	r3, r3, r3, lsl #5
    78d0:	e0400083 	sub	r0, r0, r3, lsl #1
    78d4:	e7d53000 	ldrb	r3, [r5, r0]
    78d8:	e5e83001 	strb	r3, [r8, #1]!
void Get_Seed(char * guid)
{
    char *str = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    srand((unsigned)time(NULL));
    int i = 0;
    for (i = 0; i < 32; i++)
    78dc:	e1580004 	cmp	r8, r4
    78e0:	1afffff4 	bne	78b8 <Get_Seed+0x28>
    {
        guid[i] = str[rand() % 62];
    }
    guid[32] = '\0';
    RTMP_Log(RTMP_LOGINFO, "seed: %s \n", guid);
    78e4:	e59f1020 	ldr	r1, [pc, #32]	; 790c <Get_Seed+0x7c>
    int i = 0;
    for (i = 0; i < 32; i++)
    {
        guid[i] = str[rand() % 62];
    }
    guid[32] = '\0';
    78e8:	e3a03000 	mov	r3, #0
    78ec:	e5c73020 	strb	r3, [r7, #32]
    RTMP_Log(RTMP_LOGINFO, "seed: %s \n", guid);
    78f0:	e1a02007 	mov	r2, r7
    78f4:	e3a00003 	mov	r0, #3
    78f8:	e08f1001 	add	r1, pc, r1
}
    78fc:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
    for (i = 0; i < 32; i++)
    {
        guid[i] = str[rand() % 62];
    }
    guid[32] = '\0';
    RTMP_Log(RTMP_LOGINFO, "seed: %s \n", guid);
    7900:	ea003829 	b	159ac <RTMP_Log>
    7904:	00016c38 	.word	0x00016c38
    7908:	84210843 	.word	0x84210843
    790c:	00016c2c 	.word	0x00016c2c

00007910 <init_portal>:
    RTMPSockBuf_Close(&sb);
    return ret;
}

void init_portal(RTMP_PORTAL *rtmp_url)
{
    7910:	e92d4010 	push	{r4, lr}
    memset(rtmp_url,0x00,sizeof(RTMP_PORTAL));
    7914:	e3a02f77 	mov	r2, #476	; 0x1dc
    7918:	e3a01000 	mov	r1, #0
    RTMPSockBuf_Close(&sb);
    return ret;
}

void init_portal(RTMP_PORTAL *rtmp_url)
{
    791c:	e1a04000 	mov	r4, r0
    memset(rtmp_url,0x00,sizeof(RTMP_PORTAL));
    7920:	ebfff5ea 	bl	50d0 <memset@plt>
    rtmp_url->cdn_type=-1;
    7924:	e3e02000 	mvn	r2, #0
    rtmp_url->time_useful=4000;
    7928:	e3a03efa 	mov	r3, #4000	; 0xfa0
}

void init_portal(RTMP_PORTAL *rtmp_url)
{
    memset(rtmp_url,0x00,sizeof(RTMP_PORTAL));
    rtmp_url->cdn_type=-1;
    792c:	e58421d8 	str	r2, [r4, #472]	; 0x1d8
    rtmp_url->time_useful=4000;
    7930:	e5843190 	str	r3, [r4, #400]	; 0x190
    7934:	e8bd8010 	pop	{r4, pc}

00007938 <free_portal>:
}

void free_portal(RTMP *r)
{
    //memset(r->center_portal,0x00,sizeof(RTMP_PORTAL));
    if(r)
    7938:	e3500000 	cmp	r0, #0
    793c:	012fff1e 	bxeq	lr
    rtmp_url->cdn=NULL;
    
}

void free_portal(RTMP *r)
{
    7940:	e92d4010 	push	{r4, lr}
    //memset(r->center_portal,0x00,sizeof(RTMP_PORTAL));
    if(r)
    {
        if(r->center_portal)
    7944:	e2804901 	add	r4, r0, #16384	; 0x4000
    7948:	e59401f8 	ldr	r0, [r4, #504]	; 0x1f8
    794c:	e3500000 	cmp	r0, #0
    7950:	0a00000b 	beq	7984 <free_portal+0x4c>
        {
            if(r->center_portal->cdn)
    7954:	e590319c 	ldr	r3, [r0, #412]	; 0x19c
    7958:	e3530000 	cmp	r3, #0
    795c:	0a000005 	beq	7978 <free_portal+0x40>
            {
                free(r->center_portal->cdn);
    7960:	e1a00003 	mov	r0, r3
    7964:	ebfff5a6 	bl	5004 <free@plt>
                r->center_portal->cdn=NULL;
    7968:	e59431f8 	ldr	r3, [r4, #504]	; 0x1f8
    796c:	e3a02000 	mov	r2, #0
    7970:	e1a00003 	mov	r0, r3
    7974:	e583219c 	str	r2, [r3, #412]	; 0x19c
            }
            free(r->center_portal);
    7978:	ebfff5a1 	bl	5004 <free@plt>
            r->center_portal=NULL;
    797c:	e3a03000 	mov	r3, #0
    7980:	e58431f8 	str	r3, [r4, #504]	; 0x1f8
        }
        //memset(r->area_portal,0x00,sizeof(RTMP_PORTAL));
        if(r->area_portal)
    7984:	e59401fc 	ldr	r0, [r4, #508]	; 0x1fc
    7988:	e3500000 	cmp	r0, #0
    798c:	08bd8010 	popeq	{r4, pc}
        {
            if(r->area_portal->cdn)
    7990:	e590319c 	ldr	r3, [r0, #412]	; 0x19c
    7994:	e3530000 	cmp	r3, #0
    7998:	0a000005 	beq	79b4 <free_portal+0x7c>
            {
                free(r->area_portal->cdn);
    799c:	e1a00003 	mov	r0, r3
    79a0:	ebfff597 	bl	5004 <free@plt>
                r->area_portal->cdn=NULL;
    79a4:	e59431fc 	ldr	r3, [r4, #508]	; 0x1fc
    79a8:	e3a02000 	mov	r2, #0
    79ac:	e1a00003 	mov	r0, r3
    79b0:	e583219c 	str	r2, [r3, #412]	; 0x19c
            }
            free(r->area_portal);
    79b4:	ebfff592 	bl	5004 <free@plt>
            r->area_portal=NULL;
    79b8:	e3a03000 	mov	r3, #0
    79bc:	e58431fc 	str	r3, [r4, #508]	; 0x1fc
    79c0:	e8bd8010 	pop	{r4, pc}

000079c4 <Parse_AccessUrl>:
        }
    }
}

int Parse_AccessUrl(RTMP *r,const char *url,AVal *rtmp_url)
{
    79c4:	e92d43f8 	push	{r3, r4, r5, r6, r7, r8, r9, lr}
    79c8:	e1a05000 	mov	r5, r0
    char *p,*p1,*p2;
    char *end;
    
    p=p1=p2=url;
    end=p+strlen(url);
    79cc:	e1a00001 	mov	r0, r1
        }
    }
}

int Parse_AccessUrl(RTMP *r,const char *url,AVal *rtmp_url)
{
    79d0:	e1a06001 	mov	r6, r1
    79d4:	e1a09002 	mov	r9, r2
    char *p,*p1,*p2;
    char *end;
    
    p=p1=p2=url;
    end=p+strlen(url);
    79d8:	ebfff5c8 	bl	5100 <strlen@plt>
    p1=strstr(url,"://");
    79dc:	e59f1260 	ldr	r1, [pc, #608]	; 7c44 <Parse_AccessUrl+0x280>
    79e0:	e08f1001 	add	r1, pc, r1
{
    char *p,*p1,*p2;
    char *end;
    
    p=p1=p2=url;
    end=p+strlen(url);
    79e4:	e1a07000 	mov	r7, r0
    p1=strstr(url,"://");
    79e8:	e1a00006 	mov	r0, r6
    79ec:	ebfff5e1 	bl	5178 <strstr@plt>
    
    if(p1)
    79f0:	e3500000 	cmp	r0, #0
    79f4:	0a000074 	beq	7bcc <Parse_AccessUrl+0x208>
    {
        p1+=3;
    79f8:	e2804003 	add	r4, r0, #3
        p=strstr(p1,"/");
    79fc:	e1a00004 	mov	r0, r4
    7a00:	e3a0102f 	mov	r1, #47	; 0x2f
    7a04:	ebfff5b7 	bl	50e8 <strchr@plt>
        if(!p)
    7a08:	e3500000 	cmp	r0, #0
    7a0c:	0a00006e 	beq	7bcc <Parse_AccessUrl+0x208>
            return FALSE;
        
        rtmp_url->av_val=p1;
        rtmp_url->av_len=(int)(p-p1);
    7a10:	e0643000 	rsb	r3, r4, r0
    {
        return FALSE;
        
    }
    
    p++;
    7a14:	e2808001 	add	r8, r0, #1
        p=strstr(p1,"/");
        if(!p)
            return FALSE;
        
        rtmp_url->av_val=p1;
        rtmp_url->av_len=(int)(p-p1);
    7a18:	e5893004 	str	r3, [r9, #4]
        p1+=3;
        p=strstr(p1,"/");
        if(!p)
            return FALSE;
        
        rtmp_url->av_val=p1;
    7a1c:	e5894000 	str	r4, [r9]
        return FALSE;
        
    }
    
    p++;
    p1=strstr(p,"/");
    7a20:	e1a00008 	mov	r0, r8
    7a24:	e3a0102f 	mov	r1, #47	; 0x2f
    7a28:	ebfff5ae 	bl	50e8 <strchr@plt>
    if(p1)
    7a2c:	e2503000 	subs	r3, r0, #0
    7a30:	0a000065 	beq	7bcc <Parse_AccessUrl+0x208>
    {
        memcpy(r->access.app,p,(int)(p1-p));
    7a34:	e2850b11 	add	r0, r5, #17408	; 0x4400
    7a38:	e1a01008 	mov	r1, r8
    7a3c:	e0682003 	rsb	r2, r8, r3
    }
    else
        return FALSE;
   
    
    p1++;
    7a40:	e2834001 	add	r4, r3, #1
    
    p++;
    p1=strstr(p,"/");
    if(p1)
    {
        memcpy(r->access.app,p,(int)(p1-p));
    7a44:	e2800024 	add	r0, r0, #36	; 0x24
    7a48:	ebfff5df 	bl	51cc <memcpy@plt>
    else
        return FALSE;
   
    
    p1++;
    p=strstr(p1,"?");
    7a4c:	e1a00004 	mov	r0, r4
    7a50:	e3a0103f 	mov	r1, #63	; 0x3f
    7a54:	ebfff5a3 	bl	50e8 <strchr@plt>
    if(p)
    7a58:	e2508000 	subs	r8, r0, #0
    7a5c:	0a00005a 	beq	7bcc <Parse_AccessUrl+0x208>
    {
        memcpy(r->access.stream,p1,(int)(p-p1));
    7a60:	e2850c46 	add	r0, r5, #17920	; 0x4600
    7a64:	e0642008 	rsb	r2, r4, r8
    7a68:	e1a01004 	mov	r1, r4
    7a6c:	e2800018 	add	r0, r0, #24
    7a70:	ebfff5d5 	bl	51cc <memcpy@plt>
        //memset(r->access.magic,0x00,sizeof(r->access.magic));
        return FALSE;
    }
    
    p++;
    p1=strstr(p,"uid=");
    7a74:	e59f11cc 	ldr	r1, [pc, #460]	; 7c48 <Parse_AccessUrl+0x284>
        //memset(r->access.uid,0x00,sizeof(r->access.uid));
        //memset(r->access.magic,0x00,sizeof(r->access.magic));
        return FALSE;
    }
    
    p++;
    7a78:	e2888001 	add	r8, r8, #1
    p1=strstr(p,"uid=");
    7a7c:	e1a00008 	mov	r0, r8
    7a80:	e08f1001 	add	r1, pc, r1
    7a84:	ebfff5bb 	bl	5178 <strstr@plt>
    
    if(p1)
    7a88:	e2504000 	subs	r4, r0, #0
    7a8c:	0a00005f 	beq	7c10 <Parse_AccessUrl+0x24c>
    {
        p1+=4;
    7a90:	e2844004 	add	r4, r4, #4
        p2=strstr(p1,"&");
    7a94:	e3a01026 	mov	r1, #38	; 0x26
    7a98:	e1a00004 	mov	r0, r4
    7a9c:	ebfff591 	bl	50e8 <strchr@plt>
{
    char *p,*p1,*p2;
    char *end;
    
    p=p1=p2=url;
    end=p+strlen(url);
    7aa0:	e0866007 	add	r6, r6, r7
        p1+=4;
        p2=strstr(p1,"&");
        if(p2)
        {
            
            memcpy(r->access.uid,p1,(int)(p2-p1));
    7aa4:	e2857b12 	add	r7, r5, #18432	; 0x4800
    
    if(p1)
    {
        p1+=4;
        p2=strstr(p1,"&");
        if(p2)
    7aa8:	e3500000 	cmp	r0, #0
            
            memcpy(r->access.uid,p1,(int)(p2-p1));
        }
        else
        {
            memcpy(r->access.uid,p1,(int)(end-p1));
    7aac:	01a01004 	moveq	r1, r4
        p1+=4;
        p2=strstr(p1,"&");
        if(p2)
        {
            
            memcpy(r->access.uid,p1,(int)(p2-p1));
    7ab0:	10642000 	rsbne	r2, r4, r0
    7ab4:	11a01004 	movne	r1, r4
        }
        else
        {
            memcpy(r->access.uid,p1,(int)(end-p1));
    7ab8:	00612006 	rsbeq	r2, r1, r6
        p1+=4;
        p2=strstr(p1,"&");
        if(p2)
        {
            
            memcpy(r->access.uid,p1,(int)(p2-p1));
    7abc:	1287000c 	addne	r0, r7, #12
        }
        else
        {
            memcpy(r->access.uid,p1,(int)(end-p1));
    7ac0:	0287000c 	addeq	r0, r7, #12
    7ac4:	ebfff5c0 	bl	51cc <memcpy@plt>
    {
        memset(r->access.uid,0x00,sizeof(r->access.uid));
        return FALSE;
    }
    
    p1=strstr(p,"magic=");
    7ac8:	e59f117c 	ldr	r1, [pc, #380]	; 7c4c <Parse_AccessUrl+0x288>
    7acc:	e1a00008 	mov	r0, r8
    7ad0:	e08f1001 	add	r1, pc, r1
    7ad4:	ebfff5a7 	bl	5178 <strstr@plt>
    
    if(p1)
    7ad8:	e2504000 	subs	r4, r0, #0
    7adc:	0a000052 	beq	7c2c <Parse_AccessUrl+0x268>
    {
        p1+=6;
    7ae0:	e2844006 	add	r4, r4, #6
        p2=strstr(p1,"&");
    7ae4:	e3a01026 	mov	r1, #38	; 0x26
    7ae8:	e1a00004 	mov	r0, r4
    7aec:	ebfff57d 	bl	50e8 <strchr@plt>
        if(p2)
    7af0:	e3500000 	cmp	r0, #0
        {
            memcpy(r->access.magic,p1,(int)(p2-p1));
        }
        else
        {
            memcpy(r->access.magic,p1,(int)(end-p1));
    7af4:	01a01004 	moveq	r1, r4
    {
        p1+=6;
        p2=strstr(p1,"&");
        if(p2)
        {
            memcpy(r->access.magic,p1,(int)(p2-p1));
    7af8:	10642000 	rsbne	r2, r4, r0
    7afc:	11a01004 	movne	r1, r4
        }
        else
        {
            memcpy(r->access.magic,p1,(int)(end-p1));
    7b00:	00612006 	rsbeq	r2, r1, r6
    {
        p1+=6;
        p2=strstr(p1,"&");
        if(p2)
        {
            memcpy(r->access.magic,p1,(int)(p2-p1));
    7b04:	12870070 	addne	r0, r7, #112	; 0x70
        }
        else
        {
            memcpy(r->access.magic,p1,(int)(end-p1));
    7b08:	02870070 	addeq	r0, r7, #112	; 0x70
    7b0c:	ebfff5ae 	bl	51cc <memcpy@plt>
    {
        memset(r->access.magic,0x00,sizeof(r->access.magic));
        return FALSE;
    }
    ////////////////////////////project id
    p1=strstr(p,"productID=");
    7b10:	e59f1138 	ldr	r1, [pc, #312]	; 7c50 <Parse_AccessUrl+0x28c>
    7b14:	e1a00008 	mov	r0, r8
    7b18:	e08f1001 	add	r1, pc, r1
    7b1c:	ebfff595 	bl	5178 <strstr@plt>
    
    if(p1)
    7b20:	e2501000 	subs	r1, r0, #0
    7b24:	0a000035 	beq	7c00 <Parse_AccessUrl+0x23c>
    {
        p1+=10;
    7b28:	e281400a 	add	r4, r1, #10
        p2=strstr(p1,"&");
    7b2c:	e1a00004 	mov	r0, r4
    7b30:	e3a01026 	mov	r1, #38	; 0x26
    7b34:	ebfff56b 	bl	50e8 <strchr@plt>
        if(p2)
    7b38:	e2502000 	subs	r2, r0, #0
        {
            memcpy(r->access.product_id,p1,(int)(p2-p1));
        }
        else
        {
            memcpy(r->access.product_id,p1,(int)(end-p1));
    7b3c:	01a01004 	moveq	r1, r4
    {
        p1+=10;
        p2=strstr(p1,"&");
        if(p2)
        {
            memcpy(r->access.product_id,p1,(int)(p2-p1));
    7b40:	e28700d4 	add	r0, r7, #212	; 0xd4
    7b44:	10642002 	rsbne	r2, r4, r2
    7b48:	11a01004 	movne	r1, r4
        }
        else
        {
            memcpy(r->access.product_id,p1,(int)(end-p1));
    7b4c:	00612006 	rsbeq	r2, r1, r6
    7b50:	ebfff59d 	bl	51cc <memcpy@plt>
    else
    {
        memset(r->access.product_id,0x00,sizeof(r->access.product_id));
    }
    
    p1=strstr(p,"productVersion=");
    7b54:	e59f10f8 	ldr	r1, [pc, #248]	; 7c54 <Parse_AccessUrl+0x290>
    7b58:	e1a00008 	mov	r0, r8
    7b5c:	e08f1001 	add	r1, pc, r1
    7b60:	ebfff584 	bl	5178 <strstr@plt>
    
    if(p1)
    7b64:	e2501000 	subs	r1, r0, #0
    7b68:	0a00001f 	beq	7bec <Parse_AccessUrl+0x228>
    {
        p1+=15;
    7b6c:	e281400f 	add	r4, r1, #15
        p2=strstr(p1,"&");
    7b70:	e1a00004 	mov	r0, r4
    7b74:	e3a01026 	mov	r1, #38	; 0x26
    7b78:	ebfff55a 	bl	50e8 <strchr@plt>
        {
            memcpy(r->access.product_version,p1,(int)(p2-p1));
        }
        else
        {
            memcpy(r->access.product_version,p1,(int)(end-p1));
    7b7c:	e1a01004 	mov	r1, r4
    
    if(p1)
    {
        p1+=15;
        p2=strstr(p1,"&");
        if(p2)
    7b80:	e2502000 	subs	r2, r0, #0
        {
            memcpy(r->access.product_version,p1,(int)(p2-p1));
    7b84:	e2850c49 	add	r0, r5, #18688	; 0x4900
    7b88:	10642002 	rsbne	r2, r4, r2
        }
        else
        {
            memcpy(r->access.product_version,p1,(int)(end-p1));
    7b8c:	00642006 	rsbeq	r2, r4, r6
    7b90:	e2800038 	add	r0, r0, #56	; 0x38
    7b94:	ebfff58c 	bl	51cc <memcpy@plt>
    {
        memset(r->access.product_version,0x00,sizeof(r->access.product_version));
    }

    ///////check or not
    p1=strstr(p,"check=");
    7b98:	e59f10b8 	ldr	r1, [pc, #184]	; 7c58 <Parse_AccessUrl+0x294>
    7b9c:	e1a00008 	mov	r0, r8
    7ba0:	e08f1001 	add	r1, pc, r1
    7ba4:	ebfff573 	bl	5178 <strstr@plt>
    
    if(p1)
    7ba8:	e3500000 	cmp	r0, #0
    7bac:	0a000009 	beq	7bd8 <Parse_AccessUrl+0x214>
    {
        p1+=6;
        
        r->access.becheck=atoi(p1);
    7bb0:	e2800006 	add	r0, r0, #6
    7bb4:	ebfff554 	bl	510c <atoi@plt>
    7bb8:	e2855901 	add	r5, r5, #16384	; 0x4000
    {
        r->access.becheck=0;
        return FALSE;
    }
    
    return TRUE;
    7bbc:	e3a03001 	mov	r3, #1
    
    if(p1)
    {
        p1+=6;
        
        r->access.becheck=atoi(p1);
    7bc0:	e585099c 	str	r0, [r5, #2460]	; 0x99c
        r->access.becheck=0;
        return FALSE;
    }
    
    return TRUE;
}
    7bc4:	e1a00003 	mov	r0, r3
    7bc8:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
        rtmp_url->av_val=p1;
        rtmp_url->av_len=(int)(p-p1);
    }
    else
    {
        return FALSE;
    7bcc:	e3a03000 	mov	r3, #0
        r->access.becheck=0;
        return FALSE;
    }
    
    return TRUE;
}
    7bd0:	e1a00003 	mov	r0, r3
    7bd4:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
        r->access.becheck=atoi(p1);
        
    }
    else
    {
        r->access.becheck=0;
    7bd8:	e2855901 	add	r5, r5, #16384	; 0x4000
        return FALSE;
    7bdc:	e1a03000 	mov	r3, r0
        r->access.becheck=atoi(p1);
        
    }
    else
    {
        r->access.becheck=0;
    7be0:	e585099c 	str	r0, [r5, #2460]	; 0x99c
        return FALSE;
    }
    
    return TRUE;
}
    7be4:	e1a00003 	mov	r0, r3
    7be8:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
        }
        
    }
    else
    {
        memset(r->access.product_version,0x00,sizeof(r->access.product_version));
    7bec:	e2850c49 	add	r0, r5, #18688	; 0x4900
    7bf0:	e3a02064 	mov	r2, #100	; 0x64
    7bf4:	e2800038 	add	r0, r0, #56	; 0x38
    7bf8:	ebfff534 	bl	50d0 <memset@plt>
    7bfc:	eaffffe5 	b	7b98 <Parse_AccessUrl+0x1d4>
        }
        
    }
    else
    {
        memset(r->access.product_id,0x00,sizeof(r->access.product_id));
    7c00:	e28700d4 	add	r0, r7, #212	; 0xd4
    7c04:	e3a02064 	mov	r2, #100	; 0x64
    7c08:	ebfff530 	bl	50d0 <memset@plt>
    7c0c:	eaffffd0 	b	7b54 <Parse_AccessUrl+0x190>
            memcpy(r->access.uid,p1,(int)(end-p1));
        }
    }
    else
    {
        memset(r->access.uid,0x00,sizeof(r->access.uid));
    7c10:	e2850b12 	add	r0, r5, #18432	; 0x4800
    7c14:	e280000c 	add	r0, r0, #12
    7c18:	e1a01004 	mov	r1, r4
    7c1c:	e3a02064 	mov	r2, #100	; 0x64
    7c20:	ebfff52a 	bl	50d0 <memset@plt>
        return FALSE;
    7c24:	e1a03004 	mov	r3, r4
    7c28:	eaffffe8 	b	7bd0 <Parse_AccessUrl+0x20c>
        }
        
    }
    else
    {
        memset(r->access.magic,0x00,sizeof(r->access.magic));
    7c2c:	e2870070 	add	r0, r7, #112	; 0x70
    7c30:	e1a01004 	mov	r1, r4
    7c34:	e3a02064 	mov	r2, #100	; 0x64
    7c38:	ebfff524 	bl	50d0 <memset@plt>
        return FALSE;
    7c3c:	e1a03004 	mov	r3, r4
    7c40:	eaffffe2 	b	7bd0 <Parse_AccessUrl+0x20c>
    7c44:	00016b50 	.word	0x00016b50
    7c48:	00016ab4 	.word	0x00016ab4
    7c4c:	00016a6c 	.word	0x00016a6c
    7c50:	00016a2c 	.word	0x00016a2c
    7c54:	000169f4 	.word	0x000169f4
    7c58:	000169c0 	.word	0x000169c0

00007c5c <load_url_seed>:
}

#define SAVE_SEED_NUM 20

int load_url_seed(char *url, char *seed, int *beginning)
{
    7c5c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7c60:	e24dd06c 	sub	sp, sp, #108	; 0x6c
    7c64:	e58d1020 	str	r1, [sp, #32]
    RTMP_Log(RTMP_LOGINFO, "load_url_seed");
    7c68:	e59f1300 	ldr	r1, [pc, #768]	; 7f70 <load_url_seed+0x314>
    7c6c:	e59f8300 	ldr	r8, [pc, #768]	; 7f74 <load_url_seed+0x318>
}

#define SAVE_SEED_NUM 20

int load_url_seed(char *url, char *seed, int *beginning)
{
    7c70:	e1a09000 	mov	r9, r0
    RTMP_Log(RTMP_LOGINFO, "load_url_seed");
    7c74:	e08f1001 	add	r1, pc, r1
    7c78:	e3a00003 	mov	r0, #3
}

#define SAVE_SEED_NUM 20

int load_url_seed(char *url, char *seed, int *beginning)
{
    7c7c:	e58d2024 	str	r2, [sp, #36]	; 0x24
    RTMP_Log(RTMP_LOGINFO, "load_url_seed");
    7c80:	eb003749 	bl	159ac <RTMP_Log>
            break;
        }
        SAFE_FREE(last_url);
    }
#else
    if (g_func_rtmpGetProc != NULL)
    7c84:	e79f8008 	ldr	r8, [pc, r8]
    7c88:	e5983000 	ldr	r3, [r8]
    7c8c:	e3530000 	cmp	r3, #0
    7c90:	0a00000d 	beq	7ccc <load_url_seed+0x70>
    {
        char *seed_index_string = g_func_rtmpGetProc("push_seed_index");
    7c94:	e59f02dc 	ldr	r0, [pc, #732]	; 7f78 <load_url_seed+0x31c>
    7c98:	e08f0000 	add	r0, pc, r0
    7c9c:	e12fff33 	blx	r3
        RTMP_Log(RTMP_LOGINFO, "load_url_seed seed_index : %s", seed_index_string);
    7ca0:	e59f12d4 	ldr	r1, [pc, #724]	; 7f7c <load_url_seed+0x320>
    7ca4:	e08f1001 	add	r1, pc, r1
        SAFE_FREE(last_url);
    }
#else
    if (g_func_rtmpGetProc != NULL)
    {
        char *seed_index_string = g_func_rtmpGetProc("push_seed_index");
    7ca8:	e1a04000 	mov	r4, r0
        RTMP_Log(RTMP_LOGINFO, "load_url_seed seed_index : %s", seed_index_string);
    7cac:	e1a02000 	mov	r2, r0
    7cb0:	e3a00003 	mov	r0, #3
    7cb4:	eb00373c 	bl	159ac <RTMP_Log>
        if(seed_index_string == NULL || strlen(seed_index_string) == 0)
    7cb8:	e3540000 	cmp	r4, #0
    7cbc:	0a000002 	beq	7ccc <load_url_seed+0x70>
    7cc0:	e5d43000 	ldrb	r3, [r4]
    7cc4:	e3530000 	cmp	r3, #0
    7cc8:	1a000003 	bne	7cdc <load_url_seed+0x80>
#define SAVE_SEED_NUM 20

int load_url_seed(char *url, char *seed, int *beginning)
{
    RTMP_Log(RTMP_LOGINFO, "load_url_seed");
    int success = FALSE;
    7ccc:	e3a04000 	mov	r4, #0
        }
    }
#endif
    
    return success;
}
    7cd0:	e1a00004 	mov	r0, r4
    7cd4:	e28dd06c 	add	sp, sp, #108	; 0x6c
    7cd8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    {
        char *seed_index_string = g_func_rtmpGetProc("push_seed_index");
        RTMP_Log(RTMP_LOGINFO, "load_url_seed seed_index : %s", seed_index_string);
        if(seed_index_string == NULL || strlen(seed_index_string) == 0)
            return success;
        int seed_index = atoi(seed_index_string);
    7cdc:	e1a00004 	mov	r0, r4
    7ce0:	ebfff509 	bl	510c <atoi@plt>
    7ce4:	e28d702c 	add	r7, sp, #44	; 0x2c
        int i = 0;
        for(i = SAVE_SEED_NUM; i > 0; i--)
        {
            int seed_index_temp = (seed_index+i) % SAVE_SEED_NUM;
            RTMP_Log(RTMP_LOGINFO, "load_url_seed seed_index_temp : %d", seed_index_temp);
            char last_url_string[20] = { '\0' };
    7ce8:	e3a06000 	mov	r6, #0
    {
        char *seed_index_string = g_func_rtmpGetProc("push_seed_index");
        RTMP_Log(RTMP_LOGINFO, "load_url_seed seed_index : %s", seed_index_string);
        if(seed_index_string == NULL || strlen(seed_index_string) == 0)
            return success;
        int seed_index = atoi(seed_index_string);
    7cec:	e1a0a000 	mov	sl, r0
        SAFE_FREE(seed_index_string);
    7cf0:	e1a00004 	mov	r0, r4
    7cf4:	ebfff4c2 	bl	5004 <free@plt>
        int i = 0;
        for(i = SAVE_SEED_NUM; i > 0; i--)
        {
            int seed_index_temp = (seed_index+i) % SAVE_SEED_NUM;
            RTMP_Log(RTMP_LOGINFO, "load_url_seed seed_index_temp : %d", seed_index_temp);
    7cf8:	e59f3280 	ldr	r3, [pc, #640]	; 7f80 <load_url_seed+0x324>
    7cfc:	e28a5014 	add	r5, sl, #20
    7d00:	e08f3003 	add	r3, pc, r3
    7d04:	e58d3014 	str	r3, [sp, #20]
            char last_url_string[20] = { '\0' };
            sprintf(last_url_string, "push_url%d", seed_index_temp);
    7d08:	e59f3274 	ldr	r3, [pc, #628]	; 7f84 <load_url_seed+0x328>
        int i = 0;
        for(i = SAVE_SEED_NUM; i > 0; i--)
        {
            int seed_index_temp = (seed_index+i) % SAVE_SEED_NUM;
            RTMP_Log(RTMP_LOGINFO, "load_url_seed seed_index_temp : %d", seed_index_temp);
            char last_url_string[20] = { '\0' };
    7d0c:	e1a0b00a 	mov	fp, sl
            sprintf(last_url_string, "push_url%d", seed_index_temp);
    7d10:	e08f3003 	add	r3, pc, r3
    7d14:	e58d3018 	str	r3, [sp, #24]
            char *last_url = g_func_rtmpGetProc(last_url_string);
            if (last_url != NULL || strlen(last_url) != 0)
            {
                RTMP_Log(RTMP_LOGINFO, "load_url_seed last_url=%s, url=%s", last_url, url);
    7d18:	e59f3268 	ldr	r3, [pc, #616]	; 7f88 <load_url_seed+0x32c>
    7d1c:	e08f3003 	add	r3, pc, r3
    7d20:	e58d301c 	str	r3, [sp, #28]
    7d24:	e28d3030 	add	r3, sp, #48	; 0x30
    7d28:	e58d3010 	str	r3, [sp, #16]
    7d2c:	e28d3034 	add	r3, sp, #52	; 0x34
    7d30:	e58d3004 	str	r3, [sp, #4]
    7d34:	e28d3038 	add	r3, sp, #56	; 0x38
    7d38:	e58d3008 	str	r3, [sp, #8]
    7d3c:	e28d303c 	add	r3, sp, #60	; 0x3c
    7d40:	e58d300c 	str	r3, [sp, #12]
    7d44:	ea00000e 	b	7d84 <load_url_seed+0x128>
    7d48:	e3a00003 	mov	r0, #3
    7d4c:	e59d101c 	ldr	r1, [sp, #28]
    7d50:	e1a0200a 	mov	r2, sl
    7d54:	e1a03009 	mov	r3, r9
    7d58:	eb003713 	bl	159ac <RTMP_Log>
                if (strcmp(url, last_url) == 0)
    7d5c:	e1a00009 	mov	r0, r9
    7d60:	e1a0100a 	mov	r1, sl
    7d64:	ebfff509 	bl	5190 <strcmp@plt>
    7d68:	e3500000 	cmp	r0, #0
    7d6c:	0a000023 	beq	7e00 <load_url_seed+0x1a4>
                    SAFE_FREE(last_seed);
                    SAFE_FREE(last_beginning);
                    SAFE_FREE(last_url);
                    break;
                }
                SAFE_FREE(last_url);
    7d70:	e1a0000a 	mov	r0, sl
    7d74:	e2455001 	sub	r5, r5, #1
    7d78:	ebfff4a1 	bl	5004 <free@plt>
        if(seed_index_string == NULL || strlen(seed_index_string) == 0)
            return success;
        int seed_index = atoi(seed_index_string);
        SAFE_FREE(seed_index_string);
        int i = 0;
        for(i = SAVE_SEED_NUM; i > 0; i--)
    7d7c:	e155000b 	cmp	r5, fp
    7d80:	0affffd1 	beq	7ccc <load_url_seed+0x70>
        {
            int seed_index_temp = (seed_index+i) % SAVE_SEED_NUM;
    7d84:	e59f4200 	ldr	r4, [pc, #512]	; 7f8c <load_url_seed+0x330>
            RTMP_Log(RTMP_LOGINFO, "load_url_seed seed_index_temp : %d", seed_index_temp);
    7d88:	e3a00003 	mov	r0, #3
        int seed_index = atoi(seed_index_string);
        SAFE_FREE(seed_index_string);
        int i = 0;
        for(i = SAVE_SEED_NUM; i > 0; i--)
        {
            int seed_index_temp = (seed_index+i) % SAVE_SEED_NUM;
    7d8c:	e0c43495 	smull	r3, r4, r5, r4
    7d90:	e1a03fc5 	asr	r3, r5, #31
    7d94:	e06341c4 	rsb	r4, r3, r4, asr #3
    7d98:	e0844104 	add	r4, r4, r4, lsl #2
    7d9c:	e0454104 	sub	r4, r5, r4, lsl #2
            RTMP_Log(RTMP_LOGINFO, "load_url_seed seed_index_temp : %d", seed_index_temp);
    7da0:	e1a02004 	mov	r2, r4
    7da4:	e59d1014 	ldr	r1, [sp, #20]
    7da8:	eb0036ff 	bl	159ac <RTMP_Log>
            char last_url_string[20] = { '\0' };
    7dac:	e59d3010 	ldr	r3, [sp, #16]
    7db0:	e5876000 	str	r6, [r7]
    7db4:	e5836000 	str	r6, [r3]
    7db8:	e59d3004 	ldr	r3, [sp, #4]
            sprintf(last_url_string, "push_url%d", seed_index_temp);
    7dbc:	e28d702c 	add	r7, sp, #44	; 0x2c
        int i = 0;
        for(i = SAVE_SEED_NUM; i > 0; i--)
        {
            int seed_index_temp = (seed_index+i) % SAVE_SEED_NUM;
            RTMP_Log(RTMP_LOGINFO, "load_url_seed seed_index_temp : %d", seed_index_temp);
            char last_url_string[20] = { '\0' };
    7dc0:	e5836000 	str	r6, [r3]
    7dc4:	e59d3008 	ldr	r3, [sp, #8]
            sprintf(last_url_string, "push_url%d", seed_index_temp);
    7dc8:	e1a02004 	mov	r2, r4
        int i = 0;
        for(i = SAVE_SEED_NUM; i > 0; i--)
        {
            int seed_index_temp = (seed_index+i) % SAVE_SEED_NUM;
            RTMP_Log(RTMP_LOGINFO, "load_url_seed seed_index_temp : %d", seed_index_temp);
            char last_url_string[20] = { '\0' };
    7dcc:	e5836000 	str	r6, [r3]
    7dd0:	e59d300c 	ldr	r3, [sp, #12]
            sprintf(last_url_string, "push_url%d", seed_index_temp);
    7dd4:	e59d1018 	ldr	r1, [sp, #24]
    7dd8:	e1a00007 	mov	r0, r7
        int i = 0;
        for(i = SAVE_SEED_NUM; i > 0; i--)
        {
            int seed_index_temp = (seed_index+i) % SAVE_SEED_NUM;
            RTMP_Log(RTMP_LOGINFO, "load_url_seed seed_index_temp : %d", seed_index_temp);
            char last_url_string[20] = { '\0' };
    7ddc:	e5836000 	str	r6, [r3]
            sprintf(last_url_string, "push_url%d", seed_index_temp);
    7de0:	ebfff4e1 	bl	516c <sprintf@plt>
            char *last_url = g_func_rtmpGetProc(last_url_string);
    7de4:	e1a00007 	mov	r0, r7
    7de8:	e5983000 	ldr	r3, [r8]
    7dec:	e12fff33 	blx	r3
            if (last_url != NULL || strlen(last_url) != 0)
    7df0:	e250a000 	subs	sl, r0, #0
    7df4:	1affffd3 	bne	7d48 <load_url_seed+0xec>
    7df8:	e5da3000 	ldrb	r3, [sl]
    7dfc:	e7f000f0 	udf	#0
                RTMP_Log(RTMP_LOGINFO, "load_url_seed last_url=%s, url=%s", last_url, url);
                if (strcmp(url, last_url) == 0)
                {
                    char last_seed_string[20] = { '\0' };
                    char last_beginning_string[20] = { '\0' };
                    sprintf(last_seed_string, "push_seed%d", seed_index_temp);
    7e00:	e59f1188 	ldr	r1, [pc, #392]	; 7f90 <load_url_seed+0x334>
    7e04:	e28d6040 	add	r6, sp, #64	; 0x40
    7e08:	e1a03000 	mov	r3, r0
    7e0c:	e1a02004 	mov	r2, r4
    7e10:	e08f1001 	add	r1, pc, r1
    7e14:	e1a00006 	mov	r0, r6
            if (last_url != NULL || strlen(last_url) != 0)
            {
                RTMP_Log(RTMP_LOGINFO, "load_url_seed last_url=%s, url=%s", last_url, url);
                if (strcmp(url, last_url) == 0)
                {
                    char last_seed_string[20] = { '\0' };
    7e18:	e58d3040 	str	r3, [sp, #64]	; 0x40
    7e1c:	e58d3044 	str	r3, [sp, #68]	; 0x44
    7e20:	e58d3048 	str	r3, [sp, #72]	; 0x48
    7e24:	e58d304c 	str	r3, [sp, #76]	; 0x4c
    7e28:	e58d3050 	str	r3, [sp, #80]	; 0x50
                    char last_beginning_string[20] = { '\0' };
    7e2c:	e58d3054 	str	r3, [sp, #84]	; 0x54
    7e30:	e58d3058 	str	r3, [sp, #88]	; 0x58
    7e34:	e58d305c 	str	r3, [sp, #92]	; 0x5c
    7e38:	e58d3060 	str	r3, [sp, #96]	; 0x60
    7e3c:	e58d3064 	str	r3, [sp, #100]	; 0x64
                    sprintf(last_seed_string, "push_seed%d", seed_index_temp);
    7e40:	ebfff4c9 	bl	516c <sprintf@plt>
                    sprintf(last_beginning_string, "push_beginning%d", seed_index_temp);
    7e44:	e59f1148 	ldr	r1, [pc, #328]	; 7f94 <load_url_seed+0x338>
    7e48:	e28d5054 	add	r5, sp, #84	; 0x54
    7e4c:	e1a02004 	mov	r2, r4
    7e50:	e08f1001 	add	r1, pc, r1
    7e54:	e1a00005 	mov	r0, r5
    7e58:	ebfff4c3 	bl	516c <sprintf@plt>
                    char *last_seed = g_func_rtmpGetProc(last_seed_string);
    7e5c:	e5983000 	ldr	r3, [r8]
    7e60:	e1a00006 	mov	r0, r6
    7e64:	e12fff33 	blx	r3
                    char *last_beginning = g_func_rtmpGetProc(last_beginning_string);
    7e68:	e5983000 	ldr	r3, [r8]
    7e6c:	e1a0b00a 	mov	fp, sl
                {
                    char last_seed_string[20] = { '\0' };
                    char last_beginning_string[20] = { '\0' };
                    sprintf(last_seed_string, "push_seed%d", seed_index_temp);
                    sprintf(last_beginning_string, "push_beginning%d", seed_index_temp);
                    char *last_seed = g_func_rtmpGetProc(last_seed_string);
    7e70:	e1a04000 	mov	r4, r0
                    char *last_beginning = g_func_rtmpGetProc(last_beginning_string);
    7e74:	e1a00005 	mov	r0, r5
    7e78:	e12fff33 	blx	r3
                    if (last_seed != NULL && strlen(last_seed) != 0 && last_beginning != NULL && strlen(last_beginning) != 0)
    7e7c:	e3540000 	cmp	r4, #0
                    char last_seed_string[20] = { '\0' };
                    char last_beginning_string[20] = { '\0' };
                    sprintf(last_seed_string, "push_seed%d", seed_index_temp);
                    sprintf(last_beginning_string, "push_beginning%d", seed_index_temp);
                    char *last_seed = g_func_rtmpGetProc(last_seed_string);
                    char *last_beginning = g_func_rtmpGetProc(last_beginning_string);
    7e80:	e1a08000 	mov	r8, r0
                    if (last_seed != NULL && strlen(last_seed) != 0 && last_beginning != NULL && strlen(last_beginning) != 0)
    7e84:	0a00001c 	beq	7efc <load_url_seed+0x2a0>
    7e88:	e5d43000 	ldrb	r3, [r4]
    7e8c:	e2905000 	adds	r5, r0, #0
    7e90:	13a05001 	movne	r5, #1
    7e94:	e3530000 	cmp	r3, #0
    7e98:	13500000 	cmpne	r0, #0
    7e9c:	0a000002 	beq	7eac <load_url_seed+0x250>
    7ea0:	e5d03000 	ldrb	r3, [r0]
    7ea4:	e3530000 	cmp	r3, #0
    7ea8:	1a00001e 	bne	7f28 <load_url_seed+0x2cc>
                    {
                        strcpy(seed, last_seed);
                        *beginning = atoi(last_beginning);
                        success = TRUE;
                    }
                    RTMP_Log(RTMP_LOGINFO, "load_url_seed seed : %s,beginning : %d", seed, *beginning);
    7eac:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    7eb0:	e59f10e0 	ldr	r1, [pc, #224]	; 7f98 <load_url_seed+0x33c>
    7eb4:	e59d2020 	ldr	r2, [sp, #32]
    7eb8:	e5933000 	ldr	r3, [r3]
    7ebc:	e3a00003 	mov	r0, #3
    7ec0:	e08f1001 	add	r1, pc, r1
    7ec4:	eb0036b8 	bl	159ac <RTMP_Log>
                    SAFE_FREE(last_seed);
    7ec8:	e1a00004 	mov	r0, r4
    7ecc:	ebfff44c 	bl	5004 <free@plt>
                    SAFE_FREE(last_beginning);
    7ed0:	e3550000 	cmp	r5, #0
#define SAVE_SEED_NUM 20

int load_url_seed(char *url, char *seed, int *beginning)
{
    RTMP_Log(RTMP_LOGINFO, "load_url_seed");
    int success = FALSE;
    7ed4:	01a04005 	moveq	r4, r5
                        *beginning = atoi(last_beginning);
                        success = TRUE;
                    }
                    RTMP_Log(RTMP_LOGINFO, "load_url_seed seed : %s,beginning : %d", seed, *beginning);
                    SAFE_FREE(last_seed);
                    SAFE_FREE(last_beginning);
    7ed8:	0a000002 	beq	7ee8 <load_url_seed+0x28c>
#define SAVE_SEED_NUM 20

int load_url_seed(char *url, char *seed, int *beginning)
{
    RTMP_Log(RTMP_LOGINFO, "load_url_seed");
    int success = FALSE;
    7edc:	e3a04000 	mov	r4, #0
                        *beginning = atoi(last_beginning);
                        success = TRUE;
                    }
                    RTMP_Log(RTMP_LOGINFO, "load_url_seed seed : %s,beginning : %d", seed, *beginning);
                    SAFE_FREE(last_seed);
                    SAFE_FREE(last_beginning);
    7ee0:	e1a00008 	mov	r0, r8
    7ee4:	ebfff446 	bl	5004 <free@plt>
                    SAFE_FREE(last_url);
    7ee8:	e1a0000b 	mov	r0, fp
    7eec:	ebfff444 	bl	5004 <free@plt>
        }
    }
#endif
    
    return success;
}
    7ef0:	e1a00004 	mov	r0, r4
    7ef4:	e28dd06c 	add	sp, sp, #108	; 0x6c
    7ef8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
                    {
                        strcpy(seed, last_seed);
                        *beginning = atoi(last_beginning);
                        success = TRUE;
                    }
                    RTMP_Log(RTMP_LOGINFO, "load_url_seed seed : %s,beginning : %d", seed, *beginning);
    7efc:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    7f00:	e59f1094 	ldr	r1, [pc, #148]	; 7f9c <load_url_seed+0x340>
    7f04:	e59d2020 	ldr	r2, [sp, #32]
    7f08:	e5933000 	ldr	r3, [r3]
    7f0c:	e3a00003 	mov	r0, #3
    7f10:	e08f1001 	add	r1, pc, r1
    7f14:	eb0036a4 	bl	159ac <RTMP_Log>
                    SAFE_FREE(last_seed);
                    SAFE_FREE(last_beginning);
    7f18:	e3580000 	cmp	r8, #0
#define SAVE_SEED_NUM 20

int load_url_seed(char *url, char *seed, int *beginning)
{
    RTMP_Log(RTMP_LOGINFO, "load_url_seed");
    int success = FALSE;
    7f1c:	01a04008 	moveq	r4, r8
                        *beginning = atoi(last_beginning);
                        success = TRUE;
                    }
                    RTMP_Log(RTMP_LOGINFO, "load_url_seed seed : %s,beginning : %d", seed, *beginning);
                    SAFE_FREE(last_seed);
                    SAFE_FREE(last_beginning);
    7f20:	1affffee 	bne	7ee0 <load_url_seed+0x284>
    7f24:	eaffffef 	b	7ee8 <load_url_seed+0x28c>
                    sprintf(last_beginning_string, "push_beginning%d", seed_index_temp);
                    char *last_seed = g_func_rtmpGetProc(last_seed_string);
                    char *last_beginning = g_func_rtmpGetProc(last_beginning_string);
                    if (last_seed != NULL && strlen(last_seed) != 0 && last_beginning != NULL && strlen(last_beginning) != 0)
                    {
                        strcpy(seed, last_seed);
    7f28:	e59d5020 	ldr	r5, [sp, #32]
    7f2c:	e1a01004 	mov	r1, r4
    7f30:	e1a00005 	mov	r0, r5
    7f34:	ebfff4b0 	bl	51fc <strcpy@plt>
                        *beginning = atoi(last_beginning);
    7f38:	e1a00008 	mov	r0, r8
    7f3c:	ebfff472 	bl	510c <atoi@plt>
    7f40:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
                        success = TRUE;
                    }
                    RTMP_Log(RTMP_LOGINFO, "load_url_seed seed : %s,beginning : %d", seed, *beginning);
    7f44:	e59f1054 	ldr	r1, [pc, #84]	; 7fa0 <load_url_seed+0x344>
    7f48:	e08f1001 	add	r1, pc, r1
                    char *last_seed = g_func_rtmpGetProc(last_seed_string);
                    char *last_beginning = g_func_rtmpGetProc(last_beginning_string);
                    if (last_seed != NULL && strlen(last_seed) != 0 && last_beginning != NULL && strlen(last_beginning) != 0)
                    {
                        strcpy(seed, last_seed);
                        *beginning = atoi(last_beginning);
    7f4c:	e1a03000 	mov	r3, r0
    7f50:	e5820000 	str	r0, [r2]
                        success = TRUE;
                    }
                    RTMP_Log(RTMP_LOGINFO, "load_url_seed seed : %s,beginning : %d", seed, *beginning);
    7f54:	e1a02005 	mov	r2, r5
    7f58:	e3a00003 	mov	r0, #3
    7f5c:	eb003692 	bl	159ac <RTMP_Log>
                    SAFE_FREE(last_seed);
    7f60:	e1a00004 	mov	r0, r4
    7f64:	ebfff426 	bl	5004 <free@plt>
                    char *last_beginning = g_func_rtmpGetProc(last_beginning_string);
                    if (last_seed != NULL && strlen(last_seed) != 0 && last_beginning != NULL && strlen(last_beginning) != 0)
                    {
                        strcpy(seed, last_seed);
                        *beginning = atoi(last_beginning);
                        success = TRUE;
    7f68:	e3a04001 	mov	r4, #1
    7f6c:	eaffffdb 	b	7ee0 <load_url_seed+0x284>
    7f70:	000168f4 	.word	0x000168f4
    7f74:	0001c0ec 	.word	0x0001c0ec
    7f78:	000168e0 	.word	0x000168e0
    7f7c:	000168e4 	.word	0x000168e4
    7f80:	000168a8 	.word	0x000168a8
    7f84:	000168bc 	.word	0x000168bc
    7f88:	00016904 	.word	0x00016904
    7f8c:	66666667 	.word	0x66666667
    7f90:	000167c8 	.word	0x000167c8
    7f94:	00016794 	.word	0x00016794
    7f98:	00016738 	.word	0x00016738
    7f9c:	000166e8 	.word	0x000166e8
    7fa0:	000166b0 	.word	0x000166b0

00007fa4 <save_url_seed>:
    
    return success;
}

int save_url_seed(char* url, char *seed, int beginning)
{
    7fa4:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7fa8:	e24dd094 	sub	sp, sp, #148	; 0x94
    RTMP_Log(RTMP_LOGINFO, "save_url_seed seed : %s", seed);
    7fac:	e59f3370 	ldr	r3, [pc, #880]	; 8324 <save_url_seed+0x380>
    
    return success;
}

int save_url_seed(char* url, char *seed, int beginning)
{
    7fb0:	e58d1024 	str	r1, [sp, #36]	; 0x24
    7fb4:	e58d2028 	str	r2, [sp, #40]	; 0x28
    RTMP_Log(RTMP_LOGINFO, "save_url_seed seed : %s", seed);
    7fb8:	e1a02001 	mov	r2, r1
    7fbc:	e59f1364 	ldr	r1, [pc, #868]	; 8328 <save_url_seed+0x384>
    7fc0:	e1a04003 	mov	r4, r3
    
    return success;
}

int save_url_seed(char* url, char *seed, int beginning)
{
    7fc4:	e1a0a000 	mov	sl, r0
    RTMP_Log(RTMP_LOGINFO, "save_url_seed seed : %s", seed);
    7fc8:	e08f1001 	add	r1, pc, r1
    7fcc:	e3a00003 	mov	r0, #3
    7fd0:	eb003675 	bl	159ac <RTMP_Log>
    setVPSettingString(seed_string, seed);
    setVPSettingInt(beginning_string, beginning);
    
    setVPSettingInt("live.protocol.rtmp.push_seed_index", seed_index);
#else
    if (g_func_rtmpSetProc != NULL && g_func_rtmpGetProc != NULL)
    7fd4:	e79f3004 	ldr	r3, [pc, r4]
    7fd8:	e58d302c 	str	r3, [sp, #44]	; 0x2c
    7fdc:	e5930000 	ldr	r0, [r3]
    7fe0:	e3500000 	cmp	r0, #0
    7fe4:	0a00009f 	beq	8268 <save_url_seed+0x2c4>
    7fe8:	e59f933c 	ldr	r9, [pc, #828]	; 832c <save_url_seed+0x388>
    7fec:	e79f9009 	ldr	r9, [pc, r9]
    7ff0:	e5993000 	ldr	r3, [r9]
    7ff4:	e3530000 	cmp	r3, #0
        
        return 1;
    }
#endif

    return 0;
    7ff8:	01a00003 	moveq	r0, r3
    setVPSettingString(seed_string, seed);
    setVPSettingInt(beginning_string, beginning);
    
    setVPSettingInt("live.protocol.rtmp.push_seed_index", seed_index);
#else
    if (g_func_rtmpSetProc != NULL && g_func_rtmpGetProc != NULL)
    7ffc:	0a000099 	beq	8268 <save_url_seed+0x2c4>
    {
        char *seed_index_string = g_func_rtmpGetProc("push_seed_index");
    8000:	e59f0328 	ldr	r0, [pc, #808]	; 8330 <save_url_seed+0x38c>
    8004:	e08f0000 	add	r0, pc, r0
    8008:	e12fff33 	blx	r3
        if(seed_index_string == NULL || strlen(seed_index_string) == 0)
    800c:	e2504000 	subs	r4, r0, #0
    8010:	0a0000c0 	beq	8318 <save_url_seed+0x374>
    8014:	e5d43000 	ldrb	r3, [r4]
    8018:	e3530000 	cmp	r3, #0
    801c:	0a000093 	beq	8270 <save_url_seed+0x2cc>
        {
            seed_index_string = "0";
        }
        int seed_index = atoi(seed_index_string);
    8020:	e1a00004 	mov	r0, r4
    8024:	ebfff438 	bl	510c <atoi@plt>
    8028:	e28d8054 	add	r8, sp, #84	; 0x54
        int i = 0;
        for(i = SAVE_SEED_NUM; i > 0; i--)
        {
            int seed_index_temp = (seed_index+i) % SAVE_SEED_NUM;
            char url_string[20] = { '\0' };
            sprintf(url_string, "push_url%d", seed_index_temp);
    802c:	e1a07008 	mov	r7, r8
        SAFE_FREE(seed_index_string);
        int i = 0;
        for(i = SAVE_SEED_NUM; i > 0; i--)
        {
            int seed_index_temp = (seed_index+i) % SAVE_SEED_NUM;
            char url_string[20] = { '\0' };
    8030:	e3a06000 	mov	r6, #0
        char *seed_index_string = g_func_rtmpGetProc("push_seed_index");
        if(seed_index_string == NULL || strlen(seed_index_string) == 0)
        {
            seed_index_string = "0";
        }
        int seed_index = atoi(seed_index_string);
    8034:	e1a05000 	mov	r5, r0
    8038:	e58d0020 	str	r0, [sp, #32]
        SAFE_FREE(seed_index_string);
    803c:	e1a00004 	mov	r0, r4
    8040:	ebfff3ef 	bl	5004 <free@plt>
        int i = 0;
        for(i = SAVE_SEED_NUM; i > 0; i--)
        {
            int seed_index_temp = (seed_index+i) % SAVE_SEED_NUM;
            char url_string[20] = { '\0' };
            sprintf(url_string, "push_url%d", seed_index_temp);
    8044:	e59f32e8 	ldr	r3, [pc, #744]	; 8334 <save_url_seed+0x390>
    8048:	e2855014 	add	r5, r5, #20
    804c:	e08f3003 	add	r3, pc, r3
    8050:	e58d301c 	str	r3, [sp, #28]
    8054:	e28d3058 	add	r3, sp, #88	; 0x58
    8058:	e58d300c 	str	r3, [sp, #12]
    805c:	e28d305c 	add	r3, sp, #92	; 0x5c
    8060:	e58d3010 	str	r3, [sp, #16]
    8064:	e28d3060 	add	r3, sp, #96	; 0x60
    8068:	e58d3014 	str	r3, [sp, #20]
        SAFE_FREE(seed_index_string);
        int i = 0;
        for(i = SAVE_SEED_NUM; i > 0; i--)
        {
            int seed_index_temp = (seed_index+i) % SAVE_SEED_NUM;
            char url_string[20] = { '\0' };
    806c:	e1a04005 	mov	r4, r5
    8070:	e28d3064 	add	r3, sp, #100	; 0x64
    8074:	e58d3018 	str	r3, [sp, #24]
        int seed_index = atoi(seed_index_string);
        SAFE_FREE(seed_index_string);
        int i = 0;
        for(i = SAVE_SEED_NUM; i > 0; i--)
        {
            int seed_index_temp = (seed_index+i) % SAVE_SEED_NUM;
    8078:	e59f22b8 	ldr	r2, [pc, #696]	; 8338 <save_url_seed+0x394>
            char url_string[20] = { '\0' };
            sprintf(url_string, "push_url%d", seed_index_temp);
    807c:	e59d101c 	ldr	r1, [sp, #28]
        int seed_index = atoi(seed_index_string);
        SAFE_FREE(seed_index_string);
        int i = 0;
        for(i = SAVE_SEED_NUM; i > 0; i--)
        {
            int seed_index_temp = (seed_index+i) % SAVE_SEED_NUM;
    8080:	e0c23294 	smull	r3, r2, r4, r2
    8084:	e1a03fc4 	asr	r3, r4, #31
    8088:	e063b1c2 	rsb	fp, r3, r2, asr #3
    808c:	e08b310b 	add	r3, fp, fp, lsl #2
    8090:	e044b103 	sub	fp, r4, r3, lsl #2
            char url_string[20] = { '\0' };
    8094:	e59d300c 	ldr	r3, [sp, #12]
            sprintf(url_string, "push_url%d", seed_index_temp);
    8098:	e1a0200b 	mov	r2, fp
        SAFE_FREE(seed_index_string);
        int i = 0;
        for(i = SAVE_SEED_NUM; i > 0; i--)
        {
            int seed_index_temp = (seed_index+i) % SAVE_SEED_NUM;
            char url_string[20] = { '\0' };
    809c:	e5836000 	str	r6, [r3]
    80a0:	e59d3010 	ldr	r3, [sp, #16]
            sprintf(url_string, "push_url%d", seed_index_temp);
    80a4:	e1a00007 	mov	r0, r7
        SAFE_FREE(seed_index_string);
        int i = 0;
        for(i = SAVE_SEED_NUM; i > 0; i--)
        {
            int seed_index_temp = (seed_index+i) % SAVE_SEED_NUM;
            char url_string[20] = { '\0' };
    80a8:	e5836000 	str	r6, [r3]
    80ac:	e59d3014 	ldr	r3, [sp, #20]
    80b0:	e5886000 	str	r6, [r8]
    80b4:	e5836000 	str	r6, [r3]
    80b8:	e59d3018 	ldr	r3, [sp, #24]
    80bc:	e2444001 	sub	r4, r4, #1
    80c0:	e5836000 	str	r6, [r3]
            sprintf(url_string, "push_url%d", seed_index_temp);
    80c4:	ebfff428 	bl	516c <sprintf@plt>
            char *url_temp = g_func_rtmpGetProc(url_string);
    80c8:	e5992000 	ldr	r2, [r9]
    80cc:	e1a00007 	mov	r0, r7
    80d0:	e12fff32 	blx	r2
        int i = 0;
        for(i = SAVE_SEED_NUM; i > 0; i--)
        {
            int seed_index_temp = (seed_index+i) % SAVE_SEED_NUM;
            char url_string[20] = { '\0' };
            sprintf(url_string, "push_url%d", seed_index_temp);
    80d4:	e1a08007 	mov	r8, r7
            char *url_temp = g_func_rtmpGetProc(url_string);
            if(url_temp != NULL && strcmp(url, url_temp) == 0)
    80d8:	e2505000 	subs	r5, r0, #0
    80dc:	e1a01005 	mov	r1, r5
    80e0:	e1a0000a 	mov	r0, sl
    80e4:	0a000004 	beq	80fc <save_url_seed+0x158>
    80e8:	ebfff428 	bl	5190 <strcmp@plt>
    80ec:	e2501000 	subs	r1, r0, #0
                sprintf(s, "%d", beginning);
                g_func_rtmpSetProc(beginning_string, s);
                SAFE_FREE(url_temp);
                return 1;
            }
            SAFE_FREE(url_temp);
    80f0:	e1a00005 	mov	r0, r5
        {
            int seed_index_temp = (seed_index+i) % SAVE_SEED_NUM;
            char url_string[20] = { '\0' };
            sprintf(url_string, "push_url%d", seed_index_temp);
            char *url_temp = g_func_rtmpGetProc(url_string);
            if(url_temp != NULL && strcmp(url, url_temp) == 0)
    80f4:	0a000060 	beq	827c <save_url_seed+0x2d8>
                sprintf(s, "%d", beginning);
                g_func_rtmpSetProc(beginning_string, s);
                SAFE_FREE(url_temp);
                return 1;
            }
            SAFE_FREE(url_temp);
    80f8:	ebfff3c1 	bl	5004 <free@plt>
            seed_index_string = "0";
        }
        int seed_index = atoi(seed_index_string);
        SAFE_FREE(seed_index_string);
        int i = 0;
        for(i = SAVE_SEED_NUM; i > 0; i--)
    80fc:	e59d3020 	ldr	r3, [sp, #32]
    8100:	e1540003 	cmp	r4, r3
    8104:	1affffdb 	bne	8078 <save_url_seed+0xd4>
                return 1;
            }
            SAFE_FREE(url_temp);
        }
        
        seed_index = (seed_index + 1) % SAVE_SEED_NUM;
    8108:	e59f3228 	ldr	r3, [pc, #552]	; 8338 <save_url_seed+0x394>
    810c:	e2845001 	add	r5, r4, #1
    8110:	e0c32395 	smull	r2, r3, r5, r3
    8114:	e1a06fc5 	asr	r6, r5, #31
    8118:	e06661c3 	rsb	r6, r6, r3, asr #3
    811c:	e0866106 	add	r6, r6, r6, lsl #2
        char url_string[20] = { '\0' };
        char seed_string[20] = { '\0' };
        char beginning_string[20] = { '\0' };
        sprintf(url_string, "push_url%d", seed_index);
    8120:	e59f1214 	ldr	r1, [pc, #532]	; 833c <save_url_seed+0x398>
                return 1;
            }
            SAFE_FREE(url_temp);
        }
        
        seed_index = (seed_index + 1) % SAVE_SEED_NUM;
    8124:	e0456106 	sub	r6, r5, r6, lsl #2
        char url_string[20] = { '\0' };
        char seed_string[20] = { '\0' };
        char beginning_string[20] = { '\0' };
        sprintf(url_string, "push_url%d", seed_index);
    8128:	e28d9040 	add	r9, sp, #64	; 0x40
            }
            SAFE_FREE(url_temp);
        }
        
        seed_index = (seed_index + 1) % SAVE_SEED_NUM;
        char url_string[20] = { '\0' };
    812c:	e3a04000 	mov	r4, #0
        char seed_string[20] = { '\0' };
        char beginning_string[20] = { '\0' };
        sprintf(url_string, "push_url%d", seed_index);
    8130:	e1a02006 	mov	r2, r6
    8134:	e1a00009 	mov	r0, r9
    8138:	e08f1001 	add	r1, pc, r1
            }
            SAFE_FREE(url_temp);
        }
        
        seed_index = (seed_index + 1) % SAVE_SEED_NUM;
        char url_string[20] = { '\0' };
    813c:	e58d4040 	str	r4, [sp, #64]	; 0x40
    8140:	e58d4044 	str	r4, [sp, #68]	; 0x44
    8144:	e58d4048 	str	r4, [sp, #72]	; 0x48
    8148:	e58d404c 	str	r4, [sp, #76]	; 0x4c
    814c:	e58d4050 	str	r4, [sp, #80]	; 0x50
        char seed_string[20] = { '\0' };
    8150:	e58d4054 	str	r4, [sp, #84]	; 0x54
    8154:	e58d4058 	str	r4, [sp, #88]	; 0x58
    8158:	e58d405c 	str	r4, [sp, #92]	; 0x5c
    815c:	e58d4060 	str	r4, [sp, #96]	; 0x60
    8160:	e58d4064 	str	r4, [sp, #100]	; 0x64
        char beginning_string[20] = { '\0' };
    8164:	e58d4068 	str	r4, [sp, #104]	; 0x68
    8168:	e58d406c 	str	r4, [sp, #108]	; 0x6c
    816c:	e58d4070 	str	r4, [sp, #112]	; 0x70
    8170:	e58d4074 	str	r4, [sp, #116]	; 0x74
    8174:	e58d4078 	str	r4, [sp, #120]	; 0x78
        sprintf(url_string, "push_url%d", seed_index);
    8178:	ebfff3fb 	bl	516c <sprintf@plt>
        sprintf(seed_string, "push_seed%d", seed_index);
    817c:	e59f11bc 	ldr	r1, [pc, #444]	; 8340 <save_url_seed+0x39c>
    8180:	e1a00007 	mov	r0, r7
    8184:	e1a02006 	mov	r2, r6
    8188:	e08f1001 	add	r1, pc, r1
    818c:	ebfff3f6 	bl	516c <sprintf@plt>
        sprintf(beginning_string, "push_beginning%d", seed_index);
    8190:	e59f11ac 	ldr	r1, [pc, #428]	; 8344 <save_url_seed+0x3a0>
    8194:	e28d8068 	add	r8, sp, #104	; 0x68
    8198:	e1a02006 	mov	r2, r6
    819c:	e08f1001 	add	r1, pc, r1
    81a0:	e1a00008 	mov	r0, r8
    81a4:	ebfff3f0 	bl	516c <sprintf@plt>
        g_func_rtmpSetProc(url_string, url);
    81a8:	e1a00009 	mov	r0, r9
    81ac:	e59d902c 	ldr	r9, [sp, #44]	; 0x2c
    81b0:	e1a0100a 	mov	r1, sl
    81b4:	e5993000 	ldr	r3, [r9]
    81b8:	e12fff33 	blx	r3
        g_func_rtmpSetProc(seed_string, seed);
        char s[20] = { '\0' };
        sprintf(s, "%d", beginning);
    81bc:	e59f5184 	ldr	r5, [pc, #388]	; 8348 <save_url_seed+0x3a4>
        char beginning_string[20] = { '\0' };
        sprintf(url_string, "push_url%d", seed_index);
        sprintf(seed_string, "push_seed%d", seed_index);
        sprintf(beginning_string, "push_beginning%d", seed_index);
        g_func_rtmpSetProc(url_string, url);
        g_func_rtmpSetProc(seed_string, seed);
    81c0:	e1a00007 	mov	r0, r7
    81c4:	e5993000 	ldr	r3, [r9]
    81c8:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
    81cc:	e12fff33 	blx	r3
        char s[20] = { '\0' };
        sprintf(s, "%d", beginning);
    81d0:	e59db028 	ldr	fp, [sp, #40]	; 0x28
    81d4:	e08f5005 	add	r5, pc, r5
    81d8:	e28d707c 	add	r7, sp, #124	; 0x7c
    81dc:	e1a01005 	mov	r1, r5
    81e0:	e1a0200b 	mov	r2, fp
    81e4:	e1a00007 	mov	r0, r7
        sprintf(url_string, "push_url%d", seed_index);
        sprintf(seed_string, "push_seed%d", seed_index);
        sprintf(beginning_string, "push_beginning%d", seed_index);
        g_func_rtmpSetProc(url_string, url);
        g_func_rtmpSetProc(seed_string, seed);
        char s[20] = { '\0' };
    81e8:	e58d407c 	str	r4, [sp, #124]	; 0x7c
    81ec:	e58d4080 	str	r4, [sp, #128]	; 0x80
    81f0:	e58d4084 	str	r4, [sp, #132]	; 0x84
    81f4:	e58d4088 	str	r4, [sp, #136]	; 0x88
    81f8:	e58d408c 	str	r4, [sp, #140]	; 0x8c
        sprintf(s, "%d", beginning);
    81fc:	ebfff3da 	bl	516c <sprintf@plt>
        g_func_rtmpSetProc(beginning_string, s);
    8200:	e5993000 	ldr	r3, [r9]
    8204:	e1a00008 	mov	r0, r8
    8208:	e1a01007 	mov	r1, r7
    820c:	e12fff33 	blx	r3
        char seed_index_save[10] = { '\0' };
        sprintf(seed_index_save, "%d", seed_index);
    8210:	e1a01005 	mov	r1, r5
    8214:	e28d5034 	add	r5, sp, #52	; 0x34
    8218:	e1a02006 	mov	r2, r6
    821c:	e1a00005 	mov	r0, r5
        g_func_rtmpSetProc(url_string, url);
        g_func_rtmpSetProc(seed_string, seed);
        char s[20] = { '\0' };
        sprintf(s, "%d", beginning);
        g_func_rtmpSetProc(beginning_string, s);
        char seed_index_save[10] = { '\0' };
    8220:	e58d4034 	str	r4, [sp, #52]	; 0x34
    8224:	e58d4038 	str	r4, [sp, #56]	; 0x38
    8228:	e1cd43bc 	strh	r4, [sp, #60]	; 0x3c
        sprintf(seed_index_save, "%d", seed_index);
    822c:	ebfff3ce 	bl	516c <sprintf@plt>
        g_func_rtmpSetProc("push_seed_index", seed_index_save);
    8230:	e59f0114 	ldr	r0, [pc, #276]	; 834c <save_url_seed+0x3a8>
    8234:	e1a01005 	mov	r1, r5
    8238:	e5993000 	ldr	r3, [r9]
    823c:	e08f0000 	add	r0, pc, r0
    8240:	e12fff33 	blx	r3
        RTMP_Log(RTMP_LOGINFO, "save_url_seed url=%s, seed=%s, beginning=%d, seed_index=%d", url, seed, beginning, seed_index);
    8244:	e59f1104 	ldr	r1, [pc, #260]	; 8350 <save_url_seed+0x3ac>
    8248:	e58d6004 	str	r6, [sp, #4]
    824c:	e58db000 	str	fp, [sp]
    8250:	e1a0200a 	mov	r2, sl
    8254:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    8258:	e3a00003 	mov	r0, #3
    825c:	e08f1001 	add	r1, pc, r1
    8260:	eb0035d1 	bl	159ac <RTMP_Log>
    8264:	e3a00001 	mov	r0, #1
        return 1;
    }
#endif

    return 0;
}
    8268:	e28dd094 	add	sp, sp, #148	; 0x94
    826c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (g_func_rtmpSetProc != NULL && g_func_rtmpGetProc != NULL)
    {
        char *seed_index_string = g_func_rtmpGetProc("push_seed_index");
        if(seed_index_string == NULL || strlen(seed_index_string) == 0)
        {
            seed_index_string = "0";
    8270:	e59f40dc 	ldr	r4, [pc, #220]	; 8354 <save_url_seed+0x3b0>
    8274:	e08f4004 	add	r4, pc, r4
    8278:	eaffff68 	b	8020 <save_url_seed+0x7c>
    827c:	e58d100c 	str	r1, [sp, #12]
            char url_string[20] = { '\0' };
            sprintf(url_string, "push_url%d", seed_index_temp);
            char *url_temp = g_func_rtmpGetProc(url_string);
            if(url_temp != NULL && strcmp(url, url_temp) == 0)
            {
                RTMP_Log(RTMP_LOGINFO, "save_url_seed seed exist");
    8280:	e59f10d0 	ldr	r1, [pc, #208]	; 8358 <save_url_seed+0x3b4>
    8284:	e3a00003 	mov	r0, #3
    8288:	e08f1001 	add	r1, pc, r1
    828c:	eb0035c6 	bl	159ac <RTMP_Log>
                char beginning_string[20] = { '\0' };
                sprintf(beginning_string, "push_beginning%d", seed_index_temp);
    8290:	e59f10c4 	ldr	r1, [pc, #196]	; 835c <save_url_seed+0x3b8>
    8294:	e1a0400b 	mov	r4, fp
    8298:	e1a0b005 	mov	fp, r5
    829c:	e28d5068 	add	r5, sp, #104	; 0x68
            sprintf(url_string, "push_url%d", seed_index_temp);
            char *url_temp = g_func_rtmpGetProc(url_string);
            if(url_temp != NULL && strcmp(url, url_temp) == 0)
            {
                RTMP_Log(RTMP_LOGINFO, "save_url_seed seed exist");
                char beginning_string[20] = { '\0' };
    82a0:	e59dc00c 	ldr	ip, [sp, #12]
                sprintf(beginning_string, "push_beginning%d", seed_index_temp);
    82a4:	e1a02004 	mov	r2, r4
    82a8:	e1a00005 	mov	r0, r5
    82ac:	e08f1001 	add	r1, pc, r1
            sprintf(url_string, "push_url%d", seed_index_temp);
            char *url_temp = g_func_rtmpGetProc(url_string);
            if(url_temp != NULL && strcmp(url, url_temp) == 0)
            {
                RTMP_Log(RTMP_LOGINFO, "save_url_seed seed exist");
                char beginning_string[20] = { '\0' };
    82b0:	e58dc068 	str	ip, [sp, #104]	; 0x68
    82b4:	e58dc06c 	str	ip, [sp, #108]	; 0x6c
    82b8:	e58dc070 	str	ip, [sp, #112]	; 0x70
    82bc:	e58dc074 	str	ip, [sp, #116]	; 0x74
    82c0:	e58dc078 	str	ip, [sp, #120]	; 0x78
                sprintf(beginning_string, "push_beginning%d", seed_index_temp);
    82c4:	ebfff3a8 	bl	516c <sprintf@plt>
                char s[20] = { '\0' };
                sprintf(s, "%d", beginning);
    82c8:	e59f1090 	ldr	r1, [pc, #144]	; 8360 <save_url_seed+0x3bc>
    82cc:	e28d407c 	add	r4, sp, #124	; 0x7c
            if(url_temp != NULL && strcmp(url, url_temp) == 0)
            {
                RTMP_Log(RTMP_LOGINFO, "save_url_seed seed exist");
                char beginning_string[20] = { '\0' };
                sprintf(beginning_string, "push_beginning%d", seed_index_temp);
                char s[20] = { '\0' };
    82d0:	e59dc00c 	ldr	ip, [sp, #12]
                sprintf(s, "%d", beginning);
    82d4:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
    82d8:	e1a00004 	mov	r0, r4
    82dc:	e08f1001 	add	r1, pc, r1
            if(url_temp != NULL && strcmp(url, url_temp) == 0)
            {
                RTMP_Log(RTMP_LOGINFO, "save_url_seed seed exist");
                char beginning_string[20] = { '\0' };
                sprintf(beginning_string, "push_beginning%d", seed_index_temp);
                char s[20] = { '\0' };
    82e0:	e58dc07c 	str	ip, [sp, #124]	; 0x7c
    82e4:	e58dc080 	str	ip, [sp, #128]	; 0x80
    82e8:	e58dc084 	str	ip, [sp, #132]	; 0x84
    82ec:	e58dc088 	str	ip, [sp, #136]	; 0x88
    82f0:	e58dc08c 	str	ip, [sp, #140]	; 0x8c
                sprintf(s, "%d", beginning);
    82f4:	ebfff39c 	bl	516c <sprintf@plt>
                g_func_rtmpSetProc(beginning_string, s);
    82f8:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
    82fc:	e1a00005 	mov	r0, r5
    8300:	e1a01004 	mov	r1, r4
    8304:	e5932000 	ldr	r2, [r3]
    8308:	e12fff32 	blx	r2
                SAFE_FREE(url_temp);
    830c:	e1a0000b 	mov	r0, fp
    8310:	ebfff33b 	bl	5004 <free@plt>
    8314:	eaffffd2 	b	8264 <save_url_seed+0x2c0>
    if (g_func_rtmpSetProc != NULL && g_func_rtmpGetProc != NULL)
    {
        char *seed_index_string = g_func_rtmpGetProc("push_seed_index");
        if(seed_index_string == NULL || strlen(seed_index_string) == 0)
        {
            seed_index_string = "0";
    8318:	e59f4044 	ldr	r4, [pc, #68]	; 8364 <save_url_seed+0x3c0>
    831c:	e08f4004 	add	r4, pc, r4
    8320:	eaffff3e 	b	8020 <save_url_seed+0x7c>
    8324:	0001bda0 	.word	0x0001bda0
    8328:	00016680 	.word	0x00016680
    832c:	0001bd84 	.word	0x0001bd84
    8330:	00016574 	.word	0x00016574
    8334:	00016580 	.word	0x00016580
    8338:	66666667 	.word	0x66666667
    833c:	00016494 	.word	0x00016494
    8340:	00016450 	.word	0x00016450
    8344:	00016448 	.word	0x00016448
    8348:	000164a8 	.word	0x000164a8
    834c:	0001633c 	.word	0x0001633c
    8350:	00016424 	.word	0x00016424
    8354:	000163d0 	.word	0x000163d0
    8358:	000163d8 	.word	0x000163d8
    835c:	00016338 	.word	0x00016338
    8360:	000163a0 	.word	0x000163a0
    8364:	00016328 	.word	0x00016328

00008368 <encrypt_rsa>:
             rsa_context rsa,
             const unsigned char* plaintext,
             unsigned int plaintext_size,
             unsigned char *ciphertext,
             unsigned int ciphertext_size)
{
    8368:	e24dd010 	sub	sp, sp, #16
    836c:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
    8370:	e24ddb25 	sub	sp, sp, #37888	; 0x9400
    8374:	e24dd080 	sub	sp, sp, #128	; 0x80
    8378:	e28d4b25 	add	r4, sp, #37888	; 0x9400
    837c:	e28440a0 	add	r4, r4, #160	; 0xa0
    8380:	e884000f 	stm	r4, {r0, r1, r2, r3}
    8384:	e28d3c95 	add	r3, sp, #38144	; 0x9500
    8388:	e2833034 	add	r3, r3, #52	; 0x34
    838c:	e5939000 	ldr	r9, [r3]
    8390:	e28d3c95 	add	r3, sp, #38144	; 0x9500
    8394:	e2833038 	add	r3, r3, #56	; 0x38
    8398:	e593a000 	ldr	sl, [r3]
    
    entropy_context        entropy;
    ctr_drbg_context    ctr_drbg;
    
    entropy_init(&entropy);
    839c:	e28d7e15 	add	r7, sp, #336	; 0x150
             rsa_context rsa,
             const unsigned char* plaintext,
             unsigned int plaintext_size,
             unsigned char *ciphertext,
             unsigned int ciphertext_size)
{
    83a0:	e28d3c95 	add	r3, sp, #38144	; 0x9500
    
    entropy_context        entropy;
    ctr_drbg_context    ctr_drbg;
    
    entropy_init(&entropy);
    83a4:	e1a00007 	mov	r0, r7
             rsa_context rsa,
             const unsigned char* plaintext,
             unsigned int plaintext_size,
             unsigned char *ciphertext,
             unsigned int ciphertext_size)
{
    83a8:	e283303c 	add	r3, r3, #60	; 0x3c
    83ac:	e5938000 	ldr	r8, [r3]
    
    entropy_context        entropy;
    ctr_drbg_context    ctr_drbg;
    
    entropy_init(&entropy);
    83b0:	ebfff394 	bl	5208 <entropy_init@plt>
    ctr_drbg_init(&ctr_drbg, entropy_func, &entropy, NULL, 0);
    83b4:	e59f1084 	ldr	r1, [pc, #132]	; 8440 <encrypt_rsa+0xd8>
    83b8:	e3a06000 	mov	r6, #0
    83bc:	e28d5010 	add	r5, sp, #16
    83c0:	e1a03006 	mov	r3, r6
    83c4:	e1a02007 	mov	r2, r7
    83c8:	e79f1001 	ldr	r1, [pc, r1]
    83cc:	e1a00005 	mov	r0, r5
    83d0:	e58d6000 	str	r6, [sp]
    83d4:	ebfff38e 	bl	5214 <ctr_drbg_init@plt>
    
    rsa_init(&rsa, RSA_PKCS_V15, 0);
    83d8:	e1a01006 	mov	r1, r6
    83dc:	e1a02006 	mov	r2, r6
    83e0:	e1a00004 	mov	r0, r4
    83e4:	ebfff38d 	bl	5220 <rsa_init@plt>
    
    rsa.len = (mpi_msb_polarssl(&rsa.N) + 7) >> 3;
    83e8:	e28d0b25 	add	r0, sp, #37888	; 0x9400
    83ec:	e28000a8 	add	r0, r0, #168	; 0xa8
    83f0:	ebfff38d 	bl	522c <mpi_msb_polarssl@plt>
    83f4:	e28deb25 	add	lr, sp, #37888	; 0x9400
    83f8:	e59f1044 	ldr	r1, [pc, #68]	; 8444 <encrypt_rsa+0xdc>
    83fc:	e28ee0a4 	add	lr, lr, #164	; 0xa4
    
    rsa_pkcs1_encrypt(&rsa, ctr_drbg_random, &ctr_drbg, RSA_PUBLIC, plaintext_size, plaintext, ciphertext) ;
    8400:	e58da000 	str	sl, [sp]
    8404:	e58d9004 	str	r9, [sp, #4]
    8408:	e58d8008 	str	r8, [sp, #8]
    840c:	e79f1001 	ldr	r1, [pc, r1]
    8410:	e1a02005 	mov	r2, r5
    8414:	e1a03006 	mov	r3, r6
    entropy_init(&entropy);
    ctr_drbg_init(&ctr_drbg, entropy_func, &entropy, NULL, 0);
    
    rsa_init(&rsa, RSA_PKCS_V15, 0);
    
    rsa.len = (mpi_msb_polarssl(&rsa.N) + 7) >> 3;
    8418:	e2800007 	add	r0, r0, #7
    841c:	e1a0c1a0 	lsr	ip, r0, #3
    8420:	e58ec000 	str	ip, [lr]
    
    rsa_pkcs1_encrypt(&rsa, ctr_drbg_random, &ctr_drbg, RSA_PUBLIC, plaintext_size, plaintext, ciphertext) ;
    8424:	e1a00004 	mov	r0, r4
    8428:	ebfff382 	bl	5238 <rsa_pkcs1_encrypt@plt>
}
    842c:	e28ddb25 	add	sp, sp, #37888	; 0x9400
    8430:	e28dd080 	add	sp, sp, #128	; 0x80
    8434:	e8bd47f0 	pop	{r4, r5, r6, r7, r8, r9, sl, lr}
    8438:	e28dd010 	add	sp, sp, #16
    843c:	e12fff1e 	bx	lr
    8440:	0001b9b0 	.word	0x0001b9b0
    8444:	0001b970 	.word	0x0001b970

00008448 <RTMP_Access_GETKey>:

    return TRUE;
}

int RTMP_Access_GETKey(RTMPAccess *pAccess,char *key)
{
    8448:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    844c:	e24ddf82 	sub	sp, sp, #520	; 0x208
    char seed[500]={'\0'};
    8450:	e28d5014 	add	r5, sp, #20

    return TRUE;
}

int RTMP_Access_GETKey(RTMPAccess *pAccess,char *key)
{
    8454:	e1a04000 	mov	r4, r0
    8458:	e1a08001 	mov	r8, r1
    char seed[500]={'\0'};
    845c:	e1a00005 	mov	r0, r5
    8460:	e3a01000 	mov	r1, #0
    8464:	e3a02f7d 	mov	r2, #500	; 0x1f4
    8468:	ebfff318 	bl	50d0 <memset@plt>
    unsigned char temp_key[17]={'\0'};
    846c:	e3a03000 	mov	r3, #0
    
    if(!pAccess)
    8470:	e3540000 	cmp	r4, #0
}

int RTMP_Access_GETKey(RTMPAccess *pAccess,char *key)
{
    char seed[500]={'\0'};
    unsigned char temp_key[17]={'\0'};
    8474:	e58d3000 	str	r3, [sp]
    8478:	e58d3004 	str	r3, [sp, #4]
    847c:	e58d3008 	str	r3, [sp, #8]
    8480:	e58d300c 	str	r3, [sp, #12]
    8484:	e5cd3010 	strb	r3, [sp, #16]
    
    if(!pAccess)
    8488:	0a00001c 	beq	8500 <RTMP_Access_GETKey+0xb8>
    {
        printf("access is null,return \n");
        return FALSE;
    }
    sprintf(seed,"%s_%d",pAccess->seed,pAccess->beginning);
    848c:	e59f1084 	ldr	r1, [pc, #132]	; 8518 <RTMP_Access_GETKey+0xd0>
    8490:	e2842f7d 	add	r2, r4, #500	; 0x1f4
    8494:	e5943218 	ldr	r3, [r4, #536]	; 0x218
    8498:	e08f1001 	add	r1, pc, r1
    849c:	e1a00005 	mov	r0, r5
    84a0:	ebfff331 	bl	516c <sprintf@plt>
   
    md5(seed,strlen(seed),temp_key);
    84a4:	e1a00005 	mov	r0, r5
    84a8:	ebfff314 	bl	5100 <strlen@plt>
    84ac:	e1a0200d 	mov	r2, sp
    unsigned char *ptr_tmp=temp_key;
    int len=16;
 
    for(len=16;len>0;len--)
    {
        sprintf(ptr,"%02x",*ptr_tmp);
    84b0:	e59f7064 	ldr	r7, [pc, #100]	; 851c <RTMP_Access_GETKey+0xd4>
    84b4:	e2886020 	add	r6, r8, #32
    84b8:	e08f7007 	add	r7, pc, r7
   
    md5(seed,strlen(seed),temp_key);
    
    
    
    char *ptr=key;
    84bc:	e1a04008 	mov	r4, r8
        printf("access is null,return \n");
        return FALSE;
    }
    sprintf(seed,"%s_%d",pAccess->seed,pAccess->beginning);
   
    md5(seed,strlen(seed),temp_key);
    84c0:	e1a01000 	mov	r1, r0
    84c4:	e1a00005 	mov	r0, r5
    84c8:	ebfff35d 	bl	5244 <md5@plt>
    84cc:	e1a0500d 	mov	r5, sp
    unsigned char *ptr_tmp=temp_key;
    int len=16;
 
    for(len=16;len>0;len--)
    {
        sprintf(ptr,"%02x",*ptr_tmp);
    84d0:	e1a00004 	mov	r0, r4
    84d4:	e1a01007 	mov	r1, r7
        ptr+=2;
    84d8:	e2844002 	add	r4, r4, #2
    unsigned char *ptr_tmp=temp_key;
    int len=16;
 
    for(len=16;len>0;len--)
    {
        sprintf(ptr,"%02x",*ptr_tmp);
    84dc:	e4d52001 	ldrb	r2, [r5], #1
    84e0:	ebfff321 	bl	516c <sprintf@plt>
    
    char *ptr=key;
    unsigned char *ptr_tmp=temp_key;
    int len=16;
 
    for(len=16;len>0;len--)
    84e4:	e1540006 	cmp	r4, r6
    84e8:	1afffff8 	bne	84d0 <RTMP_Access_GETKey+0x88>
    {
        sprintf(ptr,"%02x",*ptr_tmp);
        ptr+=2;
        ptr_tmp++;
    }
    *ptr='\0';
    84ec:	e3a03000 	mov	r3, #0
    
    
    return TRUE;
    84f0:	e3a00001 	mov	r0, #1
    {
        sprintf(ptr,"%02x",*ptr_tmp);
        ptr+=2;
        ptr_tmp++;
    }
    *ptr='\0';
    84f4:	e5c83020 	strb	r3, [r8, #32]
    
    
    return TRUE;
}
    84f8:	e28ddf82 	add	sp, sp, #520	; 0x208
    84fc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    char seed[500]={'\0'};
    unsigned char temp_key[17]={'\0'};
    
    if(!pAccess)
    {
        printf("access is null,return \n");
    8500:	e59f0018 	ldr	r0, [pc, #24]	; 8520 <RTMP_Access_GETKey+0xd8>
    8504:	e08f0000 	add	r0, pc, r0
    8508:	ebfff350 	bl	5250 <puts@plt>
        return FALSE;
    850c:	e1a00004 	mov	r0, r4
    }
    *ptr='\0';
    
    
    return TRUE;
}
    8510:	e28ddf82 	add	sp, sp, #520	; 0x208
    8514:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    8518:	0001623c 	.word	0x0001623c
    851c:	00015ccc 	.word	0x00015ccc
    8520:	000161b8 	.word	0x000161b8

00008524 <ff_check_interrupt_rtmp>:

int ff_check_interrupt_rtmp(RTMP_AVIOInterruptCB *cb)
{
    int ret;
    if (cb && cb->callback && (ret = cb->callback(cb->opaque)))
    8524:	e3500000 	cmp	r0, #0
    8528:	0a000004 	beq	8540 <ff_check_interrupt_rtmp+0x1c>
    852c:	e5903000 	ldr	r3, [r0]
    8530:	e3530000 	cmp	r3, #0
    8534:	0a000001 	beq	8540 <ff_check_interrupt_rtmp+0x1c>
    8538:	e5900004 	ldr	r0, [r0, #4]
    853c:	e12fff13 	bx	r3
        return ret;
    return 0;
}
    8540:	e3a00000 	mov	r0, #0
    8544:	e12fff1e 	bx	lr

00008548 <isInterrupted>:
int isInterrupted(void * args)
{
    BufferConfig *pConfig = (BufferConfig *)args;
    if(!pConfig)
    8548:	e3500000 	cmp	r0, #0
    854c:	012fff1e 	bxeq	lr
    if (cb && cb->callback && (ret = cb->callback(cb->opaque)))
        return ret;
    return 0;
}
int isInterrupted(void * args)
{
    8550:	e92d4038 	push	{r3, r4, r5, lr}
    BufferConfig *pConfig = (BufferConfig *)args;
    if(!pConfig)
        return 0;
    int status = init_status;
    
    pthread_mutex_lock(&pConfig->lock);
    8554:	e2805024 	add	r5, r0, #36	; 0x24
    8558:	e1a04000 	mov	r4, r0
    855c:	e1a00005 	mov	r0, r5
    8560:	ebfff33d 	bl	525c <pthread_mutex_lock@plt>
    status = pConfig->state;
    8564:	e594400c 	ldr	r4, [r4, #12]
    pthread_mutex_unlock(&pConfig->lock);
    8568:	e1a00005 	mov	r0, r5
    856c:	ebfff33d 	bl	5268 <pthread_mutex_unlock@plt>
    if(status == stop_send || status == disconnect_status || status== connect_fail)
    8570:	e2440003 	sub	r0, r4, #3
}
int isInterrupted(void * args)
{
    BufferConfig *pConfig = (BufferConfig *)args;
    if(!pConfig)
        return 0;
    8574:	e3740001 	cmn	r4, #1
    8578:	13500001 	cmpne	r0, #1
    857c:	93a00001 	movls	r0, #1
    8580:	83a00000 	movhi	r0, #0
    status = pConfig->state;
    pthread_mutex_unlock(&pConfig->lock);
    if(status == stop_send || status == disconnect_status || status== connect_fail)
        return 1;
    return 0;
}
    8584:	e8bd8038 	pop	{r3, r4, r5, pc}

00008588 <RTMP_GetTime>:

//portal end

uint32_t
RTMP_GetTime()
{
    8588:	e92d4010 	push	{r4, lr}
    return 0;
#elif defined(_WIN32)
    return timeGetTime();
#else
    struct tms t;
    if (!clk_tck) clk_tck = sysconf(_SC_CLK_TCK);
    858c:	e59f4044 	ldr	r4, [pc, #68]	; 85d8 <RTMP_GetTime+0x50>

//portal end

uint32_t
RTMP_GetTime()
{
    8590:	e24dd010 	sub	sp, sp, #16
    return 0;
#elif defined(_WIN32)
    return timeGetTime();
#else
    struct tms t;
    if (!clk_tck) clk_tck = sysconf(_SC_CLK_TCK);
    8594:	e08f4004 	add	r4, pc, r4
    8598:	e5943000 	ldr	r3, [r4]
    859c:	e3530000 	cmp	r3, #0
    85a0:	1a000002 	bne	85b0 <RTMP_GetTime+0x28>
    85a4:	e3a00006 	mov	r0, #6
    85a8:	ebfff331 	bl	5274 <sysconf@plt>
    85ac:	e5840000 	str	r0, [r4]
    return times(&t) * 1000 / clk_tck;
    85b0:	e1a0000d 	mov	r0, sp
    85b4:	ebfff331 	bl	5280 <times@plt>
    85b8:	e59f301c 	ldr	r3, [pc, #28]	; 85dc <RTMP_GetTime+0x54>
    85bc:	e3a02ffa 	mov	r2, #1000	; 0x3e8
    85c0:	e08f3003 	add	r3, pc, r3
    85c4:	e5931000 	ldr	r1, [r3]
    85c8:	e0000092 	mul	r0, r2, r0
    85cc:	eb004d08 	bl	1b9f4 <__aeabi_idiv>
#endif
}
    85d0:	e28dd010 	add	sp, sp, #16
    85d4:	e8bd8010 	pop	{r4, pc}
    85d8:	0001ba80 	.word	0x0001ba80
    85dc:	0001ba54 	.word	0x0001ba54

000085e0 <RTMP_GetTime_m>:

uint32_t
RTMP_GetTime_m(struct timeval t_start)
{
    85e0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    85e4:	e24dd014 	sub	sp, sp, #20
    85e8:	e88d0003 	stm	sp, {r0, r1}
    struct timeval t_end;
    gettimeofday(&t_end, NULL);
    85ec:	e28d0008 	add	r0, sp, #8
    85f0:	e3a01000 	mov	r1, #0
    85f4:	ebfff324 	bl	528c <gettimeofday@plt>
    
    uint32_t duration=0;
    duration=(t_end.tv_sec-t_start.tv_sec)*1000+(t_end.tv_usec-t_start.tv_usec)/1000;
    85f8:	e59d2004 	ldr	r2, [sp, #4]
    85fc:	e59d300c 	ldr	r3, [sp, #12]
    8600:	e59f1028 	ldr	r1, [pc, #40]	; 8630 <RTMP_GetTime_m+0x50>
    8604:	e0623003 	rsb	r3, r2, r3
    8608:	e0c12193 	smull	r2, r1, r3, r1
    860c:	e59d0000 	ldr	r0, [sp]
    8610:	e59d2008 	ldr	r2, [sp, #8]
    8614:	e1a03fc3 	asr	r3, r3, #31
    8618:	e0602002 	rsb	r2, r0, r2
    861c:	e0633341 	rsb	r3, r3, r1, asr #6
    8620:	e3a00ffa 	mov	r0, #1000	; 0x3e8
    return duration;
    
}
    8624:	e0203092 	mla	r0, r2, r0, r3
    8628:	e28dd014 	add	sp, sp, #20
    862c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    8630:	10624dd3 	.word	0x10624dd3

00008634 <RTMP_GetTime_mill>:

uint64_t
RTMP_GetTime_mill()
{
    8634:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    8638:	e24dd00c 	sub	sp, sp, #12
    struct timeval t_end;
    gettimeofday(&t_end, NULL);
    863c:	e1a0000d 	mov	r0, sp
    8640:	e3a01000 	mov	r1, #0
    8644:	ebfff310 	bl	528c <gettimeofday@plt>
    
    uint64_t duration=0;
    duration=(uint64_t)((t_end.tv_sec)*(uint64_t)1000+(t_end.tv_usec)/(uint64_t)1000);
    8648:	e59d0004 	ldr	r0, [sp, #4]
    864c:	e3a02ffa 	mov	r2, #1000	; 0x3e8
    8650:	e3a03000 	mov	r3, #0
    8654:	e1a01fc0 	asr	r1, r0, #31
    8658:	ebfff30e 	bl	5298 <__aeabi_uldivmod@plt>
    865c:	e59d2000 	ldr	r2, [sp]
    8660:	e3a03ffa 	mov	r3, #1000	; 0x3e8
    
    return duration;
    
}
    8664:	e0e10293 	smlal	r0, r1, r3, r2
    8668:	e28dd00c 	add	sp, sp, #12
    866c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00008670 <RTMP_GetTime_print>:

uint32_t
RTMP_GetTime_print()
{
    8670:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    8674:	e24dd00c 	sub	sp, sp, #12
    struct timeval t_end;
    gettimeofday(&t_end, NULL);
    8678:	e1a0000d 	mov	r0, sp
    867c:	e3a01000 	mov	r1, #0
    8680:	ebfff301 	bl	528c <gettimeofday@plt>
    
    RTMP_Log(RTMP_LOGINFO,"*** time : %d  %ld \n",t_end.tv_sec,t_end.tv_usec);
    8684:	e59f1018 	ldr	r1, [pc, #24]	; 86a4 <RTMP_GetTime_print+0x34>
    8688:	e3a00003 	mov	r0, #3
    868c:	e08f1001 	add	r1, pc, r1
    8690:	e89d000c 	ldm	sp, {r2, r3}
    8694:	eb0034c4 	bl	159ac <RTMP_Log>
    
    return 0;
    
}
    8698:	e3a00000 	mov	r0, #0
    869c:	e28dd00c 	add	sp, sp, #12
    86a0:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    86a4:	00016050 	.word	0x00016050

000086a8 <RTMP_InitMetadata>:
void RTMP_InitMetadata(RTMPMetadata *lpMetaData,int hasaudio,int hasvideo,int audio_channel,int audio_sample,int audio_samplesize,
                       int video_framerate,int video_width,int video_height,int video_bitrate,int audio_bitrate)
{
    86a8:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    86ac:	e59d7014 	ldr	r7, [sp, #20]
    86b0:	e59d6018 	ldr	r6, [sp, #24]
    86b4:	e59d501c 	ldr	r5, [sp, #28]
    86b8:	e59d4024 	ldr	r4, [sp, #36]	; 0x24
    86bc:	e59de020 	ldr	lr, [sp, #32]
    lpMetaData->nAudioSampleRate=audio_sample;
    lpMetaData->nAudioSampleSize=audio_samplesize;
    lpMetaData->nFrameRate=video_framerate;
    lpMetaData->nHeight=video_height;
    lpMetaData->nWidth=video_width;
    lpMetaData->nVideoDataRate=300;
    86c0:	e3a0cf4b 	mov	ip, #300	; 0x12c
    
}
void RTMP_InitMetadata(RTMPMetadata *lpMetaData,int hasaudio,int hasvideo,int audio_channel,int audio_sample,int audio_samplesize,
                       int video_framerate,int video_width,int video_height,int video_bitrate,int audio_bitrate)
{
    lpMetaData->bHasAudio=hasaudio;
    86c4:	e5c01014 	strb	r1, [r0, #20]
    lpMetaData->bHasVideo=hasvideo;
    86c8:	e5c02000 	strb	r2, [r0]
    lpMetaData->nAudioChannels=audio_channel;
    86cc:	e5803020 	str	r3, [r0, #32]
    lpMetaData->nAudioSampleRate=audio_sample;
    86d0:	e5807018 	str	r7, [r0, #24]
    lpMetaData->nAudioSampleSize=audio_samplesize;
    86d4:	e580601c 	str	r6, [r0, #28]
    lpMetaData->nFrameRate=video_framerate;
    86d8:	e580500c 	str	r5, [r0, #12]
    lpMetaData->nHeight=video_height;
    86dc:	e5804008 	str	r4, [r0, #8]
    lpMetaData->nWidth=video_width;
    86e0:	e580e004 	str	lr, [r0, #4]
    lpMetaData->nVideoDataRate=300;
    86e4:	e580c010 	str	ip, [r0, #16]
    86e8:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

000086ec <RTMP_SetUDT>:
    
    
}

void RTMP_SetUDT(RTMP *r,int iUdt)
{
    86ec:	e12fff1e 	bx	lr

000086f0 <RTMP_UserInterrupt>:
}


void
RTMP_UserInterrupt()
{
    86f0:	e59f300c 	ldr	r3, [pc, #12]	; 8704 <RTMP_UserInterrupt+0x14>
    RTMP_ctrlC = TRUE;
    86f4:	e3a02001 	mov	r2, #1
    86f8:	e79f3003 	ldr	r3, [pc, r3]
    86fc:	e5832000 	str	r2, [r3]
    8700:	e12fff1e 	bx	lr
    8704:	0001b688 	.word	0x0001b688

00008708 <RTMPPacket_Reset>:
}

void
RTMPPacket_Reset(RTMPPacket *p)
{
    p->m_headerType = 0;
    8708:	e3a03000 	mov	r3, #0
    870c:	e5c03000 	strb	r3, [r0]
    p->m_packetType = 0;
    8710:	e5c03001 	strb	r3, [r0, #1]
    p->m_nChannel = 0;
    8714:	e5803004 	str	r3, [r0, #4]
    p->m_nTimeStamp = 0;
    8718:	e5803008 	str	r3, [r0, #8]
    p->m_nInfoField2 = 0;
    871c:	e580300c 	str	r3, [r0, #12]
    p->m_hasAbsTimestamp = FALSE;
    8720:	e5c03002 	strb	r3, [r0, #2]
    p->m_nBodySize = 0;
    8724:	e5803010 	str	r3, [r0, #16]
    p->m_nBytesRead = 0;
    8728:	e5803014 	str	r3, [r0, #20]
    872c:	e12fff1e 	bx	lr

00008730 <RTMPPacket_Alloc>:
}

int
RTMPPacket_Alloc(RTMPPacket *p, int nSize)
{
    8730:	e92d4010 	push	{r4, lr}
    char *ptr = calloc(1, nSize + RTMP_MAX_HEADER_SIZE);
    8734:	e2811012 	add	r1, r1, #18
    p->m_nBytesRead = 0;
}

int
RTMPPacket_Alloc(RTMPPacket *p, int nSize)
{
    8738:	e1a04000 	mov	r4, r0
    char *ptr = calloc(1, nSize + RTMP_MAX_HEADER_SIZE);
    873c:	e3a00001 	mov	r0, #1
    8740:	ebfff277 	bl	5124 <calloc@plt>
    if (!ptr)
    8744:	e3500000 	cmp	r0, #0
        return FALSE;
    p->m_body = ptr + RTMP_MAX_HEADER_SIZE;
    p->m_nBytesRead = 0;
    8748:	13a03000 	movne	r3, #0
RTMPPacket_Alloc(RTMPPacket *p, int nSize)
{
    char *ptr = calloc(1, nSize + RTMP_MAX_HEADER_SIZE);
    if (!ptr)
        return FALSE;
    p->m_body = ptr + RTMP_MAX_HEADER_SIZE;
    874c:	12800012 	addne	r0, r0, #18
    8750:	1584001c 	strne	r0, [r4, #28]
    p->m_nBytesRead = 0;
    8754:	15843014 	strne	r3, [r4, #20]
    return TRUE;
    8758:	13a00001 	movne	r0, #1
}
    875c:	e8bd8010 	pop	{r4, pc}

00008760 <RTMPPacket_Free>:

void
RTMPPacket_Free(RTMPPacket *p)
{
    if (p->m_body)
    8760:	e590301c 	ldr	r3, [r0, #28]
    8764:	e3530000 	cmp	r3, #0
    8768:	012fff1e 	bxeq	lr
    return TRUE;
}

void
RTMPPacket_Free(RTMPPacket *p)
{
    876c:	e92d4010 	push	{r4, lr}
    8770:	e1a04000 	mov	r4, r0
    if (p->m_body)
    {
        free(p->m_body - RTMP_MAX_HEADER_SIZE);
    8774:	e2430012 	sub	r0, r3, #18
    8778:	ebfff221 	bl	5004 <free@plt>
        p->m_body = NULL;
    877c:	e3a03000 	mov	r3, #0
    8780:	e584301c 	str	r3, [r4, #28]
    8784:	e8bd8010 	pop	{r4, pc}

00008788 <RTMPPacket_Dump>:
RTMPPacket_Dump(RTMPPacket *p)
{
    RTMP_Log(RTMP_LOGDEBUG,
             "RTMP PACKET: packet type: 0x%02x. channel: 0x%02x. info 1: %d info 2: %d. Body size: %u. body: 0x%02x",
             p->m_packetType, p->m_nChannel, p->m_nTimeStamp, p->m_nInfoField2,
             p->m_nBodySize, p->m_body ? (unsigned char)p->m_body[0] : 0);
    8788:	e590101c 	ldr	r1, [r0, #28]
    }
}

void
RTMPPacket_Dump(RTMPPacket *p)
{
    878c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    RTMP_Log(RTMP_LOGDEBUG,
    8790:	e3510000 	cmp	r1, #0
    8794:	15d11000 	ldrbne	r1, [r1]
    }
}

void
RTMPPacket_Dump(RTMPPacket *p)
{
    8798:	e24dd014 	sub	sp, sp, #20
    RTMP_Log(RTMP_LOGDEBUG,
    879c:	e5d02001 	ldrb	r2, [r0, #1]
    87a0:	e9904008 	ldmib	r0, {r3, lr}
    87a4:	e590c00c 	ldr	ip, [r0, #12]
    87a8:	e5900010 	ldr	r0, [r0, #16]
    87ac:	e58d100c 	str	r1, [sp, #12]
    87b0:	e59f101c 	ldr	r1, [pc, #28]	; 87d4 <RTMPPacket_Dump+0x4c>
    87b4:	e58d0008 	str	r0, [sp, #8]
    87b8:	e58de000 	str	lr, [sp]
    87bc:	e58dc004 	str	ip, [sp, #4]
    87c0:	e3a00004 	mov	r0, #4
    87c4:	e08f1001 	add	r1, pc, r1
    87c8:	eb003477 	bl	159ac <RTMP_Log>
             "RTMP PACKET: packet type: 0x%02x. channel: 0x%02x. info 1: %d info 2: %d. Body size: %u. body: 0x%02x",
             p->m_packetType, p->m_nChannel, p->m_nTimeStamp, p->m_nInfoField2,
             p->m_nBodySize, p->m_body ? (unsigned char)p->m_body[0] : 0);
}
    87cc:	e28dd014 	add	sp, sp, #20
    87d0:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    87d4:	00015f30 	.word	0x00015f30

000087d8 <RTMP_LibVersion>:

int
RTMP_LibVersion()
{
    return RTMP_LIB_VERSION;
}
    87d8:	e59f0000 	ldr	r0, [pc]	; 87e0 <RTMP_LibVersion+0x8>
    87dc:	e12fff1e 	bx	lr
    87e0:	00020300 	.word	0x00020300

000087e4 <RTMP_TLS_Init>:

void
RTMP_TLS_Init()
{
    87e4:	e92d4008 	push	{r3, lr}
#ifdef CRYPTO
#ifdef USE_POLARSSL
    /* Do this regardless of NO_SSL, we use havege for rtmpe too */
    RTMP_TLS_ctx = calloc(1,sizeof(struct tls_ctx));
    87e8:	e3a00001 	mov	r0, #1
    87ec:	e59f1014 	ldr	r1, [pc, #20]	; 8808 <RTMP_TLS_Init+0x24>
    87f0:	ebfff24b 	bl	5124 <calloc@plt>
    87f4:	e59f3010 	ldr	r3, [pc, #16]	; 880c <RTMP_TLS_Init+0x28>
    87f8:	e79f3003 	ldr	r3, [pc, r3]
    87fc:	e5830000 	str	r0, [r3]
    RTMP_TLS_ctx = SSL_CTX_new(SSLv23_method());
    SSL_CTX_set_options(RTMP_TLS_ctx, SSL_OP_ALL);
    SSL_CTX_set_default_verify_paths(RTMP_TLS_ctx);
#endif
#endif
}
    8800:	e8bd4008 	pop	{r3, lr}
{
#ifdef CRYPTO
#ifdef USE_POLARSSL
    /* Do this regardless of NO_SSL, we use havege for rtmpe too */
    RTMP_TLS_ctx = calloc(1,sizeof(struct tls_ctx));
    havege_init(&RTMP_TLS_ctx->hs);
    8804:	eafff2a6 	b	52a4 <havege_init@plt>
    8808:	00009074 	.word	0x00009074
    880c:	0001b574 	.word	0x0001b574

00008810 <RTMP_TLS_AllocServerContext>:
#endif
}

void *
RTMP_TLS_AllocServerContext(const char* cert, const char* key)
{
    8810:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    8814:	e59f40ac 	ldr	r4, [pc, #172]	; 88c8 <RTMP_TLS_AllocServerContext+0xb8>
    8818:	e1a08000 	mov	r8, r0
    void *ctx = NULL;
#ifdef CRYPTO
    if (!RTMP_TLS_ctx)
    881c:	e79f4004 	ldr	r4, [pc, r4]
#endif
}

void *
RTMP_TLS_AllocServerContext(const char* cert, const char* key)
{
    8820:	e1a06001 	mov	r6, r1
    void *ctx = NULL;
#ifdef CRYPTO
    if (!RTMP_TLS_ctx)
    8824:	e5947000 	ldr	r7, [r4]
    8828:	e3570000 	cmp	r7, #0
    882c:	0a00001c 	beq	88a4 <RTMP_TLS_AllocServerContext+0x94>
        RTMP_TLS_Init();
#ifdef USE_POLARSSL
    tls_server_ctx *tc = ctx = calloc(1, sizeof(struct tls_server_ctx));
    8830:	e3a01e2d 	mov	r1, #720	; 0x2d0
    8834:	e3a00001 	mov	r0, #1
    8838:	ebfff239 	bl	5124 <calloc@plt>
    tc->dhm_P = my_dhm_P;
    883c:	e59f2088 	ldr	r2, [pc, #136]	; 88cc <RTMP_TLS_AllocServerContext+0xbc>
    tc->dhm_G = my_dhm_G;
    8840:	e59f3088 	ldr	r3, [pc, #136]	; 88d0 <RTMP_TLS_AllocServerContext+0xc0>
#ifdef CRYPTO
    if (!RTMP_TLS_ctx)
        RTMP_TLS_Init();
#ifdef USE_POLARSSL
    tls_server_ctx *tc = ctx = calloc(1, sizeof(struct tls_server_ctx));
    tc->dhm_P = my_dhm_P;
    8844:	e08f2002 	add	r2, pc, r2
    tc->dhm_G = my_dhm_G;
    8848:	e08f3003 	add	r3, pc, r3
    tc->hs = &RTMP_TLS_ctx->hs;
    if (x509parse_crtfile_polarssl(&tc->cert, cert)) {
    884c:	e1a01008 	mov	r1, r8
        RTMP_TLS_Init();
#ifdef USE_POLARSSL
    tls_server_ctx *tc = ctx = calloc(1, sizeof(struct tls_server_ctx));
    tc->dhm_P = my_dhm_P;
    tc->dhm_G = my_dhm_G;
    tc->hs = &RTMP_TLS_ctx->hs;
    8850:	e1a05000 	mov	r5, r0
#ifdef CRYPTO
    if (!RTMP_TLS_ctx)
        RTMP_TLS_Init();
#ifdef USE_POLARSSL
    tls_server_ctx *tc = ctx = calloc(1, sizeof(struct tls_server_ctx));
    tc->dhm_P = my_dhm_P;
    8854:	e58022c8 	str	r2, [r0, #712]	; 0x2c8
    tc->dhm_G = my_dhm_G;
    8858:	e58032cc 	str	r3, [r0, #716]	; 0x2cc
    void *ctx = NULL;
#ifdef CRYPTO
    if (!RTMP_TLS_ctx)
        RTMP_TLS_Init();
#ifdef USE_POLARSSL
    tls_server_ctx *tc = ctx = calloc(1, sizeof(struct tls_server_ctx));
    885c:	e1a04000 	mov	r4, r0
    tc->dhm_P = my_dhm_P;
    tc->dhm_G = my_dhm_G;
    tc->hs = &RTMP_TLS_ctx->hs;
    8860:	e4857004 	str	r7, [r5], #4
    if (x509parse_crtfile_polarssl(&tc->cert, cert)) {
    8864:	e1a00005 	mov	r0, r5
    8868:	ebfff290 	bl	52b0 <x509parse_crtfile_polarssl@plt>
    886c:	e2507000 	subs	r7, r0, #0
    8870:	1a000007 	bne	8894 <RTMP_TLS_AllocServerContext+0x84>
        free(tc);
        return NULL;
    }
    if (x509parse_keyfile_polarssl(&tc->key, key, NULL)) {
    8874:	e1a01006 	mov	r1, r6
    8878:	e2840e1d 	add	r0, r4, #464	; 0x1d0
    887c:	e1a02007 	mov	r2, r7
    8880:	ebfff28d 	bl	52bc <x509parse_keyfile_polarssl@plt>
    8884:	e3500000 	cmp	r0, #0
    8888:	1a000008 	bne	88b0 <RTMP_TLS_AllocServerContext+0xa0>
    888c:	e1a00004 	mov	r0, r4
        return NULL;
    }
#endif
#endif
    return ctx;
}
    8890:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    tls_server_ctx *tc = ctx = calloc(1, sizeof(struct tls_server_ctx));
    tc->dhm_P = my_dhm_P;
    tc->dhm_G = my_dhm_G;
    tc->hs = &RTMP_TLS_ctx->hs;
    if (x509parse_crtfile_polarssl(&tc->cert, cert)) {
        free(tc);
    8894:	e1a00004 	mov	r0, r4
    8898:	ebfff1d9 	bl	5004 <free@plt>
        return NULL;
    889c:	e3a00000 	mov	r0, #0
    88a0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
RTMP_TLS_AllocServerContext(const char* cert, const char* key)
{
    void *ctx = NULL;
#ifdef CRYPTO
    if (!RTMP_TLS_ctx)
        RTMP_TLS_Init();
    88a4:	ebffffce 	bl	87e4 <RTMP_TLS_Init>
    88a8:	e5947000 	ldr	r7, [r4]
    88ac:	eaffffdf 	b	8830 <RTMP_TLS_AllocServerContext+0x20>
    if (x509parse_crtfile_polarssl(&tc->cert, cert)) {
        free(tc);
        return NULL;
    }
    if (x509parse_keyfile_polarssl(&tc->key, key, NULL)) {
        x509_free_polarssl(&tc->cert);
    88b0:	e1a00005 	mov	r0, r5
    88b4:	ebfff283 	bl	52c8 <x509_free_polarssl@plt>
        free(tc);
    88b8:	e1a00004 	mov	r0, r4
    88bc:	ebfff1d0 	bl	5004 <free@plt>
        return NULL;
    88c0:	e1a00007 	mov	r0, r7
    88c4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    88c8:	0001b550 	.word	0x0001b550
    88cc:	00015f18 	.word	0x00015f18
    88d0:	00016018 	.word	0x00016018

000088d4 <RTMP_TLS_FreeServerContext>:
    return ctx;
}

void
RTMP_TLS_FreeServerContext(void *ctx)
{
    88d4:	e92d4010 	push	{r4, lr}
    88d8:	e1a04000 	mov	r4, r0
#ifdef CRYPTO
#ifdef USE_POLARSSL
    x509_free_polarssl(&((tls_server_ctx*)ctx)->cert);
    88dc:	e2800004 	add	r0, r0, #4
    88e0:	ebfff278 	bl	52c8 <x509_free_polarssl@plt>
    rsa_free(&((tls_server_ctx*)ctx)->key);
    88e4:	e2840e1d 	add	r0, r4, #464	; 0x1d0
    88e8:	ebfff279 	bl	52d4 <rsa_free@plt>
    free(ctx);
    88ec:	e1a00004 	mov	r0, r4
    gnutls_certificate_free_credentials(ctx);
#elif !defined(NO_SSL) /* USE_OPENSSL */
    SSL_CTX_free(ctx);
#endif
#endif
}
    88f0:	e8bd4010 	pop	{r4, lr}
{
#ifdef CRYPTO
#ifdef USE_POLARSSL
    x509_free_polarssl(&((tls_server_ctx*)ctx)->cert);
    rsa_free(&((tls_server_ctx*)ctx)->key);
    free(ctx);
    88f4:	eafff1c2 	b	5004 <free@plt>

000088f8 <RTMP_Alloc>:
}

RTMP *
RTMP_Alloc()
{
    return calloc(1, sizeof(RTMP));
    88f8:	e3a00001 	mov	r0, #1
    88fc:	e59f1000 	ldr	r1, [pc]	; 8904 <RTMP_Alloc+0xc>
    8900:	eafff207 	b	5124 <calloc@plt>
    8904:	00004bb0 	.word	0x00004bb0

00008908 <RTMP_Free>:
}

void
RTMP_Free(RTMP *r)
{
    free(r);
    8908:	eafff1bd 	b	5004 <free@plt>

0000890c <RTMP_Init>:
}

void
RTMP_Init(RTMP *r)
{
    890c:	e59f30c4 	ldr	r3, [pc, #196]	; 89d8 <RTMP_Init+0xcc>
    8910:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
#ifdef CRYPTO
    if (!RTMP_TLS_ctx)
    8914:	e79f3003 	ldr	r3, [pc, r3]
    free(r);
}

void
RTMP_Init(RTMP *r)
{
    8918:	e1a04000 	mov	r4, r0
#ifdef CRYPTO
    if (!RTMP_TLS_ctx)
    891c:	e5933000 	ldr	r3, [r3]
    8920:	e3530000 	cmp	r3, #0
    8924:	0a000029 	beq	89d0 <RTMP_Init+0xc4>
        RTMP_TLS_Init();
#endif
    
    memset(r, 0, sizeof(RTMP));
    8928:	e1a00004 	mov	r0, r4
    892c:	e3a01000 	mov	r1, #0
    8930:	e59f20a4 	ldr	r2, [pc, #164]	; 89dc <RTMP_Init+0xd0>
    8934:	ebfff1e5 	bl	50d0 <memset@plt>
    r->m_outChunkSize = RTMP_DEFAULT_CHUNKSIZE;
    r->m_nBufferMS = 30000;
    r->m_nClientBW = 2500000;
    r->m_nClientBW2 = 2;
    r->m_nServerBW = 2500000;
    r->m_fAudioCodecs = 3191.0;
    8938:	e59f70a0 	ldr	r7, [pc, #160]	; 89e0 <RTMP_Init+0xd4>
    r->m_fVideoCodecs = 252.0;
    893c:	e59f10a0 	ldr	r1, [pc, #160]	; 89e4 <RTMP_Init+0xd8>
        RTMP_TLS_Init();
#endif
    
    memset(r, 0, sizeof(RTMP));
    r->m_sb.sb_socket = -1;
    r->m_inChunkSize = RTMP_DEFAULT_CHUNKSIZE;
    8940:	e3a02080 	mov	r2, #128	; 0x80
    r->m_outChunkSize = RTMP_DEFAULT_CHUNKSIZE;
    r->m_nBufferMS = 30000;
    r->m_nClientBW = 2500000;
    8944:	e59f309c 	ldr	r3, [pc, #156]	; 89e8 <RTMP_Init+0xdc>
    r->m_nClientBW2 = 2;
    r->m_nServerBW = 2500000;
    r->m_fAudioCodecs = 3191.0;
    r->m_fVideoCodecs = 252.0;
    r->Link.timeout = 1;//default 30 //socket recv timeout
    8948:	e2845901 	add	r5, r4, #16384	; 0x4000
    894c:	e3a0e001 	mov	lr, #1
    r->Link.swfAge = 30;
    8950:	e3a0c01e 	mov	ip, #30
    r->m_outChunkSize = RTMP_DEFAULT_CHUNKSIZE;
    r->m_nBufferMS = 30000;
    r->m_nClientBW = 2500000;
    r->m_nClientBW2 = 2;
    r->m_nServerBW = 2500000;
    r->m_fAudioCodecs = 3191.0;
    8954:	e3a06000 	mov	r6, #0
    r->m_fVideoCodecs = 252.0;
    8958:	e3a00000 	mov	r0, #0
    if (!RTMP_TLS_ctx)
        RTMP_TLS_Init();
#endif
    
    memset(r, 0, sizeof(RTMP));
    r->m_sb.sb_socket = -1;
    895c:	e3e0a000 	mvn	sl, #0
    r->m_inChunkSize = RTMP_DEFAULT_CHUNKSIZE;
    r->m_outChunkSize = RTMP_DEFAULT_CHUNKSIZE;
    r->m_nBufferMS = 30000;
    8960:	e59f9084 	ldr	r9, [pc, #132]	; 89ec <RTMP_Init+0xe0>
    r->m_nClientBW = 2500000;
    r->m_nClientBW2 = 2;
    8964:	e3a08002 	mov	r8, #2
    r->m_nServerBW = 2500000;
    r->m_fAudioCodecs = 3191.0;
    r->m_fVideoCodecs = 252.0;
    8968:	e1c406f0 	strd	r0, [r4, #96]	; 0x60
        RTMP_TLS_Init();
#endif
    
    memset(r, 0, sizeof(RTMP));
    r->m_sb.sb_socket = -1;
    r->m_inChunkSize = RTMP_DEFAULT_CHUNKSIZE;
    896c:	e5842000 	str	r2, [r4]
    r->m_outChunkSize = RTMP_DEFAULT_CHUNKSIZE;
    8970:	e5842004 	str	r2, [r4, #4]
    r->m_nBufferMS = 30000;
    r->m_nClientBW = 2500000;
    8974:	e5843030 	str	r3, [r4, #48]	; 0x30
    r->m_nClientBW2 = 2;
    r->m_nServerBW = 2500000;
    8978:	e584302c 	str	r3, [r4, #44]	; 0x2c
    r->m_fAudioCodecs = 3191.0;
    897c:	e1c465f8 	strd	r6, [r4, #88]	; 0x58
    if (!RTMP_TLS_ctx)
        RTMP_TLS_Init();
#endif
    
    memset(r, 0, sizeof(RTMP));
    r->m_sb.sb_socket = -1;
    8980:	e584a0e0 	str	sl, [r4, #224]	; 0xe0
    r->m_inChunkSize = RTMP_DEFAULT_CHUNKSIZE;
    r->m_outChunkSize = RTMP_DEFAULT_CHUNKSIZE;
    r->m_nBufferMS = 30000;
    8984:	e5849014 	str	r9, [r4, #20]
    r->m_nClientBW = 2500000;
    r->m_nClientBW2 = 2;
    8988:	e5c48034 	strb	r8, [r4, #52]	; 0x34
    r->m_fAudioCodecs = 3191.0;
    r->m_fVideoCodecs = 252.0;
    r->Link.timeout = 1;//default 30 //socket recv timeout
    r->Link.swfAge = 30;
    r->m_portal=0;//default no portal
    r->center_portal=malloc(sizeof(RTMP_PORTAL));
    898c:	e3a00f77 	mov	r0, #476	; 0x1dc
    r->m_nClientBW = 2500000;
    r->m_nClientBW2 = 2;
    r->m_nServerBW = 2500000;
    r->m_fAudioCodecs = 3191.0;
    r->m_fVideoCodecs = 252.0;
    r->Link.timeout = 1;//default 30 //socket recv timeout
    8990:	e585e18c 	str	lr, [r5, #396]	; 0x18c
    r->Link.swfAge = 30;
    8994:	e585c184 	str	ip, [r5, #388]	; 0x184
    r->m_portal=0;//default no portal
    r->center_portal=malloc(sizeof(RTMP_PORTAL));
    8998:	ebfff19f 	bl	501c <malloc@plt>
    r->area_portal=malloc(sizeof(RTMP_PORTAL));
    init_portal(r->area_portal);
    init_portal(r->center_portal);
    rtmp_mutex_init(&r->lock_speed);
    899c:	e2844c4b 	add	r4, r4, #19200	; 0x4b00
    r->m_fAudioCodecs = 3191.0;
    r->m_fVideoCodecs = 252.0;
    r->Link.timeout = 1;//default 30 //socket recv timeout
    r->Link.swfAge = 30;
    r->m_portal=0;//default no portal
    r->center_portal=malloc(sizeof(RTMP_PORTAL));
    89a0:	e58501f8 	str	r0, [r5, #504]	; 0x1f8
    r->area_portal=malloc(sizeof(RTMP_PORTAL));
    89a4:	e3a00f77 	mov	r0, #476	; 0x1dc
    89a8:	ebfff19b 	bl	501c <malloc@plt>
    89ac:	e58501fc 	str	r0, [r5, #508]	; 0x1fc
    init_portal(r->area_portal);
    89b0:	ebfffbd6 	bl	7910 <init_portal>
    init_portal(r->center_portal);
    89b4:	e59501f8 	ldr	r0, [r5, #504]	; 0x1f8
    89b8:	ebfffbd4 	bl	7910 <init_portal>
    rtmp_mutex_init(&r->lock_speed);
    89bc:	e28400a8 	add	r0, r4, #168	; 0xa8
    89c0:	eb00484f 	bl	1ab04 <rtmp_mutex_init>
    rtmp_mutex_init(&r->lock_drop);
    89c4:	e28400ac 	add	r0, r4, #172	; 0xac
}
    89c8:	e8bd47f0 	pop	{r4, r5, r6, r7, r8, r9, sl, lr}
    r->center_portal=malloc(sizeof(RTMP_PORTAL));
    r->area_portal=malloc(sizeof(RTMP_PORTAL));
    init_portal(r->area_portal);
    init_portal(r->center_portal);
    rtmp_mutex_init(&r->lock_speed);
    rtmp_mutex_init(&r->lock_drop);
    89cc:	ea00484c 	b	1ab04 <rtmp_mutex_init>
void
RTMP_Init(RTMP *r)
{
#ifdef CRYPTO
    if (!RTMP_TLS_ctx)
        RTMP_TLS_Init();
    89d0:	ebffff83 	bl	87e4 <RTMP_TLS_Init>
    89d4:	eaffffd3 	b	8928 <RTMP_Init+0x1c>
    89d8:	0001b458 	.word	0x0001b458
    89dc:	00004bb0 	.word	0x00004bb0
    89e0:	40a8ee00 	.word	0x40a8ee00
    89e4:	406f8000 	.word	0x406f8000
    89e8:	002625a0 	.word	0x002625a0
    89ec:	00007530 	.word	0x00007530

000089f0 <RTMP_EnableWrite>:
}

void
RTMP_EnableWrite(RTMP *r)
{
    r->Link.protocol |= RTMP_FEATURE_WRITE;
    89f0:	e2800901 	add	r0, r0, #16384	; 0x4000
    89f4:	e5903188 	ldr	r3, [r0, #392]	; 0x188
    89f8:	e3833010 	orr	r3, r3, #16
    89fc:	e5803188 	str	r3, [r0, #392]	; 0x188
    8a00:	e12fff1e 	bx	lr

00008a04 <RTMP_GetDuration>:

double
RTMP_GetDuration(RTMP *r)
{
    return r->m_fDuration;
}
    8a04:	e1c007d0 	ldrd	r0, [r0, #112]	; 0x70
    8a08:	e12fff1e 	bx	lr

00008a0c <RTMP_IsConnected>:

int
RTMP_IsConnected(RTMP *r)
{
    return r->m_sb.sb_socket != -1;
    8a0c:	e59000e0 	ldr	r0, [r0, #224]	; 0xe0
}
    8a10:	e2900001 	adds	r0, r0, #1
    8a14:	13a00001 	movne	r0, #1
    8a18:	e12fff1e 	bx	lr

00008a1c <RTMP_Socket>:

int
RTMP_Socket(RTMP *r)
{
    return r->m_sb.sb_socket;
}
    8a1c:	e59000e0 	ldr	r0, [r0, #224]	; 0xe0
    8a20:	e12fff1e 	bx	lr

00008a24 <RTMP_IsTimedout>:

int
RTMP_IsTimedout(RTMP *r)
{
    return r->m_sb.sb_timedout;
    8a24:	e2800901 	add	r0, r0, #16384	; 0x4000
}
    8a28:	e59000ec 	ldr	r0, [r0, #236]	; 0xec
    8a2c:	e12fff1e 	bx	lr

00008a30 <RTMP_SetBufferMS>:

void
RTMP_SetBufferMS(RTMP *r, int size)
{
    r->m_nBufferMS = size;
    8a30:	e5801014 	str	r1, [r0, #20]
    8a34:	e12fff1e 	bx	lr

00008a38 <RTMP_SetupStream>:
                 AVal *subscribepath,
                 AVal *usherToken,
                 int dStart,
                 int dStop, int bLiveStream, long int timeout)
{
    RTMP_Log(RTMP_LOGDEBUG, "Protocol : %s", RTMPProtocolStrings[protocol&7]);
    8a38:	e59fc4c8 	ldr	ip, [pc, #1224]	; 8f08 <RTMP_SetupStream+0x4d0>
                 AVal *flashVer,
                 AVal *subscribepath,
                 AVal *usherToken,
                 int dStart,
                 int dStop, int bLiveStream, long int timeout)
{
    8a3c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    RTMP_Log(RTMP_LOGDEBUG, "Protocol : %s", RTMPProtocolStrings[protocol&7]);
    8a40:	e79fc00c 	ldr	ip, [pc, ip]
                 AVal *flashVer,
                 AVal *subscribepath,
                 AVal *usherToken,
                 int dStart,
                 int dStop, int bLiveStream, long int timeout)
{
    8a44:	e1a0b001 	mov	fp, r1
    RTMP_Log(RTMP_LOGDEBUG, "Protocol : %s", RTMPProtocolStrings[protocol&7]);
    8a48:	e2011007 	and	r1, r1, #7
    8a4c:	e0611181 	rsb	r1, r1, r1, lsl #3
                 AVal *flashVer,
                 AVal *subscribepath,
                 AVal *usherToken,
                 int dStart,
                 int dStop, int bLiveStream, long int timeout)
{
    8a50:	e1a0a002 	mov	sl, r2
    RTMP_Log(RTMP_LOGDEBUG, "Protocol : %s", RTMPProtocolStrings[protocol&7]);
    8a54:	e08c2001 	add	r2, ip, r1
    8a58:	e59f14ac 	ldr	r1, [pc, #1196]	; 8f0c <RTMP_SetupStream+0x4d4>
                 AVal *flashVer,
                 AVal *subscribepath,
                 AVal *usherToken,
                 int dStart,
                 int dStop, int bLiveStream, long int timeout)
{
    8a5c:	e24dd014 	sub	sp, sp, #20
    8a60:	e58d0004 	str	r0, [sp, #4]
    RTMP_Log(RTMP_LOGDEBUG, "Protocol : %s", RTMPProtocolStrings[protocol&7]);
    8a64:	e08f1001 	add	r1, pc, r1
    8a68:	e3a00004 	mov	r0, #4
                 AVal *flashVer,
                 AVal *subscribepath,
                 AVal *usherToken,
                 int dStart,
                 int dStop, int bLiveStream, long int timeout)
{
    8a6c:	e58d3000 	str	r3, [sp]
    8a70:	e59d9040 	ldr	r9, [sp, #64]	; 0x40
    8a74:	e59d8044 	ldr	r8, [sp, #68]	; 0x44
    8a78:	e59d7048 	ldr	r7, [sp, #72]	; 0x48
    8a7c:	e59d404c 	ldr	r4, [sp, #76]	; 0x4c
    8a80:	e59d6050 	ldr	r6, [sp, #80]	; 0x50
    8a84:	e59d5060 	ldr	r5, [sp, #96]	; 0x60
    RTMP_Log(RTMP_LOGDEBUG, "Protocol : %s", RTMPProtocolStrings[protocol&7]);
    8a88:	eb0033c7 	bl	159ac <RTMP_Log>
    RTMP_Log(RTMP_LOGDEBUG, "Hostname : %.*s", host->av_len, host->av_val);
    8a8c:	e59f147c 	ldr	r1, [pc, #1148]	; 8f10 <RTMP_SetupStream+0x4d8>
    8a90:	e59a3000 	ldr	r3, [sl]
    8a94:	e59a2004 	ldr	r2, [sl, #4]
    8a98:	e3a00004 	mov	r0, #4
    8a9c:	e08f1001 	add	r1, pc, r1
    8aa0:	eb0033c1 	bl	159ac <RTMP_Log>
    RTMP_Log(RTMP_LOGDEBUG, "Port     : %d", port);
    8aa4:	e59f1468 	ldr	r1, [pc, #1128]	; 8f14 <RTMP_SetupStream+0x4dc>
    8aa8:	e59d2000 	ldr	r2, [sp]
    8aac:	e3a00004 	mov	r0, #4
    8ab0:	e08f1001 	add	r1, pc, r1
    8ab4:	eb0033bc 	bl	159ac <RTMP_Log>
    RTMP_Log(RTMP_LOGDEBUG, "Playpath : %s", playpath->av_val);
    8ab8:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
    8abc:	e59f1454 	ldr	r1, [pc, #1108]	; 8f18 <RTMP_SetupStream+0x4e0>
    8ac0:	e5932000 	ldr	r2, [r3]
    8ac4:	e3a00004 	mov	r0, #4
    8ac8:	e08f1001 	add	r1, pc, r1
    8acc:	eb0033b6 	bl	159ac <RTMP_Log>
    
    if (tcUrl && tcUrl->av_val)
    8ad0:	e3590000 	cmp	r9, #0
    8ad4:	0a000006 	beq	8af4 <RTMP_SetupStream+0xbc>
    8ad8:	e5992000 	ldr	r2, [r9]
    8adc:	e3520000 	cmp	r2, #0
    8ae0:	0a000003 	beq	8af4 <RTMP_SetupStream+0xbc>
        RTMP_Log(RTMP_LOGDEBUG, "tcUrl    : %s", tcUrl->av_val);
    8ae4:	e59f1430 	ldr	r1, [pc, #1072]	; 8f1c <RTMP_SetupStream+0x4e4>
    8ae8:	e3a00004 	mov	r0, #4
    8aec:	e08f1001 	add	r1, pc, r1
    8af0:	eb0033ad 	bl	159ac <RTMP_Log>
    if (swfUrl && swfUrl->av_val)
    8af4:	e3580000 	cmp	r8, #0
    8af8:	0a000006 	beq	8b18 <RTMP_SetupStream+0xe0>
    8afc:	e5982000 	ldr	r2, [r8]
    8b00:	e3520000 	cmp	r2, #0
    8b04:	0a000003 	beq	8b18 <RTMP_SetupStream+0xe0>
        RTMP_Log(RTMP_LOGDEBUG, "swfUrl   : %s", swfUrl->av_val);
    8b08:	e59f1410 	ldr	r1, [pc, #1040]	; 8f20 <RTMP_SetupStream+0x4e8>
    8b0c:	e3a00004 	mov	r0, #4
    8b10:	e08f1001 	add	r1, pc, r1
    8b14:	eb0033a4 	bl	159ac <RTMP_Log>
    if (pageUrl && pageUrl->av_val)
    8b18:	e3570000 	cmp	r7, #0
    8b1c:	0a000006 	beq	8b3c <RTMP_SetupStream+0x104>
    8b20:	e5972000 	ldr	r2, [r7]
    8b24:	e3520000 	cmp	r2, #0
    8b28:	0a000003 	beq	8b3c <RTMP_SetupStream+0x104>
        RTMP_Log(RTMP_LOGDEBUG, "pageUrl  : %s", pageUrl->av_val);
    8b2c:	e59f13f0 	ldr	r1, [pc, #1008]	; 8f24 <RTMP_SetupStream+0x4ec>
    8b30:	e3a00004 	mov	r0, #4
    8b34:	e08f1001 	add	r1, pc, r1
    8b38:	eb00339b 	bl	159ac <RTMP_Log>
    if (app && app->av_val)
    8b3c:	e3540000 	cmp	r4, #0
    8b40:	0a000007 	beq	8b64 <RTMP_SetupStream+0x12c>
    8b44:	e5943000 	ldr	r3, [r4]
    8b48:	e3530000 	cmp	r3, #0
    8b4c:	0a000004 	beq	8b64 <RTMP_SetupStream+0x12c>
        RTMP_Log(RTMP_LOGDEBUG, "app      : %.*s", app->av_len, app->av_val);
    8b50:	e59f13d0 	ldr	r1, [pc, #976]	; 8f28 <RTMP_SetupStream+0x4f0>
    8b54:	e3a00004 	mov	r0, #4
    8b58:	e08f1001 	add	r1, pc, r1
    8b5c:	e5942004 	ldr	r2, [r4, #4]
    8b60:	eb003391 	bl	159ac <RTMP_Log>
    if (auth && auth->av_val)
    8b64:	e3560000 	cmp	r6, #0
    8b68:	0a000006 	beq	8b88 <RTMP_SetupStream+0x150>
    8b6c:	e5962000 	ldr	r2, [r6]
    8b70:	e3520000 	cmp	r2, #0
    8b74:	0a000003 	beq	8b88 <RTMP_SetupStream+0x150>
        RTMP_Log(RTMP_LOGDEBUG, "auth     : %s", auth->av_val);
    8b78:	e59f13ac 	ldr	r1, [pc, #940]	; 8f2c <RTMP_SetupStream+0x4f4>
    8b7c:	e3a00004 	mov	r0, #4
    8b80:	e08f1001 	add	r1, pc, r1
    8b84:	eb003388 	bl	159ac <RTMP_Log>
    if (subscribepath && subscribepath->av_val)
    8b88:	e3550000 	cmp	r5, #0
    8b8c:	0a000006 	beq	8bac <RTMP_SetupStream+0x174>
    8b90:	e5952000 	ldr	r2, [r5]
    8b94:	e3520000 	cmp	r2, #0
    8b98:	0a000003 	beq	8bac <RTMP_SetupStream+0x174>
        RTMP_Log(RTMP_LOGDEBUG, "subscribepath : %s", subscribepath->av_val);
    8b9c:	e59f138c 	ldr	r1, [pc, #908]	; 8f30 <RTMP_SetupStream+0x4f8>
    8ba0:	e3a00004 	mov	r0, #4
    8ba4:	e08f1001 	add	r1, pc, r1
    8ba8:	eb00337f 	bl	159ac <RTMP_Log>
    if (usherToken && usherToken->av_val)
    8bac:	e59d3064 	ldr	r3, [sp, #100]	; 0x64
    8bb0:	e3530000 	cmp	r3, #0
    8bb4:	0a000006 	beq	8bd4 <RTMP_SetupStream+0x19c>
    8bb8:	e5932000 	ldr	r2, [r3]
    8bbc:	e3520000 	cmp	r2, #0
    8bc0:	0a000003 	beq	8bd4 <RTMP_SetupStream+0x19c>
        RTMP_Log(RTMP_LOGDEBUG, "NetStream.Authenticate.UsherToken : %s", usherToken->av_val);
    8bc4:	e59f1368 	ldr	r1, [pc, #872]	; 8f34 <RTMP_SetupStream+0x4fc>
    8bc8:	e3a00004 	mov	r0, #4
    8bcc:	e08f1001 	add	r1, pc, r1
    8bd0:	eb003375 	bl	159ac <RTMP_Log>
    if (flashVer && flashVer->av_val)
    8bd4:	e59d305c 	ldr	r3, [sp, #92]	; 0x5c
    8bd8:	e3530000 	cmp	r3, #0
    8bdc:	0a000006 	beq	8bfc <RTMP_SetupStream+0x1c4>
    8be0:	e5932000 	ldr	r2, [r3]
    8be4:	e3520000 	cmp	r2, #0
    8be8:	0a000003 	beq	8bfc <RTMP_SetupStream+0x1c4>
        RTMP_Log(RTMP_LOGDEBUG, "flashVer : %s", flashVer->av_val);
    8bec:	e59f1344 	ldr	r1, [pc, #836]	; 8f38 <RTMP_SetupStream+0x500>
    8bf0:	e3a00004 	mov	r0, #4
    8bf4:	e08f1001 	add	r1, pc, r1
    8bf8:	eb00336b 	bl	159ac <RTMP_Log>
    if (dStart > 0)
    8bfc:	e59d3068 	ldr	r3, [sp, #104]	; 0x68
    8c00:	e3530000 	cmp	r3, #0
    8c04:	da000004 	ble	8c1c <RTMP_SetupStream+0x1e4>
        RTMP_Log(RTMP_LOGDEBUG, "StartTime     : %d msec", dStart);
    8c08:	e59f132c 	ldr	r1, [pc, #812]	; 8f3c <RTMP_SetupStream+0x504>
    8c0c:	e3a00004 	mov	r0, #4
    8c10:	e08f1001 	add	r1, pc, r1
    8c14:	e1a02003 	mov	r2, r3
    8c18:	eb003363 	bl	159ac <RTMP_Log>
    if (dStop > 0)
    8c1c:	e59d306c 	ldr	r3, [sp, #108]	; 0x6c
    8c20:	e3530000 	cmp	r3, #0
    8c24:	da000004 	ble	8c3c <RTMP_SetupStream+0x204>
        RTMP_Log(RTMP_LOGDEBUG, "StopTime      : %d msec", dStop);
    8c28:	e59f1310 	ldr	r1, [pc, #784]	; 8f40 <RTMP_SetupStream+0x508>
    8c2c:	e3a00004 	mov	r0, #4
    8c30:	e08f1001 	add	r1, pc, r1
    8c34:	e1a02003 	mov	r2, r3
    8c38:	eb00335b 	bl	159ac <RTMP_Log>
    
    RTMP_Log(RTMP_LOGDEBUG, "live     : %s", bLiveStream ? "yes" : "no");
    8c3c:	e59d3070 	ldr	r3, [sp, #112]	; 0x70
    8c40:	e59f22fc 	ldr	r2, [pc, #764]	; 8f44 <RTMP_SetupStream+0x50c>
    8c44:	e3530000 	cmp	r3, #0
    8c48:	e08f2002 	add	r2, pc, r2
    8c4c:	159f22f4 	ldrne	r2, [pc, #756]	; 8f48 <RTMP_SetupStream+0x510>
    8c50:	108f2002 	addne	r2, pc, r2
    8c54:	e59f12f0 	ldr	r1, [pc, #752]	; 8f4c <RTMP_SetupStream+0x514>
    8c58:	e3a00004 	mov	r0, #4
    8c5c:	e08f1001 	add	r1, pc, r1
    8c60:	eb003351 	bl	159ac <RTMP_Log>
    RTMP_Log(RTMP_LOGDEBUG, "timeout  : %ld sec", timeout);
    8c64:	e59f12e4 	ldr	r1, [pc, #740]	; 8f50 <RTMP_SetupStream+0x518>
    8c68:	e59d2074 	ldr	r2, [sp, #116]	; 0x74
    8c6c:	e3a00004 	mov	r0, #4
    8c70:	e08f1001 	add	r1, pc, r1
    8c74:	eb00334c 	bl	159ac <RTMP_Log>
    
#ifdef CRYPTO
    if (swfSHA256Hash != NULL && swfSize > 0)
    8c78:	e59d2058 	ldr	r2, [sp, #88]	; 0x58
    8c7c:	e59d3054 	ldr	r3, [sp, #84]	; 0x54
    8c80:	e3530000 	cmp	r3, #0
    8c84:	13520000 	cmpne	r2, #0
    {
        memcpy(r->Link.SWFHash, swfSHA256Hash->av_val, sizeof(r->Link.SWFHash));
    8c88:	e59d3004 	ldr	r3, [sp, #4]
    
    RTMP_Log(RTMP_LOGDEBUG, "live     : %s", bLiveStream ? "yes" : "no");
    RTMP_Log(RTMP_LOGDEBUG, "timeout  : %ld sec", timeout);
    
#ifdef CRYPTO
    if (swfSHA256Hash != NULL && swfSize > 0)
    8c8c:	03a02000 	moveq	r2, #0
        RTMP_LogHex(RTMP_LOGDEBUG, r->Link.SWFHash, sizeof(r->Link.SWFHash));
        RTMP_Log(RTMP_LOGDEBUG, "SWFSize  : %u", r->Link.SWFSize);
    }
    else
    {
        r->Link.SWFSize = 0;
    8c90:	02833901 	addeq	r3, r3, #16384	; 0x4000
    
    RTMP_Log(RTMP_LOGDEBUG, "live     : %s", bLiveStream ? "yes" : "no");
    RTMP_Log(RTMP_LOGDEBUG, "timeout  : %ld sec", timeout);
    
#ifdef CRYPTO
    if (swfSHA256Hash != NULL && swfSize > 0)
    8c94:	13a02001 	movne	r2, #1
        RTMP_LogHex(RTMP_LOGDEBUG, r->Link.SWFHash, sizeof(r->Link.SWFHash));
        RTMP_Log(RTMP_LOGDEBUG, "SWFSize  : %u", r->Link.SWFSize);
    }
    else
    {
        r->Link.SWFSize = 0;
    8c98:	058321a4 	streq	r2, [r3, #420]	; 0x1a4
    
    RTMP_Log(RTMP_LOGDEBUG, "live     : %s", bLiveStream ? "yes" : "no");
    RTMP_Log(RTMP_LOGDEBUG, "timeout  : %ld sec", timeout);
    
#ifdef CRYPTO
    if (swfSHA256Hash != NULL && swfSize > 0)
    8c9c:	1a00007b 	bne	8e90 <RTMP_SetupStream+0x458>
{ (char *)DEFAULT_FLASH_VER, sizeof(DEFAULT_FLASH_VER) - 1 };

static void
SocksSetup(RTMP *r, AVal *sockshost)
{
    if (sockshost->av_len)
    8ca0:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
    8ca4:	e5922004 	ldr	r2, [r2, #4]
    8ca8:	e3520000 	cmp	r2, #0
    8cac:	1a000071 	bne	8e78 <RTMP_SetupStream+0x440>
    }
    else
    {
        r->Link.sockshost.av_val = NULL;
        r->Link.sockshost.av_len = 0;
        r->Link.socksport = 0;
    8cb0:	e2831f65 	add	r1, r3, #404	; 0x194
        RTMP_Log(RTMP_LOGDEBUG, "Connecting via SOCKS proxy: %s:%d", r->Link.sockshost.av_val,
                 r->Link.socksport);
    }
    else
    {
        r->Link.sockshost.av_val = NULL;
    8cb4:	e58320fc 	str	r2, [r3, #252]	; 0xfc
        r->Link.sockshost.av_len = 0;
    8cb8:	e5832100 	str	r2, [r3, #256]	; 0x100
        r->Link.socksport = 0;
    8cbc:	e1c120b0 	strh	r2, [r1]
    }
#endif
    
    SocksSetup(r, sockshost);
    
    if (tcUrl && tcUrl->av_len)
    8cc0:	e3590000 	cmp	r9, #0
    8cc4:	0a000004 	beq	8cdc <RTMP_SetupStream+0x2a4>
    8cc8:	e5992004 	ldr	r2, [r9, #4]
    8ccc:	e3520000 	cmp	r2, #0
        r->Link.tcUrl = *tcUrl;
    8cd0:	18990003 	ldmne	r9, {r0, r1}
    8cd4:	12832f45 	addne	r2, r3, #276	; 0x114
    8cd8:	18820003 	stmne	r2, {r0, r1}
    if (swfUrl && swfUrl->av_len)
    8cdc:	e3580000 	cmp	r8, #0
    8ce0:	0a000004 	beq	8cf8 <RTMP_SetupStream+0x2c0>
    8ce4:	e5982004 	ldr	r2, [r8, #4]
    8ce8:	e3520000 	cmp	r2, #0
        r->Link.swfUrl = *swfUrl;
    8cec:	18980003 	ldmne	r8, {r0, r1}
    8cf0:	12832f47 	addne	r2, r3, #284	; 0x11c
    8cf4:	18820003 	stmne	r2, {r0, r1}
    if (pageUrl && pageUrl->av_len)
    8cf8:	e3570000 	cmp	r7, #0
    8cfc:	0a000004 	beq	8d14 <RTMP_SetupStream+0x2dc>
    8d00:	e5972004 	ldr	r2, [r7, #4]
    8d04:	e3520000 	cmp	r2, #0
        r->Link.pageUrl = *pageUrl;
    8d08:	18970003 	ldmne	r7, {r0, r1}
    8d0c:	12832f49 	addne	r2, r3, #292	; 0x124
    8d10:	18820003 	stmne	r2, {r0, r1}
    if (app && app->av_len)
    8d14:	e3540000 	cmp	r4, #0
    8d18:	0a000004 	beq	8d30 <RTMP_SetupStream+0x2f8>
    8d1c:	e5942004 	ldr	r2, [r4, #4]
    8d20:	e3520000 	cmp	r2, #0
        r->Link.app = *app;
    8d24:	18940003 	ldmne	r4, {r0, r1}
    8d28:	12832f4b 	addne	r2, r3, #300	; 0x12c
    8d2c:	18820003 	stmne	r2, {r0, r1}
    if (auth && auth->av_len)
    8d30:	e3560000 	cmp	r6, #0
    8d34:	0a000002 	beq	8d44 <RTMP_SetupStream+0x30c>
    8d38:	e5962004 	ldr	r2, [r6, #4]
    8d3c:	e3520000 	cmp	r2, #0
    8d40:	1a000041 	bne	8e4c <RTMP_SetupStream+0x414>
    {
        r->Link.auth = *auth;
        r->Link.lFlags |= RTMP_LF_AUTH;
    }
    if (flashVer && flashVer->av_len)
    8d44:	e59d205c 	ldr	r2, [sp, #92]	; 0x5c
    8d48:	e3520000 	cmp	r2, #0
    8d4c:	0a000002 	beq	8d5c <RTMP_SetupStream+0x324>
    8d50:	e5922004 	ldr	r2, [r2, #4]
    8d54:	e3520000 	cmp	r2, #0
    8d58:	1a000036 	bne	8e38 <RTMP_SetupStream+0x400>
    8d5c:	e59f11f0 	ldr	r1, [pc, #496]	; 8f54 <RTMP_SetupStream+0x51c>
        r->Link.flashVer = *flashVer;
    else
        r->Link.flashVer = RTMP_DefaultFlashVer;
    8d60:	e2832f4f 	add	r2, r3, #316	; 0x13c
    8d64:	e79f1001 	ldr	r1, [pc, r1]
    8d68:	e8910003 	ldm	r1, {r0, r1}
    8d6c:	e8820003 	stm	r2, {r0, r1}
    if (subscribepath && subscribepath->av_len)
    8d70:	e3550000 	cmp	r5, #0
    8d74:	0a000004 	beq	8d8c <RTMP_SetupStream+0x354>
    8d78:	e5952004 	ldr	r2, [r5, #4]
    8d7c:	e3520000 	cmp	r2, #0
        r->Link.subscribepath = *subscribepath;
    8d80:	18950003 	ldmne	r5, {r0, r1}
    8d84:	12832f51 	addne	r2, r3, #324	; 0x144
    8d88:	18820003 	stmne	r2, {r0, r1}
    if (usherToken && usherToken->av_len)
    8d8c:	e59d2064 	ldr	r2, [sp, #100]	; 0x64
    8d90:	e3520000 	cmp	r2, #0
    8d94:	0a000005 	beq	8db0 <RTMP_SetupStream+0x378>
    8d98:	e5922004 	ldr	r2, [r2, #4]
    8d9c:	e3520000 	cmp	r2, #0
        r->Link.usherToken = *usherToken;
    8da0:	159d2064 	ldrne	r2, [sp, #100]	; 0x64
    8da4:	18920003 	ldmne	r2, {r0, r1}
    8da8:	12832f53 	addne	r2, r3, #332	; 0x14c
    8dac:	18820003 	stmne	r2, {r0, r1}
    r->Link.seekTime = dStart;
    r->Link.stopTime = dStop;
    if (bLiveStream)
    8db0:	e59d2070 	ldr	r2, [sp, #112]	; 0x70
        r->Link.lFlags |= RTMP_LF_LIVE;
    r->Link.timeout = timeout;
    
    r->Link.protocol = protocol;
    r->Link.hostname = *host;
    8db4:	e89a0003 	ldm	sl, {r0, r1}
        r->Link.subscribepath = *subscribepath;
    if (usherToken && usherToken->av_len)
        r->Link.usherToken = *usherToken;
    r->Link.seekTime = dStart;
    r->Link.stopTime = dStop;
    if (bLiveStream)
    8db8:	e3520000 	cmp	r2, #0
        r->Link.flashVer = RTMP_DefaultFlashVer;
    if (subscribepath && subscribepath->av_len)
        r->Link.subscribepath = *subscribepath;
    if (usherToken && usherToken->av_len)
        r->Link.usherToken = *usherToken;
    r->Link.seekTime = dStart;
    8dbc:	e59d2068 	ldr	r2, [sp, #104]	; 0x68
    8dc0:	e5832178 	str	r2, [r3, #376]	; 0x178
    r->Link.stopTime = dStop;
    8dc4:	e59d206c 	ldr	r2, [sp, #108]	; 0x6c
    8dc8:	e583217c 	str	r2, [r3, #380]	; 0x17c
    if (bLiveStream)
        r->Link.lFlags |= RTMP_LF_LIVE;
    8dcc:	15932180 	ldrne	r2, [r3, #384]	; 0x180
    r->Link.timeout = timeout;
    
    r->Link.protocol = protocol;
    r->Link.hostname = *host;
    8dd0:	e283c0f4 	add	ip, r3, #244	; 0xf4
    if (usherToken && usherToken->av_len)
        r->Link.usherToken = *usherToken;
    r->Link.seekTime = dStart;
    r->Link.stopTime = dStop;
    if (bLiveStream)
        r->Link.lFlags |= RTMP_LF_LIVE;
    8dd4:	13822002 	orrne	r2, r2, #2
    8dd8:	15832180 	strne	r2, [r3, #384]	; 0x180
    r->Link.timeout = timeout;
    8ddc:	e59de074 	ldr	lr, [sp, #116]	; 0x74
    
    r->Link.protocol = protocol;
    r->Link.hostname = *host;
    r->Link.port = port;
    8de0:	e59d2000 	ldr	r2, [sp]
        r->Link.usherToken = *usherToken;
    r->Link.seekTime = dStart;
    r->Link.stopTime = dStop;
    if (bLiveStream)
        r->Link.lFlags |= RTMP_LF_LIVE;
    r->Link.timeout = timeout;
    8de4:	e583e18c 	str	lr, [r3, #396]	; 0x18c
    
    r->Link.protocol = protocol;
    8de8:	e583b188 	str	fp, [r3, #392]	; 0x188
    r->Link.hostname = *host;
    8dec:	e88c0003 	stm	ip, {r0, r1}
    r->Link.port = port;
    r->Link.playpath = *playpath;
    8df0:	e59d103c 	ldr	r1, [sp, #60]	; 0x3c
        r->Link.lFlags |= RTMP_LF_LIVE;
    r->Link.timeout = timeout;
    
    r->Link.protocol = protocol;
    r->Link.hostname = *host;
    r->Link.port = port;
    8df4:	e1a02802 	lsl	r2, r2, #16
    8df8:	e1a02822 	lsr	r2, r2, #16
    r->Link.playpath = *playpath;
    8dfc:	e8910003 	ldm	r1, {r0, r1}
        r->Link.lFlags |= RTMP_LF_LIVE;
    r->Link.timeout = timeout;
    
    r->Link.protocol = protocol;
    r->Link.hostname = *host;
    r->Link.port = port;
    8e00:	e283cf65 	add	ip, r3, #404	; 0x194
    r->Link.playpath = *playpath;
    
    if (r->Link.port == 0)
    8e04:	e3520000 	cmp	r2, #0
    r->Link.timeout = timeout;
    
    r->Link.protocol = protocol;
    r->Link.hostname = *host;
    r->Link.port = port;
    r->Link.playpath = *playpath;
    8e08:	e2833f43 	add	r3, r3, #268	; 0x10c
        r->Link.lFlags |= RTMP_LF_LIVE;
    r->Link.timeout = timeout;
    
    r->Link.protocol = protocol;
    r->Link.hostname = *host;
    r->Link.port = port;
    8e0c:	e1cc20b2 	strh	r2, [ip, #2]
    r->Link.playpath = *playpath;
    8e10:	e8830003 	stm	r3, {r0, r1}
    
    if (r->Link.port == 0)
    8e14:	1a000005 	bne	8e30 <RTMP_SetupStream+0x3f8>
    {
        if (protocol & RTMP_FEATURE_SSL)
    8e18:	e31b0004 	tst	fp, #4
    8e1c:	1a000011 	bne	8e68 <RTMP_SetupStream+0x430>
            r->Link.port = 443;
        else if (protocol & RTMP_FEATURE_HTTP)
    8e20:	e31b0001 	tst	fp, #1
            r->Link.port = 80;
    8e24:	13a03050 	movne	r3, #80	; 0x50
        else
            r->Link.port = 1935;
    8e28:	059f3128 	ldreq	r3, [pc, #296]	; 8f58 <RTMP_SetupStream+0x520>
    8e2c:	e1cc30b2 	strh	r3, [ip, #2]
    }
}
    8e30:	e28dd014 	add	sp, sp, #20
    8e34:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    {
        r->Link.auth = *auth;
        r->Link.lFlags |= RTMP_LF_AUTH;
    }
    if (flashVer && flashVer->av_len)
        r->Link.flashVer = *flashVer;
    8e38:	e59d205c 	ldr	r2, [sp, #92]	; 0x5c
    8e3c:	e8920003 	ldm	r2, {r0, r1}
    8e40:	e2832f4f 	add	r2, r3, #316	; 0x13c
    8e44:	e8820003 	stm	r2, {r0, r1}
    8e48:	eaffffc8 	b	8d70 <RTMP_SetupStream+0x338>
    if (app && app->av_len)
        r->Link.app = *app;
    if (auth && auth->av_len)
    {
        r->Link.auth = *auth;
        r->Link.lFlags |= RTMP_LF_AUTH;
    8e4c:	e5932180 	ldr	r2, [r3, #384]	; 0x180
        r->Link.pageUrl = *pageUrl;
    if (app && app->av_len)
        r->Link.app = *app;
    if (auth && auth->av_len)
    {
        r->Link.auth = *auth;
    8e50:	e8960003 	ldm	r6, {r0, r1}
        r->Link.lFlags |= RTMP_LF_AUTH;
    8e54:	e3822001 	orr	r2, r2, #1
        r->Link.pageUrl = *pageUrl;
    if (app && app->av_len)
        r->Link.app = *app;
    if (auth && auth->av_len)
    {
        r->Link.auth = *auth;
    8e58:	e283cf4d 	add	ip, r3, #308	; 0x134
    8e5c:	e88c0003 	stm	ip, {r0, r1}
        r->Link.lFlags |= RTMP_LF_AUTH;
    8e60:	e5832180 	str	r2, [r3, #384]	; 0x180
    8e64:	eaffffb6 	b	8d44 <RTMP_SetupStream+0x30c>
    r->Link.playpath = *playpath;
    
    if (r->Link.port == 0)
    {
        if (protocol & RTMP_FEATURE_SSL)
            r->Link.port = 443;
    8e68:	e59f30ec 	ldr	r3, [pc, #236]	; 8f5c <RTMP_SetupStream+0x524>
    8e6c:	e1cc30b2 	strh	r3, [ip, #2]
        else if (protocol & RTMP_FEATURE_HTTP)
            r->Link.port = 80;
        else
            r->Link.port = 1935;
    }
}
    8e70:	e28dd014 	add	sp, sp, #20
    8e74:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8e78:	e59d0004 	ldr	r0, [sp, #4]
    8e7c:	e59d1038 	ldr	r1, [sp, #56]	; 0x38
    8e80:	e58d3008 	str	r3, [sp, #8]
    8e84:	ebfff4c0 	bl	618c <SocksSetup.part.2>
    8e88:	e59d3008 	ldr	r3, [sp, #8]
    8e8c:	eaffff8b 	b	8cc0 <RTMP_SetupStream+0x288>
    RTMP_Log(RTMP_LOGDEBUG, "timeout  : %ld sec", timeout);
    
#ifdef CRYPTO
    if (swfSHA256Hash != NULL && swfSize > 0)
    {
        memcpy(r->Link.SWFHash, swfSHA256Hash->av_val, sizeof(r->Link.SWFHash));
    8e90:	e59d2054 	ldr	r2, [sp, #84]	; 0x54
    8e94:	e283cc41 	add	ip, r3, #16640	; 0x4100
    8e98:	e28cc0a8 	add	ip, ip, #168	; 0xa8
    8e9c:	e5921000 	ldr	r1, [r2]
    8ea0:	e1a0000c 	mov	r0, ip
        r->Link.SWFSize = swfSize;
    8ea4:	e2833901 	add	r3, r3, #16384	; 0x4000
    RTMP_Log(RTMP_LOGDEBUG, "timeout  : %ld sec", timeout);
    
#ifdef CRYPTO
    if (swfSHA256Hash != NULL && swfSize > 0)
    {
        memcpy(r->Link.SWFHash, swfSHA256Hash->av_val, sizeof(r->Link.SWFHash));
    8ea8:	e3a02020 	mov	r2, #32
    8eac:	e58dc00c 	str	ip, [sp, #12]
        r->Link.SWFSize = swfSize;
    8eb0:	e58d3008 	str	r3, [sp, #8]
    RTMP_Log(RTMP_LOGDEBUG, "timeout  : %ld sec", timeout);
    
#ifdef CRYPTO
    if (swfSHA256Hash != NULL && swfSize > 0)
    {
        memcpy(r->Link.SWFHash, swfSHA256Hash->av_val, sizeof(r->Link.SWFHash));
    8eb4:	ebfff0c4 	bl	51cc <memcpy@plt>
        r->Link.SWFSize = swfSize;
    8eb8:	e59d3008 	ldr	r3, [sp, #8]
        RTMP_Log(RTMP_LOGDEBUG, "SWFSHA256:");
    8ebc:	e59f109c 	ldr	r1, [pc, #156]	; 8f60 <RTMP_SetupStream+0x528>
    
#ifdef CRYPTO
    if (swfSHA256Hash != NULL && swfSize > 0)
    {
        memcpy(r->Link.SWFHash, swfSHA256Hash->av_val, sizeof(r->Link.SWFHash));
        r->Link.SWFSize = swfSize;
    8ec0:	e59d2058 	ldr	r2, [sp, #88]	; 0x58
    8ec4:	e58321a4 	str	r2, [r3, #420]	; 0x1a4
        RTMP_Log(RTMP_LOGDEBUG, "SWFSHA256:");
    8ec8:	e3a00004 	mov	r0, #4
    8ecc:	e08f1001 	add	r1, pc, r1
    8ed0:	eb0032b5 	bl	159ac <RTMP_Log>
        RTMP_LogHex(RTMP_LOGDEBUG, r->Link.SWFHash, sizeof(r->Link.SWFHash));
    8ed4:	e59dc00c 	ldr	ip, [sp, #12]
    8ed8:	e3a00004 	mov	r0, #4
    8edc:	e1a0100c 	mov	r1, ip
    8ee0:	e3a02020 	mov	r2, #32
    8ee4:	eb0032c0 	bl	159ec <RTMP_LogHex>
        RTMP_Log(RTMP_LOGDEBUG, "SWFSize  : %u", r->Link.SWFSize);
    8ee8:	e59d3008 	ldr	r3, [sp, #8]
    8eec:	e59f1070 	ldr	r1, [pc, #112]	; 8f64 <RTMP_SetupStream+0x52c>
    8ef0:	e59321a4 	ldr	r2, [r3, #420]	; 0x1a4
    8ef4:	e3a00004 	mov	r0, #4
    8ef8:	e08f1001 	add	r1, pc, r1
    8efc:	eb0032aa 	bl	159ac <RTMP_Log>
    8f00:	e59d3008 	ldr	r3, [sp, #8]
    8f04:	eaffff65 	b	8ca0 <RTMP_SetupStream+0x268>
    8f08:	0001b344 	.word	0x0001b344
    8f0c:	00015e08 	.word	0x00015e08
    8f10:	00015de0 	.word	0x00015de0
    8f14:	00015ddc 	.word	0x00015ddc
    8f18:	00015dd4 	.word	0x00015dd4
    8f1c:	00015dc0 	.word	0x00015dc0
    8f20:	00015dac 	.word	0x00015dac
    8f24:	00015d98 	.word	0x00015d98
    8f28:	00015d84 	.word	0x00015d84
    8f2c:	00015d6c 	.word	0x00015d6c
    8f30:	00015d58 	.word	0x00015d58
    8f34:	00015d44 	.word	0x00015d44
    8f38:	00015d44 	.word	0x00015d44
    8f3c:	00015d38 	.word	0x00015d38
    8f40:	00015d30 	.word	0x00015d30
    8f44:	00015c20 	.word	0x00015c20
    8f48:	00015c14 	.word	0x00015c14
    8f4c:	00015d1c 	.word	0x00015d1c
    8f50:	00015d18 	.word	0x00015d18
    8f54:	0001b024 	.word	0x0001b024
    8f58:	0000078f 	.word	0x0000078f
    8f5c:	000001bb 	.word	0x000001bb
    8f60:	00015ad0 	.word	0x00015ad0
    8f64:	00015ab0 	.word	0x00015ab0

00008f68 <RTMP_SetOpt>:
        (*depth)++;
    return 0;
}

int RTMP_SetOpt(RTMP *r, const AVal *opt, AVal *arg)
{
    8f68:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8f6c:	e59f4550 	ldr	r4, [pc, #1360]	; 94c4 <RTMP_SetOpt+0x55c>
    8f70:	e24dd03c 	sub	sp, sp, #60	; 0x3c
    8f74:	e08f4004 	add	r4, pc, r4
    8f78:	e1a08001 	mov	r8, r1
    8f7c:	e8910600 	ldm	r1, {r9, sl}
    8f80:	e1a07000 	mov	r7, r0
    8f84:	e58d200c 	str	r2, [sp, #12]
    8f88:	e1a06004 	mov	r6, r4
    8f8c:	e3a03005 	mov	r3, #5
    8f90:	e3a0b000 	mov	fp, #0
    8f94:	ea000004 	b	8fac <RTMP_SetOpt+0x44>
    8f98:	e2866018 	add	r6, r6, #24
    int i;
    void *v;
    
    for (i=0; options[i].name.av_len; i++) {
    8f9c:	e5963004 	ldr	r3, [r6, #4]
    8fa0:	e28bb001 	add	fp, fp, #1
    8fa4:	e3530000 	cmp	r3, #0
    8fa8:	0a000020 	beq	9030 <RTMP_SetOpt+0xc8>
        if (opt->av_len != options[i].name.av_len) continue;
    8fac:	e153000a 	cmp	r3, sl
    8fb0:	1afffff8 	bne	8f98 <RTMP_SetOpt+0x30>
        if (strcasecmp(opt->av_val, options[i].name.av_val)) continue;
    8fb4:	e1a00009 	mov	r0, r9
    8fb8:	e5961000 	ldr	r1, [r6]
    8fbc:	ebfff0c7 	bl	52e0 <strcasecmp@plt>
    8fc0:	e2505000 	subs	r5, r0, #0
    8fc4:	1afffff3 	bne	8f98 <RTMP_SetOpt+0x30>
        v = (char *)r + options[i].off;
    8fc8:	e59f34f8 	ldr	r3, [pc, #1272]	; 94c8 <RTMP_SetOpt+0x560>
    8fcc:	e1a0608b 	lsl	r6, fp, #1
    8fd0:	e086200b 	add	r2, r6, fp
    8fd4:	e08f3003 	add	r3, pc, r3
    8fd8:	e0833182 	add	r3, r3, r2, lsl #3
    8fdc:	e593c008 	ldr	ip, [r3, #8]
        switch(options[i].otype) {
    8fe0:	e593300c 	ldr	r3, [r3, #12]
    void *v;
    
    for (i=0; options[i].name.av_len; i++) {
        if (opt->av_len != options[i].name.av_len) continue;
        if (strcasecmp(opt->av_val, options[i].name.av_val)) continue;
        v = (char *)r + options[i].off;
    8fe4:	e087200c 	add	r2, r7, ip
        switch(options[i].otype) {
    8fe8:	e3530003 	cmp	r3, #3
    8fec:	908ff103 	addls	pc, pc, r3, lsl #2
    8ff0:	ea000003 	b	9004 <RTMP_SetOpt+0x9c>
    8ff4:	ea000066 	b	9194 <RTMP_SetOpt+0x22c>
    8ff8:	ea000079 	b	91e4 <RTMP_SetOpt+0x27c>
    8ffc:	ea000081 	b	9208 <RTMP_SetOpt+0x2a0>
    9000:	ea000027 	b	90a4 <RTMP_SetOpt+0x13c>
                    return FALSE;
                break;
        }
        break;
    }
    if (!options[i].name.av_len) {
    9004:	e59f84c0 	ldr	r8, [pc, #1216]	; 94cc <RTMP_SetOpt+0x564>
    9008:	e086600b 	add	r6, r6, fp
    900c:	e08f8008 	add	r8, pc, r8
    9010:	e0886186 	add	r6, r8, r6, lsl #3
    9014:	e5963004 	ldr	r3, [r6, #4]
    9018:	e3530000 	cmp	r3, #0
    901c:	0a000003 	beq	9030 <RTMP_SetOpt+0xc8>
        RTMP_Log(RTMP_LOGERROR, "Unknown option %s", opt->av_val);
        RTMP_OptUsage();
        return FALSE;
    }
    
    return TRUE;
    9020:	e3a05001 	mov	r5, #1
}
    9024:	e1a00005 	mov	r0, r5
    9028:	e28dd03c 	add	sp, sp, #60	; 0x3c
    902c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
                break;
        }
        break;
    }
    if (!options[i].name.av_len) {
        RTMP_Log(RTMP_LOGERROR, "Unknown option %s", opt->av_val);
    9030:	e59f1498 	ldr	r1, [pc, #1176]	; 94d0 <RTMP_SetOpt+0x568>
    9034:	e3a00001 	mov	r0, #1
    9038:	e08f1001 	add	r1, pc, r1
    903c:	e1a02009 	mov	r2, r9
    9040:	eb003259 	bl	159ac <RTMP_Log>

static void RTMP_OptUsage()
{
    int i;
    
    RTMP_Log(RTMP_LOGERROR, "Valid RTMP options are:\n");
    9044:	e59f1488 	ldr	r1, [pc, #1160]	; 94d4 <RTMP_SetOpt+0x56c>
    9048:	e3a00001 	mov	r0, #1
    904c:	e08f1001 	add	r1, pc, r1
    9050:	eb003255 	bl	159ac <RTMP_Log>
    for (i=0; options[i].name.av_len; i++) {
        RTMP_Log(RTMP_LOGERROR, "%10s %-7s  %s\n", options[i].name.av_val,
    9054:	e59f747c 	ldr	r7, [pc, #1148]	; 94d8 <RTMP_SetOpt+0x570>
    9058:	e59f647c 	ldr	r6, [pc, #1148]	; 94dc <RTMP_SetOpt+0x574>
    905c:	e08f7007 	add	r7, pc, r7
    9060:	e08f6006 	add	r6, pc, r6
    9064:	e594300c 	ldr	r3, [r4, #12]
    9068:	e5941014 	ldr	r1, [r4, #20]
    906c:	e0863103 	add	r3, r6, r3, lsl #2
    9070:	e5942000 	ldr	r2, [r4]
    9074:	e5933210 	ldr	r3, [r3, #528]	; 0x210
    9078:	e58d1000 	str	r1, [sp]
    907c:	e2844018 	add	r4, r4, #24
    9080:	e3a00001 	mov	r0, #1
    9084:	e1a01007 	mov	r1, r7
    9088:	eb003247 	bl	159ac <RTMP_Log>
static void RTMP_OptUsage()
{
    int i;
    
    RTMP_Log(RTMP_LOGERROR, "Valid RTMP options are:\n");
    for (i=0; options[i].name.av_len; i++) {
    908c:	e5945004 	ldr	r5, [r4, #4]
    9090:	e3550000 	cmp	r5, #0
    9094:	1afffff2 	bne	9064 <RTMP_SetOpt+0xfc>
        RTMP_OptUsage();
        return FALSE;
    }
    
    return TRUE;
}
    9098:	e1a00005 	mov	r0, r5
    909c:	e28dd03c 	add	sp, sp, #60	; 0x3c
    90a0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
static int
parseAMF(AMFObject *obj, AVal *av, int *depth)
{
    AMFObjectProperty prop = {{0,0}};
    int i;
    char *p, *arg = av->av_val;
    90a4:	e59d300c 	ldr	r3, [sp, #12]
    90a8:	e5932000 	ldr	r2, [r3]
}

static int
parseAMF(AMFObject *obj, AVal *av, int *depth)
{
    AMFObjectProperty prop = {{0,0}};
    90ac:	e3a03000 	mov	r3, #0
    90b0:	e58d3018 	str	r3, [sp, #24]
    90b4:	e58d301c 	str	r3, [sp, #28]
    90b8:	e58d3020 	str	r3, [sp, #32]
    90bc:	e58d3024 	str	r3, [sp, #36]	; 0x24
    90c0:	e58d3028 	str	r3, [sp, #40]	; 0x28
    90c4:	e58d302c 	str	r3, [sp, #44]	; 0x2c
    90c8:	e58d3030 	str	r3, [sp, #48]	; 0x30
    90cc:	e58d3034 	str	r3, [sp, #52]	; 0x34
    int i;
    char *p, *arg = av->av_val;
    
    if (arg[1] == ':')
    90d0:	e5d23001 	ldrb	r3, [r2, #1]
    90d4:	e353003a 	cmp	r3, #58	; 0x3a
    90d8:	0a000082 	beq	92e8 <RTMP_SetOpt+0x380>
                break;
            default:
                return -1;
        }
    }
    else if (arg[2] == ':' && arg[0] == 'N')
    90dc:	e5d21002 	ldrb	r1, [r2, #2]
    90e0:	e351003a 	cmp	r1, #58	; 0x3a
    90e4:	1affffce 	bne	9024 <RTMP_SetOpt+0xbc>
    90e8:	e5d23000 	ldrb	r3, [r2]
    90ec:	e353004e 	cmp	r3, #78	; 0x4e
    90f0:	1affffcb 	bne	9024 <RTMP_SetOpt+0xbc>
    {
        p = strchr(arg+3, ':');
    90f4:	e282c003 	add	ip, r2, #3
    90f8:	e1a0000c 	mov	r0, ip
    90fc:	e58d2014 	str	r2, [sp, #20]
    9100:	e58dc010 	str	ip, [sp, #16]
    9104:	ebffeff7 	bl	50e8 <strchr@plt>
        if (!p || !*depth)
    9108:	e3500000 	cmp	r0, #0
    910c:	0affffc4 	beq	9024 <RTMP_SetOpt+0xbc>
    9110:	e2879901 	add	r9, r7, #16384	; 0x4000
    9114:	e5993174 	ldr	r3, [r9, #372]	; 0x174
    9118:	e3530000 	cmp	r3, #0
    911c:	0affffc0 	beq	9024 <RTMP_SetOpt+0xbc>
            return -1;
        prop.p_name.av_val = (char *)arg+3;
        prop.p_name.av_len = p - (arg+3);
    9120:	e59dc010 	ldr	ip, [sp, #16]
        
        p++;
        switch(arg[1])
    9124:	e59d2014 	ldr	r2, [sp, #20]
    {
        p = strchr(arg+3, ':');
        if (!p || !*depth)
            return -1;
        prop.p_name.av_val = (char *)arg+3;
        prop.p_name.av_len = p - (arg+3);
    9128:	e06c1000 	rsb	r1, ip, r0
    else if (arg[2] == ':' && arg[0] == 'N')
    {
        p = strchr(arg+3, ':');
        if (!p || !*depth)
            return -1;
        prop.p_name.av_val = (char *)arg+3;
    912c:	e58dc018 	str	ip, [sp, #24]
        prop.p_name.av_len = p - (arg+3);
    9130:	e58d101c 	str	r1, [sp, #28]
        
        p++;
        switch(arg[1])
    9134:	e5d21001 	ldrb	r1, [r2, #1]
        if (!p || !*depth)
            return -1;
        prop.p_name.av_val = (char *)arg+3;
        prop.p_name.av_len = p - (arg+3);
        
        p++;
    9138:	e2800001 	add	r0, r0, #1
        switch(arg[1])
    913c:	e2411042 	sub	r1, r1, #66	; 0x42
    9140:	e3510011 	cmp	r1, #17
    9144:	908ff101 	addls	pc, pc, r1, lsl #2
    9148:	eaffffb5 	b	9024 <RTMP_SetOpt+0xbc>
    914c:	ea00005e 	b	92cc <RTMP_SetOpt+0x364>
    9150:	eaffffb3 	b	9024 <RTMP_SetOpt+0xbc>
    9154:	eaffffb2 	b	9024 <RTMP_SetOpt+0xbc>
    9158:	eaffffb1 	b	9024 <RTMP_SetOpt+0xbc>
    915c:	eaffffb0 	b	9024 <RTMP_SetOpt+0xbc>
    9160:	eaffffaf 	b	9024 <RTMP_SetOpt+0xbc>
    9164:	eaffffae 	b	9024 <RTMP_SetOpt+0xbc>
    9168:	eaffffad 	b	9024 <RTMP_SetOpt+0xbc>
    916c:	eaffffac 	b	9024 <RTMP_SetOpt+0xbc>
    9170:	eaffffab 	b	9024 <RTMP_SetOpt+0xbc>
    9174:	eaffffaa 	b	9024 <RTMP_SetOpt+0xbc>
    9178:	eaffffa9 	b	9024 <RTMP_SetOpt+0xbc>
    917c:	ea00004d 	b	92b8 <RTMP_SetOpt+0x350>
    9180:	ea000049 	b	92ac <RTMP_SetOpt+0x344>
    9184:	eaffffa6 	b	9024 <RTMP_SetOpt+0xbc>
    9188:	eaffffa5 	b	9024 <RTMP_SetOpt+0xbc>
    918c:	eaffffa4 	b	9024 <RTMP_SetOpt+0xbc>
    9190:	ea000029 	b	923c <RTMP_SetOpt+0x2d4>
        if (strcasecmp(opt->av_val, options[i].name.av_val)) continue;
        v = (char *)r + options[i].off;
        switch(options[i].otype) {
            case OPT_STR: {
                AVal *aptr = v;
                *aptr = *arg; }
    9194:	e59d300c 	ldr	r3, [sp, #12]
    9198:	e8930003 	ldm	r3, {r0, r1}
    919c:	e8820003 	stm	r2, {r0, r1}
                    return FALSE;
                break;
        }
        break;
    }
    if (!options[i].name.av_len) {
    91a0:	e59f9338 	ldr	r9, [pc, #824]	; 94e0 <RTMP_SetOpt+0x578>
    91a4:	e086600b 	add	r6, r6, fp
    91a8:	e08f9009 	add	r9, pc, r9
    91ac:	e0896186 	add	r6, r9, r6, lsl #3
    91b0:	e5963004 	ldr	r3, [r6, #4]
    91b4:	e3530000 	cmp	r3, #0
    91b8:	1affff98 	bne	9020 <RTMP_SetOpt+0xb8>
        RTMP_Log(RTMP_LOGERROR, "Unknown option %s", opt->av_val);
    91bc:	e59f1320 	ldr	r1, [pc, #800]	; 94e4 <RTMP_SetOpt+0x57c>
    91c0:	e5982000 	ldr	r2, [r8]
    91c4:	e3a00001 	mov	r0, #1
    91c8:	e08f1001 	add	r1, pc, r1
    91cc:	eb0031f6 	bl	159ac <RTMP_Log>

static void RTMP_OptUsage()
{
    int i;
    
    RTMP_Log(RTMP_LOGERROR, "Valid RTMP options are:\n");
    91d0:	e59f1310 	ldr	r1, [pc, #784]	; 94e8 <RTMP_SetOpt+0x580>
    91d4:	e3a00001 	mov	r0, #1
    91d8:	e08f1001 	add	r1, pc, r1
    91dc:	eb0031f2 	bl	159ac <RTMP_Log>
    91e0:	eaffff9b 	b	9054 <RTMP_SetOpt+0xec>
            case OPT_STR: {
                AVal *aptr = v;
                *aptr = *arg; }
                break;
            case OPT_INT: {
                long l = strtol(arg->av_val, NULL, 0);
    91e4:	e59d300c 	ldr	r3, [sp, #12]
    91e8:	e3a01000 	mov	r1, #0
    91ec:	e5930000 	ldr	r0, [r3]
    91f0:	e1a02001 	mov	r2, r1
    91f4:	e58dc010 	str	ip, [sp, #16]
    91f8:	ebfff03b 	bl	52ec <strtol@plt>
                *(int *)v = l; }
    91fc:	e59dc010 	ldr	ip, [sp, #16]
    9200:	e787000c 	str	r0, [r7, ip]
                break;
    9204:	eaffffe5 	b	91a0 <RTMP_SetOpt+0x238>
    9208:	e59d300c 	ldr	r3, [sp, #12]
            case OPT_BOOL: {
                int j, fl;
                fl = *(int *)v;
    920c:	e797500c 	ldr	r5, [r7, ip]
    9210:	e5933004 	ldr	r3, [r3, #4]
                for (j=0; truth[j].av_len; j++) {
                    if (arg->av_len != truth[j].av_len) continue;
    9214:	e3530001 	cmp	r3, #1
    9218:	0a00009a 	beq	9488 <RTMP_SetOpt+0x520>
    921c:	e3530002 	cmp	r3, #2
    9220:	0a00008e 	beq	9460 <RTMP_SetOpt+0x4f8>
    9224:	e3530003 	cmp	r3, #3
    9228:	0a000082 	beq	9438 <RTMP_SetOpt+0x4d0>
    922c:	e3530004 	cmp	r3, #4
    9230:	0a000070 	beq	93f8 <RTMP_SetOpt+0x490>
                    if (strcasecmp(arg->av_val, truth[j].av_val)) continue;
                    fl |= options[i].omisc; break; }
                *(int *)v = fl;
    9234:	e787500c 	str	r5, [r7, ip]
            }
                break;
    9238:	eaffffd8 	b	91a0 <RTMP_SetOpt+0x238>
                prop.p_vu.p_number = atoi(p);
                break;
            case 'S':
                prop.p_type = AMF_STRING;
                prop.p_vu.p_aval.av_val = p;
                prop.p_vu.p_aval.av_len = av->av_len - (p-arg);
    923c:	e59d100c 	ldr	r1, [sp, #12]
    9240:	e0602002 	rsb	r2, r0, r2
    9244:	e5911004 	ldr	r1, [r1, #4]
                prop.p_type = AMF_BOOLEAN;
                prop.p_vu.p_number = atoi(p);
                break;
            case 'S':
                prop.p_type = AMF_STRING;
                prop.p_vu.p_aval.av_val = p;
    9248:	e58d0028 	str	r0, [sp, #40]	; 0x28
                prop.p_vu.p_aval.av_len = av->av_len - (p-arg);
    924c:	e0812002 	add	r2, r1, r2
            case 'B':
                prop.p_type = AMF_BOOLEAN;
                prop.p_vu.p_number = atoi(p);
                break;
            case 'S':
                prop.p_type = AMF_STRING;
    9250:	e3a01002 	mov	r1, #2
                prop.p_vu.p_aval.av_val = p;
                prop.p_vu.p_aval.av_len = av->av_len - (p-arg);
    9254:	e58d202c 	str	r2, [sp, #44]	; 0x2c
            case 'B':
                prop.p_type = AMF_BOOLEAN;
                prop.p_vu.p_number = atoi(p);
                break;
            case 'S':
                prop.p_type = AMF_STRING;
    9258:	e58d1020 	str	r1, [sp, #32]
                    fl |= options[i].omisc; break; }
                *(int *)v = fl;
            }
                break;
            case OPT_CONN:
                if (parseAMF(&r->Link.extras, arg, &r->Link.edepth))
    925c:	e2870c41 	add	r0, r7, #16640	; 0x4100
        return -1;
    
    if (*depth)
    {
        AMFObject *o2;
        for (i=0; i<*depth; i++)
    9260:	e3530000 	cmp	r3, #0
                    fl |= options[i].omisc; break; }
                *(int *)v = fl;
            }
                break;
            case OPT_CONN:
                if (parseAMF(&r->Link.extras, arg, &r->Link.edepth))
    9264:	e280006c 	add	r0, r0, #108	; 0x6c
        return -1;
    
    if (*depth)
    {
        AMFObject *o2;
        for (i=0; i<*depth; i++)
    9268:	da000007 	ble	928c <RTMP_SetOpt+0x324>
    926c:	e3a02000 	mov	r2, #0
        {
            o2 = &obj->o_props[obj->o_num-1].p_vu.p_object;
    9270:	e5901000 	ldr	r1, [r0]
    9274:	e5900004 	ldr	r0, [r0, #4]
        return -1;
    
    if (*depth)
    {
        AMFObject *o2;
        for (i=0; i<*depth; i++)
    9278:	e2822001 	add	r2, r2, #1
        {
            o2 = &obj->o_props[obj->o_num-1].p_vu.p_object;
    927c:	e0800281 	add	r0, r0, r1, lsl #5
        return -1;
    
    if (*depth)
    {
        AMFObject *o2;
        for (i=0; i<*depth; i++)
    9280:	e1520003 	cmp	r2, r3
        {
            o2 = &obj->o_props[obj->o_num-1].p_vu.p_object;
    9284:	e2400010 	sub	r0, r0, #16
        return -1;
    
    if (*depth)
    {
        AMFObject *o2;
        for (i=0; i<*depth; i++)
    9288:	1afffff8 	bne	9270 <RTMP_SetOpt+0x308>
        {
            o2 = &obj->o_props[obj->o_num-1].p_vu.p_object;
            obj = o2;
        }
    }
    AMF_AddProp(obj, &prop);
    928c:	e28d1018 	add	r1, sp, #24
    9290:	eb003546 	bl	167b0 <AMF_AddProp>
    if (prop.p_type == AMF_OBJECT)
    9294:	e59d3020 	ldr	r3, [sp, #32]
    9298:	e3530003 	cmp	r3, #3
        (*depth)++;
    929c:	05993174 	ldreq	r3, [r9, #372]	; 0x174
    92a0:	02833001 	addeq	r3, r3, #1
    92a4:	05893174 	streq	r3, [r9, #372]	; 0x174
    92a8:	eaffffbc 	b	91a0 <RTMP_SetOpt+0x238>
            case 'N':
                prop.p_type = AMF_NUMBER;
                prop.p_vu.p_number = strtod(p, NULL);
                break;
            case 'O':
                prop.p_type = AMF_OBJECT;
    92ac:	e3a02003 	mov	r2, #3
    92b0:	e58d2020 	str	r2, [sp, #32]
    92b4:	eaffffe8 	b	925c <RTMP_SetOpt+0x2f4>
                prop.p_vu.p_aval.av_val = p;
                prop.p_vu.p_aval.av_len = av->av_len - (p-arg);
                break;
            case 'N':
                prop.p_type = AMF_NUMBER;
                prop.p_vu.p_number = strtod(p, NULL);
    92b8:	e3a01000 	mov	r1, #0
    92bc:	ebfff00d 	bl	52f8 <strtod@plt>
    92c0:	e5993174 	ldr	r3, [r9, #372]	; 0x174
    92c4:	e1cd02f8 	strd	r0, [sp, #40]	; 0x28
    92c8:	eaffffe3 	b	925c <RTMP_SetOpt+0x2f4>
        
        p++;
        switch(arg[1])
        {
            case 'B':
                prop.p_type = AMF_BOOLEAN;
    92cc:	e3a03001 	mov	r3, #1
    92d0:	e58d3020 	str	r3, [sp, #32]
                prop.p_vu.p_number = atoi(p);
    92d4:	ebffef8c 	bl	510c <atoi@plt>
    92d8:	eb004abb 	bl	1bdcc <__aeabi_i2d>
    92dc:	e5993174 	ldr	r3, [r9, #372]	; 0x174
    92e0:	e1cd02f8 	strd	r0, [sp, #40]	; 0x28
    92e4:	eaffffdc 	b	925c <RTMP_SetOpt+0x2f4>
    char *p, *arg = av->av_val;
    
    if (arg[1] == ':')
    {
        p = (char *)arg+2;
        switch(arg[0])
    92e8:	e5d23000 	ldrb	r3, [r2]
    int i;
    char *p, *arg = av->av_val;
    
    if (arg[1] == ':')
    {
        p = (char *)arg+2;
    92ec:	e2820002 	add	r0, r2, #2
        switch(arg[0])
    92f0:	e2433042 	sub	r3, r3, #66	; 0x42
    92f4:	e3530018 	cmp	r3, #24
    92f8:	908ff103 	addls	pc, pc, r3, lsl #2
    92fc:	eaffff48 	b	9024 <RTMP_SetOpt+0xbc>
    9300:	ea000034 	b	93d8 <RTMP_SetOpt+0x470>
    9304:	eaffff46 	b	9024 <RTMP_SetOpt+0xbc>
    9308:	eaffff45 	b	9024 <RTMP_SetOpt+0xbc>
    930c:	eaffff44 	b	9024 <RTMP_SetOpt+0xbc>
    9310:	eaffff43 	b	9024 <RTMP_SetOpt+0xbc>
    9314:	eaffff42 	b	9024 <RTMP_SetOpt+0xbc>
    9318:	eaffff41 	b	9024 <RTMP_SetOpt+0xbc>
    931c:	eaffff40 	b	9024 <RTMP_SetOpt+0xbc>
    9320:	eaffff3f 	b	9024 <RTMP_SetOpt+0xbc>
    9324:	eaffff3e 	b	9024 <RTMP_SetOpt+0xbc>
    9328:	eaffff3d 	b	9024 <RTMP_SetOpt+0xbc>
    932c:	eaffff3c 	b	9024 <RTMP_SetOpt+0xbc>
    9330:	ea000022 	b	93c0 <RTMP_SetOpt+0x458>
    9334:	ea000019 	b	93a0 <RTMP_SetOpt+0x438>
    9338:	eaffff39 	b	9024 <RTMP_SetOpt+0xbc>
    933c:	eaffff38 	b	9024 <RTMP_SetOpt+0xbc>
    9340:	eaffff37 	b	9024 <RTMP_SetOpt+0xbc>
    9344:	ea00000b 	b	9378 <RTMP_SetOpt+0x410>
    9348:	eaffff35 	b	9024 <RTMP_SetOpt+0xbc>
    934c:	eaffff34 	b	9024 <RTMP_SetOpt+0xbc>
    9350:	eaffff33 	b	9024 <RTMP_SetOpt+0xbc>
    9354:	eaffff32 	b	9024 <RTMP_SetOpt+0xbc>
    9358:	eaffff31 	b	9024 <RTMP_SetOpt+0xbc>
    935c:	eaffff30 	b	9024 <RTMP_SetOpt+0xbc>
    9360:	eaffffff 	b	9364 <RTMP_SetOpt+0x3fc>
            case 'N':
                prop.p_type = AMF_NUMBER;
                prop.p_vu.p_number = strtod(p, NULL);
                break;
            case 'Z':
                prop.p_type = AMF_NULL;
    9364:	e3a03005 	mov	r3, #5
    9368:	e2879901 	add	r9, r7, #16384	; 0x4000
    936c:	e58d3020 	str	r3, [sp, #32]
    9370:	e5993174 	ldr	r3, [r9, #372]	; 0x174
    9374:	eaffffb8 	b	925c <RTMP_SetOpt+0x2f4>
                prop.p_vu.p_number = atoi(p);
                break;
            case 'S':
                prop.p_type = AMF_STRING;
                prop.p_vu.p_aval.av_val = p;
                prop.p_vu.p_aval.av_len = av->av_len - (p-arg);
    9378:	e59d300c 	ldr	r3, [sp, #12]
            case 'B':
                prop.p_type = AMF_BOOLEAN;
                prop.p_vu.p_number = atoi(p);
                break;
            case 'S':
                prop.p_type = AMF_STRING;
    937c:	e3a02002 	mov	r2, #2
                prop.p_vu.p_aval.av_val = p;
                prop.p_vu.p_aval.av_len = av->av_len - (p-arg);
    9380:	e5933004 	ldr	r3, [r3, #4]
    9384:	e2879901 	add	r9, r7, #16384	; 0x4000
    9388:	e2433002 	sub	r3, r3, #2
    938c:	e58d302c 	str	r3, [sp, #44]	; 0x2c
                prop.p_type = AMF_BOOLEAN;
                prop.p_vu.p_number = atoi(p);
                break;
            case 'S':
                prop.p_type = AMF_STRING;
                prop.p_vu.p_aval.av_val = p;
    9390:	e58d0028 	str	r0, [sp, #40]	; 0x28
            case 'B':
                prop.p_type = AMF_BOOLEAN;
                prop.p_vu.p_number = atoi(p);
                break;
            case 'S':
                prop.p_type = AMF_STRING;
    9394:	e58d2020 	str	r2, [sp, #32]
    9398:	e5993174 	ldr	r3, [r9, #372]	; 0x174
    939c:	eaffffae 	b	925c <RTMP_SetOpt+0x2f4>
                break;
            case 'Z':
                prop.p_type = AMF_NULL;
                break;
            case 'O':
                i = atoi(p);
    93a0:	ebffef59 	bl	510c <atoi@plt>
                if (i)
    93a4:	e3500000 	cmp	r0, #0
    93a8:	0a000040 	beq	94b0 <RTMP_SetOpt+0x548>
                {
                    prop.p_type = AMF_OBJECT;
    93ac:	e3a03003 	mov	r3, #3
    93b0:	e2879901 	add	r9, r7, #16384	; 0x4000
    93b4:	e58d3020 	str	r3, [sp, #32]
    93b8:	e5993174 	ldr	r3, [r9, #372]	; 0x174
    93bc:	eaffffa6 	b	925c <RTMP_SetOpt+0x2f4>
                prop.p_vu.p_aval.av_val = p;
                prop.p_vu.p_aval.av_len = av->av_len - (p-arg);
                break;
            case 'N':
                prop.p_type = AMF_NUMBER;
                prop.p_vu.p_number = strtod(p, NULL);
    93c0:	e3a01000 	mov	r1, #0
    93c4:	ebffefcb 	bl	52f8 <strtod@plt>
    93c8:	e2879901 	add	r9, r7, #16384	; 0x4000
    93cc:	e5993174 	ldr	r3, [r9, #372]	; 0x174
    93d0:	e1cd02f8 	strd	r0, [sp, #40]	; 0x28
    93d4:	eaffffa0 	b	925c <RTMP_SetOpt+0x2f4>
    {
        p = (char *)arg+2;
        switch(arg[0])
        {
            case 'B':
                prop.p_type = AMF_BOOLEAN;
    93d8:	e3a03001 	mov	r3, #1
    93dc:	e58d3020 	str	r3, [sp, #32]
                prop.p_vu.p_number = atoi(p);
    93e0:	ebffef49 	bl	510c <atoi@plt>
    93e4:	eb004a78 	bl	1bdcc <__aeabi_i2d>
    93e8:	e2879901 	add	r9, r7, #16384	; 0x4000
    93ec:	e5993174 	ldr	r3, [r9, #372]	; 0x174
    93f0:	e1cd02f8 	strd	r0, [sp, #40]	; 0x28
    93f4:	eaffff98 	b	925c <RTMP_SetOpt+0x2f4>
            case OPT_BOOL: {
                int j, fl;
                fl = *(int *)v;
                for (j=0; truth[j].av_len; j++) {
                    if (arg->av_len != truth[j].av_len) continue;
                    if (strcasecmp(arg->av_val, truth[j].av_val)) continue;
    93f8:	e59d300c 	ldr	r3, [sp, #12]
    93fc:	e59f10e8 	ldr	r1, [pc, #232]	; 94ec <RTMP_SetOpt+0x584>
    9400:	e5930000 	ldr	r0, [r3]
    9404:	e08f1001 	add	r1, pc, r1
    9408:	e58dc010 	str	ip, [sp, #16]
    940c:	ebffefb3 	bl	52e0 <strcasecmp@plt>
    9410:	e59dc010 	ldr	ip, [sp, #16]
    9414:	e3500000 	cmp	r0, #0
    9418:	1affff85 	bne	9234 <RTMP_SetOpt+0x2cc>
                    fl |= options[i].omisc; break; }
    941c:	e59f30cc 	ldr	r3, [pc, #204]	; 94f0 <RTMP_SetOpt+0x588>
    9420:	e086200b 	add	r2, r6, fp
    9424:	e08f3003 	add	r3, pc, r3
    9428:	e0833182 	add	r3, r3, r2, lsl #3
    942c:	e5933010 	ldr	r3, [r3, #16]
    9430:	e1855003 	orr	r5, r5, r3
    9434:	eaffff7e 	b	9234 <RTMP_SetOpt+0x2cc>
            case OPT_BOOL: {
                int j, fl;
                fl = *(int *)v;
                for (j=0; truth[j].av_len; j++) {
                    if (arg->av_len != truth[j].av_len) continue;
                    if (strcasecmp(arg->av_val, truth[j].av_val)) continue;
    9438:	e59d300c 	ldr	r3, [sp, #12]
    943c:	e59f10b0 	ldr	r1, [pc, #176]	; 94f4 <RTMP_SetOpt+0x58c>
    9440:	e5930000 	ldr	r0, [r3]
    9444:	e08f1001 	add	r1, pc, r1
    9448:	e58dc010 	str	ip, [sp, #16]
    944c:	ebffefa3 	bl	52e0 <strcasecmp@plt>
    9450:	e59dc010 	ldr	ip, [sp, #16]
    9454:	e3500000 	cmp	r0, #0
    9458:	1affff75 	bne	9234 <RTMP_SetOpt+0x2cc>
    945c:	eaffffee 	b	941c <RTMP_SetOpt+0x4b4>
    9460:	e59d300c 	ldr	r3, [sp, #12]
    9464:	e59f108c 	ldr	r1, [pc, #140]	; 94f8 <RTMP_SetOpt+0x590>
    9468:	e5930000 	ldr	r0, [r3]
    946c:	e08f1001 	add	r1, pc, r1
    9470:	e58dc010 	str	ip, [sp, #16]
    9474:	ebffef99 	bl	52e0 <strcasecmp@plt>
    9478:	e59dc010 	ldr	ip, [sp, #16]
    947c:	e3500000 	cmp	r0, #0
    9480:	1affff6b 	bne	9234 <RTMP_SetOpt+0x2cc>
    9484:	eaffffe4 	b	941c <RTMP_SetOpt+0x4b4>
    9488:	e59d300c 	ldr	r3, [sp, #12]
    948c:	e59f1068 	ldr	r1, [pc, #104]	; 94fc <RTMP_SetOpt+0x594>
    9490:	e5930000 	ldr	r0, [r3]
    9494:	e08f1001 	add	r1, pc, r1
    9498:	e58dc010 	str	ip, [sp, #16]
    949c:	ebffef8f 	bl	52e0 <strcasecmp@plt>
    94a0:	e59dc010 	ldr	ip, [sp, #16]
    94a4:	e3500000 	cmp	r0, #0
    94a8:	1affff61 	bne	9234 <RTMP_SetOpt+0x2cc>
    94ac:	eaffffda 	b	941c <RTMP_SetOpt+0x4b4>
                {
                    prop.p_type = AMF_OBJECT;
                }
                else
                {
                    (*depth)--;
    94b0:	e2877901 	add	r7, r7, #16384	; 0x4000
    94b4:	e5973174 	ldr	r3, [r7, #372]	; 0x174
    94b8:	e2433001 	sub	r3, r3, #1
    94bc:	e5873174 	str	r3, [r7, #372]	; 0x174
    94c0:	eaffff36 	b	91a0 <RTMP_SetOpt+0x238>
    94c4:	0001a8d4 	.word	0x0001a8d4
    94c8:	0001a874 	.word	0x0001a874
    94cc:	0001a83c 	.word	0x0001a83c
    94d0:	00015990 	.word	0x00015990
    94d4:	00015990 	.word	0x00015990
    94d8:	0001599c 	.word	0x0001599c
    94dc:	0001a7e8 	.word	0x0001a7e8
    94e0:	0001a6a0 	.word	0x0001a6a0
    94e4:	00015800 	.word	0x00015800
    94e8:	00015804 	.word	0x00015804
    94ec:	000155bc 	.word	0x000155bc
    94f0:	0001a424 	.word	0x0001a424
    94f4:	00015420 	.word	0x00015420
    94f8:	00015550 	.word	0x00015550
    94fc:	00015524 	.word	0x00015524

00009500 <RTMP_SetupURL>:
    return TRUE;
}


int RTMP_SetupURL(RTMP *r, char *url)
{
    9500:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9504:	e1a0a001 	mov	sl, r1
    9508:	e24dd04c 	sub	sp, sp, #76	; 0x4c
    AVal opt, arg;
    char *p1, *p2, *ptr = strchr(url, ' ');
    950c:	e3a01020 	mov	r1, #32
    return TRUE;
}


int RTMP_SetupURL(RTMP *r, char *url)
{
    9510:	e58d001c 	str	r0, [sp, #28]
    AVal opt, arg;
    char *p1, *p2, *ptr = strchr(url, ' ');
    9514:	e1a0000a 	mov	r0, sl
    9518:	ebffeef2 	bl	50e8 <strchr@plt>
    
    if (ptr)
        *ptr = '\0';
    
    len = strlen(url);
    ret = RTMP_ParseURL(url, &r->Link.protocol, &r->Link.hostname,
    951c:	e59d501c 	ldr	r5, [sp, #28]
int RTMP_SetupURL(RTMP *r, char *url)
{
    AVal opt, arg;
    char *p1, *p2, *ptr = strchr(url, ' ');
    int ret, len;
    unsigned int port = 0;
    9520:	e3a03000 	mov	r3, #0
    9524:	e58d3030 	str	r3, [sp, #48]	; 0x30
    
    if (ptr)
        *ptr = '\0';
    
    len = strlen(url);
    ret = RTMP_ParseURL(url, &r->Link.protocol, &r->Link.hostname,
    9528:	e2856901 	add	r6, r5, #16384	; 0x4000
    AVal opt, arg;
    char *p1, *p2, *ptr = strchr(url, ' ');
    int ret, len;
    unsigned int port = 0;
    
    if (ptr)
    952c:	e250b000 	subs	fp, r0, #0
        *ptr = '\0';
    9530:	15cb3000 	strbne	r3, [fp]
    
    len = strlen(url);
    9534:	e1a0000a 	mov	r0, sl
    ret = RTMP_ParseURL(url, &r->Link.protocol, &r->Link.hostname,
    9538:	e2853c41 	add	r3, r5, #16640	; 0x4100
    953c:	e1a04003 	mov	r4, r3
    9540:	e58d3024 	str	r3, [sp, #36]	; 0x24
    unsigned int port = 0;
    
    if (ptr)
        *ptr = '\0';
    
    len = strlen(url);
    9544:	ebffeeed 	bl	5100 <strlen@plt>
    ret = RTMP_ParseURL(url, &r->Link.protocol, &r->Link.hostname,
    9548:	e2842004 	add	r2, r4, #4
    954c:	e284302c 	add	r3, r4, #44	; 0x2c
    9550:	e88d000c 	stm	sp, {r2, r3}
    9554:	e2841088 	add	r1, r4, #136	; 0x88
    9558:	e28620f4 	add	r2, r6, #244	; 0xf4
    955c:	e28d3030 	add	r3, sp, #48	; 0x30
    unsigned int port = 0;
    
    if (ptr)
        *ptr = '\0';
    
    len = strlen(url);
    9560:	e58d0020 	str	r0, [sp, #32]
    ret = RTMP_ParseURL(url, &r->Link.protocol, &r->Link.hostname,
    9564:	e1a0000a 	mov	r0, sl
    9568:	eb003e47 	bl	18e8c <RTMP_ParseURL>
                        &port, &r->Link.playpath0, &r->Link.app);
    printf(" %.*s     %.*s   \n",r->Link.hostname.av_len,r->Link.hostname.av_val,r->Link.app.av_len,r->Link.app.av_val);
    956c:	e59610f8 	ldr	r1, [r6, #248]	; 0xf8
    9570:	e59620f4 	ldr	r2, [r6, #244]	; 0xf4
    9574:	e5963130 	ldr	r3, [r6, #304]	; 0x130
    
    if (ptr)
        *ptr = '\0';
    
    len = strlen(url);
    ret = RTMP_ParseURL(url, &r->Link.protocol, &r->Link.hostname,
    9578:	e1a04000 	mov	r4, r0
                        &port, &r->Link.playpath0, &r->Link.app);
    printf(" %.*s     %.*s   \n",r->Link.hostname.av_len,r->Link.hostname.av_val,r->Link.app.av_len,r->Link.app.av_val);
    957c:	e596012c 	ldr	r0, [r6, #300]	; 0x12c
    9580:	e58d0000 	str	r0, [sp]
    9584:	e59f0390 	ldr	r0, [pc, #912]	; 991c <RTMP_SetupURL+0x41c>
    9588:	e08f0000 	add	r0, pc, r0
    958c:	ebffef5c 	bl	5304 <printf@plt>
    if (!ret)
    9590:	e3540000 	cmp	r4, #0
    9594:	1a000002 	bne	95a4 <RTMP_SetupURL+0xa4>
        for (p1=p2; port >0;) {
            if (*p1 == '\\')
            {
                unsigned int c;
                if (port < 3)
                    return FALSE;
    9598:	e3a00000 	mov	r0, #0
        else
            r->Link.port = 1935;
    }
    
    return TRUE;
}
    959c:	e28dd04c 	add	sp, sp, #76	; 0x4c
    95a0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
                        &port, &r->Link.playpath0, &r->Link.app);
    printf(" %.*s     %.*s   \n",r->Link.hostname.av_len,r->Link.hostname.av_val,r->Link.app.av_len,r->Link.app.av_val);
    if (!ret)
        return ret;
    r->Link.port = port;
    r->Link.playpath = r->Link.playpath0;
    95a4:	e2863f41 	add	r3, r6, #260	; 0x104
    95a8:	e8930003 	ldm	r3, {r0, r1}
    ret = RTMP_ParseURL(url, &r->Link.protocol, &r->Link.hostname,
                        &port, &r->Link.playpath0, &r->Link.app);
    printf(" %.*s     %.*s   \n",r->Link.hostname.av_len,r->Link.hostname.av_val,r->Link.app.av_len,r->Link.app.av_val);
    if (!ret)
        return ret;
    r->Link.port = port;
    95ac:	e2862f65 	add	r2, r6, #404	; 0x194
    95b0:	e59de030 	ldr	lr, [sp, #48]	; 0x30
    r->Link.playpath = r->Link.playpath0;
    95b4:	e2863f43 	add	r3, r6, #268	; 0x10c
    ret = RTMP_ParseURL(url, &r->Link.protocol, &r->Link.hostname,
                        &port, &r->Link.playpath0, &r->Link.app);
    printf(" %.*s     %.*s   \n",r->Link.hostname.av_len,r->Link.hostname.av_val,r->Link.app.av_len,r->Link.app.av_val);
    if (!ret)
        return ret;
    r->Link.port = port;
    95b8:	e1c2e0b2 	strh	lr, [r2, #2]
    r->Link.playpath = r->Link.playpath0;
    95bc:	e8830003 	stm	r3, {r0, r1}
    
    RTMP_Log(RTMP_LOGINFO,"playpath:%.*s",r->Link.playpath.av_len,r->Link.playpath.av_val);
    95c0:	e59f1358 	ldr	r1, [pc, #856]	; 9920 <RTMP_SetupURL+0x420>
    95c4:	e3a00003 	mov	r0, #3
    95c8:	e5962110 	ldr	r2, [r6, #272]	; 0x110
    95cc:	e596310c 	ldr	r3, [r6, #268]	; 0x10c
    95d0:	e08f1001 	add	r1, pc, r1
    95d4:	eb0030f4 	bl	159ac <RTMP_Log>
    while (ptr) {
    95d8:	e35b0000 	cmp	fp, #0
    95dc:	0a000052 	beq	972c <RTMP_SetupURL+0x22c>
            if (*p1 == '\\')
            {
                unsigned int c;
                if (port < 3)
                    return FALSE;
                sscanf(p1+1, "%02x", &c);
    95e0:	e59f833c 	ldr	r8, [pc, #828]	; 9924 <RTMP_SetupURL+0x424>
                port--;
            }
        }
        arg.av_len = p2 - arg.av_val;
        
        ret = RTMP_SetOpt(r, &opt, &arg);
    95e4:	e28d3038 	add	r3, sp, #56	; 0x38
    95e8:	e59d901c 	ldr	r9, [sp, #28]
    95ec:	e58d602c 	str	r6, [sp, #44]	; 0x2c
            if (*p1 == '\\')
            {
                unsigned int c;
                if (port < 3)
                    return FALSE;
                sscanf(p1+1, "%02x", &c);
    95f0:	e08f8008 	add	r8, pc, r8
                port--;
            }
        }
        arg.av_len = p2 - arg.av_val;
        
        ret = RTMP_SetOpt(r, &opt, &arg);
    95f4:	e1a0600b 	mov	r6, fp
    r->Link.port = port;
    r->Link.playpath = r->Link.playpath0;
    
    RTMP_Log(RTMP_LOGINFO,"playpath:%.*s",r->Link.playpath.av_len,r->Link.playpath.av_val);
    while (ptr) {
        *ptr++ = '\0';
    95f8:	e3a05000 	mov	r5, #0
            if (*p1 == '\\')
            {
                unsigned int c;
                if (port < 3)
                    return FALSE;
                sscanf(p1+1, "%02x", &c);
    95fc:	e28d7034 	add	r7, sp, #52	; 0x34
                port--;
            }
        }
        arg.av_len = p2 - arg.av_val;
        
        ret = RTMP_SetOpt(r, &opt, &arg);
    9600:	e1a0b003 	mov	fp, r3
    9604:	e58da028 	str	sl, [sp, #40]	; 0x28
    r->Link.port = port;
    r->Link.playpath = r->Link.playpath0;
    
    RTMP_Log(RTMP_LOGINFO,"playpath:%.*s",r->Link.playpath.av_len,r->Link.playpath.av_val);
    while (ptr) {
        *ptr++ = '\0';
    9608:	e286a001 	add	sl, r6, #1
    960c:	e5c65000 	strb	r5, [r6]
        p1 = ptr;
        p2 = strchr(p1, '=');
    9610:	e1a0000a 	mov	r0, sl
    9614:	e3a0103d 	mov	r1, #61	; 0x3d
    9618:	ebffeeb2 	bl	50e8 <strchr@plt>
        if (!p2)
    961c:	e3500000 	cmp	r0, #0
    9620:	0a00003f 	beq	9724 <RTMP_SetupURL+0x224>
            break;
        opt.av_val = p1;
        opt.av_len = p2 - p1;
        *p2++ = '\0';
    9624:	e2804001 	add	r4, r0, #1
        p1 = ptr;
        p2 = strchr(p1, '=');
        if (!p2)
            break;
        opt.av_val = p1;
        opt.av_len = p2 - p1;
    9628:	e06a2000 	rsb	r2, sl, r0
        *p2++ = '\0';
    962c:	e5c05000 	strb	r5, [r0]
        arg.av_val = p2;
        ptr = strchr(p2, ' ');
    9630:	e3a01020 	mov	r1, #32
    9634:	e1a00004 	mov	r0, r4
        *ptr++ = '\0';
        p1 = ptr;
        p2 = strchr(p1, '=');
        if (!p2)
            break;
        opt.av_val = p1;
    9638:	e58da038 	str	sl, [sp, #56]	; 0x38
        opt.av_len = p2 - p1;
    963c:	e58d203c 	str	r2, [sp, #60]	; 0x3c
        *p2++ = '\0';
        arg.av_val = p2;
    9640:	e58d4040 	str	r4, [sp, #64]	; 0x40
        ptr = strchr(p2, ' ');
    9644:	ebffeea7 	bl	50e8 <strchr@plt>
        if (ptr) {
    9648:	e2506000 	subs	r6, r0, #0
    964c:	0a00005e 	beq	97cc <RTMP_SetupURL+0x2cc>
            *ptr = '\0';
            arg.av_len = ptr - p2;
            /* skip repeated spaces */
            while(ptr[1] == ' ')
    9650:	e5d63001 	ldrb	r3, [r6, #1]
        *p2++ = '\0';
        arg.av_val = p2;
        ptr = strchr(p2, ' ');
        if (ptr) {
            *ptr = '\0';
            arg.av_len = ptr - p2;
    9654:	e0640006 	rsb	r0, r4, r6
            /* skip repeated spaces */
            while(ptr[1] == ' ')
    9658:	e3530020 	cmp	r3, #32
        opt.av_len = p2 - p1;
        *p2++ = '\0';
        arg.av_val = p2;
        ptr = strchr(p2, ' ');
        if (ptr) {
            *ptr = '\0';
    965c:	e5c65000 	strb	r5, [r6]
            arg.av_len = ptr - p2;
    9660:	e58d0044 	str	r0, [sp, #68]	; 0x44
            /* skip repeated spaces */
            while(ptr[1] == ' ')
    9664:	1a000008 	bne	968c <RTMP_SetupURL+0x18c>
    9668:	e2863001 	add	r3, r6, #1
    966c:	e1a02003 	mov	r2, r3
    9670:	ea000000 	b	9678 <RTMP_SetupURL+0x178>
    9674:	e2833001 	add	r3, r3, #1
                *ptr++ = '\0';
    9678:	e5435001 	strb	r5, [r3, #-1]
        ptr = strchr(p2, ' ');
        if (ptr) {
            *ptr = '\0';
            arg.av_len = ptr - p2;
            /* skip repeated spaces */
            while(ptr[1] == ' ')
    967c:	e5f21001 	ldrb	r1, [r2, #1]!
                *ptr++ = '\0';
    9680:	e1a06003 	mov	r6, r3
        ptr = strchr(p2, ' ');
        if (ptr) {
            *ptr = '\0';
            arg.av_len = ptr - p2;
            /* skip repeated spaces */
            while(ptr[1] == ' ')
    9684:	e3510020 	cmp	r1, #32
    9688:	0afffff9 	beq	9674 <RTMP_SetupURL+0x174>
        } else {
            arg.av_len = strlen(p2);
        }
        
        /* unescape */
        port = arg.av_len;
    968c:	e1a0e000 	mov	lr, r0
    9690:	e58d0030 	str	r0, [sp, #48]	; 0x30
    9694:	e1a0a004 	mov	sl, r4
        for (p1=p2; port >0;) {
    9698:	ea000004 	b	96b0 <RTMP_SetupURL+0x1b0>
                p1 += 3;
            }
            else
            {
                *p2++ = *p1++;
                port--;
    969c:	e24ee001 	sub	lr, lr, #1
                port -= 3;
                p1 += 3;
            }
            else
            {
                *p2++ = *p1++;
    96a0:	e2844001 	add	r4, r4, #1
                port--;
    96a4:	e58de030 	str	lr, [sp, #48]	; 0x30
                port -= 3;
                p1 += 3;
            }
            else
            {
                *p2++ = *p1++;
    96a8:	e5ca3000 	strb	r3, [sl]
    96ac:	e28aa001 	add	sl, sl, #1
            arg.av_len = strlen(p2);
        }
        
        /* unescape */
        port = arg.av_len;
        for (p1=p2; port >0;) {
    96b0:	e35e0000 	cmp	lr, #0
    96b4:	0a00000f 	beq	96f8 <RTMP_SetupURL+0x1f8>
            if (*p1 == '\\')
    96b8:	e5d43000 	ldrb	r3, [r4]
    96bc:	e353005c 	cmp	r3, #92	; 0x5c
    96c0:	1afffff5 	bne	969c <RTMP_SetupURL+0x19c>
            {
                unsigned int c;
                if (port < 3)
    96c4:	e35e0002 	cmp	lr, #2
                    return FALSE;
                sscanf(p1+1, "%02x", &c);
    96c8:	e2840001 	add	r0, r4, #1
    96cc:	e1a01008 	mov	r1, r8
    96d0:	e1a02007 	mov	r2, r7
        port = arg.av_len;
        for (p1=p2; port >0;) {
            if (*p1 == '\\')
            {
                unsigned int c;
                if (port < 3)
    96d4:	9affffaf 	bls	9598 <RTMP_SetupURL+0x98>
                    return FALSE;
                sscanf(p1+1, "%02x", &c);
    96d8:	ebffef0c 	bl	5310 <sscanf@plt>
                *p2++ = c;
                port -= 3;
    96dc:	e59de030 	ldr	lr, [sp, #48]	; 0x30
            {
                unsigned int c;
                if (port < 3)
                    return FALSE;
                sscanf(p1+1, "%02x", &c);
                *p2++ = c;
    96e0:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
                port -= 3;
    96e4:	e24ee003 	sub	lr, lr, #3
                p1 += 3;
    96e8:	e2844003 	add	r4, r4, #3
                unsigned int c;
                if (port < 3)
                    return FALSE;
                sscanf(p1+1, "%02x", &c);
                *p2++ = c;
                port -= 3;
    96ec:	e58de030 	str	lr, [sp, #48]	; 0x30
            {
                unsigned int c;
                if (port < 3)
                    return FALSE;
                sscanf(p1+1, "%02x", &c);
                *p2++ = c;
    96f0:	e5ca3000 	strb	r3, [sl]
    96f4:	eaffffec 	b	96ac <RTMP_SetupURL+0x1ac>
            {
                *p2++ = *p1++;
                port--;
            }
        }
        arg.av_len = p2 - arg.av_val;
    96f8:	e59d2040 	ldr	r2, [sp, #64]	; 0x40
        
        ret = RTMP_SetOpt(r, &opt, &arg);
    96fc:	e1a00009 	mov	r0, r9
            {
                *p2++ = *p1++;
                port--;
            }
        }
        arg.av_len = p2 - arg.av_val;
    9700:	e062300a 	rsb	r3, r2, sl
        
        ret = RTMP_SetOpt(r, &opt, &arg);
    9704:	e1a0100b 	mov	r1, fp
    9708:	e28d2040 	add	r2, sp, #64	; 0x40
            {
                *p2++ = *p1++;
                port--;
            }
        }
        arg.av_len = p2 - arg.av_val;
    970c:	e58d3044 	str	r3, [sp, #68]	; 0x44
        
        ret = RTMP_SetOpt(r, &opt, &arg);
    9710:	ebfffe14 	bl	8f68 <RTMP_SetOpt>
        if (!ret)
    9714:	e3500000 	cmp	r0, #0
    9718:	0affff9e 	beq	9598 <RTMP_SetupURL+0x98>
        return ret;
    r->Link.port = port;
    r->Link.playpath = r->Link.playpath0;
    
    RTMP_Log(RTMP_LOGINFO,"playpath:%.*s",r->Link.playpath.av_len,r->Link.playpath.av_val);
    while (ptr) {
    971c:	e3560000 	cmp	r6, #0
    9720:	1affffb8 	bne	9608 <RTMP_SetupURL+0x108>
    9724:	e59da028 	ldr	sl, [sp, #40]	; 0x28
    9728:	e59d602c 	ldr	r6, [sp, #44]	; 0x2c
        ret = RTMP_SetOpt(r, &opt, &arg);
        if (!ret)
            return ret;
    }
    
    if (!r->Link.tcUrl.av_len)
    972c:	e5962118 	ldr	r2, [r6, #280]	; 0x118
    9730:	e3520000 	cmp	r2, #0
    9734:	0a00002c 	beq	97ec <RTMP_SetupURL+0x2ec>
        {
            printf("tcurl len:%d \n",strlen(url));
            r->Link.tcUrl.av_len = strlen(url);
        }
    }
    LOGE("tcurl: %s   %d\n",r->Link.tcUrl.av_val,r->Link.tcUrl.av_len);
    9738:	e59f01e8 	ldr	r0, [pc, #488]	; 9928 <RTMP_SetupURL+0x428>
    973c:	e5961114 	ldr	r1, [r6, #276]	; 0x114
    9740:	e08f0000 	add	r0, pc, r0
    9744:	ebffeeee 	bl	5304 <printf@plt>
    
#ifdef CRYPTO
    if ((r->Link.lFlags & RTMP_LF_SWFV) && r->Link.swfUrl.av_len)
    9748:	e5963180 	ldr	r3, [r6, #384]	; 0x180
    974c:	e3130004 	tst	r3, #4
    9750:	0a000008 	beq	9778 <RTMP_SetupURL+0x278>
    9754:	e5963120 	ldr	r3, [r6, #288]	; 0x120
    9758:	e3530000 	cmp	r3, #0
    975c:	0a000005 	beq	9778 <RTMP_SetupURL+0x278>
        RTMP_HashSWF(r->Link.swfUrl.av_val, &r->Link.SWFSize,
    9760:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    9764:	e596011c 	ldr	r0, [r6, #284]	; 0x11c
    9768:	e28310a4 	add	r1, r3, #164	; 0xa4
    976c:	e28320a8 	add	r2, r3, #168	; 0xa8
    9770:	e5963184 	ldr	r3, [r6, #388]	; 0x184
    9774:	eb003a0f 	bl	17fb8 <RTMP_HashSWF>
{ (char *)DEFAULT_FLASH_VER, sizeof(DEFAULT_FLASH_VER) - 1 };

static void
SocksSetup(RTMP *r, AVal *sockshost)
{
    if (sockshost->av_len)
    9778:	e5963100 	ldr	r3, [r6, #256]	; 0x100
    977c:	e3530000 	cmp	r3, #0
    9780:	1a000015 	bne	97dc <RTMP_SetupURL+0x2dc>
    }
    else
    {
        r->Link.sockshost.av_val = NULL;
        r->Link.sockshost.av_len = 0;
        r->Link.socksport = 0;
    9784:	e2862f65 	add	r2, r6, #404	; 0x194
        RTMP_Log(RTMP_LOGDEBUG, "Connecting via SOCKS proxy: %s:%d", r->Link.sockshost.av_val,
                 r->Link.socksport);
    }
    else
    {
        r->Link.sockshost.av_val = NULL;
    9788:	e58630fc 	str	r3, [r6, #252]	; 0xfc
        r->Link.sockshost.av_len = 0;
    978c:	e5863100 	str	r3, [r6, #256]	; 0x100
        r->Link.socksport = 0;
    9790:	e1c230b0 	strh	r3, [r2]
                     (unsigned char *)r->Link.SWFHash, r->Link.swfAge);
#endif
    
    SocksSetup(r, &r->Link.sockshost);
    
    if (r->Link.port == 0)
    9794:	e2863f65 	add	r3, r6, #404	; 0x194
    9798:	e1d320b2 	ldrh	r2, [r3, #2]
    979c:	e3520000 	cmp	r2, #0
            r->Link.port = 80;
        else
            r->Link.port = 1935;
    }
    
    return TRUE;
    97a0:	13a00001 	movne	r0, #1
                     (unsigned char *)r->Link.SWFHash, r->Link.swfAge);
#endif
    
    SocksSetup(r, &r->Link.sockshost);
    
    if (r->Link.port == 0)
    97a4:	1affff7c 	bne	959c <RTMP_SetupURL+0x9c>
    {
        if (r->Link.protocol & RTMP_FEATURE_SSL)
    97a8:	e5962188 	ldr	r2, [r6, #392]	; 0x188
    97ac:	e3120004 	tst	r2, #4
    97b0:	1a000028 	bne	9858 <RTMP_SetupURL+0x358>
            r->Link.port = 443;
        else if (r->Link.protocol & RTMP_FEATURE_HTTP)
    97b4:	e3120001 	tst	r2, #1
            r->Link.port = 80;
    97b8:	13a02050 	movne	r2, #80	; 0x50
        else
            r->Link.port = 1935;
    97bc:	059f2168 	ldreq	r2, [pc, #360]	; 992c <RTMP_SetupURL+0x42c>
    97c0:	e1c320b2 	strh	r2, [r3, #2]
    }
    
    return TRUE;
    97c4:	e3a00001 	mov	r0, #1
    97c8:	eaffff73 	b	959c <RTMP_SetupURL+0x9c>
            arg.av_len = ptr - p2;
            /* skip repeated spaces */
            while(ptr[1] == ' ')
                *ptr++ = '\0';
        } else {
            arg.av_len = strlen(p2);
    97cc:	e1a00004 	mov	r0, r4
    97d0:	ebffee4a 	bl	5100 <strlen@plt>
    97d4:	e58d0044 	str	r0, [sp, #68]	; 0x44
    97d8:	eaffffab 	b	968c <RTMP_SetupURL+0x18c>
    97dc:	e59d001c 	ldr	r0, [sp, #28]
    97e0:	e28610fc 	add	r1, r6, #252	; 0xfc
    97e4:	ebfff268 	bl	618c <SocksSetup.part.2>
    97e8:	eaffffe9 	b	9794 <RTMP_SetupURL+0x294>
            return ret;
    }
    
    if (!r->Link.tcUrl.av_len)
    {
        printf("r->Link.tcUrl.av_len :%d \n",r->Link.tcUrl.av_len);
    97ec:	e59f013c 	ldr	r0, [pc, #316]	; 9930 <RTMP_SetupURL+0x430>
    97f0:	e1a01002 	mov	r1, r2
    97f4:	e08f0000 	add	r0, pc, r0
    97f8:	ebffeec1 	bl	5304 <printf@plt>
        r->Link.tcUrl.av_val = url;
        if (r->Link.app.av_len)
    97fc:	e5961130 	ldr	r1, [r6, #304]	; 0x130
    }
    
    if (!r->Link.tcUrl.av_len)
    {
        printf("r->Link.tcUrl.av_len :%d \n",r->Link.tcUrl.av_len);
        r->Link.tcUrl.av_val = url;
    9800:	e586a114 	str	sl, [r6, #276]	; 0x114
        if (r->Link.app.av_len)
    9804:	e3510000 	cmp	r1, #0
    9808:	0a000016 	beq	9868 <RTMP_SetupURL+0x368>
        {
            printf("r->Link.app.av_len:%d \n",r->Link.app.av_len);
    980c:	e59f0120 	ldr	r0, [pc, #288]	; 9934 <RTMP_SetupURL+0x434>
    9810:	e08f0000 	add	r0, pc, r0
    9814:	ebffeeba 	bl	5304 <printf@plt>
            if (r->Link.app.av_val < url + len)
    9818:	e59d3020 	ldr	r3, [sp, #32]
    981c:	e596212c 	ldr	r2, [r6, #300]	; 0x12c
    9820:	e08a3003 	add	r3, sl, r3
    9824:	e1520003 	cmp	r2, r3
    9828:	2a000019 	bcs	9894 <RTMP_SetupURL+0x394>
            {
                /* if app is part of original url, just use it */
                
                r->Link.tcUrl.av_len = r->Link.app.av_len + (r->Link.app.av_val - url);
    982c:	e5963130 	ldr	r3, [r6, #304]	; 0x130
    9830:	e06a2002 	rsb	r2, sl, r2
                printf("url:%s  len:%d tcurl:%d \n",url,len,r->Link.tcUrl.av_len);
    9834:	e59f00fc 	ldr	r0, [pc, #252]	; 9938 <RTMP_SetupURL+0x438>
            printf("r->Link.app.av_len:%d \n",r->Link.app.av_len);
            if (r->Link.app.av_val < url + len)
            {
                /* if app is part of original url, just use it */
                
                r->Link.tcUrl.av_len = r->Link.app.av_len + (r->Link.app.av_val - url);
    9838:	e0823003 	add	r3, r2, r3
                printf("url:%s  len:%d tcurl:%d \n",url,len,r->Link.tcUrl.av_len);
    983c:	e1a0100a 	mov	r1, sl
    9840:	e59d2020 	ldr	r2, [sp, #32]
            printf("r->Link.app.av_len:%d \n",r->Link.app.av_len);
            if (r->Link.app.av_val < url + len)
            {
                /* if app is part of original url, just use it */
                
                r->Link.tcUrl.av_len = r->Link.app.av_len + (r->Link.app.av_val - url);
    9844:	e5863118 	str	r3, [r6, #280]	; 0x118
                printf("url:%s  len:%d tcurl:%d \n",url,len,r->Link.tcUrl.av_len);
    9848:	e08f0000 	add	r0, pc, r0
    984c:	ebffeeac 	bl	5304 <printf@plt>
    9850:	e5962118 	ldr	r2, [r6, #280]	; 0x118
    9854:	eaffffb7 	b	9738 <RTMP_SetupURL+0x238>
    SocksSetup(r, &r->Link.sockshost);
    
    if (r->Link.port == 0)
    {
        if (r->Link.protocol & RTMP_FEATURE_SSL)
            r->Link.port = 443;
    9858:	e59f20dc 	ldr	r2, [pc, #220]	; 993c <RTMP_SetupURL+0x43c>
    985c:	e1c320b2 	strh	r2, [r3, #2]
            r->Link.port = 80;
        else
            r->Link.port = 1935;
    }
    
    return TRUE;
    9860:	e3a00001 	mov	r0, #1
    9864:	eaffff4c 	b	959c <RTMP_SetupURL+0x9c>
                r->Link.lFlags |= RTMP_LF_FTCU;
            }
        }
        else
        {
            printf("tcurl len:%d \n",strlen(url));
    9868:	e1a0000a 	mov	r0, sl
    986c:	ebffee23 	bl	5100 <strlen@plt>
    9870:	e1a01000 	mov	r1, r0
    9874:	e59f00c4 	ldr	r0, [pc, #196]	; 9940 <RTMP_SetupURL+0x440>
    9878:	e08f0000 	add	r0, pc, r0
    987c:	ebffeea0 	bl	5304 <printf@plt>
            r->Link.tcUrl.av_len = strlen(url);
    9880:	e1a0000a 	mov	r0, sl
    9884:	ebffee1d 	bl	5100 <strlen@plt>
    9888:	e1a02000 	mov	r2, r0
    988c:	e5860118 	str	r0, [r6, #280]	; 0x118
    9890:	eaffffa8 	b	9738 <RTMP_SetupURL+0x238>
                r->Link.tcUrl.av_len = r->Link.app.av_len + (r->Link.app.av_val - url);
                printf("url:%s  len:%d tcurl:%d \n",url,len,r->Link.tcUrl.av_len);
            }
            else
            {
                printf("r->Link.app.av_val >= url + len");
    9894:	e59f00a8 	ldr	r0, [pc, #168]	; 9944 <RTMP_SetupURL+0x444>
    9898:	e08f0000 	add	r0, pc, r0
    989c:	ebffee98 	bl	5304 <printf@plt>
                len = r->Link.hostname.av_len + r->Link.app.av_len +
    98a0:	e59670f8 	ldr	r7, [r6, #248]	; 0xf8
    98a4:	e5965130 	ldr	r5, [r6, #304]	; 0x130
    98a8:	e0874005 	add	r4, r7, r5
    98ac:	e2844011 	add	r4, r4, #17
                sizeof("rtmpte://:65535/");
                r->Link.tcUrl.av_val = malloc(len);
    98b0:	e1a00004 	mov	r0, r4
    98b4:	ebffedd8 	bl	501c <malloc@plt>
                r->Link.tcUrl.av_len = snprintf(r->Link.tcUrl.av_val, len,
                                                "%s://%.*s:%d/%.*s",
                                                RTMPProtocolStringsLower[r->Link.protocol],
                                                r->Link.hostname.av_len, r->Link.hostname.av_val,
                                                r->Link.port,
    98b8:	e2862f65 	add	r2, r6, #404	; 0x194
            {
                printf("r->Link.app.av_val >= url + len");
                len = r->Link.hostname.av_len + r->Link.app.av_len +
                sizeof("rtmpte://:65535/");
                r->Link.tcUrl.av_val = malloc(len);
                r->Link.tcUrl.av_len = snprintf(r->Link.tcUrl.av_val, len,
    98bc:	e59f3084 	ldr	r3, [pc, #132]	; 9948 <RTMP_SetupURL+0x448>
    98c0:	e1d280b2 	ldrh	r8, [r2, #2]
    98c4:	e596c188 	ldr	ip, [r6, #392]	; 0x188
    98c8:	e596212c 	ldr	r2, [r6, #300]	; 0x12c
    98cc:	e596e0f4 	ldr	lr, [r6, #244]	; 0xf4
    98d0:	e79f3003 	ldr	r3, [pc, r3]
    98d4:	e58d2010 	str	r2, [sp, #16]
    98d8:	e59f206c 	ldr	r2, [pc, #108]	; 994c <RTMP_SetupURL+0x44c>
    98dc:	e06cc18c 	rsb	ip, ip, ip, lsl #3
    98e0:	e58d7000 	str	r7, [sp]
    98e4:	e58d500c 	str	r5, [sp, #12]
    98e8:	e083300c 	add	r3, r3, ip
    98ec:	e58d8008 	str	r8, [sp, #8]
    98f0:	e58de004 	str	lr, [sp, #4]
    98f4:	e08f2002 	add	r2, pc, r2
    98f8:	e1a01004 	mov	r1, r4
            else
            {
                printf("r->Link.app.av_val >= url + len");
                len = r->Link.hostname.av_len + r->Link.app.av_len +
                sizeof("rtmpte://:65535/");
                r->Link.tcUrl.av_val = malloc(len);
    98fc:	e5860114 	str	r0, [r6, #276]	; 0x114
                r->Link.tcUrl.av_len = snprintf(r->Link.tcUrl.av_val, len,
    9900:	ebffedf5 	bl	50dc <snprintf@plt>
                                                "%s://%.*s:%d/%.*s",
                                                RTMPProtocolStringsLower[r->Link.protocol],
                                                r->Link.hostname.av_len, r->Link.hostname.av_val,
                                                r->Link.port,
                                                r->Link.app.av_len, r->Link.app.av_val);
                r->Link.lFlags |= RTMP_LF_FTCU;
    9904:	e5963180 	ldr	r3, [r6, #384]	; 0x180
    9908:	e3833020 	orr	r3, r3, #32
    990c:	e5863180 	str	r3, [r6, #384]	; 0x180
            {
                printf("r->Link.app.av_val >= url + len");
                len = r->Link.hostname.av_len + r->Link.app.av_len +
                sizeof("rtmpte://:65535/");
                r->Link.tcUrl.av_val = malloc(len);
                r->Link.tcUrl.av_len = snprintf(r->Link.tcUrl.av_val, len,
    9910:	e1a02000 	mov	r2, r0
    9914:	e5860118 	str	r0, [r6, #280]	; 0x118
    9918:	eaffff86 	b	9738 <RTMP_SetupURL+0x238>
    991c:	00015480 	.word	0x00015480
    9920:	0001544c 	.word	0x0001544c
    9924:	00014b94 	.word	0x00014b94
    9928:	00015380 	.word	0x00015380
    992c:	0000078f 	.word	0x0000078f
    9930:	00015238 	.word	0x00015238
    9934:	00015238 	.word	0x00015238
    9938:	00015218 	.word	0x00015218
    993c:	000001bb 	.word	0x000001bb
    9940:	00015238 	.word	0x00015238
    9944:	000151e4 	.word	0x000151e4
    9948:	0001a4bc 	.word	0x0001a4bc
    994c:	000151a8 	.word	0x000151a8

00009950 <RTMP_TLS_Accept>:
    return TRUE;
}

int
RTMP_TLS_Accept(RTMP *r, void *ctx)
{
    9950:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    9954:	e1a06000 	mov	r6, r0
    9958:	e24dd008 	sub	sp, sp, #8
#if defined(CRYPTO) && !defined(NO_SSL)
    TLS_server(ctx, r->m_sb.sb_ssl);
    995c:	e3a00e17 	mov	r0, #368	; 0x170
    return TRUE;
}

int
RTMP_TLS_Accept(RTMP *r, void *ctx)
{
    9960:	e1a07001 	mov	r7, r1
#if defined(CRYPTO) && !defined(NO_SSL)
    TLS_server(ctx, r->m_sb.sb_ssl);
    9964:	ebffedac 	bl	501c <malloc@plt>
    9968:	e2864901 	add	r4, r6, #16384	; 0x4000
    return TRUE;
}

int
RTMP_TLS_Accept(RTMP *r, void *ctx)
{
    996c:	e59f50dc 	ldr	r5, [pc, #220]	; 9a50 <RTMP_TLS_Accept+0x100>
#if defined(CRYPTO) && !defined(NO_SSL)
    TLS_server(ctx, r->m_sb.sb_ssl);
    9970:	e1a08007 	mov	r8, r7
    return TRUE;
}

int
RTMP_TLS_Accept(RTMP *r, void *ctx)
{
    9974:	e08f5005 	add	r5, pc, r5
#if defined(CRYPTO) && !defined(NO_SSL)
    TLS_server(ctx, r->m_sb.sb_ssl);
    9978:	e58400f0 	str	r0, [r4, #240]	; 0xf0
    997c:	ebffee66 	bl	531c <ssl_init@plt>
    9980:	e59400f0 	ldr	r0, [r4, #240]	; 0xf0
    9984:	e3a01001 	mov	r1, #1
    9988:	ebffee66 	bl	5328 <ssl_set_endpoint@plt>
    998c:	e59400f0 	ldr	r0, [r4, #240]	; 0xf0
    9990:	e3a01000 	mov	r1, #0
    9994:	ebffee66 	bl	5334 <ssl_set_authmode@plt>
    9998:	e59f30b4 	ldr	r3, [pc, #180]	; 9a54 <RTMP_TLS_Accept+0x104>
    999c:	e4982264 	ldr	r2, [r8], #612	; 0x264
    99a0:	e7951003 	ldr	r1, [r5, r3]
    99a4:	e59400f0 	ldr	r0, [r4, #240]	; 0xf0
    99a8:	ebffee64 	bl	5340 <ssl_set_rng@plt>
    99ac:	e59f30a4 	ldr	r3, [pc, #164]	; 9a58 <RTMP_TLS_Accept+0x108>
    99b0:	e59400f0 	ldr	r0, [r4, #240]	; 0xf0
    99b4:	e7951003 	ldr	r1, [r5, r3]
    99b8:	ebffee63 	bl	534c <ssl_set_ciphersuites@plt>
    99bc:	e1a01008 	mov	r1, r8
    99c0:	e59400f0 	ldr	r0, [r4, #240]	; 0xf0
    99c4:	ebffee63 	bl	5358 <ssl_set_session@plt>
    99c8:	e59400f0 	ldr	r0, [r4, #240]	; 0xf0
    99cc:	e2871004 	add	r1, r7, #4
    99d0:	e2872e1d 	add	r2, r7, #464	; 0x1d0
    99d4:	ebffee62 	bl	5364 <ssl_set_own_cert@plt>
    99d8:	e59712c8 	ldr	r1, [r7, #712]	; 0x2c8
    99dc:	e59722cc 	ldr	r2, [r7, #716]	; 0x2cc
    99e0:	e59400f0 	ldr	r0, [r4, #240]	; 0xf0
    99e4:	ebffee61 	bl	5370 <ssl_set_dh_param@plt>
    TLS_setfd(r->m_sb.sb_ssl, r->m_sb.sb_socket);
    99e8:	e59f206c 	ldr	r2, [pc, #108]	; 9a5c <RTMP_TLS_Accept+0x10c>
    99ec:	e59f306c 	ldr	r3, [pc, #108]	; 9a60 <RTMP_TLS_Accept+0x110>
    99f0:	e7951002 	ldr	r1, [r5, r2]
    99f4:	e28620e0 	add	r2, r6, #224	; 0xe0
    99f8:	e59400f0 	ldr	r0, [r4, #240]	; 0xf0
    99fc:	e7953003 	ldr	r3, [r5, r3]
    9a00:	e58d2000 	str	r2, [sp]
    9a04:	ebffee5c 	bl	537c <ssl_set_bio@plt>
    if (TLS_accept(r->m_sb.sb_ssl) < 0)
    9a08:	e59400f0 	ldr	r0, [r4, #240]	; 0xf0
    9a0c:	ebffee5d 	bl	5388 <ssl_handshake@plt>
    9a10:	e3500000 	cmp	r0, #0
    {
        RTMP_Log(RTMP_LOGERROR, "%s, TLS_Connect failed", __FUNCTION__);
        return FALSE;
    }
    return TRUE;
    9a14:	a3a00001 	movge	r0, #1
RTMP_TLS_Accept(RTMP *r, void *ctx)
{
#if defined(CRYPTO) && !defined(NO_SSL)
    TLS_server(ctx, r->m_sb.sb_ssl);
    TLS_setfd(r->m_sb.sb_ssl, r->m_sb.sb_socket);
    if (TLS_accept(r->m_sb.sb_ssl) < 0)
    9a18:	ba000001 	blt	9a24 <RTMP_TLS_Accept+0xd4>
    }
    return TRUE;
#else
    return FALSE;
#endif
}
    9a1c:	e28dd008 	add	sp, sp, #8
    9a20:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
#if defined(CRYPTO) && !defined(NO_SSL)
    TLS_server(ctx, r->m_sb.sb_ssl);
    TLS_setfd(r->m_sb.sb_ssl, r->m_sb.sb_socket);
    if (TLS_accept(r->m_sb.sb_ssl) < 0)
    {
        RTMP_Log(RTMP_LOGERROR, "%s, TLS_Connect failed", __FUNCTION__);
    9a24:	e59f2038 	ldr	r2, [pc, #56]	; 9a64 <RTMP_TLS_Accept+0x114>
    9a28:	e59f1038 	ldr	r1, [pc, #56]	; 9a68 <RTMP_TLS_Accept+0x118>
    9a2c:	e08f2002 	add	r2, pc, r2
    9a30:	e2422eca 	sub	r2, r2, #3232	; 0xca0
    9a34:	e3a00001 	mov	r0, #1
    9a38:	e2422004 	sub	r2, r2, #4
    9a3c:	e08f1001 	add	r1, pc, r1
    9a40:	eb002fd9 	bl	159ac <RTMP_Log>
        return FALSE;
    9a44:	e3a00000 	mov	r0, #0
    }
    return TRUE;
#else
    return FALSE;
#endif
}
    9a48:	e28dd008 	add	sp, sp, #8
    9a4c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    9a50:	0001a444 	.word	0x0001a444
    9a54:	ffffffb0 	.word	0xffffffb0
    9a58:	ffffffd8 	.word	0xffffffd8
    9a5c:	ffffffdc 	.word	0xffffffdc
    9a60:	ffffffe0 	.word	0xffffffe0
    9a64:	00014db4 	.word	0x00014db4
    9a68:	0001509c 	.word	0x0001509c

00009a6c <RTMP_DropRequest>:
    vals[i].num = 0;
}

void
RTMP_DropRequest(RTMP *r, int i, int freeit)
{
    9a6c:	e1a0c000 	mov	ip, r0
    9a70:	e1a03002 	mov	r3, r2
    AV_erase(r->m_methodCalls, &r->m_numCalls, i, freeit);
    9a74:	e5900040 	ldr	r0, [r0, #64]	; 0x40
    9a78:	e1a02001 	mov	r2, r1
    9a7c:	e28c103c 	add	r1, ip, #60	; 0x3c
    9a80:	eaffef70 	b	5848 <AV_erase>

00009a84 <RTMP_FindFirstMatchingProperty>:
}

int
RTMP_FindFirstMatchingProperty(AMFObject *obj, const AVal *name,
                               AMFObjectProperty * p)
{
    9a84:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    int n;
    /* this is a small object search to locate the "duration" property */
    for (n = 0; n < obj->o_num; n++)
    9a88:	e5904000 	ldr	r4, [r0]
    9a8c:	e3540000 	cmp	r4, #0
    9a90:	c1a08002 	movgt	r8, r2
    9a94:	c1a07001 	movgt	r7, r1
    9a98:	c1a06000 	movgt	r6, r0
    9a9c:	c3a04000 	movgt	r4, #0
    9aa0:	ca000003 	bgt	9ab4 <RTMP_FindFirstMatchingProperty+0x30>
    9aa4:	ea000023 	b	9b38 <RTMP_FindFirstMatchingProperty+0xb4>
    9aa8:	e5963000 	ldr	r3, [r6]
    9aac:	e1530004 	cmp	r3, r4
    9ab0:	da000020 	ble	9b38 <RTMP_FindFirstMatchingProperty+0xb4>
    {
        AMFObjectProperty *prop = AMF_GetProp(obj, NULL, n);
    9ab4:	e1a02004 	mov	r2, r4
    9ab8:	e1a00006 	mov	r0, r6
    9abc:	e3a01000 	mov	r1, #0
    9ac0:	eb003352 	bl	16810 <AMF_GetProp>
        
        if (AVMATCH(&prop->p_name, name))
    9ac4:	e5973004 	ldr	r3, [r7, #4]
RTMP_FindFirstMatchingProperty(AMFObject *obj, const AVal *name,
                               AMFObjectProperty * p)
{
    int n;
    /* this is a small object search to locate the "duration" property */
    for (n = 0; n < obj->o_num; n++)
    9ac8:	e2844001 	add	r4, r4, #1
    {
        AMFObjectProperty *prop = AMF_GetProp(obj, NULL, n);
        
        if (AVMATCH(&prop->p_name, name))
    9acc:	e5902004 	ldr	r2, [r0, #4]
{
    int n;
    /* this is a small object search to locate the "duration" property */
    for (n = 0; n < obj->o_num; n++)
    {
        AMFObjectProperty *prop = AMF_GetProp(obj, NULL, n);
    9ad0:	e1a05000 	mov	r5, r0
        
        if (AVMATCH(&prop->p_name, name))
    9ad4:	e1520003 	cmp	r2, r3
    9ad8:	0a00000b 	beq	9b0c <RTMP_FindFirstMatchingProperty+0x88>
        {
            memcpy(p, prop, sizeof(*prop));
            return TRUE;
        }
        
        if (prop->p_type == AMF_OBJECT || prop->p_type == AMF_ECMA_ARRAY)
    9adc:	e5953008 	ldr	r3, [r5, #8]
    9ae0:	e3530003 	cmp	r3, #3
    9ae4:	13530008 	cmpne	r3, #8
    9ae8:	1affffee 	bne	9aa8 <RTMP_FindFirstMatchingProperty+0x24>
        {
            if (RTMP_FindFirstMatchingProperty(&prop->p_vu.p_object, name, p))
    9aec:	e2850010 	add	r0, r5, #16
    9af0:	e1a01007 	mov	r1, r7
    9af4:	e1a02008 	mov	r2, r8
    9af8:	ebffffe1 	bl	9a84 <RTMP_FindFirstMatchingProperty>
    9afc:	e3500000 	cmp	r0, #0
    9b00:	0affffe8 	beq	9aa8 <RTMP_FindFirstMatchingProperty+0x24>
                return TRUE;
    9b04:	e3a00001 	mov	r0, #1
        }
    }
    return FALSE;
}
    9b08:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    /* this is a small object search to locate the "duration" property */
    for (n = 0; n < obj->o_num; n++)
    {
        AMFObjectProperty *prop = AMF_GetProp(obj, NULL, n);
        
        if (AVMATCH(&prop->p_name, name))
    9b0c:	e5900000 	ldr	r0, [r0]
    9b10:	e5971000 	ldr	r1, [r7]
    9b14:	ebffedaf 	bl	51d8 <memcmp@plt>
    9b18:	e3500000 	cmp	r0, #0
    9b1c:	1affffee 	bne	9adc <RTMP_FindFirstMatchingProperty+0x58>
        {
            memcpy(p, prop, sizeof(*prop));
    9b20:	e1a00008 	mov	r0, r8
    9b24:	e1a01005 	mov	r1, r5
    9b28:	e3a02020 	mov	r2, #32
    9b2c:	ebffeda6 	bl	51cc <memcpy@plt>
            return TRUE;
    9b30:	e3a00001 	mov	r0, #1
    9b34:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        {
            if (RTMP_FindFirstMatchingProperty(&prop->p_vu.p_object, name, p))
                return TRUE;
        }
    }
    return FALSE;
    9b38:	e3a00000 	mov	r0, #0
    9b3c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

00009b40 <RTMP_FindPrefixProperty>:
int
RTMP_FindPrefixProperty(AMFObject *obj, const AVal *name,
                        AMFObjectProperty * p)
{
    int n;
    for (n = 0; n < obj->o_num; n++)
    9b40:	e5903000 	ldr	r3, [r0]
    9b44:	e3530000 	cmp	r3, #0
    9b48:	da00002b 	ble	9bfc <RTMP_FindPrefixProperty+0xbc>

/* Like above, but only check if name is a prefix of property */
int
RTMP_FindPrefixProperty(AMFObject *obj, const AVal *name,
                        AMFObjectProperty * p)
{
    9b4c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    9b50:	e1a08002 	mov	r8, r2
    9b54:	e1a07001 	mov	r7, r1
    9b58:	e1a06000 	mov	r6, r0
    int n;
    for (n = 0; n < obj->o_num; n++)
    9b5c:	e3a04000 	mov	r4, #0
    9b60:	ea000002 	b	9b70 <RTMP_FindPrefixProperty+0x30>
    9b64:	e5963000 	ldr	r3, [r6]
    9b68:	e1530004 	cmp	r3, r4
    9b6c:	da00001a 	ble	9bdc <RTMP_FindPrefixProperty+0x9c>
    {
        AMFObjectProperty *prop = AMF_GetProp(obj, NULL, n);
    9b70:	e1a02004 	mov	r2, r4
    9b74:	e1a00006 	mov	r0, r6
    9b78:	e3a01000 	mov	r1, #0
    9b7c:	eb003323 	bl	16810 <AMF_GetProp>
        
        if (prop->p_name.av_len > name->av_len &&
    9b80:	e5973004 	ldr	r3, [r7, #4]
int
RTMP_FindPrefixProperty(AMFObject *obj, const AVal *name,
                        AMFObjectProperty * p)
{
    int n;
    for (n = 0; n < obj->o_num; n++)
    9b84:	e2844001 	add	r4, r4, #1
    {
        AMFObjectProperty *prop = AMF_GetProp(obj, NULL, n);
        
        if (prop->p_name.av_len > name->av_len &&
            !memcmp(prop->p_name.av_val, name->av_val, name->av_len))
    9b88:	e1a02003 	mov	r2, r3
                        AMFObjectProperty * p)
{
    int n;
    for (n = 0; n < obj->o_num; n++)
    {
        AMFObjectProperty *prop = AMF_GetProp(obj, NULL, n);
    9b8c:	e1a05000 	mov	r5, r0
        
        if (prop->p_name.av_len > name->av_len &&
    9b90:	e5900004 	ldr	r0, [r0, #4]
    9b94:	e1500003 	cmp	r0, r3
    9b98:	da000004 	ble	9bb0 <RTMP_FindPrefixProperty+0x70>
            !memcmp(prop->p_name.av_val, name->av_val, name->av_len))
    9b9c:	e5950000 	ldr	r0, [r5]
    9ba0:	e5971000 	ldr	r1, [r7]
    9ba4:	ebffed8b 	bl	51d8 <memcmp@plt>
    int n;
    for (n = 0; n < obj->o_num; n++)
    {
        AMFObjectProperty *prop = AMF_GetProp(obj, NULL, n);
        
        if (prop->p_name.av_len > name->av_len &&
    9ba8:	e3500000 	cmp	r0, #0
    9bac:	0a00000c 	beq	9be4 <RTMP_FindPrefixProperty+0xa4>
        {
            memcpy(p, prop, sizeof(*prop));
            return TRUE;
        }
        
        if (prop->p_type == AMF_OBJECT)
    9bb0:	e5953008 	ldr	r3, [r5, #8]
    9bb4:	e3530003 	cmp	r3, #3
    9bb8:	1affffe9 	bne	9b64 <RTMP_FindPrefixProperty+0x24>
        {
            if (RTMP_FindPrefixProperty(&prop->p_vu.p_object, name, p))
    9bbc:	e2850010 	add	r0, r5, #16
    9bc0:	e1a01007 	mov	r1, r7
    9bc4:	e1a02008 	mov	r2, r8
    9bc8:	ebffffdc 	bl	9b40 <RTMP_FindPrefixProperty>
    9bcc:	e3500000 	cmp	r0, #0
    9bd0:	0affffe3 	beq	9b64 <RTMP_FindPrefixProperty+0x24>
                return TRUE;
    9bd4:	e3a00001 	mov	r0, #1
        }
    }
    return FALSE;
}
    9bd8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        {
            if (RTMP_FindPrefixProperty(&prop->p_vu.p_object, name, p))
                return TRUE;
        }
    }
    return FALSE;
    9bdc:	e3a00000 	mov	r0, #0
    9be0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        AMFObjectProperty *prop = AMF_GetProp(obj, NULL, n);
        
        if (prop->p_name.av_len > name->av_len &&
            !memcmp(prop->p_name.av_val, name->av_val, name->av_len))
        {
            memcpy(p, prop, sizeof(*prop));
    9be4:	e1a00008 	mov	r0, r8
    9be8:	e1a01005 	mov	r1, r5
    9bec:	e3a02020 	mov	r2, #32
    9bf0:	ebffed75 	bl	51cc <memcpy@plt>
            return TRUE;
    9bf4:	e3a00001 	mov	r0, #1
    9bf8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        {
            if (RTMP_FindPrefixProperty(&prop->p_vu.p_object, name, p))
                return TRUE;
        }
    }
    return FALSE;
    9bfc:	e3a00000 	mov	r0, #0
}
    9c00:	e12fff1e 	bx	lr

00009c04 <HandleMetadata>:
SAVC(video);
SAVC(audio);

static int
HandleMetadata(RTMP *r, char *body, unsigned int len)
{
    9c04:	e92d4070 	push	{r4, r5, r6, lr}
    9c08:	e24dd030 	sub	sp, sp, #48	; 0x30
    9c0c:	e1a05000 	mov	r5, r0
    
    AMFObject obj;
    AVal metastring;
    int ret = FALSE;
    
    int nRes = AMF_Decode(&obj, body, len, FALSE);
    9c10:	e3a03000 	mov	r3, #0
    9c14:	e1a0000d 	mov	r0, sp
    9c18:	eb0036bb 	bl	1770c <AMF_Decode>
    9c1c:	e1a0400d 	mov	r4, sp
    if (nRes < 0)
    9c20:	e3500000 	cmp	r0, #0
    9c24:	ba00003c 	blt	9d1c <HandleMetadata+0x118>
    {
        RTMP_Log(RTMP_LOGERROR, "%s, error decoding meta data packet", __FUNCTION__);
        return FALSE;
    }
    
    AMF_Dump(&obj);
    9c28:	e1a0000d 	mov	r0, sp
    9c2c:	eb00332c 	bl	168e4 <AMF_Dump>
    AMFProp_GetString(AMF_GetProp(&obj, NULL, 0), &metastring);
    9c30:	e3a01000 	mov	r1, #0
    9c34:	e1a02001 	mov	r2, r1
    9c38:	e1a0000d 	mov	r0, sp
    9c3c:	eb0032f3 	bl	16810 <AMF_GetProp>
    9c40:	e28d1008 	add	r1, sp, #8
    9c44:	eb003193 	bl	16298 <AMFProp_GetString>
    
    if (AVMATCH(&metastring, &av_onMetaData))
    9c48:	e59d200c 	ldr	r2, [sp, #12]
    9c4c:	e352000a 	cmp	r2, #10
    9c50:	0a000005 	beq	9c6c <HandleMetadata+0x68>
    /* allright we get some info here, so parse it and print it */
    /* also keep duration or filesize to make a nice progress bar */
    
    AMFObject obj;
    AVal metastring;
    int ret = FALSE;
    9c54:	e3a05000 	mov	r5, #0
            r->m_read.dataType |= 1;
        if (RTMP_FindPrefixProperty(&obj, &av_audio, &prop))
            r->m_read.dataType |= 4;
        ret = TRUE;
    }
    AMF_Reset(&obj);
    9c58:	e1a00004 	mov	r0, r4
    9c5c:	eb0033da 	bl	16bcc <AMF_Reset>
    return ret;
    9c60:	e1a00005 	mov	r0, r5
}
    9c64:	e28dd030 	add	sp, sp, #48	; 0x30
    9c68:	e8bd8070 	pop	{r4, r5, r6, pc}
    }
    
    AMF_Dump(&obj);
    AMFProp_GetString(AMF_GetProp(&obj, NULL, 0), &metastring);
    
    if (AVMATCH(&metastring, &av_onMetaData))
    9c6c:	e59f10d4 	ldr	r1, [pc, #212]	; 9d48 <HandleMetadata+0x144>
    9c70:	e59d0008 	ldr	r0, [sp, #8]
    9c74:	e08f1001 	add	r1, pc, r1
    9c78:	ebffed56 	bl	51d8 <memcmp@plt>
    9c7c:	e3500000 	cmp	r0, #0
    9c80:	1afffff3 	bne	9c54 <HandleMetadata+0x50>
    {
        AMFObjectProperty prop;
        /* Show metadata */
        RTMP_Log(RTMP_LOGINFO, "Metadata:");
    9c84:	e59f10c0 	ldr	r1, [pc, #192]	; 9d4c <HandleMetadata+0x148>
    9c88:	e3a00003 	mov	r0, #3
    9c8c:	e08f1001 	add	r1, pc, r1
    9c90:	eb002f45 	bl	159ac <RTMP_Log>
        DumpMetaData(&obj);
    9c94:	e1a0000d 	mov	r0, sp
    9c98:	ebfff0ad 	bl	5f54 <DumpMetaData>
        if (RTMP_FindFirstMatchingProperty(&obj, &av_duration, &prop))
    9c9c:	e59f10ac 	ldr	r1, [pc, #172]	; 9d50 <HandleMetadata+0x14c>
    9ca0:	e28d6010 	add	r6, sp, #16
    9ca4:	e08f1001 	add	r1, pc, r1
    9ca8:	e2811e22 	add	r1, r1, #544	; 0x220
    9cac:	e1a02006 	mov	r2, r6
    9cb0:	e1a0000d 	mov	r0, sp
    9cb4:	ebffff72 	bl	9a84 <RTMP_FindFirstMatchingProperty>
    9cb8:	e3500000 	cmp	r0, #0
        {
            r->m_fDuration = prop.p_vu.p_number;
    9cbc:	11cd22d0 	ldrdne	r2, [sp, #32]
    9cc0:	11c527f0 	strdne	r2, [r5, #112]	; 0x70
            /*RTMP_Log(RTMP_LOGDEBUG, "Set duration: %.2f", m_fDuration); */
        }
        /* Search for audio or video tags */
        if (RTMP_FindPrefixProperty(&obj, &av_video, &prop))
    9cc4:	e59f1088 	ldr	r1, [pc, #136]	; 9d54 <HandleMetadata+0x150>
    9cc8:	e1a02006 	mov	r2, r6
    9ccc:	e08f1001 	add	r1, pc, r1
    9cd0:	e2811f8a 	add	r1, r1, #552	; 0x228
    9cd4:	e1a00004 	mov	r0, r4
    9cd8:	ebffff98 	bl	9b40 <RTMP_FindPrefixProperty>
            r->m_read.dataType |= 1;
        if (RTMP_FindPrefixProperty(&obj, &av_audio, &prop))
    9cdc:	e59f1074 	ldr	r1, [pc, #116]	; 9d58 <HandleMetadata+0x154>
    9ce0:	e1a02006 	mov	r2, r6
    9ce4:	e08f1001 	add	r1, pc, r1
    9ce8:	e2811e23 	add	r1, r1, #560	; 0x230
        {
            r->m_fDuration = prop.p_vu.p_number;
            /*RTMP_Log(RTMP_LOGDEBUG, "Set duration: %.2f", m_fDuration); */
        }
        /* Search for audio or video tags */
        if (RTMP_FindPrefixProperty(&obj, &av_video, &prop))
    9cec:	e3500000 	cmp	r0, #0
            r->m_read.dataType |= 1;
    9cf0:	15d530a0 	ldrbne	r3, [r5, #160]	; 0xa0
        if (RTMP_FindPrefixProperty(&obj, &av_audio, &prop))
    9cf4:	e1a00004 	mov	r0, r4
            r->m_fDuration = prop.p_vu.p_number;
            /*RTMP_Log(RTMP_LOGDEBUG, "Set duration: %.2f", m_fDuration); */
        }
        /* Search for audio or video tags */
        if (RTMP_FindPrefixProperty(&obj, &av_video, &prop))
            r->m_read.dataType |= 1;
    9cf8:	13833001 	orrne	r3, r3, #1
    9cfc:	15c530a0 	strbne	r3, [r5, #160]	; 0xa0
        if (RTMP_FindPrefixProperty(&obj, &av_audio, &prop))
    9d00:	ebffff8e 	bl	9b40 <RTMP_FindPrefixProperty>
    9d04:	e3500000 	cmp	r0, #0
            r->m_read.dataType |= 4;
    9d08:	15d530a0 	ldrbne	r3, [r5, #160]	; 0xa0
    9d0c:	13833004 	orrne	r3, r3, #4
    9d10:	15c530a0 	strbne	r3, [r5, #160]	; 0xa0
        ret = TRUE;
    9d14:	e3a05001 	mov	r5, #1
    9d18:	eaffffce 	b	9c58 <HandleMetadata+0x54>
    int ret = FALSE;
    
    int nRes = AMF_Decode(&obj, body, len, FALSE);
    if (nRes < 0)
    {
        RTMP_Log(RTMP_LOGERROR, "%s, error decoding meta data packet", __FUNCTION__);
    9d1c:	e59f2038 	ldr	r2, [pc, #56]	; 9d5c <HandleMetadata+0x158>
    9d20:	e59f1038 	ldr	r1, [pc, #56]	; 9d60 <HandleMetadata+0x15c>
    9d24:	e08f2002 	add	r2, pc, r2
    9d28:	e2422ec9 	sub	r2, r2, #3216	; 0xc90
    9d2c:	e3a00001 	mov	r0, #1
    9d30:	e2422004 	sub	r2, r2, #4
    9d34:	e08f1001 	add	r1, pc, r1
    9d38:	eb002f1b 	bl	159ac <RTMP_Log>
        return FALSE;
    9d3c:	e3a00000 	mov	r0, #0
            r->m_read.dataType |= 4;
        ret = TRUE;
    }
    AMF_Reset(&obj);
    return ret;
}
    9d40:	e28dd030 	add	sp, sp, #48	; 0x30
    9d44:	e8bd8070 	pop	{r4, r5, r6, pc}
    9d48:	00014ea0 	.word	0x00014ea0
    9d4c:	00014e94 	.word	0x00014e94
    9d50:	00019ba4 	.word	0x00019ba4
    9d54:	00019b7c 	.word	0x00019b7c
    9d58:	00019b64 	.word	0x00019b64
    9d5c:	00014abc 	.word	0x00014abc
    9d60:	00014dbc 	.word	0x00014dbc

00009d64 <RTMPSockBuf_Fill>:
#endif
}

int
RTMPSockBuf_Fill(RTMPSockBuf *sb)
{
    9d64:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
    int nBytes;
    
    if (!sb->sb_size)
    9d68:	e590e004 	ldr	lr, [r0, #4]
#endif
}

int
RTMPSockBuf_Fill(RTMPSockBuf *sb)
{
    9d6c:	e1a04000 	mov	r4, r0
    int nBytes;
    
    if (!sb->sb_size)
    9d70:	e35e0000 	cmp	lr, #0
        sb->sb_start = sb->sb_buf;
    9d74:	0280300c 	addeq	r3, r0, #12
    9d78:	01a05003 	moveq	r5, r3
    9d7c:	15907008 	ldrne	r7, [r0, #8]
    9d80:	1280500c 	addne	r5, r0, #12
    9d84:	01a07005 	moveq	r7, r5
    9d88:	e2806901 	add	r6, r0, #16384	; 0x4000
    9d8c:	05803008 	streq	r3, [r0, #8]
    
    while (1)
    {
        nBytes = sizeof(sb->sb_buf) - 1 - sb->sb_size - (sb->sb_start - sb->sb_buf);
#if defined(CRYPTO) && !defined(NO_SSL)
        if (sb->sb_ssl)
    9d90:	e5963010 	ldr	r3, [r6, #16]
    9d94:	e26e2dff 	rsb	r2, lr, #16320	; 0x3fc0
    9d98:	e282203f 	add	r2, r2, #63	; 0x3f
    if (!sb->sb_size)
        sb->sb_start = sb->sb_buf;
    
    while (1)
    {
        nBytes = sizeof(sb->sb_buf) - 1 - sb->sb_size - (sb->sb_start - sb->sb_buf);
    9d9c:	e067c005 	rsb	ip, r7, r5
    9da0:	e082c00c 	add	ip, r2, ip
#if defined(CRYPTO) && !defined(NO_SSL)
        if (sb->sb_ssl)
    9da4:	e3530000 	cmp	r3, #0
        {
            nBytes = TLS_read(sb->sb_ssl, sb->sb_start + sb->sb_size, nBytes);
    9da8:	e1a00003 	mov	r0, r3
    9dac:	e087100e 	add	r1, r7, lr
    9db0:	e1a0200c 	mov	r2, ip
    
    while (1)
    {
        nBytes = sizeof(sb->sb_buf) - 1 - sb->sb_size - (sb->sb_start - sb->sb_buf);
#if defined(CRYPTO) && !defined(NO_SSL)
        if (sb->sb_ssl)
    9db4:	0a000015 	beq	9e10 <RTMPSockBuf_Fill+0xac>
        {
            nBytes = TLS_read(sb->sb_ssl, sb->sb_start + sb->sb_size, nBytes);
    9db8:	ebffed75 	bl	5394 <ssl_read@plt>
    9dbc:	e1a07000 	mov	r7, r0
        else
#endif
        {
			nBytes = recv(sb->sb_socket, sb->sb_start + sb->sb_size, nBytes, 0);
        }
        if (nBytes != -1)
    9dc0:	e3770001 	cmn	r7, #1
    9dc4:	1a000017 	bne	9e28 <RTMPSockBuf_Fill+0xc4>
        }
        else
        {
            
            int sockerr;
			sockerr = GetSockError();
    9dc8:	ebffed74 	bl	53a0 <__errno@plt>
    9dcc:	e59f3064 	ldr	r3, [pc, #100]	; 9e38 <RTMPSockBuf_Fill+0xd4>
    9dd0:	e5902000 	ldr	r2, [r0]
			//RTMP_Log(RTMP_LOGINFO, "%s, recv returned %d. GetSockError(): %d (%s)", __FUNCTION__, nBytes, sockerr, strerror(sockerr));
            if (sockerr == EINTR && !RTMP_ctrlC)
    9dd4:	e3520004 	cmp	r2, #4
    9dd8:	1a000006 	bne	9df8 <RTMPSockBuf_Fill+0x94>
    9ddc:	e79f3003 	ldr	r3, [pc, r3]
    9de0:	e5933000 	ldr	r3, [r3]
    9de4:	e3530000 	cmp	r3, #0
    9de8:	1a000006 	bne	9e08 <RTMPSockBuf_Fill+0xa4>
    9dec:	e5947008 	ldr	r7, [r4, #8]
    9df0:	e594e004 	ldr	lr, [r4, #4]
    9df4:	eaffffe5 	b	9d90 <RTMPSockBuf_Fill+0x2c>
                continue;
                
            if (sockerr == EWOULDBLOCK || sockerr == EAGAIN)
    9df8:	e352000b 	cmp	r2, #11
            {
//                RTMP_Log(RTMP_LOGINFO, "%s, timeout is true \n",__FUNCTION__);
                sb->sb_timedout = TRUE;
    9dfc:	03a03001 	moveq	r3, #1
                nBytes = 0;
    9e00:	03a07000 	moveq	r7, #0
                continue;
                
            if (sockerr == EWOULDBLOCK || sockerr == EAGAIN)
            {
//                RTMP_Log(RTMP_LOGINFO, "%s, timeout is true \n",__FUNCTION__);
                sb->sb_timedout = TRUE;
    9e04:	0586300c 	streq	r3, [r6, #12]
        }
        break;
    }
    
    return nBytes;
}
    9e08:	e1a00007 	mov	r0, r7
    9e0c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
            nBytes = TLS_read(sb->sb_ssl, sb->sb_start + sb->sb_size, nBytes);
        }
        else
#endif
        {
			nBytes = recv(sb->sb_socket, sb->sb_start + sb->sb_size, nBytes, 0);
    9e10:	e087100e 	add	r1, r7, lr
    9e14:	e1a0200c 	mov	r2, ip
    9e18:	e5940000 	ldr	r0, [r4]
    9e1c:	ebffed62 	bl	53ac <recv@plt>
    9e20:	e1a07000 	mov	r7, r0
    9e24:	eaffffe5 	b	9dc0 <RTMPSockBuf_Fill+0x5c>
        }
        if (nBytes != -1)
        {
            sb->sb_size += nBytes;
    9e28:	e5943004 	ldr	r3, [r4, #4]
    9e2c:	e0833007 	add	r3, r3, r7
    9e30:	e5843004 	str	r3, [r4, #4]
    9e34:	eafffff3 	b	9e08 <RTMPSockBuf_Fill+0xa4>
    9e38:	00019fa4 	.word	0x00019fa4

00009e3c <HTTP_read>:
        return -2;
    }
    if (strncmp(r->m_sb.sb_start, "HTTP/1.1 200 ", 13))
        return -1;
    r->m_sb.sb_start[r->m_sb.sb_size] = '\0';
    if (!strstr(r->m_sb.sb_start, "\r\n\r\n")) {
    9e3c:	e59f31d4 	ldr	r3, [pc, #468]	; a018 <HTTP_read+0x1dc>
    return hlen;
}

static int
HTTP_read(RTMP *r, int fill)
{
    9e40:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
        return -2;
    }
    if (strncmp(r->m_sb.sb_start, "HTTP/1.1 200 ", 13))
        return -1;
    r->m_sb.sb_start[r->m_sb.sb_size] = '\0';
    if (!strstr(r->m_sb.sb_start, "\r\n\r\n")) {
    9e44:	e08f3003 	add	r3, pc, r3
    return hlen;
}

static int
HTTP_read(RTMP *r, int fill)
{
    9e48:	e24dd00c 	sub	sp, sp, #12
    if (r->m_sb.sb_size < 13) {
        if (fill)
            goto restart;
        return -2;
    }
    if (strncmp(r->m_sb.sb_start, "HTTP/1.1 200 ", 13))
    9e4c:	e59fa1c8 	ldr	sl, [pc, #456]	; a01c <HTTP_read+0x1e0>
        return -1;
    r->m_sb.sb_start[r->m_sb.sb_size] = '\0';
    if (!strstr(r->m_sb.sb_start, "\r\n\r\n")) {
    9e50:	e58d3000 	str	r3, [sp]
            goto restart;
        return -2;
    }
    
    ptr = r->m_sb.sb_start + sizeof("HTTP/1.1 200");
    while ((ptr = strstr(ptr, "Content-"))) {
    9e54:	e59f61c4 	ldr	r6, [pc, #452]	; a020 <HTTP_read+0x1e4>
        if (!strncasecmp(ptr+8, "length:", 7)) break;
    9e58:	e59f51c4 	ldr	r5, [pc, #452]	; a024 <HTTP_read+0x1e8>
        ptr += 8;
    }
    if (!ptr)
        return -1;
    hlen = atoi(ptr+16);
    ptr = strstr(ptr+16, "\r\n\r\n");
    9e5c:	e59f31c4 	ldr	r3, [pc, #452]	; a028 <HTTP_read+0x1ec>
    if (r->m_sb.sb_size < 13) {
        if (fill)
            goto restart;
        return -2;
    }
    if (strncmp(r->m_sb.sb_start, "HTTP/1.1 200 ", 13))
    9e60:	e08fa00a 	add	sl, pc, sl
        ptr += 8;
    }
    if (!ptr)
        return -1;
    hlen = atoi(ptr+16);
    ptr = strstr(ptr+16, "\r\n\r\n");
    9e64:	e08f3003 	add	r3, pc, r3
            goto restart;
        return -2;
    }
    
    ptr = r->m_sb.sb_start + sizeof("HTTP/1.1 200");
    while ((ptr = strstr(ptr, "Content-"))) {
    9e68:	e08f6006 	add	r6, pc, r6
        if (!strncasecmp(ptr+8, "length:", 7)) break;
    9e6c:	e08f5005 	add	r5, pc, r5
    return hlen;
}

static int
HTTP_read(RTMP *r, int fill)
{
    9e70:	e1a07000 	mov	r7, r0
    9e74:	e1a08001 	mov	r8, r1
        ptr += 8;
    }
    if (!ptr)
        return -1;
    hlen = atoi(ptr+16);
    ptr = strstr(ptr+16, "\r\n\r\n");
    9e78:	e58d3004 	str	r3, [sp, #4]
{
    char *ptr;
    int hlen;
    
restart:
    if (fill)
    9e7c:	e3580000 	cmp	r8, #0
    9e80:	1a000006 	bne	9ea0 <HTTP_read+0x64>
        RTMPSockBuf_Fill(&r->m_sb);
    if (r->m_sb.sb_size < 13) {
    9e84:	e59740e4 	ldr	r4, [r7, #228]	; 0xe4
    9e88:	e354000c 	cmp	r4, #12
    9e8c:	ca000008 	bgt	9eb4 <HTTP_read+0x78>
        return -1;
    r->m_sb.sb_start[r->m_sb.sb_size] = '\0';
    if (!strstr(r->m_sb.sb_start, "\r\n\r\n")) {
        if (fill)
            goto restart;
        return -2;
    9e90:	e3e04001 	mvn	r4, #1
        r->m_resplen = hlen - 1;
        r->m_sb.sb_start++;
        r->m_sb.sb_size--;
    }
    return 0;
}
    9e94:	e1a00004 	mov	r0, r4
    9e98:	e28dd00c 	add	sp, sp, #12
    9e9c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    char *ptr;
    int hlen;
    
restart:
    if (fill)
        RTMPSockBuf_Fill(&r->m_sb);
    9ea0:	e28700e0 	add	r0, r7, #224	; 0xe0
    9ea4:	ebffffae 	bl	9d64 <RTMPSockBuf_Fill>
    if (r->m_sb.sb_size < 13) {
    9ea8:	e59740e4 	ldr	r4, [r7, #228]	; 0xe4
    9eac:	e354000c 	cmp	r4, #12
    9eb0:	dafffff1 	ble	9e7c <HTTP_read+0x40>
        if (fill)
            goto restart;
        return -2;
    }
    if (strncmp(r->m_sb.sb_start, "HTTP/1.1 200 ", 13))
    9eb4:	e59790e8 	ldr	r9, [r7, #232]	; 0xe8
    9eb8:	e1a0100a 	mov	r1, sl
    9ebc:	e1a00009 	mov	r0, r9
    9ec0:	e3a0200d 	mov	r2, #13
    9ec4:	ebffed3b 	bl	53b8 <strncmp@plt>
    9ec8:	e3500000 	cmp	r0, #0
    9ecc:	1a000014 	bne	9f24 <HTTP_read+0xe8>
        return -1;
    r->m_sb.sb_start[r->m_sb.sb_size] = '\0';
    9ed0:	e7c90004 	strb	r0, [r9, r4]
    if (!strstr(r->m_sb.sb_start, "\r\n\r\n")) {
    9ed4:	e59790e8 	ldr	r9, [r7, #232]	; 0xe8
    9ed8:	e59d1000 	ldr	r1, [sp]
    9edc:	e1a00009 	mov	r0, r9
    9ee0:	ebffeca4 	bl	5178 <strstr@plt>
    9ee4:	e3500000 	cmp	r0, #0
        if (fill)
            goto restart;
        return -2;
    }
    
    ptr = r->m_sb.sb_start + sizeof("HTTP/1.1 200");
    9ee8:	1289900d 	addne	r9, r9, #13
        return -2;
    }
    if (strncmp(r->m_sb.sb_start, "HTTP/1.1 200 ", 13))
        return -1;
    r->m_sb.sb_start[r->m_sb.sb_size] = '\0';
    if (!strstr(r->m_sb.sb_start, "\r\n\r\n")) {
    9eec:	1a000003 	bne	9f00 <HTTP_read+0xc4>
    9ef0:	ea000024 	b	9f88 <HTTP_read+0x14c>
        return -2;
    }
    
    ptr = r->m_sb.sb_start + sizeof("HTTP/1.1 200");
    while ((ptr = strstr(ptr, "Content-"))) {
        if (!strncasecmp(ptr+8, "length:", 7)) break;
    9ef4:	ebffed32 	bl	53c4 <strncasecmp@plt>
    9ef8:	e3500000 	cmp	r0, #0
    9efc:	0a00000c 	beq	9f34 <HTTP_read+0xf8>
            goto restart;
        return -2;
    }
    
    ptr = r->m_sb.sb_start + sizeof("HTTP/1.1 200");
    while ((ptr = strstr(ptr, "Content-"))) {
    9f00:	e1a00009 	mov	r0, r9
    9f04:	e1a01006 	mov	r1, r6
    9f08:	ebffec9a 	bl	5178 <strstr@plt>
        if (!strncasecmp(ptr+8, "length:", 7)) break;
    9f0c:	e1a01005 	mov	r1, r5
    9f10:	e3a02007 	mov	r2, #7
            goto restart;
        return -2;
    }
    
    ptr = r->m_sb.sb_start + sizeof("HTTP/1.1 200");
    while ((ptr = strstr(ptr, "Content-"))) {
    9f14:	e250b000 	subs	fp, r0, #0
        if (!strncasecmp(ptr+8, "length:", 7)) break;
    9f18:	e28b9008 	add	r9, fp, #8
    9f1c:	e1a00009 	mov	r0, r9
            goto restart;
        return -2;
    }
    
    ptr = r->m_sb.sb_start + sizeof("HTTP/1.1 200");
    while ((ptr = strstr(ptr, "Content-"))) {
    9f20:	1afffff3 	bne	9ef4 <HTTP_read+0xb8>
        if (fill)
            goto restart;
        return -2;
    }
    if (strncmp(r->m_sb.sb_start, "HTTP/1.1 200 ", 13))
        return -1;
    9f24:	e3e04000 	mvn	r4, #0
        r->m_resplen = hlen - 1;
        r->m_sb.sb_start++;
        r->m_sb.sb_size--;
    }
    return 0;
}
    9f28:	e1a00004 	mov	r0, r4
    9f2c:	e28dd00c 	add	sp, sp, #12
    9f30:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if (!strncasecmp(ptr+8, "length:", 7)) break;
        ptr += 8;
    }
    if (!ptr)
        return -1;
    hlen = atoi(ptr+16);
    9f34:	e28bb010 	add	fp, fp, #16
    9f38:	e1a04000 	mov	r4, r0
    9f3c:	e1a0000b 	mov	r0, fp
    9f40:	ebffec71 	bl	510c <atoi@plt>
    ptr = strstr(ptr+16, "\r\n\r\n");
    9f44:	e59d1004 	ldr	r1, [sp, #4]
        if (!strncasecmp(ptr+8, "length:", 7)) break;
        ptr += 8;
    }
    if (!ptr)
        return -1;
    hlen = atoi(ptr+16);
    9f48:	e1a09000 	mov	r9, r0
    ptr = strstr(ptr+16, "\r\n\r\n");
    9f4c:	e1a0000b 	mov	r0, fp
    9f50:	ebffec88 	bl	5178 <strstr@plt>
    if (!ptr)
    9f54:	e3500000 	cmp	r0, #0
    9f58:	0afffff1 	beq	9f24 <HTTP_read+0xe8>
        return -1;
    ptr += 4;
    if (ptr + (r->m_clientID.av_val ? 1 : hlen) > r->m_sb.sb_start + r->m_sb.sb_size)
    9f5c:	e5971088 	ldr	r1, [r7, #136]	; 0x88
    9f60:	e59720e8 	ldr	r2, [r7, #232]	; 0xe8
    9f64:	e3510000 	cmp	r1, #0
    9f68:	e597c0e4 	ldr	ip, [r7, #228]	; 0xe4
    9f6c:	01a03009 	moveq	r3, r9
    9f70:	13a03001 	movne	r3, #1
        return -1;
    hlen = atoi(ptr+16);
    ptr = strstr(ptr+16, "\r\n\r\n");
    if (!ptr)
        return -1;
    ptr += 4;
    9f74:	e280b004 	add	fp, r0, #4
    if (ptr + (r->m_clientID.av_val ? 1 : hlen) > r->m_sb.sb_start + r->m_sb.sb_size)
    9f78:	e08b3003 	add	r3, fp, r3
    9f7c:	e082e00c 	add	lr, r2, ip
    9f80:	e153000e 	cmp	r3, lr
    9f84:	9a000002 	bls	9f94 <HTTP_read+0x158>
    }
    if (strncmp(r->m_sb.sb_start, "HTTP/1.1 200 ", 13))
        return -1;
    r->m_sb.sb_start[r->m_sb.sb_size] = '\0';
    if (!strstr(r->m_sb.sb_start, "\r\n\r\n")) {
        if (fill)
    9f88:	e3580000 	cmp	r8, #0
    9f8c:	1affffba 	bne	9e7c <HTTP_read+0x40>
    9f90:	eaffffbe 	b	9e90 <HTTP_read+0x54>
            goto restart;
        return -2;
    }
    r->m_sb.sb_size -= ptr - r->m_sb.sb_start;
    r->m_sb.sb_start = ptr;
    r->m_unackd--;
    9f94:	e5973084 	ldr	r3, [r7, #132]	; 0x84
    {
        if (fill)
            goto restart;
        return -2;
    }
    r->m_sb.sb_size -= ptr - r->m_sb.sb_start;
    9f98:	e06b2002 	rsb	r2, fp, r2
    9f9c:	e082c00c 	add	ip, r2, ip
    r->m_sb.sb_start = ptr;
    r->m_unackd--;
    9fa0:	e2433001 	sub	r3, r3, #1
    
    if (!r->m_clientID.av_val)
    9fa4:	e3510000 	cmp	r1, #0
    {
        if (fill)
            goto restart;
        return -2;
    }
    r->m_sb.sb_size -= ptr - r->m_sb.sb_start;
    9fa8:	e587c0e4 	str	ip, [r7, #228]	; 0xe4
    r->m_sb.sb_start = ptr;
    9fac:	e587b0e8 	str	fp, [r7, #232]	; 0xe8
    r->m_unackd--;
    9fb0:	e5873084 	str	r3, [r7, #132]	; 0x84
    
    if (!r->m_clientID.av_val)
    9fb4:	0a000008 	beq	9fdc <HTTP_read+0x1a0>
        r->m_clientID.av_val[hlen] = 0;
        r->m_sb.sb_size = 0;
    }
    else
    {
        r->m_polling = *ptr++;
    9fb8:	e5d02004 	ldrb	r2, [r0, #4]
        r->m_resplen = hlen - 1;
    9fbc:	e2499001 	sub	r9, r9, #1
        r->m_sb.sb_start++;
        r->m_sb.sb_size--;
    9fc0:	e24c3001 	sub	r3, ip, #1
    }
    else
    {
        r->m_polling = *ptr++;
        r->m_resplen = hlen - 1;
        r->m_sb.sb_start++;
    9fc4:	e2800005 	add	r0, r0, #5
        r->m_sb.sb_size = 0;
    }
    else
    {
        r->m_polling = *ptr++;
        r->m_resplen = hlen - 1;
    9fc8:	e5879080 	str	r9, [r7, #128]	; 0x80
        r->m_clientID.av_val[hlen] = 0;
        r->m_sb.sb_size = 0;
    }
    else
    {
        r->m_polling = *ptr++;
    9fcc:	e587207c 	str	r2, [r7, #124]	; 0x7c
        r->m_resplen = hlen - 1;
        r->m_sb.sb_start++;
        r->m_sb.sb_size--;
    9fd0:	e58730e4 	str	r3, [r7, #228]	; 0xe4
    }
    else
    {
        r->m_polling = *ptr++;
        r->m_resplen = hlen - 1;
        r->m_sb.sb_start++;
    9fd4:	e58700e8 	str	r0, [r7, #232]	; 0xe8
    9fd8:	eaffffad 	b	9e94 <HTTP_read+0x58>
    r->m_sb.sb_start = ptr;
    r->m_unackd--;
    
    if (!r->m_clientID.av_val)
    {
        r->m_clientID.av_len = hlen;
    9fdc:	e587908c 	str	r9, [r7, #140]	; 0x8c
        r->m_clientID.av_val = malloc(hlen+1);
    9fe0:	e2890001 	add	r0, r9, #1
    9fe4:	ebffec0c 	bl	501c <malloc@plt>
        if (!r->m_clientID.av_val)
    9fe8:	e3500000 	cmp	r0, #0
    r->m_unackd--;
    
    if (!r->m_clientID.av_val)
    {
        r->m_clientID.av_len = hlen;
        r->m_clientID.av_val = malloc(hlen+1);
    9fec:	e1a05000 	mov	r5, r0
    9ff0:	e5870088 	str	r0, [r7, #136]	; 0x88
        if (!r->m_clientID.av_val)
    9ff4:	0affffca 	beq	9f24 <HTTP_read+0xe8>
            return -1;
        r->m_clientID.av_val[0] = '/';
    9ff8:	e3a0302f 	mov	r3, #47	; 0x2f
        memcpy(r->m_clientID.av_val+1, ptr, hlen-1);
    9ffc:	e1a0100b 	mov	r1, fp
    {
        r->m_clientID.av_len = hlen;
        r->m_clientID.av_val = malloc(hlen+1);
        if (!r->m_clientID.av_val)
            return -1;
        r->m_clientID.av_val[0] = '/';
    a000:	e4c03001 	strb	r3, [r0], #1
        memcpy(r->m_clientID.av_val+1, ptr, hlen-1);
    a004:	e2492001 	sub	r2, r9, #1
    a008:	ebffec6f 	bl	51cc <memcpy@plt>
        r->m_clientID.av_val[hlen] = 0;
    a00c:	e7c54009 	strb	r4, [r5, r9]
        r->m_sb.sb_size = 0;
    a010:	e58740e4 	str	r4, [r7, #228]	; 0xe4
    a014:	eaffff9e 	b	9e94 <HTTP_read+0x58>
    a018:	00014cf8 	.word	0x00014cf8
    a01c:	00014ccc 	.word	0x00014ccc
    a020:	00014ce4 	.word	0x00014ce4
    a024:	00014cd8 	.word	0x00014cd8
    a028:	00014cd8 	.word	0x00014cd8

0000a02c <RTMPSockBuf_Send>:
#ifdef _DEBUG
    fwrite(buf, 1, len, netstackdump);
#endif
    
#if defined(CRYPTO) && !defined(NO_SSL)
    if (sb->sb_ssl)
    a02c:	e2803901 	add	r3, r0, #16384	; 0x4000
    a030:	e5933010 	ldr	r3, [r3, #16]
    a034:	e3530000 	cmp	r3, #0
    a038:	0a000001 	beq	a044 <RTMPSockBuf_Send+0x18>
    {
        rc = TLS_write(sb->sb_ssl, buf, len);
    a03c:	e1a00003 	mov	r0, r3
    a040:	eaffece2 	b	53d0 <ssl_write@plt>
    }
    else
#endif
    {
        rc = send(sb->sb_socket, buf, len, 0);
    a044:	e5900000 	ldr	r0, [r0]
    a048:	eaffece3 	b	53dc <send@plt>

0000a04c <HTTP_Post>:
    free(out);
}

static int
HTTP_Post(RTMP *r, RTMPTCmd cmd, const char *buf, int len)
{
    a04c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
                        "User-Agent: Shockwave Flash\r\n"
                        "Connection: Keep-Alive\r\n"
                        "Cache-Control: no-cache\r\n"
                        "Content-type: application/x-fcs\r\n"
                        "Content-length: %d\r\n\r\n", RTMPT_cmds[cmd],
                        r->m_clientID.av_val ? r->m_clientID.av_val : "",
    a050:	e590c088 	ldr	ip, [r0, #136]	; 0x88
    free(out);
}

static int
HTTP_Post(RTMP *r, RTMPTCmd cmd, const char *buf, int len)
{
    a054:	e1a04000 	mov	r4, r0
    char hbuf[512];
    int hlen = snprintf(hbuf, sizeof(hbuf), "POST /%s%s/%d HTTP/1.1\r\n"
    a058:	e59f00b4 	ldr	r0, [pc, #180]	; a114 <HTTP_Post+0xc8>
    a05c:	e35c0000 	cmp	ip, #0
    a060:	e08f0000 	add	r0, pc, r0
    a064:	e0801101 	add	r1, r0, r1, lsl #2
    free(out);
}

static int
HTTP_Post(RTMP *r, RTMPTCmd cmd, const char *buf, int len)
{
    a068:	e1a06003 	mov	r6, r3
    a06c:	e24ddf86 	sub	sp, sp, #536	; 0x218
    a070:	e1a08002 	mov	r8, r2
    char hbuf[512];
    int hlen = snprintf(hbuf, sizeof(hbuf), "POST /%s%s/%d HTTP/1.1\r\n"
    a074:	e5913238 	ldr	r3, [r1, #568]	; 0x238
    a078:	0a000022 	beq	a108 <HTTP_Post+0xbc>
    a07c:	e2842901 	add	r2, r4, #16384	; 0x4000
                        "Cache-Control: no-cache\r\n"
                        "Content-type: application/x-fcs\r\n"
                        "Content-length: %d\r\n\r\n", RTMPT_cmds[cmd],
                        r->m_clientID.av_val ? r->m_clientID.av_val : "",
                        r->m_msgCounter, r->Link.hostname.av_len, r->Link.hostname.av_val,
                        r->Link.port, len);
    a080:	e2821f65 	add	r1, r2, #404	; 0x194

static int
HTTP_Post(RTMP *r, RTMPTCmd cmd, const char *buf, int len)
{
    char hbuf[512];
    int hlen = snprintf(hbuf, sizeof(hbuf), "POST /%s%s/%d HTTP/1.1\r\n"
    a084:	e1d1e0b2 	ldrh	lr, [r1, #2]
    a088:	e59200f8 	ldr	r0, [r2, #248]	; 0xf8
    a08c:	e59210f4 	ldr	r1, [r2, #244]	; 0xf4
    a090:	e5942078 	ldr	r2, [r4, #120]	; 0x78
    a094:	e58d2004 	str	r2, [sp, #4]
    a098:	e59f2078 	ldr	r2, [pc, #120]	; a118 <HTTP_Post+0xcc>
    a09c:	e28d5018 	add	r5, sp, #24
    a0a0:	e58dc000 	str	ip, [sp]
    a0a4:	e58de010 	str	lr, [sp, #16]
    a0a8:	e58d0008 	str	r0, [sp, #8]
    a0ac:	e58d100c 	str	r1, [sp, #12]
    a0b0:	e58d6014 	str	r6, [sp, #20]
    a0b4:	e1a00005 	mov	r0, r5
    a0b8:	e3a01c02 	mov	r1, #512	; 0x200
    a0bc:	e08f2002 	add	r2, pc, r2
    a0c0:	ebffec05 	bl	50dc <snprintf@plt>
                        "Content-type: application/x-fcs\r\n"
                        "Content-length: %d\r\n\r\n", RTMPT_cmds[cmd],
                        r->m_clientID.av_val ? r->m_clientID.av_val : "",
                        r->m_msgCounter, r->Link.hostname.av_len, r->Link.hostname.av_val,
                        r->Link.port, len);
    RTMPSockBuf_Send(&r->m_sb, hbuf, hlen);
    a0c4:	e28470e0 	add	r7, r4, #224	; 0xe0
    a0c8:	e1a01005 	mov	r1, r5

static int
HTTP_Post(RTMP *r, RTMPTCmd cmd, const char *buf, int len)
{
    char hbuf[512];
    int hlen = snprintf(hbuf, sizeof(hbuf), "POST /%s%s/%d HTTP/1.1\r\n"
    a0cc:	e1a02000 	mov	r2, r0
                        "Content-type: application/x-fcs\r\n"
                        "Content-length: %d\r\n\r\n", RTMPT_cmds[cmd],
                        r->m_clientID.av_val ? r->m_clientID.av_val : "",
                        r->m_msgCounter, r->Link.hostname.av_len, r->Link.hostname.av_val,
                        r->Link.port, len);
    RTMPSockBuf_Send(&r->m_sb, hbuf, hlen);
    a0d0:	e1a00007 	mov	r0, r7
    a0d4:	ebffffd4 	bl	a02c <RTMPSockBuf_Send>
    hlen = RTMPSockBuf_Send(&r->m_sb, buf, len);
    a0d8:	e1a02006 	mov	r2, r6
    a0dc:	e1a00007 	mov	r0, r7
    a0e0:	e1a01008 	mov	r1, r8
    a0e4:	ebffffd0 	bl	a02c <RTMPSockBuf_Send>
    r->m_msgCounter++;
    a0e8:	e5942078 	ldr	r2, [r4, #120]	; 0x78
    r->m_unackd++;
    a0ec:	e5943084 	ldr	r3, [r4, #132]	; 0x84
                        r->m_clientID.av_val ? r->m_clientID.av_val : "",
                        r->m_msgCounter, r->Link.hostname.av_len, r->Link.hostname.av_val,
                        r->Link.port, len);
    RTMPSockBuf_Send(&r->m_sb, hbuf, hlen);
    hlen = RTMPSockBuf_Send(&r->m_sb, buf, len);
    r->m_msgCounter++;
    a0f0:	e2822001 	add	r2, r2, #1
    r->m_unackd++;
    a0f4:	e2833001 	add	r3, r3, #1
                        r->m_clientID.av_val ? r->m_clientID.av_val : "",
                        r->m_msgCounter, r->Link.hostname.av_len, r->Link.hostname.av_val,
                        r->Link.port, len);
    RTMPSockBuf_Send(&r->m_sb, hbuf, hlen);
    hlen = RTMPSockBuf_Send(&r->m_sb, buf, len);
    r->m_msgCounter++;
    a0f8:	e5842078 	str	r2, [r4, #120]	; 0x78
    r->m_unackd++;
    a0fc:	e5843084 	str	r3, [r4, #132]	; 0x84
    return hlen;
}
    a100:	e28ddf86 	add	sp, sp, #536	; 0x218
    a104:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

static int
HTTP_Post(RTMP *r, RTMPTCmd cmd, const char *buf, int len)
{
    char hbuf[512];
    int hlen = snprintf(hbuf, sizeof(hbuf), "POST /%s%s/%d HTTP/1.1\r\n"
    a108:	e59fc00c 	ldr	ip, [pc, #12]	; a11c <HTTP_Post+0xd0>
    a10c:	e08fc00c 	add	ip, pc, ip
    a110:	eaffffd9 	b	a07c <HTTP_Post+0x30>
    a114:	000197e8 	.word	0x000197e8
    a118:	00014a9c 	.word	0x00014a9c
    a11c:	00013d25 	.word	0x00013d25

0000a120 <RTMPSockBuf_Close>:
    return rc;
}

int
RTMPSockBuf_Close(RTMPSockBuf *sb)
{
    a120:	e92d4038 	push	{r3, r4, r5, lr}
#if defined(CRYPTO) && !defined(NO_SSL)
    if (sb->sb_ssl)
    a124:	e2804901 	add	r4, r0, #16384	; 0x4000
    return rc;
}

int
RTMPSockBuf_Close(RTMPSockBuf *sb)
{
    a128:	e1a05000 	mov	r5, r0
#if defined(CRYPTO) && !defined(NO_SSL)
    if (sb->sb_ssl)
    a12c:	e5940010 	ldr	r0, [r4, #16]
    a130:	e3500000 	cmp	r0, #0
    a134:	0a000006 	beq	a154 <RTMPSockBuf_Close+0x34>
    {
        TLS_shutdown(sb->sb_ssl);
    a138:	ebffecaa 	bl	53e8 <ssl_close_notify@plt>
        TLS_close(sb->sb_ssl);
    a13c:	e5940010 	ldr	r0, [r4, #16]
    a140:	ebffecab 	bl	53f4 <ssl_free@plt>
    a144:	e5940010 	ldr	r0, [r4, #16]
    a148:	ebffebad 	bl	5004 <free@plt>
        sb->sb_ssl = NULL;
    a14c:	e3a03000 	mov	r3, #0
    a150:	e5843010 	str	r3, [r4, #16]
    }
#endif
    if (sb->sb_socket != -1)
    a154:	e5950000 	ldr	r0, [r5]
    a158:	e3700001 	cmn	r0, #1
    a15c:	0a000003 	beq	a170 <RTMPSockBuf_Close+0x50>
    {
		int result = closesocket(sb->sb_socket);
    a160:	ebffeca6 	bl	5400 <close@plt>
		sb->sb_socket = -1;
    a164:	e3e03000 	mvn	r3, #0
    a168:	e5853000 	str	r3, [r5]
		return result;
    a16c:	e8bd8038 	pop	{r3, r4, r5, pc}
    }
    return 0;
    a170:	e3a00000 	mov	r0, #0
}
    a174:	e8bd8038 	pop	{r3, r4, r5, pc}

0000a178 <RTMP_HTTP_get>:
//portal


HTTPResult
RTMP_HTTP_get(struct HTTP_ctx *http, const char *url,RTMP_AVIOInterruptCB *cb)
{
    a178:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a17c:	e24ddc42 	sub	sp, sp, #16896	; 0x4200
    a180:	e24dd084 	sub	sp, sp, #132	; 0x84
    int hlen, flen = 0;
    int rc, i;
	int sockfd = -1, error = 0, flags;
    
    HTTPResult ret = HTTPRES_OK;
    RTMPSockBuf sb = {0};
    a184:	e28d6d0a 	add	r6, sp, #640	; 0x280
//portal


HTTPResult
RTMP_HTTP_get(struct HTTP_ctx *http, const char *url,RTMP_AVIOInterruptCB *cb)
{
    a188:	e1a08000 	mov	r8, r0
    a18c:	e1a07001 	mov	r7, r1
    a190:	e1a0b002 	mov	fp, r2
    int hlen, flen = 0;
    int rc, i;
	int sockfd = -1, error = 0, flags;
    
    HTTPResult ret = HTTPRES_OK;
    RTMPSockBuf sb = {0};
    a194:	e3a01000 	mov	r1, #0
    a198:	e59f2698 	ldr	r2, [pc, #1688]	; a838 <RTMP_HTTP_get+0x6c0>
    a19c:	e2460014 	sub	r0, r6, #20
    a1a0:	ebffebca 	bl	50d0 <memset@plt>
    
    http->status = -1;
    a1a4:	e3e03000 	mvn	r3, #0
    a1a8:	e5883008 	str	r3, [r8, #8]
	
    p1 = strchr(url + 4, ':');
    a1ac:	e2870004 	add	r0, r7, #4
    a1b0:	e3a0103a 	mov	r1, #58	; 0x3a
    a1b4:	ebffebcb 	bl	50e8 <strchr@plt>
    if (!p1 || strncmp(p1, "://", 3))
    a1b8:	e2504000 	subs	r4, r0, #0
    a1bc:	0a000005 	beq	a1d8 <RTMP_HTTP_get+0x60>
    a1c0:	e59f1674 	ldr	r1, [pc, #1652]	; a83c <RTMP_HTTP_get+0x6c4>
    a1c4:	e3a02003 	mov	r2, #3
    a1c8:	e08f1001 	add	r1, pc, r1
    a1cc:	ebffec79 	bl	53b8 <strncmp@plt>
    a1d0:	e2505000 	subs	r5, r0, #0
    a1d4:	0a000003 	beq	a1e8 <RTMP_HTTP_get+0x70>
        return HTTPRES_BAD_REQUEST;
    a1d8:	e3a00003 	mov	r0, #3
    
leave:
    RTMP_Log(RTMP_LOGINFO,"http end: %lld   %d",RTMP_GetTime_mill(),ret);
    RTMPSockBuf_Close(&sb);
    return ret;
}
    a1dc:	e28ddc42 	add	sp, sp, #16896	; 0x4200
    a1e0:	e28dd084 	add	sp, sp, #132	; 0x84
    a1e4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
	
    p1 = strchr(url + 4, ':');
    if (!p1 || strncmp(p1, "://", 3))
        return HTTPRES_BAD_REQUEST;
    
    host = p1 + 3;
    a1e8:	e2844003 	add	r4, r4, #3
    path = strchr(host, '/');
    a1ec:	e1a00004 	mov	r0, r4
    a1f0:	e3a0102f 	mov	r1, #47	; 0x2f
    a1f4:	ebffebbb 	bl	50e8 <strchr@plt>
    hlen = path - host;
    strncpy(hbuf, host, hlen);
    a1f8:	e28d3d06 	add	r3, sp, #384	; 0x180
    a1fc:	e58d3010 	str	r3, [sp, #16]
    a200:	e28d3f5b 	add	r3, sp, #364	; 0x16c
    a204:	e1a01004 	mov	r1, r4
    a208:	e58d3018 	str	r3, [sp, #24]
    if (!p1 || strncmp(p1, "://", 3))
        return HTTPRES_BAD_REQUEST;
    
    host = p1 + 3;
    path = strchr(host, '/');
    hlen = path - host;
    a20c:	e0649000 	rsb	r9, r4, r0
    strncpy(hbuf, host, hlen);
    a210:	e1a02009 	mov	r2, r9
    a214:	e1a04003 	mov	r4, r3
    p1 = strchr(url + 4, ':');
    if (!p1 || strncmp(p1, "://", 3))
        return HTTPRES_BAD_REQUEST;
    
    host = p1 + 3;
    path = strchr(host, '/');
    a218:	e58d0020 	str	r0, [sp, #32]
    hlen = path - host;
    strncpy(hbuf, host, hlen);
    a21c:	e1a00003 	mov	r0, r3
    a220:	ebffebd7 	bl	5184 <strncpy@plt>
    hbuf[hlen] = '\0';
    a224:	e0869009 	add	r9, r6, r9
    host = hbuf;
    p1 = strrchr(host, ':');
    a228:	e1a00004 	mov	r0, r4
    a22c:	e3a0103a 	mov	r1, #58	; 0x3a
    
    host = p1 + 3;
    path = strchr(host, '/');
    hlen = path - host;
    strncpy(hbuf, host, hlen);
    hbuf[hlen] = '\0';
    a230:	e5495114 	strb	r5, [r9, #-276]	; 0xfffffeec
    host = hbuf;
    p1 = strrchr(host, ':');
    a234:	ebffec74 	bl	540c <strrchr@plt>
    if (p1)
    a238:	e3500000 	cmp	r0, #0
    a23c:	0a0000c3 	beq	a550 <RTMP_HTTP_get+0x3d8>
    {
        *p1++ = '\0';
    a240:	e4c05001 	strb	r5, [r0], #1
        port = atoi(p1);
    a244:	ebffebb0 	bl	510c <atoi@plt>
    a248:	e58d0014 	str	r0, [sp, #20]
    }
	
	struct addrinfo hints, *res, *aip;
	
	memset(&hints, 0, sizeof(hints));
    a24c:	e28d9080 	add	r9, sp, #128	; 0x80
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	char SERVICE[10] = { '\0' };
	sprintf(SERVICE, "%d", port);
    a250:	e59f15e8 	ldr	r1, [pc, #1512]	; a840 <RTMP_HTTP_get+0x6c8>
        port = atoi(p1);
    }
	
	struct addrinfo hints, *res, *aip;
	
	memset(&hints, 0, sizeof(hints));
    a254:	e3a03000 	mov	r3, #0
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	char SERVICE[10] = { '\0' };
	sprintf(SERVICE, "%d", port);
    a258:	e2494040 	sub	r4, r9, #64	; 0x40
	struct addrinfo hints, *res, *aip;
	
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	char SERVICE[10] = { '\0' };
    a25c:	e246cf8e 	sub	ip, r6, #568	; 0x238
	
	struct addrinfo hints, *res, *aip;
	
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
    a260:	e3a0e001 	mov	lr, #1
        port = atoi(p1);
    }
	
	struct addrinfo hints, *res, *aip;
	
	memset(&hints, 0, sizeof(hints));
    a264:	e5093034 	str	r3, [r9, #-52]	; 0xffffffcc
    a268:	e5093030 	str	r3, [r9, #-48]	; 0xffffffd0
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	char SERVICE[10] = { '\0' };
	sprintf(SERVICE, "%d", port);
    a26c:	e08f1001 	add	r1, pc, r1
    a270:	e59d2014 	ldr	r2, [sp, #20]
        port = atoi(p1);
    }
	
	struct addrinfo hints, *res, *aip;
	
	memset(&hints, 0, sizeof(hints));
    a274:	e5093028 	str	r3, [r9, #-40]	; 0xffffffd8
    a278:	e5093024 	str	r3, [r9, #-36]	; 0xffffffdc
    a27c:	e5093020 	str	r3, [r9, #-32]	; 0xffffffe0
    a280:	e509301c 	str	r3, [r9, #-28]	; 0xffffffe4
    a284:	e5093018 	str	r3, [r9, #-24]	; 0xffffffe8
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	char SERVICE[10] = { '\0' };
	sprintf(SERVICE, "%d", port);
    a288:	e1a00004 	mov	r0, r4
	struct addrinfo hints, *res, *aip;
	
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	char SERVICE[10] = { '\0' };
    a28c:	e1cc30b0 	strh	r3, [ip]
	
	struct addrinfo hints, *res, *aip;
	
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
    a290:	e506e22c 	str	lr, [r6, #-556]	; 0xfffffdd4
	char SERVICE[10] = { '\0' };
    a294:	e5063240 	str	r3, [r6, #-576]	; 0xfffffdc0
    a298:	e506323c 	str	r3, [r6, #-572]	; 0xfffffdc4
	sprintf(SERVICE, "%d", port);
    a29c:	ebffebb2 	bl	516c <sprintf@plt>
	
	RTMP_Log(RTMP_LOGINFO, "getaddrinfo hostname=%s, servname=%s", host, SERVICE);
    a2a0:	e59da018 	ldr	sl, [sp, #24]
    a2a4:	e59f1598 	ldr	r1, [pc, #1432]	; a844 <RTMP_HTTP_get+0x6cc>
    a2a8:	e1a03004 	mov	r3, r4
    a2ac:	e3a00003 	mov	r0, #3
    a2b0:	e08f1001 	add	r1, pc, r1
    a2b4:	e1a0200a 	mov	r2, sl
        port = atoi(p1);
    }
	
	struct addrinfo hints, *res, *aip;
	
	memset(&hints, 0, sizeof(hints));
    a2b8:	e2495034 	sub	r5, r9, #52	; 0x34
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	char SERVICE[10] = { '\0' };
	sprintf(SERVICE, "%d", port);
	
	RTMP_Log(RTMP_LOGINFO, "getaddrinfo hostname=%s, servname=%s", host, SERVICE);
    a2bc:	eb002dba 	bl	159ac <RTMP_Log>
	error = getaddrinfo(host, SERVICE, &hints, &res);
    a2c0:	e249304c 	sub	r3, r9, #76	; 0x4c
    a2c4:	e1a0000a 	mov	r0, sl
    a2c8:	e1a01004 	mov	r1, r4
    a2cc:	e1a02005 	mov	r2, r5
    a2d0:	ebffec50 	bl	5418 <getaddrinfo@plt>
	if (error != 0)
    a2d4:	e2503000 	subs	r3, r0, #0
    a2d8:	0a000003 	beq	a2ec <RTMP_HTTP_get+0x174>
	
	freeaddrinfo(res);
	
	sb.sb_socket = sockfd;
    if (sb.sb_socket == -1)
        return HTTPRES_LOST_CONNECTION;
    a2dc:	e3a00006 	mov	r0, #6
    
leave:
    RTMP_Log(RTMP_LOGINFO,"http end: %lld   %d",RTMP_GetTime_mill(),ret);
    RTMPSockBuf_Close(&sb);
    return ret;
}
    a2e0:	e28ddc42 	add	sp, sp, #16896	; 0x4200
    a2e4:	e28dd084 	add	sp, sp, #132	; 0x84
    a2e8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (error != 0)
	{
		return HTTPRES_LOST_CONNECTION;
	}
	
	for (aip = res; aip != NULL; aip = aip->ai_next)
    a2ec:	e516424c 	ldr	r4, [r6, #-588]	; 0xfffffdb4
    a2f0:	e3540000 	cmp	r4, #0
    a2f4:	0a0000f1 	beq	a6c0 <RTMP_HTTP_get+0x548>
					break;
			}
		}
		else
		{
			flags = fcntl(sockfd, F_GETFL, 0);
    a2f8:	e58d301c 	str	r3, [sp, #28]
				struct timeval tm;
				fd_set read_set, write_set;
				
				tm.tv_sec = 2;
				tm.tv_usec = 0;
				FD_ZERO(&read_set);
    a2fc:	e2493014 	sub	r3, r9, #20
    a300:	e58db02c 	str	fp, [sp, #44]	; 0x2c
    a304:	e58d8024 	str	r8, [sp, #36]	; 0x24
    a308:	e58d7028 	str	r7, [sp, #40]	; 0x28
    a30c:	e1a0b003 	mov	fp, r3
    a310:	ea000012 	b	a360 <RTMP_HTTP_get+0x1e8>
					break;
			}
		}
		else
		{
			flags = fcntl(sockfd, F_GETFL, 0);
    a314:	ebffec42 	bl	5424 <fcntl@plt>
			fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);
    a318:	e3a01004 	mov	r1, #4
    a31c:	e3802b02 	orr	r2, r0, #2048	; 0x800
    a320:	e1a00005 	mov	r0, r5
    a324:	ebffec3e 	bl	5424 <fcntl@plt>
#ifdef PLATFORM_IOS
			int iset = 1;
			setsockopt(sockfd, SOL_SOCKET, SO_NOSIGPIPE, (void *)&iset, sizeof(int));
#endif
			connect(sockfd, aip->ai_addr, aip->ai_addrlen);
    a328:	e5941018 	ldr	r1, [r4, #24]
    a32c:	e5942010 	ldr	r2, [r4, #16]
    a330:	e1a00005 	mov	r0, r5
    a334:	ebffec3d 	bl	5430 <connect@plt>
			if (EINPROGRESS == errno)
    a338:	ebffec18 	bl	53a0 <__errno@plt>
    a33c:	e5903000 	ldr	r3, [r0]
    a340:	e3530073 	cmp	r3, #115	; 0x73
    a344:	0a00000e 	beq	a384 <RTMP_HTTP_get+0x20c>
						break;
					}
				}
			}
			
			close(sockfd);
    a348:	e1a00005 	mov	r0, r5
    a34c:	ebffec2b 	bl	5400 <close@plt>
			sockfd = -1;
    a350:	e3e05000 	mvn	r5, #0
	if (error != 0)
	{
		return HTTPRES_LOST_CONNECTION;
	}
	
	for (aip = res; aip != NULL; aip = aip->ai_next)
    a354:	e594401c 	ldr	r4, [r4, #28]
    a358:	e3540000 	cmp	r4, #0
    a35c:	0a00007e 	beq	a55c <RTMP_HTTP_get+0x3e4>
	{
		sockfd = socket(aip->ai_family, aip->ai_socktype, aip->ai_protocol);
    a360:	e9940007 	ldmib	r4, {r0, r1, r2}
    a364:	ebffec34 	bl	543c <socket@plt>
					break;
			}
		}
		else
		{
			flags = fcntl(sockfd, F_GETFL, 0);
    a368:	e3a01003 	mov	r1, #3
    a36c:	e3a02000 	mov	r2, #0
	
	for (aip = res; aip != NULL; aip = aip->ai_next)
	{
		sockfd = socket(aip->ai_family, aip->ai_socktype, aip->ai_protocol);
		
		if (sockfd < 0)
    a370:	e2505000 	subs	r5, r0, #0
    a374:	aaffffe6 	bge	a314 <RTMP_HTTP_get+0x19c>
		{
			switch (errno)
    a378:	ebffec08 	bl	53a0 <__errno@plt>
    a37c:	e5903000 	ldr	r3, [r0]
    a380:	eafffff3 	b	a354 <RTMP_HTTP_get+0x1dc>
				fd_set read_set, write_set;
				
				tm.tv_sec = 2;
				tm.tv_usec = 0;
				FD_ZERO(&read_set);
				FD_ZERO(&write_set);
    a384:	e59d3010 	ldr	r3, [sp, #16]
				struct timeval tm;
				fd_set read_set, write_set;
				
				tm.tv_sec = 2;
				tm.tv_usec = 0;
				FD_ZERO(&read_set);
    a388:	e3a01000 	mov	r1, #0
				FD_ZERO(&write_set);
    a38c:	e2438094 	sub	r8, r3, #148	; 0x94
			if (EINPROGRESS == errno)
			{
				struct timeval tm;
				fd_set read_set, write_set;
				
				tm.tv_sec = 2;
    a390:	e3a03002 	mov	r3, #2
				tm.tv_usec = 0;
				FD_ZERO(&read_set);
    a394:	e3a02080 	mov	r2, #128	; 0x80
			if (EINPROGRESS == errno)
			{
				struct timeval tm;
				fd_set read_set, write_set;
				
				tm.tv_sec = 2;
    a398:	e5063248 	str	r3, [r6, #-584]	; 0xfffffdb8
				tm.tv_usec = 0;
				FD_ZERO(&read_set);
    a39c:	e1a0000b 	mov	r0, fp
			{
				struct timeval tm;
				fd_set read_set, write_set;
				
				tm.tv_sec = 2;
				tm.tv_usec = 0;
    a3a0:	e59d301c 	ldr	r3, [sp, #28]
    a3a4:	e5063244 	str	r3, [r6, #-580]	; 0xfffffdbc
				FD_ZERO(&read_set);
    a3a8:	ebffeb48 	bl	50d0 <memset@plt>
				FD_ZERO(&write_set);
    a3ac:	e1a00008 	mov	r0, r8
    a3b0:	e3a01000 	mov	r1, #0
    a3b4:	e3a02080 	mov	r2, #128	; 0x80
    a3b8:	ebffeb44 	bl	50d0 <memset@plt>
				
				FD_SET(sockfd, &read_set);
    a3bc:	e3a0c001 	mov	ip, #1
    a3c0:	e205301f 	and	r3, r5, #31
    a3c4:	e1a0731c 	lsl	r7, ip, r3
    a3c8:	e1a012c5 	asr	r1, r5, #5
				FD_SET(sockfd, &write_set);
				
				if (select(sockfd + 1, &read_set, &write_set, NULL, &tm) > 0)
    a3cc:	e2493048 	sub	r3, r9, #72	; 0x48
    a3d0:	e1a02008 	mov	r2, r8
				tm.tv_sec = 2;
				tm.tv_usec = 0;
				FD_ZERO(&read_set);
				FD_ZERO(&write_set);
				
				FD_SET(sockfd, &read_set);
    a3d4:	e0868101 	add	r8, r6, r1, lsl #2
				FD_SET(sockfd, &write_set);
				
				if (select(sockfd + 1, &read_set, &write_set, NULL, &tm) > 0)
    a3d8:	e58d3000 	str	r3, [sp]
    a3dc:	e1a0100b 	mov	r1, fp
    a3e0:	e085000c 	add	r0, r5, ip
    a3e4:	e3a03000 	mov	r3, #0
				tm.tv_sec = 2;
				tm.tv_usec = 0;
				FD_ZERO(&read_set);
				FD_ZERO(&write_set);
				
				FD_SET(sockfd, &read_set);
    a3e8:	e5087214 	str	r7, [r8, #-532]	; 0xfffffdec
				FD_SET(sockfd, &write_set);
    a3ec:	e5087194 	str	r7, [r8, #-404]	; 0xfffffe6c
				
				if (select(sockfd + 1, &read_set, &write_set, NULL, &tm) > 0)
    a3f0:	ebffec14 	bl	5448 <select@plt>
				struct timeval tm;
				fd_set read_set, write_set;
				
				tm.tv_sec = 2;
				tm.tv_usec = 0;
				FD_ZERO(&read_set);
    a3f4:	e1a0a00b 	mov	sl, fp
				FD_ZERO(&write_set);
				
				FD_SET(sockfd, &read_set);
				FD_SET(sockfd, &write_set);
				
				if (select(sockfd + 1, &read_set, &write_set, NULL, &tm) > 0)
    a3f8:	e3500000 	cmp	r0, #0
    a3fc:	daffffd1 	ble	a348 <RTMP_HTTP_get+0x1d0>
				{
					if (FD_ISSET(sockfd, &write_set))
    a400:	e5183194 	ldr	r3, [r8, #-404]	; 0xfffffe6c
    a404:	e1170003 	tst	r7, r3
    a408:	0affffce 	beq	a348 <RTMP_HTTP_get+0x1d0>
			close(sockfd);
			sockfd = -1;
		}
	}
	
	freeaddrinfo(res);
    a40c:	e516024c 	ldr	r0, [r6, #-588]	; 0xfffffdb4
    a410:	e1a0900a 	mov	r9, sl
    a414:	e59d8024 	ldr	r8, [sp, #36]	; 0x24
    a418:	e59d7028 	ldr	r7, [sp, #40]	; 0x28
    a41c:	e59db02c 	ldr	fp, [sp, #44]	; 0x2c
    a420:	ebffec0b 	bl	5454 <freeaddrinfo@plt>
	
	sb.sb_socket = sockfd;
    a424:	e5065014 	str	r5, [r6, #-20]	; 0xffffffec
    if (sb.sb_socket == -1)
        return HTTPRES_LOST_CONNECTION;
    if(port != 80 )
    a428:	e59d1014 	ldr	r1, [sp, #20]
        i = sprintf(sb.sb_buf,
					"GET %s HTTP/1.0\r\nUser-Agent: %s\r\nHost: %s:%d\r\nReferer: %.*s\r\n",
					path, AGENT_RTMP, host,port, (int)(path - url + 1), url);
    a42c:	e59d2020 	ldr	r2, [sp, #32]
	freeaddrinfo(res);
	
	sb.sb_socket = sockfd;
    if (sb.sb_socket == -1)
        return HTTPRES_LOST_CONNECTION;
    if(port != 80 )
    a430:	e3510050 	cmp	r1, #80	; 0x50
        i = sprintf(sb.sb_buf,
					"GET %s HTTP/1.0\r\nUser-Agent: %s\r\nHost: %s:%d\r\nReferer: %.*s\r\n",
					path, AGENT_RTMP, host,port, (int)(path - url + 1), url);
    a434:	e0673002 	rsb	r3, r7, r2
	
	sb.sb_socket = sockfd;
    if (sb.sb_socket == -1)
        return HTTPRES_LOST_CONNECTION;
    if(port != 80 )
        i = sprintf(sb.sb_buf,
    a438:	e2833001 	add	r3, r3, #1
	freeaddrinfo(res);
	
	sb.sb_socket = sockfd;
    if (sb.sb_socket == -1)
        return HTTPRES_LOST_CONNECTION;
    if(port != 80 )
    a43c:	0a000085 	beq	a658 <RTMP_HTTP_get+0x4e0>
        i = sprintf(sb.sb_buf,
    a440:	e59d0018 	ldr	r0, [sp, #24]
    a444:	e88d008b 	stm	sp, {r0, r1, r3, r7}
    a448:	e59f13f8 	ldr	r1, [pc, #1016]	; a848 <RTMP_HTTP_get+0x6d0>
    a44c:	e59f33f8 	ldr	r3, [pc, #1016]	; a84c <RTMP_HTTP_get+0x6d4>
    a450:	e2460008 	sub	r0, r6, #8
    a454:	e08f1001 	add	r1, pc, r1
    a458:	e08f3003 	add	r3, pc, r3
    a45c:	ebffeb42 	bl	516c <sprintf@plt>
    a460:	e1a05000 	mov	r5, r0
    else
        i = sprintf(sb.sb_buf,
					"GET %s HTTP/1.0\r\nUser-Agent: %s\r\nHost: %s\r\nReferer: %.*s\r\n",
					path, AGENT_RTMP, host,(int)(path - url + 1), url);
    
    i += sprintf(sb.sb_buf + i, "\r\n");
    a464:	e2467014 	sub	r7, r6, #20
    a468:	e59f13e0 	ldr	r1, [pc, #992]	; a850 <RTMP_HTTP_get+0x6d8>
    a46c:	e0870005 	add	r0, r7, r5
    a470:	e3a02003 	mov	r2, #3
    a474:	e08f1001 	add	r1, pc, r1
    a478:	e280000c 	add	r0, r0, #12
    a47c:	ebffeb52 	bl	51cc <memcpy@plt>
   
    RTMP_Log(RTMP_LOGINFO,"connect begin: %lld",RTMP_GetTime_mill());
    a480:	ebfff86b 	bl	8634 <RTMP_GetTime_mill>
        }
#endif
    }
#endif
    RTMP_Log(RTMP_LOGINFO,"http send begin: %lld",RTMP_GetTime_mill());
    SET_RCVTIMEO(tv, 1);
    a484:	e3a04001 	mov	r4, #1
					"GET %s HTTP/1.0\r\nUser-Agent: %s\r\nHost: %s\r\nReferer: %.*s\r\n",
					path, AGENT_RTMP, host,(int)(path - url + 1), url);
    
    i += sprintf(sb.sb_buf + i, "\r\n");
   
    RTMP_Log(RTMP_LOGINFO,"connect begin: %lld",RTMP_GetTime_mill());
    a488:	e1a03001 	mov	r3, r1
    a48c:	e59f13c0 	ldr	r1, [pc, #960]	; a854 <RTMP_HTTP_get+0x6dc>
    a490:	e1a02000 	mov	r2, r0
    a494:	e08f1001 	add	r1, pc, r1
    a498:	e3a00003 	mov	r0, #3
    a49c:	eb002d42 	bl	159ac <RTMP_Log>
    
    flags = fcntl(sb.sb_socket, F_GETFL, 0);
    a4a0:	e3a01003 	mov	r1, #3
    a4a4:	e3a02000 	mov	r2, #0
    a4a8:	e5160014 	ldr	r0, [r6, #-20]	; 0xffffffec
    a4ac:	ebffebdc 	bl	5424 <fcntl@plt>
    fcntl(sb.sb_socket, F_SETFL, flags & ~O_NONBLOCK);
    a4b0:	e3a01004 	mov	r1, #4
    a4b4:	e3c02b02 	bic	r2, r0, #2048	; 0x800
    a4b8:	e5160014 	ldr	r0, [r6, #-20]	; 0xffffffec
    a4bc:	ebffebd8 	bl	5424 <fcntl@plt>
            goto leave;
        }
#endif
    }
#endif
    RTMP_Log(RTMP_LOGINFO,"http send begin: %lld",RTMP_GetTime_mill());
    a4c0:	ebfff85b 	bl	8634 <RTMP_GetTime_mill>
    a4c4:	e1a03001 	mov	r3, r1
    a4c8:	e59f1388 	ldr	r1, [pc, #904]	; a858 <RTMP_HTTP_get+0x6e0>
    a4cc:	e1a02000 	mov	r2, r0
    a4d0:	e08f1001 	add	r1, pc, r1
    a4d4:	e3a00003 	mov	r0, #3
    a4d8:	eb002d33 	bl	159ac <RTMP_Log>
    SET_RCVTIMEO(tv, 1);
    if (setsockopt
    a4dc:	e3a02008 	mov	r2, #8
        }
#endif
    }
#endif
    RTMP_Log(RTMP_LOGINFO,"http send begin: %lld",RTMP_GetTime_mill());
    SET_RCVTIMEO(tv, 1);
    a4e0:	e3a0c000 	mov	ip, #0
    if (setsockopt
    a4e4:	e5160014 	ldr	r0, [r6, #-20]	; 0xffffffec
    a4e8:	e1a03009 	mov	r3, r9
    a4ec:	e58d2000 	str	r2, [sp]
    a4f0:	e1a01004 	mov	r1, r4
    a4f4:	e3a02015 	mov	r2, #21
        }
#endif
    }
#endif
    RTMP_Log(RTMP_LOGINFO,"http send begin: %lld",RTMP_GetTime_mill());
    SET_RCVTIMEO(tv, 1);
    a4f8:	e5064214 	str	r4, [r6, #-532]	; 0xfffffdec
    a4fc:	e506c210 	str	ip, [r6, #-528]	; 0xfffffdf0
    if (setsockopt
    a500:	ebffebd6 	bl	5460 <setsockopt@plt>
    a504:	e3500000 	cmp	r0, #0
    a508:	1a000048 	bne	a630 <RTMP_HTTP_get+0x4b8>
        (sb.sb_socket, SOL_SOCKET, SO_SNDTIMEO, (char *)&tv, sizeof(tv)))
    {
        RTMP_Log(RTMP_LOGERROR, "%s, Setting socket timeout to %ds failed!",
                 __FUNCTION__, 2);
    }
    if(!ff_check_interrupt_rtmp(cb))
    a50c:	e1a0000b 	mov	r0, fp
    a510:	ebfff803 	bl	8524 <ff_check_interrupt_rtmp>
    a514:	e2504000 	subs	r4, r0, #0
#endif
    int hlen, flen = 0;
    int rc, i;
	int sockfd = -1, error = 0, flags;
    
    HTTPResult ret = HTTPRES_OK;
    a518:	13a04000 	movne	r4, #0
        (sb.sb_socket, SOL_SOCKET, SO_SNDTIMEO, (char *)&tv, sizeof(tv)))
    {
        RTMP_Log(RTMP_LOGERROR, "%s, Setting socket timeout to %ds failed!",
                 __FUNCTION__, 2);
    }
    if(!ff_check_interrupt_rtmp(cb))
    a51c:	0a000019 	beq	a588 <RTMP_HTTP_get+0x410>
    http->size=flen;
    //memcpy(http->data,sb.sb_start,flen);
    sprintf(http->data,"%s",sb.sb_start);
    
leave:
    RTMP_Log(RTMP_LOGINFO,"http end: %lld   %d",RTMP_GetTime_mill(),ret);
    a520:	ebfff843 	bl	8634 <RTMP_GetTime_mill>
    a524:	e58d4000 	str	r4, [sp]
    a528:	e1a03001 	mov	r3, r1
    a52c:	e59f1328 	ldr	r1, [pc, #808]	; a85c <RTMP_HTTP_get+0x6e4>
    a530:	e1a02000 	mov	r2, r0
    a534:	e08f1001 	add	r1, pc, r1
    a538:	e3a00003 	mov	r0, #3
    a53c:	eb002d1a 	bl	159ac <RTMP_Log>
    RTMPSockBuf_Close(&sb);
    a540:	e1a00007 	mov	r0, r7
    a544:	ebfffef5 	bl	a120 <RTMPSockBuf_Close>
    return ret;
    a548:	e1a00004 	mov	r0, r4
    a54c:	eaffff22 	b	a1dc <RTMP_HTTP_get+0x64>
RTMP_HTTP_get(struct HTTP_ctx *http, const char *url,RTMP_AVIOInterruptCB *cb)
{
    char *host, *path;
    char *p1, *p2;
    char hbuf[256];
    int port = 80;
    a550:	e3a03050 	mov	r3, #80	; 0x50
    a554:	e58d3014 	str	r3, [sp, #20]
    a558:	eaffff3b 	b	a24c <RTMP_HTTP_get+0xd4>
			close(sockfd);
			sockfd = -1;
		}
	}
	
	freeaddrinfo(res);
    a55c:	e516024c 	ldr	r0, [r6, #-588]	; 0xfffffdb4
    a560:	e59d8024 	ldr	r8, [sp, #36]	; 0x24
    a564:	e59d7028 	ldr	r7, [sp, #40]	; 0x28
    a568:	e59db02c 	ldr	fp, [sp, #44]	; 0x2c
    a56c:	ebffebb8 	bl	5454 <freeaddrinfo@plt>
	
	sb.sb_socket = sockfd;
    if (sb.sb_socket == -1)
    a570:	e3750001 	cmn	r5, #1
		}
	}
	
	freeaddrinfo(res);
	
	sb.sb_socket = sockfd;
    a574:	e5065014 	str	r5, [r6, #-20]	; 0xffffffec
    if (sb.sb_socket == -1)
    a578:	0affff57 	beq	a2dc <RTMP_HTTP_get+0x164>
    a57c:	e28d306c 	add	r3, sp, #108	; 0x6c
    a580:	e1a09003 	mov	r9, r3
    a584:	eaffffa7 	b	a428 <RTMP_HTTP_get+0x2b0>
    {
        RTMP_Log(RTMP_LOGERROR, "%s, Setting socket timeout to %ds failed!",
                 __FUNCTION__, 2);
    }
    if(!ff_check_interrupt_rtmp(cb))
        RTMPSockBuf_Send(&sb, sb.sb_buf, i);
    a588:	e2852002 	add	r2, r5, #2
    a58c:	e2461008 	sub	r1, r6, #8
    a590:	e1a00007 	mov	r0, r7
    a594:	ebfffea4 	bl	a02c <RTMPSockBuf_Send>
    //RTMP_Log(RTMP_LOGINFO,"SEND PORTAL:%s ",sb.sb_buf);
    
#define HTTP_TIMEOUT	5
    {
        SET_RCVTIMEO(tv, HTTP_TIMEOUT);
        if (setsockopt
    a598:	e59d3010 	ldr	r3, [sp, #16]
    a59c:	e3a02008 	mov	r2, #8
    
    //RTMP_Log(RTMP_LOGINFO,"SEND PORTAL:%s ",sb.sb_buf);
    
#define HTTP_TIMEOUT	5
    {
        SET_RCVTIMEO(tv, HTTP_TIMEOUT);
    a5a0:	e3a05005 	mov	r5, #5
        if (setsockopt
    a5a4:	e5160014 	ldr	r0, [r6, #-20]	; 0xffffffec
    a5a8:	e2433094 	sub	r3, r3, #148	; 0x94
    a5ac:	e58d2000 	str	r2, [sp]
    a5b0:	e3a01001 	mov	r1, #1
    a5b4:	e3a02014 	mov	r2, #20
    
    //RTMP_Log(RTMP_LOGINFO,"SEND PORTAL:%s ",sb.sb_buf);
    
#define HTTP_TIMEOUT	5
    {
        SET_RCVTIMEO(tv, HTTP_TIMEOUT);
    a5b8:	e5064190 	str	r4, [r6, #-400]	; 0xfffffe70
    a5bc:	e5065194 	str	r5, [r6, #-404]	; 0xfffffe6c
        if (setsockopt
    a5c0:	ebffeba6 	bl	5460 <setsockopt@plt>
    a5c4:	e3500000 	cmp	r0, #0
    a5c8:	1a00002c 	bne	a680 <RTMP_HTTP_get+0x508>
        {
            RTMP_Log(RTMP_LOGERROR, "%s, Setting socket timeout to %ds failed!",
                     __FUNCTION__, HTTP_TIMEOUT);
        }
    }
    RTMP_Log(RTMP_LOGINFO,"http recv begin: %lld",RTMP_GetTime_mill());
    a5cc:	ebfff818 	bl	8634 <RTMP_GetTime_mill>
    a5d0:	e1a03001 	mov	r3, r1
    a5d4:	e59f1284 	ldr	r1, [pc, #644]	; a860 <RTMP_HTTP_get+0x6e8>
    a5d8:	e1a02000 	mov	r2, r0
    a5dc:	e08f1001 	add	r1, pc, r1
    a5e0:	e3a00003 	mov	r0, #3
    a5e4:	eb002cf0 	bl	159ac <RTMP_Log>
    sb.sb_size = 0;
    a5e8:	e3a02000 	mov	r2, #0
    sb.sb_timedout = FALSE;
    a5ec:	e28d3dca 	add	r3, sp, #12928	; 0x3280
    if (RTMPSockBuf_Fill(&sb) < 1)
    a5f0:	e1a00007 	mov	r0, r7
            RTMP_Log(RTMP_LOGERROR, "%s, Setting socket timeout to %ds failed!",
                     __FUNCTION__, HTTP_TIMEOUT);
        }
    }
    RTMP_Log(RTMP_LOGINFO,"http recv begin: %lld",RTMP_GetTime_mill());
    sb.sb_size = 0;
    a5f4:	e5062010 	str	r2, [r6, #-16]
    sb.sb_timedout = FALSE;
    a5f8:	e5832ff8 	str	r2, [r3, #4088]	; 0xff8
    if (RTMPSockBuf_Fill(&sb) < 1)
    a5fc:	ebfffdd8 	bl	9d64 <RTMPSockBuf_Fill>
    a600:	e3500000 	cmp	r0, #0
    a604:	da00002b 	ble	a6b8 <RTMP_HTTP_get+0x540>
    {
        ret = HTTPRES_LOST_CONNECTION;
        goto leave;
    }
    if (strncmp(sb.sb_buf, "HTTP/1", 6))
    a608:	e59f1254 	ldr	r1, [pc, #596]	; a864 <RTMP_HTTP_get+0x6ec>
    a60c:	e2465008 	sub	r5, r6, #8
    a610:	e1a00005 	mov	r0, r5
    a614:	e08f1001 	add	r1, pc, r1
    a618:	e3a02006 	mov	r2, #6
    a61c:	ebffeb65 	bl	53b8 <strncmp@plt>
    a620:	e2504000 	subs	r4, r0, #0
    a624:	0a000027 	beq	a6c8 <RTMP_HTTP_get+0x550>
    {
        ret = HTTPRES_BAD_REQUEST;
    a628:	e3a04003 	mov	r4, #3
    a62c:	eaffffbb 	b	a520 <RTMP_HTTP_get+0x3a8>
    RTMP_Log(RTMP_LOGINFO,"http send begin: %lld",RTMP_GetTime_mill());
    SET_RCVTIMEO(tv, 1);
    if (setsockopt
        (sb.sb_socket, SOL_SOCKET, SO_SNDTIMEO, (char *)&tv, sizeof(tv)))
    {
        RTMP_Log(RTMP_LOGERROR, "%s, Setting socket timeout to %ds failed!",
    a630:	e59f2230 	ldr	r2, [pc, #560]	; a868 <RTMP_HTTP_get+0x6f0>
    a634:	e59f1230 	ldr	r1, [pc, #560]	; a86c <RTMP_HTTP_get+0x6f4>
    a638:	e08f2002 	add	r2, pc, r2
    a63c:	e2422d32 	sub	r2, r2, #3200	; 0xc80
    a640:	e1a00004 	mov	r0, r4
    a644:	e2422004 	sub	r2, r2, #4
    a648:	e08f1001 	add	r1, pc, r1
    a64c:	e3a03002 	mov	r3, #2
    a650:	eb002cd5 	bl	159ac <RTMP_Log>
    a654:	eaffffac 	b	a50c <RTMP_HTTP_get+0x394>
    if(port != 80 )
        i = sprintf(sb.sb_buf,
					"GET %s HTTP/1.0\r\nUser-Agent: %s\r\nHost: %s:%d\r\nReferer: %.*s\r\n",
					path, AGENT_RTMP, host,port, (int)(path - url + 1), url);
    else
        i = sprintf(sb.sb_buf,
    a658:	e59d1018 	ldr	r1, [sp, #24]
    a65c:	e2460008 	sub	r0, r6, #8
    a660:	e88d008a 	stm	sp, {r1, r3, r7}
    a664:	e59f1204 	ldr	r1, [pc, #516]	; a870 <RTMP_HTTP_get+0x6f8>
    a668:	e59f3204 	ldr	r3, [pc, #516]	; a874 <RTMP_HTTP_get+0x6fc>
    a66c:	e08f1001 	add	r1, pc, r1
    a670:	e08f3003 	add	r3, pc, r3
    a674:	ebffeabc 	bl	516c <sprintf@plt>
    a678:	e1a05000 	mov	r5, r0
    a67c:	eaffff78 	b	a464 <RTMP_HTTP_get+0x2ec>
    {
        SET_RCVTIMEO(tv, HTTP_TIMEOUT);
        if (setsockopt
            (sb.sb_socket, SOL_SOCKET, SO_RCVTIMEO, (char *)&tv, sizeof(tv)))
        {
            RTMP_Log(RTMP_LOGERROR, "%s, Setting socket timeout to %ds failed!",
    a680:	e59f21f0 	ldr	r2, [pc, #496]	; a878 <RTMP_HTTP_get+0x700>
    a684:	e59f11f0 	ldr	r1, [pc, #496]	; a87c <RTMP_HTTP_get+0x704>
    a688:	e08f2002 	add	r2, pc, r2
    a68c:	e2422d32 	sub	r2, r2, #3200	; 0xc80
    a690:	e1a03005 	mov	r3, r5
    a694:	e2422004 	sub	r2, r2, #4
    a698:	e3a00001 	mov	r0, #1
    a69c:	e08f1001 	add	r1, pc, r1
    a6a0:	eb002cc1 	bl	159ac <RTMP_Log>
    a6a4:	eaffffc8 	b	a5cc <RTMP_HTTP_get+0x454>
        sb.sb_size -= p2 - sb.sb_start;
        sb.sb_start = p2;
        
        if (sb.sb_size < 1  && !ff_check_interrupt_rtmp(cb))
        {
            if (RTMPSockBuf_Fill(&sb) < 1)
    a6a8:	e1a00007 	mov	r0, r7
    a6ac:	ebfffdac 	bl	9d64 <RTMPSockBuf_Fill>
    a6b0:	e3500000 	cmp	r0, #0
    a6b4:	ca000052 	bgt	a804 <RTMP_HTTP_get+0x68c>
    RTMP_Log(RTMP_LOGINFO,"http recv begin: %lld",RTMP_GetTime_mill());
    sb.sb_size = 0;
    sb.sb_timedout = FALSE;
    if (RTMPSockBuf_Fill(&sb) < 1)
    {
        ret = HTTPRES_LOST_CONNECTION;
    a6b8:	e3a04006 	mov	r4, #6
    a6bc:	eaffff97 	b	a520 <RTMP_HTTP_get+0x3a8>
			close(sockfd);
			sockfd = -1;
		}
	}
	
	freeaddrinfo(res);
    a6c0:	ebffeb63 	bl	5454 <freeaddrinfo@plt>
    a6c4:	eaffff04 	b	a2dc <RTMP_HTTP_get+0x164>
        goto leave;
    }
    
    //RTMP_Log(RTMP_LOGINFO," recv http: %s \n",sb.sb_buf);
    
    p1 = strchr(sb.sb_buf, ' ');
    a6c8:	e3a01020 	mov	r1, #32
    a6cc:	e1a00005 	mov	r0, r5
    a6d0:	ebffea84 	bl	50e8 <strchr@plt>
    rc = atoi(p1 + 1);
    a6d4:	e2800001 	add	r0, r0, #1
    a6d8:	ebffea8b 	bl	510c <atoi@plt>
    http->status = rc;
    
    if (rc >= 300)
    a6dc:	e3500f4b 	cmp	r0, #300	; 0x12c
    
    //RTMP_Log(RTMP_LOGINFO," recv http: %s \n",sb.sb_buf);
    
    p1 = strchr(sb.sb_buf, ' ');
    rc = atoi(p1 + 1);
    http->status = rc;
    a6e0:	e5880008 	str	r0, [r8, #8]
    
    if (rc >= 300)
    a6e4:	ba00000b 	blt	a718 <RTMP_HTTP_get+0x5a0>
    {
        if (rc == 304)
    a6e8:	e3500e13 	cmp	r0, #304	; 0x130
        {
            ret = HTTPRES_OK_NOT_MODIFIED;
    a6ec:	03a04001 	moveq	r4, #1
    rc = atoi(p1 + 1);
    http->status = rc;
    
    if (rc >= 300)
    {
        if (rc == 304)
    a6f0:	0affff8a 	beq	a520 <RTMP_HTTP_get+0x3a8>
        {
            ret = HTTPRES_OK_NOT_MODIFIED;
            goto leave;
        }
        else if (rc == 404)
    a6f4:	e3500f65 	cmp	r0, #404	; 0x194
            ret = HTTPRES_NOT_FOUND;
    a6f8:	03a04002 	moveq	r4, #2
        if (rc == 304)
        {
            ret = HTTPRES_OK_NOT_MODIFIED;
            goto leave;
        }
        else if (rc == 404)
    a6fc:	0a000005 	beq	a718 <RTMP_HTTP_get+0x5a0>
            ret = HTTPRES_NOT_FOUND;
        else if (rc >= 500)
    a700:	e3500f7d 	cmp	r0, #500	; 0x1f4
            ret = HTTPRES_SERVER_ERROR;
    a704:	a3a04004 	movge	r4, #4
            ret = HTTPRES_OK_NOT_MODIFIED;
            goto leave;
        }
        else if (rc == 404)
            ret = HTTPRES_NOT_FOUND;
        else if (rc >= 500)
    a708:	aa000002 	bge	a718 <RTMP_HTTP_get+0x5a0>
            ret = HTTPRES_SERVER_ERROR;
        else if (rc >= 400)
            ret = HTTPRES_BAD_REQUEST;
        else
            ret = HTTPRES_REDIRECTED;
    a70c:	e3500e19 	cmp	r0, #400	; 0x190
    a710:	a3a04003 	movge	r4, #3
    a714:	b3a04005 	movlt	r4, #5
    }
    
    p1 = memchr(sb.sb_buf, '\n', sb.sb_size);
    a718:	e516a010 	ldr	sl, [r6, #-16]
    a71c:	e2465008 	sub	r5, r6, #8
    a720:	e1a0200a 	mov	r2, sl
    a724:	e1a00005 	mov	r0, r5
    a728:	e3a0100a 	mov	r1, #10
    a72c:	ebffeb4e 	bl	546c <memchr@plt>
    if (!p1)
    a730:	e3500000 	cmp	r0, #0
    a734:	0affffbb 	beq	a628 <RTMP_HTTP_get+0x4b0>
    int port = 80;
	
#ifdef CRYPTO
    int ssl = 0;
#endif
    int hlen, flen = 0;
    a738:	e3a03000 	mov	r3, #0
    a73c:	e58d3014 	str	r3, [sp, #20]
        {
            sb.sb_start += 2;
            sb.sb_size -= 2;
            break;
        }
        else if (!strncasecmp
    a740:	e59f3138 	ldr	r3, [pc, #312]	; a880 <RTMP_HTTP_get+0x708>
    if (!p1)
    {
        ret = HTTPRES_BAD_REQUEST;
        goto leave;
    }
    sb.sb_start = p1 + 1;
    a744:	e2809001 	add	r9, r0, #1
        {
            sb.sb_start += 2;
            sb.sb_size -= 2;
            break;
        }
        else if (!strncasecmp
    a748:	e08f3003 	add	r3, pc, r3
    a74c:	e58d3010 	str	r3, [sp, #16]
                 (sb.sb_start, "Content-Length: ", sizeof("Content-Length: ") - 1) || !strncasecmp
    a750:	e59f312c 	ldr	r3, [pc, #300]	; a884 <RTMP_HTTP_get+0x70c>
    {
        ret = HTTPRES_BAD_REQUEST;
        goto leave;
    }
    sb.sb_start = p1 + 1;
    sb.sb_size -= sb.sb_start - sb.sb_buf;
    a754:	e0692005 	rsb	r2, r9, r5
    a758:	e08aa002 	add	sl, sl, r2
            sb.sb_start += 2;
            sb.sb_size -= 2;
            break;
        }
        else if (!strncasecmp
                 (sb.sb_start, "Content-Length: ", sizeof("Content-Length: ") - 1) || !strncasecmp
    a75c:	e08f3003 	add	r3, pc, r3
    {
        ret = HTTPRES_BAD_REQUEST;
        goto leave;
    }
    sb.sb_start = p1 + 1;
    sb.sb_size -= sb.sb_start - sb.sb_buf;
    a760:	e506a010 	str	sl, [r6, #-16]
    if (!p1)
    {
        ret = HTTPRES_BAD_REQUEST;
        goto leave;
    }
    sb.sb_start = p1 + 1;
    a764:	e506900c 	str	r9, [r6, #-12]
            sb.sb_start += 2;
            sb.sb_size -= 2;
            break;
        }
        else if (!strncasecmp
                 (sb.sb_start, "Content-Length: ", sizeof("Content-Length: ") - 1) || !strncasecmp
    a768:	e58d3018 	str	r3, [sp, #24]
        goto leave;
    }
    sb.sb_start = p1 + 1;
    sb.sb_size -= sb.sb_start - sb.sb_buf;
    
    while ((p2 = memchr(sb.sb_start, '\r', sb.sb_size)))
    a76c:	e1a00009 	mov	r0, r9
    a770:	e3a0100d 	mov	r1, #13
    a774:	e1a0200a 	mov	r2, sl
    a778:	ebffeb3b 	bl	546c <memchr@plt>
    a77c:	e2505000 	subs	r5, r0, #0
    a780:	0a000026 	beq	a820 <RTMP_HTTP_get+0x6a8>
    {
        if (*sb.sb_start == '\r')
    a784:	e5d93000 	ldrb	r3, [r9]
    a788:	e353000d 	cmp	r3, #13
    a78c:	0a00001f 	beq	a810 <RTMP_HTTP_get+0x698>
        {
            sb.sb_start += 2;
            sb.sb_size -= 2;
            break;
        }
        else if (!strncasecmp
    a790:	e1a00009 	mov	r0, r9
    a794:	e59d1010 	ldr	r1, [sp, #16]
    a798:	e3a02010 	mov	r2, #16
    a79c:	ebffeb08 	bl	53c4 <strncasecmp@plt>
    a7a0:	e3500000 	cmp	r0, #0
    a7a4:	0a000005 	beq	a7c0 <RTMP_HTTP_get+0x648>
                 (sb.sb_start, "Content-Length: ", sizeof("Content-Length: ") - 1) || !strncasecmp
    a7a8:	e1a00009 	mov	r0, r9
    a7ac:	e59d1018 	ldr	r1, [sp, #24]
    a7b0:	e3a0200f 	mov	r2, #15
    a7b4:	ebffeb02 	bl	53c4 <strncasecmp@plt>
    a7b8:	e3500000 	cmp	r0, #0
    a7bc:	1a000004 	bne	a7d4 <RTMP_HTTP_get+0x65c>
                 (sb.sb_start, "Content-Length:", sizeof("Content-Length:") - 1))
        {
            flen = atoi(sb.sb_start + sizeof("Content-Length: ") - 1);
    a7c0:	e2890010 	add	r0, r9, #16
    a7c4:	ebffea50 	bl	510c <atoi@plt>
    a7c8:	e516a010 	ldr	sl, [r6, #-16]
    a7cc:	e516900c 	ldr	r9, [r6, #-12]
    a7d0:	e58d0014 	str	r0, [sp, #20]
        }
        
        p2 += 2;
    a7d4:	e2853002 	add	r3, r5, #2
        sb.sb_size -= p2 - sb.sb_start;
    a7d8:	e0639009 	rsb	r9, r3, r9
    a7dc:	e08aa009 	add	sl, sl, r9
        sb.sb_start = p2;
        
        if (sb.sb_size < 1  && !ff_check_interrupt_rtmp(cb))
    a7e0:	e35a0000 	cmp	sl, #0
        {
            flen = atoi(sb.sb_start + sizeof("Content-Length: ") - 1);
        }
        
        p2 += 2;
        sb.sb_size -= p2 - sb.sb_start;
    a7e4:	e506a010 	str	sl, [r6, #-16]
        sb.sb_start = p2;
    a7e8:	e506300c 	str	r3, [r6, #-12]
    a7ec:	c1a09003 	movgt	r9, r3
        
        if (sb.sb_size < 1  && !ff_check_interrupt_rtmp(cb))
    a7f0:	caffffdd 	bgt	a76c <RTMP_HTTP_get+0x5f4>
    a7f4:	e1a0000b 	mov	r0, fp
    a7f8:	ebfff749 	bl	8524 <ff_check_interrupt_rtmp>
    a7fc:	e3500000 	cmp	r0, #0
    a800:	0affffa8 	beq	a6a8 <RTMP_HTTP_get+0x530>
    a804:	e516900c 	ldr	r9, [r6, #-12]
    a808:	e516a010 	ldr	sl, [r6, #-16]
    a80c:	eaffffd6 	b	a76c <RTMP_HTTP_get+0x5f4>
    
    while ((p2 = memchr(sb.sb_start, '\r', sb.sb_size)))
    {
        if (*sb.sb_start == '\r')
        {
            sb.sb_start += 2;
    a810:	e2893002 	add	r3, r9, #2
            sb.sb_size -= 2;
    a814:	e24ac002 	sub	ip, sl, #2
    
    while ((p2 = memchr(sb.sb_start, '\r', sb.sb_size)))
    {
        if (*sb.sb_start == '\r')
        {
            sb.sb_start += 2;
    a818:	e506300c 	str	r3, [r6, #-12]
            sb.sb_size -= 2;
    a81c:	e506c010 	str	ip, [r6, #-16]
                goto leave;
            }
        }
    }
	
    http->size=flen;
    a820:	e59d3014 	ldr	r3, [sp, #20]
    a824:	e5883004 	str	r3, [r8, #4]
    //memcpy(http->data,sb.sb_start,flen);
    sprintf(http->data,"%s",sb.sb_start);
    a828:	e598000c 	ldr	r0, [r8, #12]
    a82c:	e516100c 	ldr	r1, [r6, #-12]
    a830:	ebffea71 	bl	51fc <strcpy@plt>
    a834:	eaffff39 	b	a520 <RTMP_HTTP_get+0x3a8>
    a838:	00004014 	.word	0x00004014
    a83c:	00014368 	.word	0x00014368
    a840:	00014410 	.word	0x00014410
    a844:	00014964 	.word	0x00014964
    a848:	000147e8 	.word	0x000147e8
    a84c:	00014824 	.word	0x00014824
    a850:	00014850 	.word	0x00014850
    a854:	00014834 	.word	0x00014834
    a858:	0001480c 	.word	0x0001480c
    a85c:	00014830 	.word	0x00014830
    a860:	00014744 	.word	0x00014744
    a864:	00014724 	.word	0x00014724
    a868:	000141a8 	.word	0x000141a8
    a86c:	000146ac 	.word	0x000146ac
    a870:	0001461c 	.word	0x0001461c
    a874:	0001460c 	.word	0x0001460c
    a878:	00014158 	.word	0x00014158
    a87c:	00014658 	.word	0x00014658
    a880:	000145f8 	.word	0x000145f8
    a884:	000145f8 	.word	0x000145f8

0000a888 <request_access>:
    
    rsa_pkcs1_encrypt(&rsa, ctr_drbg_random, &ctr_drbg, RSA_PUBLIC, plaintext_size, plaintext, ciphertext) ;
}

int request_access(RTMP *r,char *url)
{  
    a888:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a88c:	e24ddd63 	sub	sp, sp, #6336	; 0x18c0
    a890:	e24dd024 	sub	sp, sp, #36	; 0x24
    char req_url[5000]={'\0'};
    a894:	e28d4e8e 	add	r4, sp, #2272	; 0x8e0
    
    rsa_pkcs1_encrypt(&rsa, ctr_drbg_random, &ctr_drbg, RSA_PUBLIC, plaintext_size, plaintext, ciphertext) ;
}

int request_access(RTMP *r,char *url)
{  
    a898:	e1a05000 	mov	r5, r0
    a89c:	e1a08001 	mov	r8, r1
    char req_url[5000]={'\0'};
    a8a0:	e59f23f4 	ldr	r2, [pc, #1012]	; ac9c <request_access+0x414>
    a8a4:	e3a01000 	mov	r1, #0
    a8a8:	e2440fe2 	sub	r0, r4, #904	; 0x388
    AVal pRTMPUrl;
    
    if(!Parse_AccessUrl(r,url,&pRTMPUrl))
    a8ac:	e28d9060 	add	r9, sp, #96	; 0x60
    rsa_pkcs1_encrypt(&rsa, ctr_drbg_random, &ctr_drbg, RSA_PUBLIC, plaintext_size, plaintext, ciphertext) ;
}

int request_access(RTMP *r,char *url)
{  
    char req_url[5000]={'\0'};
    a8b0:	ebffea06 	bl	50d0 <memset@plt>
    AVal pRTMPUrl;
    
    if(!Parse_AccessUrl(r,url,&pRTMPUrl))
    a8b4:	e1a00005 	mov	r0, r5
    a8b8:	e1a01008 	mov	r1, r8
    a8bc:	e2492020 	sub	r2, r9, #32
    a8c0:	ebfff43f 	bl	79c4 <Parse_AccessUrl>
    a8c4:	e250b000 	subs	fp, r0, #0
    a8c8:	0a0000db 	beq	ac3c <request_access+0x3b4>
    {
        printf("parse access url fail :%s\n",url);
        return 0;
    }

    RTMP_Log(RTMP_LOGINFO, "request_access url=%s", url);
    a8cc:	e59f13cc 	ldr	r1, [pc, #972]	; aca0 <request_access+0x418>
    
    memset(req_url,0x00,strlen(req_url));
    a8d0:	e28d6e56 	add	r6, sp, #1376	; 0x560
    {
        printf("parse access url fail :%s\n",url);
        return 0;
    }

    RTMP_Log(RTMP_LOGINFO, "request_access url=%s", url);
    a8d4:	e08f1001 	add	r1, pc, r1
    a8d8:	e1a02008 	mov	r2, r8
    a8dc:	e3a00003 	mov	r0, #3
    
    memset(req_url,0x00,strlen(req_url));
    a8e0:	e2466008 	sub	r6, r6, #8
    {
        printf("parse access url fail :%s\n",url);
        return 0;
    }

    RTMP_Log(RTMP_LOGINFO, "request_access url=%s", url);
    a8e4:	eb002c30 	bl	159ac <RTMP_Log>
    
    memset(req_url,0x00,strlen(req_url));
    a8e8:	e1a00006 	mov	r0, r6
    a8ec:	ebffea03 	bl	5100 <strlen@plt>
    char seed[256] = { '\0' };
    a8f0:	e249a008 	sub	sl, r9, #8
        return 0;
    }

    RTMP_Log(RTMP_LOGINFO, "request_access url=%s", url);
    
    memset(req_url,0x00,strlen(req_url));
    a8f4:	e3a01000 	mov	r1, #0
    char seed[256] = { '\0' };
    int beginning = 0;
    a8f8:	e3a0b000 	mov	fp, #0
        return 0;
    }

    RTMP_Log(RTMP_LOGINFO, "request_access url=%s", url);
    
    memset(req_url,0x00,strlen(req_url));
    a8fc:	e1a02000 	mov	r2, r0
    a900:	e1a00006 	mov	r0, r6
    a904:	ebffe9f1 	bl	50d0 <memset@plt>
    char seed[256] = { '\0' };
    a908:	e3a01000 	mov	r1, #0
    a90c:	e3a02c01 	mov	r2, #256	; 0x100
    a910:	e1a0000a 	mov	r0, sl
    a914:	ebffe9ed 	bl	50d0 <memset@plt>
    int beginning = 0;
    if (load_url_seed(url, seed, &beginning))
    a918:	e1a0100a 	mov	r1, sl
    a91c:	e1a00008 	mov	r0, r8
    a920:	e2492024 	sub	r2, r9, #36	; 0x24

    RTMP_Log(RTMP_LOGINFO, "request_access url=%s", url);
    
    memset(req_url,0x00,strlen(req_url));
    char seed[256] = { '\0' };
    int beginning = 0;
    a924:	e504b8a4 	str	fp, [r4, #-2212]	; 0xfffff75c
    if (load_url_seed(url, seed, &beginning))
    a928:	ebfff4cb 	bl	7c5c <load_url_seed>
    a92c:	e150000b 	cmp	r0, fp
    a930:	1a000080 	bne	ab38 <request_access+0x2b0>
            r->access.uid, r->access.magic, r->access.product_id, r->access.product_version, r->m_os, RTMP_SDK_VERSION, r->access.becheck,
            key, r->access.beginning);
    }
    else
    {
        sprintf(req_url, "http://%.*s/pushAccess?v=0&sn=%s.%s&uid=%s&magic=%s&callback=&productID=%s&productVersion=%s&os=%d&sdkVersion=%s&check=%d",
    a934:	e2851b12 	add	r1, r5, #18432	; 0x4800
    a938:	e285cc46 	add	ip, r5, #17920	; 0x4600
    a93c:	e2857b11 	add	r7, r5, #17408	; 0x4400
    a940:	e28ce018 	add	lr, ip, #24
    a944:	e285a901 	add	sl, r5, #16384	; 0x4000
    a948:	e281c00c 	add	ip, r1, #12
    a94c:	e2877024 	add	r7, r7, #36	; 0x24
    a950:	e514289c 	ldr	r2, [r4, #-2204]	; 0xfffff764
    a954:	e51438a0 	ldr	r3, [r4, #-2208]	; 0xfffff760
    a958:	e281b070 	add	fp, r1, #112	; 0x70
    a95c:	e58d7000 	str	r7, [sp]
    a960:	e28110d4 	add	r1, r1, #212	; 0xd4
    a964:	e59a7b94 	ldr	r7, [sl, #2964]	; 0xb94
    a968:	e58de004 	str	lr, [sp, #4]
    a96c:	e59ae99c 	ldr	lr, [sl, #2460]	; 0x99c
    a970:	e58dc008 	str	ip, [sp, #8]
    a974:	e59fc328 	ldr	ip, [pc, #808]	; aca4 <request_access+0x41c>
    a978:	e58d1010 	str	r1, [sp, #16]
    a97c:	e2850c49 	add	r0, r5, #18688	; 0x4900
    a980:	e59f1320 	ldr	r1, [pc, #800]	; aca8 <request_access+0x420>
    a984:	e2800038 	add	r0, r0, #56	; 0x38
    a988:	e08fc00c 	add	ip, pc, ip
    a98c:	e58d0014 	str	r0, [sp, #20]
    a990:	e58d7018 	str	r7, [sp, #24]
    a994:	e58db00c 	str	fp, [sp, #12]
    a998:	e58de020 	str	lr, [sp, #32]
    a99c:	e58dc01c 	str	ip, [sp, #28]
    a9a0:	e1a00006 	mov	r0, r6
    a9a4:	e08f1001 	add	r1, pc, r1
    a9a8:	ebffe9ef 	bl	516c <sprintf@plt>
    a9ac:	e28d7e16 	add	r7, sp, #352	; 0x160
            pRTMPUrl.av_len, pRTMPUrl.av_val, r->access.app, r->access.stream,
            r->access.uid, r->access.magic, r->access.product_id, r->access.product_version, r->m_os, RTMP_SDK_VERSION, r->access.becheck);
    }

    RTMP_Log(RTMP_LOGINFO,"access request:%s \n",req_url);
    a9b0:	e59f12f4 	ldr	r1, [pc, #756]	; acac <request_access+0x424>
    
    struct HTTP_ctx http = { 0 };
    a9b4:	e3a0b000 	mov	fp, #0
    char data[1024] = {'\0'};
    a9b8:	e2477008 	sub	r7, r7, #8
        sprintf(req_url, "http://%.*s/pushAccess?v=0&sn=%s.%s&uid=%s&magic=%s&callback=&productID=%s&productVersion=%s&os=%d&sdkVersion=%s&check=%d",
            pRTMPUrl.av_len, pRTMPUrl.av_val, r->access.app, r->access.stream,
            r->access.uid, r->access.magic, r->access.product_id, r->access.product_version, r->m_os, RTMP_SDK_VERSION, r->access.becheck);
    }

    RTMP_Log(RTMP_LOGINFO,"access request:%s \n",req_url);
    a9bc:	e3a00003 	mov	r0, #3
    a9c0:	e08f1001 	add	r1, pc, r1
    a9c4:	e1a02006 	mov	r2, r6
    a9c8:	eb002bf7 	bl	159ac <RTMP_Log>
    
    struct HTTP_ctx http = { 0 };
    char data[1024] = {'\0'};
    a9cc:	e1a0100b 	mov	r1, fp
    a9d0:	e3a02b01 	mov	r2, #1024	; 0x400
    a9d4:	e1a00007 	mov	r0, r7
            r->access.uid, r->access.magic, r->access.product_id, r->access.product_version, r->m_os, RTMP_SDK_VERSION, r->access.becheck);
    }

    RTMP_Log(RTMP_LOGINFO,"access request:%s \n",req_url);
    
    struct HTTP_ctx http = { 0 };
    a9d8:	e504b898 	str	fp, [r4, #-2200]	; 0xfffff768
    a9dc:	e504b894 	str	fp, [r4, #-2196]	; 0xfffff76c
    a9e0:	e504b890 	str	fp, [r4, #-2192]	; 0xfffff770
    char data[1024] = {'\0'};
    a9e4:	ebffe9b9 	bl	50d0 <memset@plt>
    http.data=data;
    http.size=0;
    
    if(RTMP_HTTP_get(&http,req_url,NULL)!=HTTPRES_OK)
    a9e8:	e2490018 	sub	r0, r9, #24
    a9ec:	e1a01006 	mov	r1, r6
    a9f0:	e1a0200b 	mov	r2, fp

    RTMP_Log(RTMP_LOGINFO,"access request:%s \n",req_url);
    
    struct HTTP_ctx http = { 0 };
    char data[1024] = {'\0'};
    http.data=data;
    a9f4:	e504788c 	str	r7, [r4, #-2188]	; 0xfffff774
    http.size=0;
    
    if(RTMP_HTTP_get(&http,req_url,NULL)!=HTTPRES_OK)
    a9f8:	ebfffdde 	bl	a178 <RTMP_HTTP_get>
    a9fc:	e150000b 	cmp	r0, fp
    {
        RTMP_Log(RTMP_LOGINFO,"http get access address fail \n");
    aa00:	e3a00003 	mov	r0, #3
    struct HTTP_ctx http = { 0 };
    char data[1024] = {'\0'};
    http.data=data;
    http.size=0;
    
    if(RTMP_HTTP_get(&http,req_url,NULL)!=HTTPRES_OK)
    aa04:	1a000094 	bne	ac5c <request_access+0x3d4>
    {
        RTMP_Log(RTMP_LOGINFO,"http get access address fail \n");
        return FALSE;
    }
    RTMP_Log(RTMP_LOGINFO,"http res, size=%d, data=%s", http.size, (char *)http.data);
    aa08:	e59f12a0 	ldr	r1, [pc, #672]	; acb0 <request_access+0x428>
    aa0c:	e5142894 	ldr	r2, [r4, #-2196]	; 0xfffff76c
    aa10:	e08f1001 	add	r1, pc, r1
    aa14:	e514388c 	ldr	r3, [r4, #-2188]	; 0xfffff774
    aa18:	eb002be3 	bl	159ac <RTMP_Log>

    //parse http data js
    if (http.data != NULL && http.size > 0)
    aa1c:	e514088c 	ldr	r0, [r4, #-2188]	; 0xfffff774
    aa20:	e3500000 	cmp	r0, #0
    aa24:	0a000093 	beq	ac78 <request_access+0x3f0>
    aa28:	e5143894 	ldr	r3, [r4, #-2196]	; 0xfffff76c
    aa2c:	e3530000 	cmp	r3, #0
    aa30:	da000090 	ble	ac78 <request_access+0x3f0>
    {
        cJSON * pJson = cJSON_Parse(http.data);
    aa34:	eb0028a0 	bl	14cbc <cJSON_Parse>
        if (NULL == pJson)
    aa38:	e250b000 	subs	fp, r0, #0
    aa3c:	0a000039 	beq	ab28 <request_access+0x2a0>
        {
            return FALSE;
        }

        cJSON *pJsonR = cJSON_GetObjectItem(pJson, "r");
    aa40:	e59f126c 	ldr	r1, [pc, #620]	; acb4 <request_access+0x42c>
    aa44:	e08f1001 	add	r1, pc, r1
    aa48:	eb0028cf 	bl	14d8c <cJSON_GetObjectItem>
        if (NULL == pJsonR || pJsonR->valueint < 0)
    aa4c:	e3500000 	cmp	r0, #0
    aa50:	0a00008d 	beq	ac8c <request_access+0x404>
    aa54:	e5903014 	ldr	r3, [r0, #20]
    aa58:	e3530000 	cmp	r3, #0
    aa5c:	ba00008a 	blt	ac8c <request_access+0x404>
        {
            cJSON_Delete(pJson);
            return FALSE;
        }
        
        cJSON *pJsonDt = cJSON_GetObjectItem(pJson, "dt");
    aa60:	e59f1250 	ldr	r1, [pc, #592]	; acb8 <request_access+0x430>
    aa64:	e1a0000b 	mov	r0, fp
    aa68:	e08f1001 	add	r1, pc, r1
    aa6c:	eb0028c6 	bl	14d8c <cJSON_GetObjectItem>
        if (pJsonDt != NULL)
    aa70:	e2504000 	subs	r4, r0, #0
    aa74:	0a000028 	beq	ab1c <request_access+0x294>
        {
            cJSON *pJsonEndpoint = cJSON_GetObjectItem(pJsonDt, "endpoint");
    aa78:	e59f123c 	ldr	r1, [pc, #572]	; acbc <request_access+0x434>
    aa7c:	e08f1001 	add	r1, pc, r1
    aa80:	eb0028c1 	bl	14d8c <cJSON_GetObjectItem>
            if (pJsonEndpoint != NULL)
    aa84:	e3500000 	cmp	r0, #0
    aa88:	0a00000d 	beq	aac4 <request_access+0x23c>
            {
                strcpy(r->access.real_url, pJsonEndpoint->valuestring);
    aa8c:	e2853c42 	add	r3, r5, #16896	; 0x4200
    aa90:	e2833008 	add	r3, r3, #8
    aa94:	e5901010 	ldr	r1, [r0, #16]
    aa98:	e1a00003 	mov	r0, r3
    aa9c:	ebffe9d6 	bl	51fc <strcpy@plt>
    aaa0:	e59f2218 	ldr	r2, [pc, #536]	; acc0 <request_access+0x438>
				if (g_func_rtmpSetStatValue != NULL)
    aaa4:	e79f2002 	ldr	r2, [pc, r2]
    aaa8:	e5922000 	ldr	r2, [r2]
    aaac:	e3520000 	cmp	r2, #0
    aab0:	0a000003 	beq	aac4 <request_access+0x23c>
				{
					g_func_rtmpSetStatValue("value_publish_rtmp_real_url", r->access.real_url);//yiqin callback 
    aab4:	e1a01000 	mov	r1, r0
    aab8:	e59f0204 	ldr	r0, [pc, #516]	; acc4 <request_access+0x43c>
    aabc:	e08f0000 	add	r0, pc, r0
    aac0:	e12fff32 	blx	r2
#ifdef _LINUX_IOS_
                setValue("event_rtmp_rtmpUrl", r->access.real_url);
#endif
            }

            cJSON *pJsonSeed = cJSON_GetObjectItem(pJsonDt, "seed");
    aac4:	e59f11fc 	ldr	r1, [pc, #508]	; acc8 <request_access+0x440>
    aac8:	e1a00004 	mov	r0, r4
    aacc:	e08f1001 	add	r1, pc, r1
    aad0:	eb0028ad 	bl	14d8c <cJSON_GetObjectItem>
            if (pJsonSeed!= NULL)
            {
                strcpy(r->access.seed, pJsonSeed->valuestring);
    aad4:	e2855c43 	add	r5, r5, #17152	; 0x4300
    aad8:	e28550fc 	add	r5, r5, #252	; 0xfc
                setValue("event_rtmp_rtmpUrl", r->access.real_url);
#endif
            }

            cJSON *pJsonSeed = cJSON_GetObjectItem(pJsonDt, "seed");
            if (pJsonSeed!= NULL)
    aadc:	e3500000 	cmp	r0, #0
    aae0:	0a000002 	beq	aaf0 <request_access+0x268>
            {
                strcpy(r->access.seed, pJsonSeed->valuestring);
    aae4:	e5901010 	ldr	r1, [r0, #16]
    aae8:	e1a00005 	mov	r0, r5
    aaec:	ebffe9c2 	bl	51fc <strcpy@plt>
            }

            cJSON *pJsonBeginning = cJSON_GetObjectItem(pJsonDt, "beginning");
    aaf0:	e59f11d4 	ldr	r1, [pc, #468]	; accc <request_access+0x444>
    aaf4:	e1a00004 	mov	r0, r4
    aaf8:	e08f1001 	add	r1, pc, r1
    aafc:	eb0028a2 	bl	14d8c <cJSON_GetObjectItem>
            if (pJsonBeginning != NULL)
            {
                r->access.beginning = pJsonBeginning->valueint;
            }

            save_url_seed(url, r->access.seed, r->access.beginning);
    ab00:	e1a01005 	mov	r1, r5
            {
                strcpy(r->access.seed, pJsonSeed->valuestring);
            }

            cJSON *pJsonBeginning = cJSON_GetObjectItem(pJsonDt, "beginning");
            if (pJsonBeginning != NULL)
    ab04:	e3500000 	cmp	r0, #0
            {
                r->access.beginning = pJsonBeginning->valueint;
    ab08:	15902014 	ldrne	r2, [r0, #20]
    ab0c:	059a2420 	ldreq	r2, [sl, #1056]	; 0x420
    ab10:	158a2420 	strne	r2, [sl, #1056]	; 0x420
            }

            save_url_seed(url, r->access.seed, r->access.beginning);
    ab14:	e1a00008 	mov	r0, r8
    ab18:	ebfff521 	bl	7fa4 <save_url_seed>
        }

        cJSON_Delete(pJson);
    ab1c:	e1a0000b 	mov	r0, fp
    ab20:	eb0027f4 	bl	14af8 <cJSON_Delete>
    }

    return TRUE;
    ab24:	e3a0b001 	mov	fp, #1
}
    ab28:	e1a0000b 	mov	r0, fp
    ab2c:	e28ddd63 	add	sp, sp, #6336	; 0x18c0
    ab30:	e28dd024 	add	sp, sp, #36	; 0x24
    ab34:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    memset(req_url,0x00,strlen(req_url));
    char seed[256] = { '\0' };
    int beginning = 0;
    if (load_url_seed(url, seed, &beginning))
    {
        strcpy(r->access.seed, seed);
    ab38:	e2853c43 	add	r3, r5, #17152	; 0x4300
    ab3c:	e28330fc 	add	r3, r3, #252	; 0xfc
    ab40:	e1a0100a 	mov	r1, sl
    ab44:	e1a00003 	mov	r0, r3
    ab48:	ebffe9ab 	bl	51fc <strcpy@plt>
        r->access.beginning = beginning + 1;
    ab4c:	e51428a4 	ldr	r2, [r4, #-2212]	; 0xfffff75c
    ab50:	e285a901 	add	sl, r5, #16384	; 0x4000
    ab54:	e2822001 	add	r2, r2, #1

        save_url_seed(url, r->access.seed, r->access.beginning);

        char key[33]={'\0'};
    ab58:	e28d7e16 	add	r7, sp, #352	; 0x160
    char seed[256] = { '\0' };
    int beginning = 0;
    if (load_url_seed(url, seed, &beginning))
    {
        strcpy(r->access.seed, seed);
        r->access.beginning = beginning + 1;
    ab5c:	e58a2420 	str	r2, [sl, #1056]	; 0x420

        save_url_seed(url, r->access.seed, r->access.beginning);
    ab60:	e1a01000 	mov	r1, r0
    ab64:	e1a00008 	mov	r0, r8
    ab68:	ebfff50d 	bl	7fa4 <save_url_seed>

        char key[33]={'\0'};
        RTMP_Access_GETKey(&r->access,key);
    ab6c:	e2473008 	sub	r3, r7, #8
    ab70:	e1a0e003 	mov	lr, r3
    ab74:	e2850c42 	add	r0, r5, #16896	; 0x4200
        strcpy(r->access.seed, seed);
        r->access.beginning = beginning + 1;

        save_url_seed(url, r->access.seed, r->access.beginning);

        char key[33]={'\0'};
    ab78:	e1a03007 	mov	r3, r7
    ab7c:	e483b004 	str	fp, [r3], #4
        RTMP_Access_GETKey(&r->access,key);
    ab80:	e1a0100e 	mov	r1, lr
        strcpy(r->access.seed, seed);
        r->access.beginning = beginning + 1;

        save_url_seed(url, r->access.seed, r->access.beginning);

        char key[33]={'\0'};
    ab84:	e2833004 	add	r3, r3, #4
        RTMP_Access_GETKey(&r->access,key);
    ab88:	e2800008 	add	r0, r0, #8
        strcpy(r->access.seed, seed);
        r->access.beginning = beginning + 1;

        save_url_seed(url, r->access.seed, r->access.beginning);

        char key[33]={'\0'};
    ab8c:	e483b004 	str	fp, [r3], #4
        RTMP_Access_GETKey(&r->access,key);
    ab90:	e58de034 	str	lr, [sp, #52]	; 0x34
        strcpy(r->access.seed, seed);
        r->access.beginning = beginning + 1;

        save_url_seed(url, r->access.seed, r->access.beginning);

        char key[33]={'\0'};
    ab94:	e483b004 	str	fp, [r3], #4
    ab98:	e507b008 	str	fp, [r7, #-8]
    ab9c:	e483b004 	str	fp, [r3], #4
    aba0:	e507b004 	str	fp, [r7, #-4]
    aba4:	e483b004 	str	fp, [r3], #4
    aba8:	e587b004 	str	fp, [r7, #4]
    abac:	e5c3b000 	strb	fp, [r3]
        RTMP_Access_GETKey(&r->access,key);
    abb0:	ebfff624 	bl	8448 <RTMP_Access_GETKey>

        sprintf(req_url, "http://%.*s/pushAccess?v=0&sn=%s.%s&uid=%s&magic=%s&callback=&productID=%s&productVersion=%s&os=%d&sdkVersion=%s&check=%d&key=%s&pos=%d",
    abb4:	e59de034 	ldr	lr, [sp, #52]	; 0x34
    abb8:	e514289c 	ldr	r2, [r4, #-2204]	; 0xfffff764
    abbc:	e2850c46 	add	r0, r5, #17920	; 0x4600
    abc0:	e58de024 	str	lr, [sp, #36]	; 0x24
    abc4:	e59aeb94 	ldr	lr, [sl, #2964]	; 0xb94
    abc8:	e58de018 	str	lr, [sp, #24]
    abcc:	e2851c49 	add	r1, r5, #18688	; 0x4900
    abd0:	e59ae99c 	ldr	lr, [sl, #2460]	; 0x99c
    abd4:	e2800018 	add	r0, r0, #24
    abd8:	e58de020 	str	lr, [sp, #32]
    abdc:	e285cb11 	add	ip, r5, #17408	; 0x4400
    abe0:	e59ae420 	ldr	lr, [sl, #1056]	; 0x420
    abe4:	e2811038 	add	r1, r1, #56	; 0x38
    abe8:	e58d0004 	str	r0, [sp, #4]
    abec:	e59f00dc 	ldr	r0, [pc, #220]	; acd0 <request_access+0x448>
    abf0:	e2853b12 	add	r3, r5, #18432	; 0x4800
    abf4:	e58d1014 	str	r1, [sp, #20]
    abf8:	e28cc024 	add	ip, ip, #36	; 0x24
    abfc:	e59f10d0 	ldr	r1, [pc, #208]	; acd4 <request_access+0x44c>
    ac00:	e58de028 	str	lr, [sp, #40]	; 0x28
    ac04:	e58dc000 	str	ip, [sp]
    ac08:	e283e00c 	add	lr, r3, #12
    ac0c:	e283c070 	add	ip, r3, #112	; 0x70
    ac10:	e08f0000 	add	r0, pc, r0
    ac14:	e28330d4 	add	r3, r3, #212	; 0xd4
    ac18:	e58de008 	str	lr, [sp, #8]
    ac1c:	e58dc00c 	str	ip, [sp, #12]
    ac20:	e58d3010 	str	r3, [sp, #16]
    ac24:	e08f1001 	add	r1, pc, r1
    ac28:	e51438a0 	ldr	r3, [r4, #-2208]	; 0xfffff760
    ac2c:	e58d001c 	str	r0, [sp, #28]
    ac30:	e1a00006 	mov	r0, r6
    ac34:	ebffe94c 	bl	516c <sprintf@plt>
    ac38:	eaffff5c 	b	a9b0 <request_access+0x128>
    char req_url[5000]={'\0'};
    AVal pRTMPUrl;
    
    if(!Parse_AccessUrl(r,url,&pRTMPUrl))
    {
        printf("parse access url fail :%s\n",url);
    ac3c:	e59f0094 	ldr	r0, [pc, #148]	; acd8 <request_access+0x450>
    ac40:	e1a01008 	mov	r1, r8
    ac44:	e08f0000 	add	r0, pc, r0
    ac48:	ebffe9ad 	bl	5304 <printf@plt>

        cJSON_Delete(pJson);
    }

    return TRUE;
}
    ac4c:	e1a0000b 	mov	r0, fp
    ac50:	e28ddd63 	add	sp, sp, #6336	; 0x18c0
    ac54:	e28dd024 	add	sp, sp, #36	; 0x24
    ac58:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    http.data=data;
    http.size=0;
    
    if(RTMP_HTTP_get(&http,req_url,NULL)!=HTTPRES_OK)
    {
        RTMP_Log(RTMP_LOGINFO,"http get access address fail \n");
    ac5c:	e59f1078 	ldr	r1, [pc, #120]	; acdc <request_access+0x454>
    ac60:	e08f1001 	add	r1, pc, r1
    ac64:	eb002b50 	bl	159ac <RTMP_Log>

        cJSON_Delete(pJson);
    }

    return TRUE;
}
    ac68:	e1a0000b 	mov	r0, fp
    ac6c:	e28ddd63 	add	sp, sp, #6336	; 0x18c0
    ac70:	e28dd024 	add	sp, sp, #36	; 0x24
    ac74:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        }

        cJSON_Delete(pJson);
    }

    return TRUE;
    ac78:	e3a0b001 	mov	fp, #1
}
    ac7c:	e1a0000b 	mov	r0, fp
    ac80:	e28ddd63 	add	sp, sp, #6336	; 0x18c0
    ac84:	e28dd024 	add	sp, sp, #36	; 0x24
    ac88:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        }

        cJSON *pJsonR = cJSON_GetObjectItem(pJson, "r");
        if (NULL == pJsonR || pJsonR->valueint < 0)
        {
            cJSON_Delete(pJson);
    ac8c:	e1a0000b 	mov	r0, fp
    ac90:	eb002798 	bl	14af8 <cJSON_Delete>
            return FALSE;
    ac94:	e3a0b000 	mov	fp, #0
    ac98:	eaffffa2 	b	ab28 <request_access+0x2a0>
    ac9c:	00001388 	.word	0x00001388
    aca0:	000144c0 	.word	0x000144c0
    aca4:	000144ac 	.word	0x000144ac
    aca8:	00014498 	.word	0x00014498
    acac:	000144f8 	.word	0x000144f8
    acb0:	000144dc 	.word	0x000144dc
    acb4:	000144c4 	.word	0x000144c4
    acb8:	000144a4 	.word	0x000144a4
    acbc:	00014494 	.word	0x00014494
    acc0:	000192f8 	.word	0x000192f8
    acc4:	00014460 	.word	0x00014460
    acc8:	0001446c 	.word	0x0001446c
    accc:	00014448 	.word	0x00014448
    acd0:	00014224 	.word	0x00014224
    acd4:	00014188 	.word	0x00014188
    acd8:	00014134 	.word	0x00014134
    acdc:	0001426c 	.word	0x0001426c

0000ace0 <RTMP_Request_Access>:

    return 0;
}

int RTMP_Request_Access(RTMP *r,char * url,char *real_url)
{
    ace0:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
    int ret=0;
    if(!strcmp(r->access.real_url,""))
    ace4:	e2809901 	add	r9, r0, #16384	; 0x4000
    ace8:	e5d93208 	ldrb	r3, [r9, #520]	; 0x208

    return 0;
}

int RTMP_Request_Access(RTMP *r,char * url,char *real_url)
{
    acec:	e24dd044 	sub	sp, sp, #68	; 0x44
    int ret=0;
    if(!strcmp(r->access.real_url,""))
    acf0:	e3530000 	cmp	r3, #0

    return 0;
}

int RTMP_Request_Access(RTMP *r,char * url,char *real_url)
{
    acf4:	e1a04000 	mov	r4, r0
    acf8:	e1a06001 	mov	r6, r1
    acfc:	e1a05002 	mov	r5, r2
    int ret=0;
    if(!strcmp(r->access.real_url,""))
    ad00:	1a000038 	bne	ade8 <RTMP_Request_Access+0x108>
    {
        if(url)
    ad04:	e3510000 	cmp	r1, #0
    ad08:	0a000033 	beq	addc <RTMP_Request_Access+0xfc>
        {
            RTMP_Log(RTMP_LOGINFO, "*** test url=%s", url);
    ad0c:	e59f10f8 	ldr	r1, [pc, #248]	; ae0c <RTMP_Request_Access+0x12c>
    ad10:	e1a02006 	mov	r2, r6
    ad14:	e3a00003 	mov	r0, #3
    ad18:	e08f1001 	add	r1, pc, r1
    ad1c:	eb002b22 	bl	159ac <RTMP_Log>
            ret=request_access(r,url);
    ad20:	e1a01006 	mov	r1, r6
    ad24:	e1a00004 	mov	r0, r4
    ad28:	ebfffed6 	bl	a888 <request_access>
        }
        if(!ret)
    ad2c:	e2506000 	subs	r6, r0, #0
    ad30:	0a000029 	beq	addc <RTMP_Request_Access+0xfc>
        r->access.beginning++;
        ret=1;
        save_url_seed(url, r->access.seed, r->access.beginning);
    }
    char key[33]={'\0'};
    RTMP_Access_GETKey(&r->access,key);
    ad34:	e2848c42 	add	r8, r4, #16896	; 0x4200
    ad38:	e2888008 	add	r8, r8, #8
    ad3c:	e28d701c 	add	r7, sp, #28
    {
        r->access.beginning++;
        ret=1;
        save_url_seed(url, r->access.seed, r->access.beginning);
    }
    char key[33]={'\0'};
    ad40:	e3a03000 	mov	r3, #0
    RTMP_Access_GETKey(&r->access,key);
    ad44:	e1a01007 	mov	r1, r7
    ad48:	e1a00008 	mov	r0, r8
    {
        r->access.beginning++;
        ret=1;
        save_url_seed(url, r->access.seed, r->access.beginning);
    }
    char key[33]={'\0'};
    ad4c:	e58d301c 	str	r3, [sp, #28]
    ad50:	e58d3020 	str	r3, [sp, #32]
    ad54:	e58d3024 	str	r3, [sp, #36]	; 0x24
    ad58:	e58d3028 	str	r3, [sp, #40]	; 0x28
    ad5c:	e58d302c 	str	r3, [sp, #44]	; 0x2c
    ad60:	e58d3030 	str	r3, [sp, #48]	; 0x30
    ad64:	e58d3034 	str	r3, [sp, #52]	; 0x34
    ad68:	e58d3038 	str	r3, [sp, #56]	; 0x38
    ad6c:	e5cd303c 	strb	r3, [sp, #60]	; 0x3c
    RTMP_Access_GETKey(&r->access,key);
    ad70:	ebfff5b4 	bl	8448 <RTMP_Access_GETKey>
    
    //char rtmp_url[500]={'\0'};
    sprintf(real_url,"rtmp://%s/%s/%s?key=%s&uid=%s&sn=%s.%s&pos=%d",r->access.real_url,r->access.app,r->access.stream,key,r->access.uid,r->access.app,r->access.stream,r->access.beginning);
    ad74:	e2841c46 	add	r1, r4, #17920	; 0x4600
    ad78:	e2811018 	add	r1, r1, #24
    ad7c:	e5990420 	ldr	r0, [r9, #1056]	; 0x420
    ad80:	e2843b11 	add	r3, r4, #17408	; 0x4400
    ad84:	e58d1000 	str	r1, [sp]
    ad88:	e58d1010 	str	r1, [sp, #16]
    ad8c:	e2844b12 	add	r4, r4, #18432	; 0x4800
    ad90:	e59f1078 	ldr	r1, [pc, #120]	; ae10 <RTMP_Request_Access+0x130>
    ad94:	e2833024 	add	r3, r3, #36	; 0x24
    ad98:	e284400c 	add	r4, r4, #12
    ad9c:	e1a02008 	mov	r2, r8
    ada0:	e58d0014 	str	r0, [sp, #20]
    ada4:	e58d300c 	str	r3, [sp, #12]
    ada8:	e58d7004 	str	r7, [sp, #4]
    adac:	e58d4008 	str	r4, [sp, #8]
    adb0:	e1a00005 	mov	r0, r5
    adb4:	e08f1001 	add	r1, pc, r1
    adb8:	ebffe8eb 	bl	516c <sprintf@plt>
    
    RTMP_Log(RTMP_LOGINFO,"real rtmp url: %s \n",real_url);
    adbc:	e59f1050 	ldr	r1, [pc, #80]	; ae14 <RTMP_Request_Access+0x134>
    adc0:	e1a02005 	mov	r2, r5
    adc4:	e3a00003 	mov	r0, #3
    adc8:	e08f1001 	add	r1, pc, r1
    adcc:	eb002af6 	bl	159ac <RTMP_Log>
    return ret;
    add0:	e1a00006 	mov	r0, r6
    
}
    add4:	e28dd044 	add	sp, sp, #68	; 0x44
    add8:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
        {
            RTMP_Log(RTMP_LOGINFO, "*** test url=%s", url);
            ret=request_access(r,url);
        }
        if(!ret)
            return FALSE;
    addc:	e3a00000 	mov	r0, #0
    sprintf(real_url,"rtmp://%s/%s/%s?key=%s&uid=%s&sn=%s.%s&pos=%d",r->access.real_url,r->access.app,r->access.stream,key,r->access.uid,r->access.app,r->access.stream,r->access.beginning);
    
    RTMP_Log(RTMP_LOGINFO,"real rtmp url: %s \n",real_url);
    return ret;
    
}
    ade0:	e28dd044 	add	sp, sp, #68	; 0x44
    ade4:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
        if(!ret)
            return FALSE;
    }
    else
    {
        r->access.beginning++;
    ade8:	e5992420 	ldr	r2, [r9, #1056]	; 0x420
        ret=1;
        save_url_seed(url, r->access.seed, r->access.beginning);
    adec:	e2801c43 	add	r1, r0, #17152	; 0x4300
        if(!ret)
            return FALSE;
    }
    else
    {
        r->access.beginning++;
    adf0:	e2822001 	add	r2, r2, #1
        ret=1;
        save_url_seed(url, r->access.seed, r->access.beginning);
    adf4:	e1a00006 	mov	r0, r6
        if(!ret)
            return FALSE;
    }
    else
    {
        r->access.beginning++;
    adf8:	e5892420 	str	r2, [r9, #1056]	; 0x420
        ret=1;
        save_url_seed(url, r->access.seed, r->access.beginning);
    adfc:	e28110fc 	add	r1, r1, #252	; 0xfc
    ae00:	ebfff467 	bl	7fa4 <save_url_seed>
            return FALSE;
    }
    else
    {
        r->access.beginning++;
        ret=1;
    ae04:	e3a06001 	mov	r6, #1
    ae08:	eaffffc9 	b	ad34 <RTMP_Request_Access+0x54>
    ae0c:	00014234 	.word	0x00014234
    ae10:	000141a8 	.word	0x000141a8
    ae14:	000141c4 	.word	0x000141c4

0000ae18 <CloseInternal>:
    CloseInternal(r, 0);
}

static void
CloseInternal(RTMP *r, int reconnect)
{
    ae18:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
    ae1c:	e1a04000 	mov	r4, r0
    ae20:	e1a07001 	mov	r7, r1
    int i;
    
    if (RTMP_IsConnected(r))
    ae24:	ebfff6f8 	bl	8a0c <RTMP_IsConnected>
    ae28:	e3500000 	cmp	r0, #0
    ae2c:	02846901 	addeq	r6, r4, #16384	; 0x4000
    ae30:	0a00001e 	beq	aeb0 <CloseInternal+0x98>
    {
        if (r->m_stream_id > 0)
    ae34:	e5945018 	ldr	r5, [r4, #24]
        {
            i = r->m_stream_id;
            r->m_stream_id = 0;
            if ((r->Link.protocol & RTMP_FEATURE_WRITE))
    ae38:	e2846901 	add	r6, r4, #16384	; 0x4000
{
    int i;
    
    if (RTMP_IsConnected(r))
    {
        if (r->m_stream_id > 0)
    ae3c:	e3550000 	cmp	r5, #0
    ae40:	da00000a 	ble	ae70 <CloseInternal+0x58>
        {
            i = r->m_stream_id;
            r->m_stream_id = 0;
            if ((r->Link.protocol & RTMP_FEATURE_WRITE))
    ae44:	e5962188 	ldr	r2, [r6, #392]	; 0x188
    if (RTMP_IsConnected(r))
    {
        if (r->m_stream_id > 0)
        {
            i = r->m_stream_id;
            r->m_stream_id = 0;
    ae48:	e3a03000 	mov	r3, #0
            if ((r->Link.protocol & RTMP_FEATURE_WRITE))
    ae4c:	e3120010 	tst	r2, #16
    if (RTMP_IsConnected(r))
    {
        if (r->m_stream_id > 0)
        {
            i = r->m_stream_id;
            r->m_stream_id = 0;
    ae50:	e5843018 	str	r3, [r4, #24]
            if ((r->Link.protocol & RTMP_FEATURE_WRITE))
    ae54:	1a0000bc 	bne	b14c <CloseInternal+0x334>
                SendFCUnpublish(r);
            SendDeleteStream(r, i);
    ae58:	e1a00005 	mov	r0, r5
    ae5c:	eb0043da 	bl	1bdcc <__aeabi_i2d>
    ae60:	e1a02000 	mov	r2, r0
    ae64:	e1a03001 	mov	r3, r1
    ae68:	e1a00004 	mov	r0, r4
    ae6c:	eb000418 	bl	bed4 <SendDeleteStream>
        }
        if (r->m_clientID.av_val)
    ae70:	e5943088 	ldr	r3, [r4, #136]	; 0x88
    ae74:	e3530000 	cmp	r3, #0
    ae78:	0a00000a 	beq	aea8 <CloseInternal+0x90>
        {
            HTTP_Post(r, RTMPT_CLOSE, "", 1);
    ae7c:	e59f22d4 	ldr	r2, [pc, #724]	; b158 <CloseInternal+0x340>
    ae80:	e3a03001 	mov	r3, #1
    ae84:	e3a01003 	mov	r1, #3
    ae88:	e08f2002 	add	r2, pc, r2
    ae8c:	e1a00004 	mov	r0, r4
    ae90:	ebfffc6d 	bl	a04c <HTTP_Post>
            free(r->m_clientID.av_val);
    ae94:	e5940088 	ldr	r0, [r4, #136]	; 0x88
    ae98:	ebffe859 	bl	5004 <free@plt>
            r->m_clientID.av_val = NULL;
    ae9c:	e3a03000 	mov	r3, #0
    aea0:	e5843088 	str	r3, [r4, #136]	; 0x88
            r->m_clientID.av_len = 0;
    aea4:	e584308c 	str	r3, [r4, #140]	; 0x8c
        }
        RTMPSockBuf_Close(&r->m_sb);
    aea8:	e28400e0 	add	r0, r4, #224	; 0xe0
    aeac:	ebfffc9b 	bl	a120 <RTMPSockBuf_Close>
    r->m_sb.sb_socket = -1;
    r->m_nBWCheckCounter = 0;
    r->m_nBytesIn = 0;
    r->m_nBytesInSent = 0;
    
    if (r->m_read.flags & RTMP_READ_HEADER) {
    aeb0:	e5d420a1 	ldrb	r2, [r4, #161]	; 0xa1
        RTMPSockBuf_Close(&r->m_sb);
    }
    
    r->m_stream_id = -1;
    r->m_sb.sb_socket = -1;
    r->m_nBWCheckCounter = 0;
    aeb4:	e3a05000 	mov	r5, #0
            r->m_clientID.av_len = 0;
        }
        RTMPSockBuf_Close(&r->m_sb);
    }
    
    r->m_stream_id = -1;
    aeb8:	e3e03000 	mvn	r3, #0
    r->m_sb.sb_socket = -1;
    r->m_nBWCheckCounter = 0;
    r->m_nBytesIn = 0;
    r->m_nBytesInSent = 0;
    
    if (r->m_read.flags & RTMP_READ_HEADER) {
    aebc:	e3120001 	tst	r2, #1
            r->m_clientID.av_len = 0;
        }
        RTMPSockBuf_Close(&r->m_sb);
    }
    
    r->m_stream_id = -1;
    aec0:	e5843018 	str	r3, [r4, #24]
    r->m_sb.sb_socket = -1;
    aec4:	e58430e0 	str	r3, [r4, #224]	; 0xe0
    r->m_nBWCheckCounter = 0;
    aec8:	e5845008 	str	r5, [r4, #8]
    r->m_nBytesIn = 0;
    aecc:	e584500c 	str	r5, [r4, #12]
    r->m_nBytesInSent = 0;
    aed0:	e5845010 	str	r5, [r4, #16]
    
    if (r->m_read.flags & RTMP_READ_HEADER) {
    aed4:	1a000085 	bne	b0f0 <CloseInternal+0x2d8>
        free(r->m_read.buf);
        r->m_read.buf = NULL;
    }
    r->m_read.dataType = 0;
    aed8:	e3a05000 	mov	r5, #0
    aedc:	e5c450a0 	strb	r5, [r4, #160]	; 0xa0
    r->m_read.flags = 0;
    aee0:	e5c450a1 	strb	r5, [r4, #161]	; 0xa1
    r->m_read.status = 0;
    aee4:	e5c450a2 	strb	r5, [r4, #162]	; 0xa2
    r->m_read.nResumeTS = 0;
    aee8:	e58450a4 	str	r5, [r4, #164]	; 0xa4
    r->m_read.nIgnoredFrameCounter = 0;
    aeec:	e58450b8 	str	r5, [r4, #184]	; 0xb8
    r->m_read.nIgnoredFlvFrameCounter = 0;
    aef0:	e58450bc 	str	r5, [r4, #188]	; 0xbc
    
    r->m_write.m_nBytesRead = 0;
    aef4:	e58450d4 	str	r5, [r4, #212]	; 0xd4
    RTMPPacket_Free(&r->m_write);
    aef8:	e28400c0 	add	r0, r4, #192	; 0xc0
    aefc:	ebfff617 	bl	8760 <RTMPPacket_Free>
    
    for (i = 0; i < r->m_channelsAllocatedIn; i++)
    af00:	e5942044 	ldr	r2, [r4, #68]	; 0x44
    af04:	e594104c 	ldr	r1, [r4, #76]	; 0x4c
    af08:	e1520005 	cmp	r2, r5
    {
        if (r->m_vecChannelsIn[i])
        {
            RTMPPacket_Free(r->m_vecChannelsIn[i]);
            free(r->m_vecChannelsIn[i]);
            r->m_vecChannelsIn[i] = NULL;
    af0c:	c1a08005 	movgt	r8, r5
    r->m_read.nIgnoredFlvFrameCounter = 0;
    
    r->m_write.m_nBytesRead = 0;
    RTMPPacket_Free(&r->m_write);
    
    for (i = 0; i < r->m_channelsAllocatedIn; i++)
    af10:	da00000d 	ble	af4c <CloseInternal+0x134>
    {
        if (r->m_vecChannelsIn[i])
    af14:	e7913105 	ldr	r3, [r1, r5, lsl #2]
    af18:	e2530000 	subs	r0, r3, #0
    af1c:	0a000007 	beq	af40 <CloseInternal+0x128>
        {
            RTMPPacket_Free(r->m_vecChannelsIn[i]);
    af20:	ebfff60e 	bl	8760 <RTMPPacket_Free>
            free(r->m_vecChannelsIn[i]);
    af24:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
    af28:	e7930105 	ldr	r0, [r3, r5, lsl #2]
    af2c:	ebffe834 	bl	5004 <free@plt>
            r->m_vecChannelsIn[i] = NULL;
    af30:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
    af34:	e5942044 	ldr	r2, [r4, #68]	; 0x44
    af38:	e7838105 	str	r8, [r3, r5, lsl #2]
    af3c:	e594104c 	ldr	r1, [r4, #76]	; 0x4c
    r->m_read.nIgnoredFlvFrameCounter = 0;
    
    r->m_write.m_nBytesRead = 0;
    RTMPPacket_Free(&r->m_write);
    
    for (i = 0; i < r->m_channelsAllocatedIn; i++)
    af40:	e2855001 	add	r5, r5, #1
    af44:	e1520005 	cmp	r2, r5
    af48:	cafffff1 	bgt	af14 <CloseInternal+0xfc>
            free(r->m_vecChannelsIn[i]);
            r->m_vecChannelsIn[i] = NULL;
        }
    }
    free(r->m_vecChannelsIn);
    r->m_vecChannelsIn = NULL;
    af4c:	e3a05000 	mov	r5, #0
            RTMPPacket_Free(r->m_vecChannelsIn[i]);
            free(r->m_vecChannelsIn[i]);
            r->m_vecChannelsIn[i] = NULL;
        }
    }
    free(r->m_vecChannelsIn);
    af50:	e1a00001 	mov	r0, r1
    af54:	ebffe82a 	bl	5004 <free@plt>
    r->m_vecChannelsIn = NULL;
    af58:	e584504c 	str	r5, [r4, #76]	; 0x4c
    free(r->m_channelTimestamp);
    af5c:	e5940054 	ldr	r0, [r4, #84]	; 0x54
    af60:	ebffe827 	bl	5004 <free@plt>
    r->m_channelTimestamp = NULL;
    r->m_channelsAllocatedIn = 0;
    for (i = 0; i < r->m_channelsAllocatedOut; i++)
    af64:	e5942048 	ldr	r2, [r4, #72]	; 0x48
        }
    }
    free(r->m_vecChannelsIn);
    r->m_vecChannelsIn = NULL;
    free(r->m_channelTimestamp);
    r->m_channelTimestamp = NULL;
    af68:	e5845054 	str	r5, [r4, #84]	; 0x54
    r->m_channelsAllocatedIn = 0;
    for (i = 0; i < r->m_channelsAllocatedOut; i++)
    af6c:	e1520005 	cmp	r2, r5
    }
    free(r->m_vecChannelsIn);
    r->m_vecChannelsIn = NULL;
    free(r->m_channelTimestamp);
    r->m_channelTimestamp = NULL;
    r->m_channelsAllocatedIn = 0;
    af70:	e5845044 	str	r5, [r4, #68]	; 0x44
    af74:	e5941050 	ldr	r1, [r4, #80]	; 0x50
    for (i = 0; i < r->m_channelsAllocatedOut; i++)
    {
        if (r->m_vecChannelsOut[i])
        {
            free(r->m_vecChannelsOut[i]);
            r->m_vecChannelsOut[i] = NULL;
    af78:	c1a08005 	movgt	r8, r5
    free(r->m_vecChannelsIn);
    r->m_vecChannelsIn = NULL;
    free(r->m_channelTimestamp);
    r->m_channelTimestamp = NULL;
    r->m_channelsAllocatedIn = 0;
    for (i = 0; i < r->m_channelsAllocatedOut; i++)
    af7c:	da00000a 	ble	afac <CloseInternal+0x194>
    {
        if (r->m_vecChannelsOut[i])
    af80:	e7913105 	ldr	r3, [r1, r5, lsl #2]
    af84:	e2530000 	subs	r0, r3, #0
    af88:	0a000004 	beq	afa0 <CloseInternal+0x188>
        {
            free(r->m_vecChannelsOut[i]);
    af8c:	ebffe81c 	bl	5004 <free@plt>
            r->m_vecChannelsOut[i] = NULL;
    af90:	e5943050 	ldr	r3, [r4, #80]	; 0x50
    af94:	e5942048 	ldr	r2, [r4, #72]	; 0x48
    af98:	e7838105 	str	r8, [r3, r5, lsl #2]
    af9c:	e5941050 	ldr	r1, [r4, #80]	; 0x50
    free(r->m_vecChannelsIn);
    r->m_vecChannelsIn = NULL;
    free(r->m_channelTimestamp);
    r->m_channelTimestamp = NULL;
    r->m_channelsAllocatedIn = 0;
    for (i = 0; i < r->m_channelsAllocatedOut; i++)
    afa0:	e2855001 	add	r5, r5, #1
    afa4:	e1520005 	cmp	r2, r5
    afa8:	cafffff4 	bgt	af80 <CloseInternal+0x168>
        {
            free(r->m_vecChannelsOut[i]);
            r->m_vecChannelsOut[i] = NULL;
        }
    }
    free(r->m_vecChannelsOut);
    afac:	e1a00001 	mov	r0, r1
    afb0:	ebffe813 	bl	5004 <free@plt>
    r->m_vecChannelsOut = NULL;
    r->m_channelsAllocatedOut = 0;
    AV_clear(r->m_methodCalls, r->m_numCalls);
    afb4:	e594a03c 	ldr	sl, [r4, #60]	; 0x3c
            free(r->m_vecChannelsOut[i]);
            r->m_vecChannelsOut[i] = NULL;
        }
    }
    free(r->m_vecChannelsOut);
    r->m_vecChannelsOut = NULL;
    afb8:	e3a05000 	mov	r5, #0

static void
AV_clear(RTMP_METHOD *vals, int num)
{
    int i;
    for (i = 0; i < num; i++)
    afbc:	e15a0005 	cmp	sl, r5
            free(r->m_vecChannelsOut[i]);
            r->m_vecChannelsOut[i] = NULL;
        }
    }
    free(r->m_vecChannelsOut);
    r->m_vecChannelsOut = NULL;
    afc0:	e5845050 	str	r5, [r4, #80]	; 0x50
    r->m_channelsAllocatedOut = 0;
    afc4:	e5845048 	str	r5, [r4, #72]	; 0x48
    AV_clear(r->m_methodCalls, r->m_numCalls);
    afc8:	e5949040 	ldr	r9, [r4, #64]	; 0x40

static void
AV_clear(RTMP_METHOD *vals, int num)
{
    int i;
    for (i = 0; i < num; i++)
    afcc:	c1a08005 	movgt	r8, r5
    afd0:	da000005 	ble	afec <CloseInternal+0x1d4>
        free(vals[i].name.av_val);
    afd4:	e7990005 	ldr	r0, [r9, r5]

static void
AV_clear(RTMP_METHOD *vals, int num)
{
    int i;
    for (i = 0; i < num; i++)
    afd8:	e2888001 	add	r8, r8, #1
        free(vals[i].name.av_val);
    afdc:	ebffe808 	bl	5004 <free@plt>

static void
AV_clear(RTMP_METHOD *vals, int num)
{
    int i;
    for (i = 0; i < num; i++)
    afe0:	e158000a 	cmp	r8, sl
    afe4:	e285500c 	add	r5, r5, #12
    afe8:	1afffff9 	bne	afd4 <CloseInternal+0x1bc>
    }
    free(r->m_vecChannelsOut);
    r->m_vecChannelsOut = NULL;
    r->m_channelsAllocatedOut = 0;
    AV_clear(r->m_methodCalls, r->m_numCalls);
    r->m_methodCalls = NULL;
    afec:	e3a05000 	mov	r5, #0
AV_clear(RTMP_METHOD *vals, int num)
{
    int i;
    for (i = 0; i < num; i++)
        free(vals[i].name.av_val);
    free(vals);
    aff0:	e1a00009 	mov	r0, r9
    aff4:	ebffe802 	bl	5004 <free@plt>
    AV_clear(r->m_methodCalls, r->m_numCalls);
    r->m_methodCalls = NULL;
    r->m_numCalls = 0;
    r->m_numInvokes = 0;
    
    r->m_bPlaying = FALSE;
    aff8:	e5c45035 	strb	r5, [r4, #53]	; 0x35
    
    r->m_msgCounter = 0;
    r->m_resplen = 0;
    r->m_unackd = 0;
    
    if (r->Link.lFlags & RTMP_LF_FTCU && !reconnect)
    affc:	e5963180 	ldr	r3, [r6, #384]	; 0x180
    b000:	e16f7f17 	clz	r7, r7
    b004:	e1a072a7 	lsr	r7, r7, #5
    b008:	e01722a3 	ands	r2, r7, r3, lsr #5
    }
    free(r->m_vecChannelsOut);
    r->m_vecChannelsOut = NULL;
    r->m_channelsAllocatedOut = 0;
    AV_clear(r->m_methodCalls, r->m_numCalls);
    r->m_methodCalls = NULL;
    b00c:	e5845040 	str	r5, [r4, #64]	; 0x40
    r->m_numCalls = 0;
    b010:	e584503c 	str	r5, [r4, #60]	; 0x3c
    r->m_numInvokes = 0;
    b014:	e5845038 	str	r5, [r4, #56]	; 0x38
    
    r->m_bPlaying = FALSE;
    r->m_sb.sb_size = 0;
    b018:	e58450e4 	str	r5, [r4, #228]	; 0xe4
    
    r->m_msgCounter = 0;
    b01c:	e5845078 	str	r5, [r4, #120]	; 0x78
    r->m_resplen = 0;
    b020:	e5845080 	str	r5, [r4, #128]	; 0x80
    r->m_unackd = 0;
    b024:	e5845084 	str	r5, [r4, #132]	; 0x84
    
    if (r->Link.lFlags & RTMP_LF_FTCU && !reconnect)
    b028:	1a000040 	bne	b130 <CloseInternal+0x318>
    {
        free(r->Link.tcUrl.av_val);
        r->Link.tcUrl.av_val = NULL;
        r->Link.lFlags ^= RTMP_LF_FTCU;
    }
    if (r->Link.lFlags & RTMP_LF_FAPU && !reconnect)
    b02c:	e3130040 	tst	r3, #64	; 0x40
    b030:	0a000027 	beq	b0d4 <CloseInternal+0x2bc>
    b034:	e3570000 	cmp	r7, #0
    b038:	1a000030 	bne	b100 <CloseInternal+0x2e8>
        r->Link.playpath0.av_val = NULL;
    }
    //rtmp_mutex_destroy(r->lock_speed);
    //rtmp_mutex_destroy(r->lock_drop);
#ifdef CRYPTO
    if (r->Link.dh)
    b03c:	e5964198 	ldr	r4, [r6, #408]	; 0x198
    b040:	e3540000 	cmp	r4, #0
    b044:	0a000015 	beq	b0a0 <CloseInternal+0x288>
    {
        MDH_free(r->Link.dh);
    b048:	e2840014 	add	r0, r4, #20
    b04c:	ebffe837 	bl	5130 <dhm_free@plt>
    b050:	e5940000 	ldr	r0, [r4]
    b054:	ebffe808 	bl	507c <mpi_free_polarssl@plt>
    b058:	e5940000 	ldr	r0, [r4]
    b05c:	ebffe7e8 	bl	5004 <free@plt>
    b060:	e5940004 	ldr	r0, [r4, #4]
    b064:	ebffe804 	bl	507c <mpi_free_polarssl@plt>
    b068:	e5940004 	ldr	r0, [r4, #4]
    b06c:	ebffe7e4 	bl	5004 <free@plt>
    b070:	e5940008 	ldr	r0, [r4, #8]
    b074:	ebffe800 	bl	507c <mpi_free_polarssl@plt>
    b078:	e5940008 	ldr	r0, [r4, #8]
    b07c:	ebffe7e0 	bl	5004 <free@plt>
    b080:	e594000c 	ldr	r0, [r4, #12]
    b084:	ebffe7fc 	bl	507c <mpi_free_polarssl@plt>
    b088:	e594000c 	ldr	r0, [r4, #12]
    b08c:	ebffe7dc 	bl	5004 <free@plt>
    b090:	e1a00004 	mov	r0, r4
    b094:	ebffe7da 	bl	5004 <free@plt>
        r->Link.dh = NULL;
    b098:	e3a03000 	mov	r3, #0
    b09c:	e5863198 	str	r3, [r6, #408]	; 0x198
    }
    if (r->Link.rc4keyIn)
    b0a0:	e596019c 	ldr	r0, [r6, #412]	; 0x19c
    b0a4:	e3500000 	cmp	r0, #0
    b0a8:	0a000002 	beq	b0b8 <CloseInternal+0x2a0>
    {
        RC4_free(r->Link.rc4keyIn);
    b0ac:	ebffe7d4 	bl	5004 <free@plt>
        r->Link.rc4keyIn = NULL;
    b0b0:	e3a03000 	mov	r3, #0
    b0b4:	e586319c 	str	r3, [r6, #412]	; 0x19c
    }
    if (r->Link.rc4keyOut)
    b0b8:	e59601a0 	ldr	r0, [r6, #416]	; 0x1a0
    b0bc:	e3500000 	cmp	r0, #0
    b0c0:	08bd87f0 	popeq	{r4, r5, r6, r7, r8, r9, sl, pc}
    {
        RC4_free(r->Link.rc4keyOut);
    b0c4:	ebffe7ce 	bl	5004 <free@plt>
        r->Link.rc4keyOut = NULL;
    b0c8:	e3a03000 	mov	r3, #0
    b0cc:	e58631a0 	str	r3, [r6, #416]	; 0x1a0
    b0d0:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
        free(r->Link.app.av_val);
        r->Link.app.av_val = NULL;
        r->Link.lFlags ^= RTMP_LF_FAPU;
    }
    
    if (!reconnect)
    b0d4:	e3570000 	cmp	r7, #0
    b0d8:	0affffd7 	beq	b03c <CloseInternal+0x224>
    {
        free(r->Link.playpath0.av_val);
    b0dc:	e5960104 	ldr	r0, [r6, #260]	; 0x104
    b0e0:	ebffe7c7 	bl	5004 <free@plt>
        r->Link.playpath0.av_val = NULL;
    b0e4:	e3a03000 	mov	r3, #0
    b0e8:	e5863104 	str	r3, [r6, #260]	; 0x104
    b0ec:	eaffffd2 	b	b03c <CloseInternal+0x224>
    r->m_nBWCheckCounter = 0;
    r->m_nBytesIn = 0;
    r->m_nBytesInSent = 0;
    
    if (r->m_read.flags & RTMP_READ_HEADER) {
        free(r->m_read.buf);
    b0f0:	e5940090 	ldr	r0, [r4, #144]	; 0x90
    b0f4:	ebffe7c2 	bl	5004 <free@plt>
        r->m_read.buf = NULL;
    b0f8:	e5845090 	str	r5, [r4, #144]	; 0x90
    b0fc:	eaffff75 	b	aed8 <CloseInternal+0xc0>
        r->Link.tcUrl.av_val = NULL;
        r->Link.lFlags ^= RTMP_LF_FTCU;
    }
    if (r->Link.lFlags & RTMP_LF_FAPU && !reconnect)
    {
        free(r->Link.app.av_val);
    b100:	e596012c 	ldr	r0, [r6, #300]	; 0x12c
    b104:	ebffe7be 	bl	5004 <free@plt>
        r->Link.app.av_val = NULL;
        r->Link.lFlags ^= RTMP_LF_FAPU;
    b108:	e5963180 	ldr	r3, [r6, #384]	; 0x180
        r->Link.lFlags ^= RTMP_LF_FTCU;
    }
    if (r->Link.lFlags & RTMP_LF_FAPU && !reconnect)
    {
        free(r->Link.app.av_val);
        r->Link.app.av_val = NULL;
    b10c:	e3a02000 	mov	r2, #0
        r->Link.lFlags ^= RTMP_LF_FAPU;
    b110:	e2233040 	eor	r3, r3, #64	; 0x40
    b114:	e5863180 	str	r3, [r6, #384]	; 0x180
        r->Link.lFlags ^= RTMP_LF_FTCU;
    }
    if (r->Link.lFlags & RTMP_LF_FAPU && !reconnect)
    {
        free(r->Link.app.av_val);
        r->Link.app.av_val = NULL;
    b118:	e586212c 	str	r2, [r6, #300]	; 0x12c
        r->Link.lFlags ^= RTMP_LF_FAPU;
    }
    
    if (!reconnect)
    {
        free(r->Link.playpath0.av_val);
    b11c:	e5960104 	ldr	r0, [r6, #260]	; 0x104
    b120:	ebffe7b7 	bl	5004 <free@plt>
        r->Link.playpath0.av_val = NULL;
    b124:	e3a03000 	mov	r3, #0
    b128:	e5863104 	str	r3, [r6, #260]	; 0x104
    b12c:	eaffffc2 	b	b03c <CloseInternal+0x224>
    r->m_resplen = 0;
    r->m_unackd = 0;
    
    if (r->Link.lFlags & RTMP_LF_FTCU && !reconnect)
    {
        free(r->Link.tcUrl.av_val);
    b130:	e5960114 	ldr	r0, [r6, #276]	; 0x114
    b134:	ebffe7b2 	bl	5004 <free@plt>
        r->Link.tcUrl.av_val = NULL;
        r->Link.lFlags ^= RTMP_LF_FTCU;
    b138:	e5963180 	ldr	r3, [r6, #384]	; 0x180
    r->m_unackd = 0;
    
    if (r->Link.lFlags & RTMP_LF_FTCU && !reconnect)
    {
        free(r->Link.tcUrl.av_val);
        r->Link.tcUrl.av_val = NULL;
    b13c:	e5865114 	str	r5, [r6, #276]	; 0x114
        r->Link.lFlags ^= RTMP_LF_FTCU;
    b140:	e2233020 	eor	r3, r3, #32
    b144:	e5863180 	str	r3, [r6, #384]	; 0x180
    b148:	eaffffb7 	b	b02c <CloseInternal+0x214>
        if (r->m_stream_id > 0)
        {
            i = r->m_stream_id;
            r->m_stream_id = 0;
            if ((r->Link.protocol & RTMP_FEATURE_WRITE))
                SendFCUnpublish(r);
    b14c:	e1a00004 	mov	r0, r4
    b150:	eb00059f 	bl	c7d4 <SendFCUnpublish>
    b154:	eaffff3f 	b	ae58 <CloseInternal+0x40>
    b158:	00012fa9 	.word	0x00012fa9

0000b15c <RTMP_Close>:
}

void
RTMP_Close(RTMP *r)
{
    CloseInternal(r, 0);
    b15c:	e3a01000 	mov	r1, #0
    b160:	eaffff2c 	b	ae18 <CloseInternal>

0000b164 <WriteN.isra.9>:
    //RTMP_Log(RTMP_LOGINFO,"ReadN return :%d \n",nOriginalSize - n);
    return nOriginalSize - n;
}

static int
WriteN(RTMP *r, const char *buffer, int n,int priority)
    b164:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    const char *ptr = buffer;
#ifdef CRYPTO
    char *encrypted = 0;
    char buf[RTMP_BUFFER_CACHE_SIZE];
    
    if (r->Link.rc4keyOut)
    b168:	e2806901 	add	r6, r0, #16384	; 0x4000
    b16c:	e59671a0 	ldr	r7, [r6, #416]	; 0x1a0
    //RTMP_Log(RTMP_LOGINFO,"ReadN return :%d \n",nOriginalSize - n);
    return nOriginalSize - n;
}

static int
WriteN(RTMP *r, const char *buffer, int n,int priority)
    b170:	e24dd901 	sub	sp, sp, #16384	; 0x4000
    const char *ptr = buffer;
#ifdef CRYPTO
    char *encrypted = 0;
    char buf[RTMP_BUFFER_CACHE_SIZE];
    
    if (r->Link.rc4keyOut)
    b174:	e3570000 	cmp	r7, #0
    //RTMP_Log(RTMP_LOGINFO,"ReadN return :%d \n",nOriginalSize - n);
    return nOriginalSize - n;
}

static int
WriteN(RTMP *r, const char *buffer, int n,int priority)
    b178:	e24dd00c 	sub	sp, sp, #12
    b17c:	e1a08000 	mov	r8, r0
    b180:	e1a09001 	mov	r9, r1
    b184:	e1a04002 	mov	r4, r2
    const char *ptr = buffer;
#ifdef CRYPTO
    char *encrypted = 0;
    char buf[RTMP_BUFFER_CACHE_SIZE];
    
    if (r->Link.rc4keyOut)
    b188:	0a000053 	beq	b2dc <WriteN.isra.9+0x178>
    {
        if (n > sizeof(buf))
    b18c:	e3520901 	cmp	r2, #16384	; 0x4000
    b190:	93a03000 	movls	r3, #0
    b194:	958d3000 	strls	r3, [sp]
            encrypted = (char *)malloc(n);
        else
            encrypted = (char *)buf;
    b198:	928d5008 	addls	r5, sp, #8
    char *encrypted = 0;
    char buf[RTMP_BUFFER_CACHE_SIZE];
    
    if (r->Link.rc4keyOut)
    {
        if (n > sizeof(buf))
    b19c:	8a00003e 	bhi	b29c <WriteN.isra.9+0x138>
            encrypted = (char *)malloc(n);
        else
            encrypted = (char *)buf;
        ptr = encrypted;
        RC4_encrypt2(r->Link.rc4keyOut, n, buffer, ptr);
    b1a0:	e1a00007 	mov	r0, r7
    b1a4:	e1a02009 	mov	r2, r9
    b1a8:	e1a01004 	mov	r1, r4
    b1ac:	e1a03005 	mov	r3, r5
    b1b0:	ebffe8b0 	bl	5478 <arc4_crypt@plt>
    }
#endif
    
    while (n > 0)
    b1b4:	e3540000 	cmp	r4, #0
    b1b8:	e58d5004 	str	r5, [sp, #4]
    b1bc:	da000040 	ble	b2c4 <WriteN.isra.9+0x160>
        if (nBytes < 0)
        {
            int sockerr ;
			sockerr= GetSockError();

            LOGE("%s, RTMP send error %d (%d bytes)", __FUNCTION__,
    b1c0:	e59f9138 	ldr	r9, [pc, #312]	; b300 <WriteN.isra.9+0x19c>
    b1c4:	e59fb138 	ldr	fp, [pc, #312]	; b304 <WriteN.isra.9+0x1a0>
    b1c8:	e08f9009 	add	r9, pc, r9
    b1cc:	e2499ec7 	sub	r9, r9, #3184	; 0xc70
    b1d0:	e08fb00b 	add	fp, pc, fp
    b1d4:	e2499004 	sub	r9, r9, #4
        int nBytes;
        
        if (r->Link.protocol & RTMP_FEATURE_HTTP)
            nBytes = HTTP_Post(r, RTMPT_SEND, ptr, n);
        else
            nBytes = RTMPSockBuf_Send(&r->m_sb, ptr, n);//socket send
    b1d8:	e28870e0 	add	r7, r8, #224	; 0xe0
    b1dc:	ea00000a 	b	b20c <WriteN.isra.9+0xa8>
    while (n > 0)
    {
        int nBytes;
        
        if (r->Link.protocol & RTMP_FEATURE_HTTP)
            nBytes = HTTP_Post(r, RTMPT_SEND, ptr, n);
    b1e0:	e1a00008 	mov	r0, r8
    b1e4:	e3a01001 	mov	r1, #1
    b1e8:	e1a02005 	mov	r2, r5
    b1ec:	ebfffb96 	bl	a04c <HTTP_Post>
        else
            nBytes = RTMPSockBuf_Send(&r->m_sb, ptr, n);//socket send
        /*RTMP_Log(RTMP_LOGDEBUG, "%s: %d\n", __FUNCTION__, nBytes); */
        
        if (nBytes < 0)
    b1f0:	e3500000 	cmp	r0, #0
    b1f4:	ba00000e 	blt	b234 <WriteN.isra.9+0xd0>
        //LOGE("send data len:%d ",nBytes);
        if (nBytes == 0)
            break;
        
        n -= nBytes;
        ptr += nBytes;
    b1f8:	e0855000 	add	r5, r5, r0
            RTMP_Close(r);
            n = 1;
            break;
        }
        //LOGE("send data len:%d ",nBytes);
        if (nBytes == 0)
    b1fc:	0a000033 	beq	b2d0 <WriteN.isra.9+0x16c>
            break;
        
        n -= nBytes;
    b200:	e0604004 	rsb	r4, r0, r4
        ptr = encrypted;
        RC4_encrypt2(r->Link.rc4keyOut, n, buffer, ptr);
    }
#endif
    
    while (n > 0)
    b204:	e3540000 	cmp	r4, #0
    b208:	da00002d 	ble	b2c4 <WriteN.isra.9+0x160>
    {
        int nBytes;
        
        if (r->Link.protocol & RTMP_FEATURE_HTTP)
    b20c:	e5963188 	ldr	r3, [r6, #392]	; 0x188
            nBytes = HTTP_Post(r, RTMPT_SEND, ptr, n);
        else
            nBytes = RTMPSockBuf_Send(&r->m_sb, ptr, n);//socket send
    b210:	e1a01005 	mov	r1, r5
    
    while (n > 0)
    {
        int nBytes;
        
        if (r->Link.protocol & RTMP_FEATURE_HTTP)
    b214:	e3130001 	tst	r3, #1
            nBytes = HTTP_Post(r, RTMPT_SEND, ptr, n);
        else
            nBytes = RTMPSockBuf_Send(&r->m_sb, ptr, n);//socket send
    b218:	e1a02004 	mov	r2, r4
    b21c:	e1a00007 	mov	r0, r7
    while (n > 0)
    {
        int nBytes;
        
        if (r->Link.protocol & RTMP_FEATURE_HTTP)
            nBytes = HTTP_Post(r, RTMPT_SEND, ptr, n);
    b220:	e1a03004 	mov	r3, r4
    
    while (n > 0)
    {
        int nBytes;
        
        if (r->Link.protocol & RTMP_FEATURE_HTTP)
    b224:	1affffed 	bne	b1e0 <WriteN.isra.9+0x7c>
            nBytes = HTTP_Post(r, RTMPT_SEND, ptr, n);
        else
            nBytes = RTMPSockBuf_Send(&r->m_sb, ptr, n);//socket send
    b228:	ebfffb7f 	bl	a02c <RTMPSockBuf_Send>
        /*RTMP_Log(RTMP_LOGDEBUG, "%s: %d\n", __FUNCTION__, nBytes); */
        
        if (nBytes < 0)
    b22c:	e3500000 	cmp	r0, #0
    b230:	aafffff0 	bge	b1f8 <WriteN.isra.9+0x94>
        {
            int sockerr ;
			sockerr= GetSockError();
    b234:	ebffe859 	bl	53a0 <__errno@plt>

            LOGE("%s, RTMP send error %d (%d bytes)", __FUNCTION__,
    b238:	e1a03004 	mov	r3, r4
    b23c:	e1a01009 	mov	r1, r9
        /*RTMP_Log(RTMP_LOGDEBUG, "%s: %d\n", __FUNCTION__, nBytes); */
        
        if (nBytes < 0)
        {
            int sockerr ;
			sockerr= GetSockError();
    b240:	e590a000 	ldr	sl, [r0]

            LOGE("%s, RTMP send error %d (%d bytes)", __FUNCTION__,
    b244:	e1a0000b 	mov	r0, fp
    b248:	e1a0200a 	mov	r2, sl
    b24c:	ebffe82c 	bl	5304 <printf@plt>
                 sockerr, n);
            
            if (sockerr == EINTR && !RTMP_ctrlC)
    b250:	e35a0004 	cmp	sl, #4
    b254:	e59f30ac 	ldr	r3, [pc, #172]	; b308 <WriteN.isra.9+0x1a4>
    b258:	1a000003 	bne	b26c <WriteN.isra.9+0x108>
    b25c:	e79f3003 	ldr	r3, [pc, r3]
    b260:	e5933000 	ldr	r3, [r3]
    b264:	e3530000 	cmp	r3, #0
    b268:	0affffe5 	beq	b204 <WriteN.isra.9+0xa0>
                continue;
            
            RTMP_Close(r);
    b26c:	e1a00008 	mov	r0, r8
    b270:	ebffffb9 	bl	b15c <RTMP_Close>
    b274:	e3a04000 	mov	r4, #0
        n -= nBytes;
        ptr += nBytes;
    }
    
#ifdef CRYPTO
    if (encrypted && encrypted != buf)
    b278:	e59d3000 	ldr	r3, [sp]
    b27c:	e3530000 	cmp	r3, #0
    b280:	0a000001 	beq	b28c <WriteN.isra.9+0x128>
        free(encrypted);
    b284:	e59d0004 	ldr	r0, [sp, #4]
    b288:	ebffe75d 	bl	5004 <free@plt>
#endif
    
    return n == 0;
}
    b28c:	e1a00004 	mov	r0, r4
    b290:	e28dd901 	add	sp, sp, #16384	; 0x4000
    b294:	e28dd00c 	add	sp, sp, #12
    b298:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    char buf[RTMP_BUFFER_CACHE_SIZE];
    
    if (r->Link.rc4keyOut)
    {
        if (n > sizeof(buf))
            encrypted = (char *)malloc(n);
    b29c:	e1a00002 	mov	r0, r2
    b2a0:	ebffe75d 	bl	501c <malloc@plt>
    b2a4:	e28da008 	add	sl, sp, #8
    b2a8:	e3500000 	cmp	r0, #0
    b2ac:	1150000a 	cmpne	r0, sl
    b2b0:	13a03001 	movne	r3, #1
    b2b4:	03a03000 	moveq	r3, #0
    b2b8:	e1a05000 	mov	r5, r0
    b2bc:	e58d3000 	str	r3, [sp]
    b2c0:	eaffffb6 	b	b1a0 <WriteN.isra.9+0x3c>
    b2c4:	03a04001 	moveq	r4, #1
    b2c8:	13a04000 	movne	r4, #0
    b2cc:	eaffffe9 	b	b278 <WriteN.isra.9+0x114>
    b2d0:	e16f4f14 	clz	r4, r4
    b2d4:	e1a042a4 	lsr	r4, r4, #5
    b2d8:	eaffffe6 	b	b278 <WriteN.isra.9+0x114>
        ptr = encrypted;
        RC4_encrypt2(r->Link.rc4keyOut, n, buffer, ptr);
    }
#endif
    
    while (n > 0)
    b2dc:	e3520000 	cmp	r2, #0
    b2e0:	c1a03007 	movgt	r3, r7
    b2e4:	c58d3000 	strgt	r3, [sp]
}

static int
WriteN(RTMP *r, const char *buffer, int n,int priority)
{
    const char *ptr = buffer;
    b2e8:	c1a05001 	movgt	r5, r1
#ifdef CRYPTO
    char *encrypted = 0;
    b2ec:	c58d3004 	strgt	r3, [sp, #4]
        ptr = encrypted;
        RC4_encrypt2(r->Link.rc4keyOut, n, buffer, ptr);
    }
#endif
    
    while (n > 0)
    b2f0:	caffffb2 	bgt	b1c0 <WriteN.isra.9+0x5c>
    b2f4:	03a04001 	moveq	r4, #1
    b2f8:	13a04000 	movne	r4, #0
    b2fc:	eaffffe2 	b	b28c <WriteN.isra.9+0x128>
    b300:	00013618 	.word	0x00013618
    b304:	00013dd0 	.word	0x00013dd0
    b308:	00018b24 	.word	0x00018b24

0000b30c <RTMP_SendChunk>:
RTMP_SendChunk(RTMP *r, RTMPChunk *chunk)
{
    int wrote;
    char hbuf[RTMP_MAX_HEADER_SIZE];
    
    RTMP_Log(RTMP_LOGDEBUG2, "%s: fd=%d, size=%d", __FUNCTION__, r->m_sb.sb_socket,
    b30c:	e59f20e0 	ldr	r2, [pc, #224]	; b3f4 <RTMP_SendChunk+0xe8>
}
#endif

int
RTMP_SendChunk(RTMP *r, RTMPChunk *chunk)
{
    b310:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
    b314:	e1a04001 	mov	r4, r1
    b318:	e24dd024 	sub	sp, sp, #36	; 0x24
    int wrote;
    char hbuf[RTMP_MAX_HEADER_SIZE];
    
    RTMP_Log(RTMP_LOGDEBUG2, "%s: fd=%d, size=%d", __FUNCTION__, r->m_sb.sb_socket,
    b31c:	e5911004 	ldr	r1, [r1, #4]
    b320:	e59030e0 	ldr	r3, [r0, #224]	; 0xe0
    b324:	e08f2002 	add	r2, pc, r2
    b328:	e58d1000 	str	r1, [sp]
    b32c:	e59f10c4 	ldr	r1, [pc, #196]	; b3f8 <RTMP_SendChunk+0xec>
    b330:	e2422ec6 	sub	r2, r2, #3168	; 0xc60
    b334:	e242200c 	sub	r2, r2, #12
    b338:	e08f1001 	add	r1, pc, r1
}
#endif

int
RTMP_SendChunk(RTMP *r, RTMPChunk *chunk)
{
    b33c:	e1a07000 	mov	r7, r0
    int wrote;
    char hbuf[RTMP_MAX_HEADER_SIZE];
    
    RTMP_Log(RTMP_LOGDEBUG2, "%s: fd=%d, size=%d", __FUNCTION__, r->m_sb.sb_socket,
             chunk->c_chunkSize);
    RTMP_LogHexString(RTMP_LOGDEBUG2, (uint8_t *)chunk->c_header, chunk->c_headerSize);
    b340:	e284600c 	add	r6, r4, #12
RTMP_SendChunk(RTMP *r, RTMPChunk *chunk)
{
    int wrote;
    char hbuf[RTMP_MAX_HEADER_SIZE];
    
    RTMP_Log(RTMP_LOGDEBUG2, "%s: fd=%d, size=%d", __FUNCTION__, r->m_sb.sb_socket,
    b344:	e3a00005 	mov	r0, #5
    b348:	eb002997 	bl	159ac <RTMP_Log>
             chunk->c_chunkSize);
    RTMP_LogHexString(RTMP_LOGDEBUG2, (uint8_t *)chunk->c_header, chunk->c_headerSize);
    b34c:	e5942000 	ldr	r2, [r4]
    b350:	e1a01006 	mov	r1, r6
    b354:	e3a00005 	mov	r0, #5
    b358:	eb0029e1 	bl	15ae4 <RTMP_LogHexString>
    if (chunk->c_chunkSize)
    b35c:	e5942004 	ldr	r2, [r4, #4]
    b360:	e3520000 	cmp	r2, #0
    b364:	1a000005 	bne	b380 <RTMP_SendChunk+0x74>
        memcpy(ptr, chunk->c_header, chunk->c_headerSize);
        wrote = WriteN(r, ptr, chunk->c_headerSize + chunk->c_chunkSize,0);
        memcpy(ptr, hbuf, chunk->c_headerSize);
    }
    else
        wrote = WriteN(r, chunk->c_header, chunk->c_headerSize,0);
    b368:	e1a00007 	mov	r0, r7
    b36c:	e1a01006 	mov	r1, r6
    b370:	e5942000 	ldr	r2, [r4]
    return wrote;
}
    b374:	e28dd024 	add	sp, sp, #36	; 0x24
    b378:	e8bd43f0 	pop	{r4, r5, r6, r7, r8, r9, lr}
        memcpy(ptr, chunk->c_header, chunk->c_headerSize);
        wrote = WriteN(r, ptr, chunk->c_headerSize + chunk->c_chunkSize,0);
        memcpy(ptr, hbuf, chunk->c_headerSize);
    }
    else
        wrote = WriteN(r, chunk->c_header, chunk->c_headerSize,0);
    b37c:	eaffff78 	b	b164 <WriteN.isra.9>
    RTMP_Log(RTMP_LOGDEBUG2, "%s: fd=%d, size=%d", __FUNCTION__, r->m_sb.sb_socket,
             chunk->c_chunkSize);
    RTMP_LogHexString(RTMP_LOGDEBUG2, (uint8_t *)chunk->c_header, chunk->c_headerSize);
    if (chunk->c_chunkSize)
    {
        char *ptr = chunk->c_chunk - chunk->c_headerSize;
    b380:	e5943008 	ldr	r3, [r4, #8]
    b384:	e5945000 	ldr	r5, [r4]
        RTMP_LogHexString(RTMP_LOGDEBUG2, (uint8_t *)chunk->c_chunk, chunk->c_chunkSize);
    b388:	e1a01003 	mov	r1, r3
    b38c:	e3a00005 	mov	r0, #5
    RTMP_Log(RTMP_LOGDEBUG2, "%s: fd=%d, size=%d", __FUNCTION__, r->m_sb.sb_socket,
             chunk->c_chunkSize);
    RTMP_LogHexString(RTMP_LOGDEBUG2, (uint8_t *)chunk->c_header, chunk->c_headerSize);
    if (chunk->c_chunkSize)
    {
        char *ptr = chunk->c_chunk - chunk->c_headerSize;
    b390:	e0655003 	rsb	r5, r5, r3
        RTMP_LogHexString(RTMP_LOGDEBUG2, (uint8_t *)chunk->c_chunk, chunk->c_chunkSize);
    b394:	eb0029d2 	bl	15ae4 <RTMP_LogHexString>
        /* save header bytes we're about to overwrite */
        memcpy(hbuf, ptr, chunk->c_headerSize);
    b398:	e5949000 	ldr	r9, [r4]
    b39c:	e28d800c 	add	r8, sp, #12
    b3a0:	e1a01005 	mov	r1, r5
    b3a4:	e1a02009 	mov	r2, r9
    b3a8:	e1a00008 	mov	r0, r8
    b3ac:	ebffe786 	bl	51cc <memcpy@plt>
        memcpy(ptr, chunk->c_header, chunk->c_headerSize);
    b3b0:	e1a01006 	mov	r1, r6
    b3b4:	e1a02009 	mov	r2, r9
    b3b8:	e1a00005 	mov	r0, r5
    b3bc:	ebffe782 	bl	51cc <memcpy@plt>
        wrote = WriteN(r, ptr, chunk->c_headerSize + chunk->c_chunkSize,0);
    b3c0:	e894000c 	ldm	r4, {r2, r3}
    b3c4:	e1a01005 	mov	r1, r5
    b3c8:	e0822003 	add	r2, r2, r3
    b3cc:	e1a00007 	mov	r0, r7
    b3d0:	ebffff63 	bl	b164 <WriteN.isra.9>
        memcpy(ptr, hbuf, chunk->c_headerSize);
    b3d4:	e1a01008 	mov	r1, r8
    b3d8:	e5942000 	ldr	r2, [r4]
        char *ptr = chunk->c_chunk - chunk->c_headerSize;
        RTMP_LogHexString(RTMP_LOGDEBUG2, (uint8_t *)chunk->c_chunk, chunk->c_chunkSize);
        /* save header bytes we're about to overwrite */
        memcpy(hbuf, ptr, chunk->c_headerSize);
        memcpy(ptr, chunk->c_header, chunk->c_headerSize);
        wrote = WriteN(r, ptr, chunk->c_headerSize + chunk->c_chunkSize,0);
    b3dc:	e1a06000 	mov	r6, r0
        memcpy(ptr, hbuf, chunk->c_headerSize);
    b3e0:	e1a00005 	mov	r0, r5
    b3e4:	ebffe778 	bl	51cc <memcpy@plt>
    }
    else
        wrote = WriteN(r, chunk->c_header, chunk->c_headerSize,0);
    return wrote;
}
    b3e8:	e1a00006 	mov	r0, r6
    b3ec:	e28dd024 	add	sp, sp, #36	; 0x24
    b3f0:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
    b3f4:	000134bc 	.word	0x000134bc
    b3f8:	00013c94 	.word	0x00013c94

0000b3fc <RTMP_SendPacket>:
    return ret;
}

int
RTMP_SendPacket(RTMP *r, RTMPPacket *packet, int queue)
{
    b3fc:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint32_t t;
    char *buffer, *tbuf = NULL, *toff = NULL;
    int nChunkSize;
    int tlen=0;
    
    if (packet->m_nChannel >= r->m_channelsAllocatedOut)
    b400:	e5903048 	ldr	r3, [r0, #72]	; 0x48
    b404:	e5918004 	ldr	r8, [r1, #4]
    return ret;
}

int
RTMP_SendPacket(RTMP *r, RTMPPacket *packet, int queue)
{
    b408:	e24dd03c 	sub	sp, sp, #60	; 0x3c
    uint32_t t;
    char *buffer, *tbuf = NULL, *toff = NULL;
    int nChunkSize;
    int tlen=0;
    
    if (packet->m_nChannel >= r->m_channelsAllocatedOut)
    b40c:	e1580003 	cmp	r8, r3
    return ret;
}

int
RTMP_SendPacket(RTMP *r, RTMPPacket *packet, int queue)
{
    b410:	e58d0010 	str	r0, [sp, #16]
    b414:	e58d1008 	str	r1, [sp, #8]
    b418:	e58d2014 	str	r2, [sp, #20]
    uint32_t t;
    char *buffer, *tbuf = NULL, *toff = NULL;
    int nChunkSize;
    int tlen=0;
    
    if (packet->m_nChannel >= r->m_channelsAllocatedOut)
    b41c:	aa0000f5 	bge	b7f8 <RTMP_SendPacket+0x3fc>
        r->m_vecChannelsOut = packets;
        memset(r->m_vecChannelsOut + r->m_channelsAllocatedOut, 0, sizeof(RTMPPacket*) * (n - r->m_channelsAllocatedOut));
        r->m_channelsAllocatedOut = n;
    }
    
    prevPacket = r->m_vecChannelsOut[packet->m_nChannel];
    b420:	e59d3010 	ldr	r3, [sp, #16]
    if (prevPacket && packet->m_headerType != RTMP_PACKET_SIZE_LARGE)
    b424:	e59d2008 	ldr	r2, [sp, #8]
        r->m_vecChannelsOut = packets;
        memset(r->m_vecChannelsOut + r->m_channelsAllocatedOut, 0, sizeof(RTMPPacket*) * (n - r->m_channelsAllocatedOut));
        r->m_channelsAllocatedOut = n;
    }
    
    prevPacket = r->m_vecChannelsOut[packet->m_nChannel];
    b428:	e5933050 	ldr	r3, [r3, #80]	; 0x50
    if (prevPacket && packet->m_headerType != RTMP_PACKET_SIZE_LARGE)
    b42c:	e5d2a000 	ldrb	sl, [r2]
        r->m_vecChannelsOut = packets;
        memset(r->m_vecChannelsOut + r->m_channelsAllocatedOut, 0, sizeof(RTMPPacket*) * (n - r->m_channelsAllocatedOut));
        r->m_channelsAllocatedOut = n;
    }
    
    prevPacket = r->m_vecChannelsOut[packet->m_nChannel];
    b430:	e7933108 	ldr	r3, [r3, r8, lsl #2]
    if (prevPacket && packet->m_headerType != RTMP_PACKET_SIZE_LARGE)
    b434:	e3530000 	cmp	r3, #0
    b438:	0a000128 	beq	b8e0 <RTMP_SendPacket+0x4e4>
    b43c:	e35a0000 	cmp	sl, #0
    b440:	0a000010 	beq	b488 <RTMP_SendPacket+0x8c>
    {
        /* compress a bit by using the prev packet's attributes */
        if (prevPacket->m_nBodySize == packet->m_nBodySize
    b444:	e5931010 	ldr	r1, [r3, #16]
    b448:	e5922010 	ldr	r2, [r2, #16]
    b44c:	e1510002 	cmp	r1, r2
    b450:	0a00012e 	beq	b910 <RTMP_SendPacket+0x514>
            && prevPacket->m_packetType == packet->m_packetType
            && packet->m_headerType == RTMP_PACKET_SIZE_MEDIUM)
            packet->m_headerType = RTMP_PACKET_SIZE_SMALL;
        
        if (prevPacket->m_nTimeStamp == packet->m_nTimeStamp
    b454:	e593c008 	ldr	ip, [r3, #8]
    b458:	e59d3008 	ldr	r3, [sp, #8]
    b45c:	e5934008 	ldr	r4, [r3, #8]
    b460:	e15c0004 	cmp	ip, r4
    b464:	0a000121 	beq	b8f0 <RTMP_SendPacket+0x4f4>
            && packet->m_headerType == RTMP_PACKET_SIZE_SMALL)
            packet->m_headerType = RTMP_PACKET_SIZE_MINIMUM;
        last = prevPacket->m_nTimeStamp;
    }
    
    if (packet->m_headerType > 3)	/* sanity */
    b468:	e35a0003 	cmp	sl, #3
    b46c:	e1a0200a 	mov	r2, sl
    b470:	8a00010f 	bhi	b8b4 <RTMP_SendPacket+0x4b8>
    b474:	e59d3008 	ldr	r3, [sp, #8]
    b478:	e5934008 	ldr	r4, [r3, #8]
    b47c:	e1a0930a 	lsl	r9, sl, #6
        if (prevPacket->m_nBodySize == packet->m_nBodySize
            && prevPacket->m_packetType == packet->m_packetType
            && packet->m_headerType == RTMP_PACKET_SIZE_MEDIUM)
            packet->m_headerType = RTMP_PACKET_SIZE_SMALL;
        
        if (prevPacket->m_nTimeStamp == packet->m_nTimeStamp
    b480:	e20970c0 	and	r7, r9, #192	; 0xc0
    b484:	ea000004 	b	b49c <RTMP_SendPacket+0xa0>
    b488:	e59d3008 	ldr	r3, [sp, #8]
        memset(r->m_vecChannelsOut + r->m_channelsAllocatedOut, 0, sizeof(RTMPPacket*) * (n - r->m_channelsAllocatedOut));
        r->m_channelsAllocatedOut = n;
    }
    
    prevPacket = r->m_vecChannelsOut[packet->m_nChannel];
    if (prevPacket && packet->m_headerType != RTMP_PACKET_SIZE_LARGE)
    b48c:	e1a0700a 	mov	r7, sl
    b490:	e5934008 	ldr	r4, [r3, #8]
    b494:	e1a0200a 	mov	r2, sl

int
RTMP_SendPacket(RTMP *r, RTMPPacket *packet, int queue)
{
    const RTMPPacket *prevPacket;
    uint32_t last = 0;
    b498:	e1a0c00a 	mov	ip, sl
        RTMP_Log(RTMP_LOGERROR, "sanity failed!! trying to send header of type: 0x%02x.",
                 (unsigned char)packet->m_headerType);
        return FALSE;
    }
    
    nSize = packetSize[packet->m_headerType];
    b49c:	e59f35d0 	ldr	r3, [pc, #1488]	; ba74 <RTMP_SendPacket+0x678>
    hSize = nSize;
    cSize = 0;//basic header,fmt + cs id
    t = packet->m_nTimeStamp - last;
    
    if (packet->m_body)
    b4a0:	e59d1008 	ldr	r1, [sp, #8]
        RTMP_Log(RTMP_LOGERROR, "sanity failed!! trying to send header of type: 0x%02x.",
                 (unsigned char)packet->m_headerType);
        return FALSE;
    }
    
    nSize = packetSize[packet->m_headerType];
    b4a4:	e08f3003 	add	r3, pc, r3
    hSize = nSize;
    cSize = 0;//basic header,fmt + cs id
    t = packet->m_nTimeStamp - last;
    
    if (packet->m_body)
    b4a8:	e591101c 	ldr	r1, [r1, #28]
        RTMP_Log(RTMP_LOGERROR, "sanity failed!! trying to send header of type: 0x%02x.",
                 (unsigned char)packet->m_headerType);
        return FALSE;
    }
    
    nSize = packetSize[packet->m_headerType];
    b4ac:	e0839102 	add	r9, r3, r2, lsl #2
    hSize = nSize;
    cSize = 0;//basic header,fmt + cs id
    t = packet->m_nTimeStamp - last;
    
    if (packet->m_body)
    b4b0:	e3510000 	cmp	r1, #0
        RTMP_Log(RTMP_LOGERROR, "sanity failed!! trying to send header of type: 0x%02x.",
                 (unsigned char)packet->m_headerType);
        return FALSE;
    }
    
    nSize = packetSize[packet->m_headerType];
    b4b4:	e5196c5c 	ldr	r6, [r9, #-3164]	; 0xfffff3a4
        hend = packet->m_body;
    }
    else
    {
        header = hbuf + 6;
        hend = hbuf + sizeof(hbuf);
    b4b8:	028d3036 	addeq	r3, sp, #54	; 0x36
    nSize = packetSize[packet->m_headerType];
    hSize = nSize;
    cSize = 0;//basic header,fmt + cs id
    t = packet->m_nTimeStamp - last;
    
    if (packet->m_body)
    b4bc:	e58d1004 	str	r1, [sp, #4]
    {
        header = packet->m_body - nSize;
    b4c0:	10662001 	rsbne	r2, r6, r1
        hend = packet->m_body;
    }
    else
    {
        header = hbuf + 6;
        hend = hbuf + sizeof(hbuf);
    b4c4:	058d3004 	streq	r3, [sp, #4]
        header = packet->m_body - nSize;
        hend = packet->m_body;
    }
    else
    {
        header = hbuf + 6;
    b4c8:	028d202a 	addeq	r2, sp, #42	; 0x2a
        hend = hbuf + sizeof(hbuf);
    }
    
    if (packet->m_nChannel > 319)
    b4cc:	e3580d05 	cmp	r8, #320	; 0x140
    }
    
    nSize = packetSize[packet->m_headerType];
    hSize = nSize;
    cSize = 0;//basic header,fmt + cs id
    t = packet->m_nTimeStamp - last;
    b4d0:	e06c4004 	rsb	r4, ip, r4
    {
        header = hbuf + 6;
        hend = hbuf + sizeof(hbuf);
    }
    
    if (packet->m_nChannel > 319)
    b4d4:	aa000086 	bge	b6f4 <RTMP_SendPacket+0x2f8>
        cSize = 2;
    else if (packet->m_nChannel > 63)
    b4d8:	e358003f 	cmp	r8, #63	; 0x3f
    b4dc:	ca0000fc 	bgt	b8d4 <RTMP_SendPacket+0x4d8>
    {
        header -= cSize;
        hSize += cSize;
    }
    
    if (nSize > 1 && t >= 0xffffff)
    b4e0:	e3560001 	cmp	r6, #1
    b4e4:	e59f558c 	ldr	r5, [pc, #1420]	; ba78 <RTMP_SendPacket+0x67c>
    b4e8:	d3a01000 	movle	r1, #0
    b4ec:	c3a01001 	movgt	r1, #1
    b4f0:	e1540005 	cmp	r4, r5
    b4f4:	93a05000 	movls	r5, #0
    b4f8:	82015001 	andhi	r5, r1, #1
    b4fc:	e3550000 	cmp	r5, #0
    b500:	01a0a002 	moveq	sl, r2
        RTMP_Log(RTMP_LOGERROR, "sanity failed!! trying to send header of type: 0x%02x.",
                 (unsigned char)packet->m_headerType);
        return FALSE;
    }
    
    nSize = packetSize[packet->m_headerType];
    b504:	01a0b006 	moveq	fp, r6
    {
        header -= cSize;
        hSize += cSize;
    }
    
    if (nSize > 1 && t >= 0xffffff)
    b508:	0a0000de 	beq	b888 <RTMP_SendPacket+0x48c>
    b50c:	e1a0b006 	mov	fp, r6
        return FALSE;
    }
    
    nSize = packetSize[packet->m_headerType];
    hSize = nSize;
    cSize = 0;//basic header,fmt + cs id
    b510:	e3a09000 	mov	r9, #0
    }
    
    hptr = header;
    c = packet->m_headerType << 6;// basic header fmt+cd id
    
    switch (cSize)
    b514:	e3590000 	cmp	r9, #0
    }
    
    if (nSize > 1 && t >= 0xffffff)
    {
        header -= 4;
        hSize += 4;
    b518:	e28bb004 	add	fp, fp, #4
        hSize += cSize;
    }
    
    if (nSize > 1 && t >= 0xffffff)
    {
        header -= 4;
    b51c:	e242a004 	sub	sl, r2, #4
    }
    
    hptr = header;
    c = packet->m_headerType << 6;// basic header fmt+cd id
    
    switch (cSize)
    b520:	0a0000d6 	beq	b880 <RTMP_SendPacket+0x484>
    b524:	e3590002 	cmp	r9, #2
    b528:	1a0000c4 	bne	b840 <RTMP_SendPacket+0x444>
    b52c:	e3a01001 	mov	r1, #1
    b530:	e1a05001 	mov	r5, r1
            c |= packet->m_nChannel;
            break;
        case 1:
            break;
        case 2:
            c |= 1;
    b534:	e3877001 	orr	r7, r7, #1
            break;
    }
    *hptr++ = c;
    if (cSize)
    {
        int tmp = packet->m_nChannel - 64;
    b538:	e59d3008 	ldr	r3, [sp, #8]
            c |= packet->m_nChannel;
            break;
        case 1:
            break;
        case 2:
            c |= 1;
    b53c:	e20770ff 	and	r7, r7, #255	; 0xff
            break;
    }
    *hptr++ = c;
    b540:	e5ca7000 	strb	r7, [sl]
    if (cSize)
    {
        int tmp = packet->m_nChannel - 64;
    b544:	e5930004 	ldr	r0, [r3, #4]
    b548:	e2400040 	sub	r0, r0, #64	; 0x40
        *hptr++ = tmp & 0xff;
    b54c:	e5ca0001 	strb	r0, [sl, #1]
        if (cSize == 2)
            *hptr++ = tmp >> 8;
    b550:	e1a00440 	asr	r0, r0, #8
    b554:	e28a2003 	add	r2, sl, #3
    b558:	e5ca0002 	strb	r0, [sl, #2]
    }
    //msg header :time delta
    if (nSize > 1)
    b55c:	e3510000 	cmp	r1, #0
    b560:	0a00001d 	beq	b5dc <RTMP_SendPacket+0x1e0>
    {
        hptr = AMF_EncodeInt24(hptr, hend, t > 0xffffff ? 0xffffff : t);
    b564:	e3e014ff 	mvn	r1, #-16777216	; 0xff000000
    b568:	e59d8004 	ldr	r8, [sp, #4]
    b56c:	e1540001 	cmp	r4, r1
    b570:	e1a00002 	mov	r0, r2
    b574:	21a02001 	movcs	r2, r1
    b578:	31a02004 	movcc	r2, r4
    b57c:	e1a01008 	mov	r1, r8
    b580:	eb002a7f 	bl	15f84 <AMF_EncodeInt24>
    }
    //msg header: msg len,msg type
    if (nSize > 4)
    b584:	e3560004 	cmp	r6, #4
            *hptr++ = tmp >> 8;
    }
    //msg header :time delta
    if (nSize > 1)
    {
        hptr = AMF_EncodeInt24(hptr, hend, t > 0xffffff ? 0xffffff : t);
    b588:	e1a02000 	mov	r2, r0
    }
    //msg header: msg len,msg type
    if (nSize > 4)
    b58c:	da000012 	ble	b5dc <RTMP_SendPacket+0x1e0>
    {
        hptr = AMF_EncodeInt24(hptr, hend, packet->m_nBodySize);
    b590:	e1a01008 	mov	r1, r8
    b594:	e59d8008 	ldr	r8, [sp, #8]
    b598:	e5982010 	ldr	r2, [r8, #16]
    b59c:	eb002a78 	bl	15f84 <AMF_EncodeInt24>
        *hptr++ = packet->m_packetType;
    b5a0:	e5d82001 	ldrb	r2, [r8, #1]
    }
    //msg header: msg stream id
    if (nSize > 8)
    b5a4:	e3560008 	cmp	r6, #8
    }
    //msg header: msg len,msg type
    if (nSize > 4)
    {
        hptr = AMF_EncodeInt24(hptr, hend, packet->m_nBodySize);
        *hptr++ = packet->m_packetType;
    b5a8:	e5c02000 	strb	r2, [r0]
    b5ac:	d2802001 	addle	r2, r0, #1
    }
    //msg header: msg stream id
    if (nSize > 8)
    b5b0:	da000009 	ble	b5dc <RTMP_SendPacket+0x1e0>
        hptr += EncodeInt32LE(hptr, packet->m_nInfoField2);
    b5b4:	e59d3008 	ldr	r3, [sp, #8]
    b5b8:	e2802005 	add	r2, r0, #5
    b5bc:	e593100c 	ldr	r1, [r3, #12]
}

static int
EncodeInt32LE(char *output, int nVal)
{
    output[0] = nVal;
    b5c0:	e5c01001 	strb	r1, [r0, #1]
    nVal >>= 8;
    b5c4:	e1a0e441 	asr	lr, r1, #8
    output[1] = nVal;
    b5c8:	e5c0e002 	strb	lr, [r0, #2]
    nVal >>= 8;
    b5cc:	e1a0e841 	asr	lr, r1, #16
    output[2] = nVal;
    nVal >>= 8;
    b5d0:	e1a01c41 	asr	r1, r1, #24
{
    output[0] = nVal;
    nVal >>= 8;
    output[1] = nVal;
    nVal >>= 8;
    output[2] = nVal;
    b5d4:	e5c0e003 	strb	lr, [r0, #3]
    nVal >>= 8;
    output[3] = nVal;
    b5d8:	e5c01004 	strb	r1, [r0, #4]
    }
    //msg header: msg stream id
    if (nSize > 8)
        hptr += EncodeInt32LE(hptr, packet->m_nInfoField2);
    //msg header: À©Õ¹Ê±¼ä´Á
    if (nSize > 1 && t >= 0xffffff)
    b5dc:	e3550000 	cmp	r5, #0
    b5e0:	1a0000ae 	bne	b8a0 <RTMP_SendPacket+0x4a4>
    buffer = packet->m_body;
    nChunkSize = r->m_outChunkSize;
    
    //RTMP_Log(RTMP_LOGDEBUG2, "%s: fd=%d, size=%d", __FUNCTION__, r->m_sb.sb_socket,nSize);
    /* send all chunks in one HTTP request */
    if (r->Link.protocol & RTMP_FEATURE_HTTP )
    b5e4:	e59d1010 	ldr	r1, [sp, #16]
    b5e8:	e2812901 	add	r2, r1, #16384	; 0x4000
    b5ec:	e5923188 	ldr	r3, [r2, #392]	; 0x188
        hptr += EncodeInt32LE(hptr, packet->m_nInfoField2);
    //msg header: À©Õ¹Ê±¼ä´Á
    if (nSize > 1 && t >= 0xffffff)
        hptr = AMF_EncodeInt32(hptr, hend, t);
    
    nSize = packet->m_nBodySize;
    b5f0:	e59d2008 	ldr	r2, [sp, #8]
    buffer = packet->m_body;
    nChunkSize = r->m_outChunkSize;
    
    //RTMP_Log(RTMP_LOGDEBUG2, "%s: fd=%d, size=%d", __FUNCTION__, r->m_sb.sb_socket,nSize);
    /* send all chunks in one HTTP request */
    if (r->Link.protocol & RTMP_FEATURE_HTTP )
    b5f4:	e2133001 	ands	r3, r3, #1
        hptr += EncodeInt32LE(hptr, packet->m_nInfoField2);
    //msg header: À©Õ¹Ê±¼ä´Á
    if (nSize > 1 && t >= 0xffffff)
        hptr = AMF_EncodeInt32(hptr, hend, t);
    
    nSize = packet->m_nBodySize;
    b5f8:	e5925010 	ldr	r5, [r2, #16]
    buffer = packet->m_body;
    b5fc:	e592601c 	ldr	r6, [r2, #28]
    nChunkSize = r->m_outChunkSize;
    b600:	e5914004 	ldr	r4, [r1, #4]
    
    //RTMP_Log(RTMP_LOGDEBUG2, "%s: fd=%d, size=%d", __FUNCTION__, r->m_sb.sb_socket,nSize);
    /* send all chunks in one HTTP request */
    if (r->Link.protocol & RTMP_FEATURE_HTTP )
    b604:	0a000079 	beq	b7f0 <RTMP_SendPacket+0x3f4>
    {
        int chunks = (nSize+nChunkSize-1) / nChunkSize;
    b608:	e0850004 	add	r0, r5, r4
    b60c:	e2400001 	sub	r0, r0, #1
    b610:	e1a01004 	mov	r1, r4
    b614:	eb0040f6 	bl	1b9f4 <__aeabi_idiv>
        if (chunks > 1)
    b618:	e3500001 	cmp	r0, #1
    b61c:	da000072 	ble	b7ec <RTMP_SendPacket+0x3f0>
        {
            tlen = chunks * (cSize + 1) + nSize + hSize;
    b620:	e0200099 	mla	r0, r9, r0, r0
    b624:	e0800005 	add	r0, r0, r5
            tbuf = malloc(tlen);
    b628:	e080000b 	add	r0, r0, fp
    b62c:	ebffe67a 	bl	501c <malloc@plt>
            if (!tbuf)
    b630:	e2503000 	subs	r3, r0, #0
    b634:	e58d3004 	str	r3, [sp, #4]
    b638:	0a000046 	beq	b758 <RTMP_SendPacket+0x35c>
            if (cSize)
            {
                header -= cSize;
                hSize += cSize;
            }
            *header = (0xc0 | c);
    b63c:	e1e03d07 	mvn	r3, r7, lsl #26
    b640:	e59d8004 	ldr	r8, [sp, #4]
    b644:	e1e03d23 	mvn	r3, r3, lsr #26
    b648:	e58d300c 	str	r3, [sp, #12]
    else
        m_priority_packet=0;
    
    ////////////////////////////////////////////////////////////////
    
    while (nSize + hSize)
    b64c:	e175000b 	cmn	r5, fp
        int wrote;
        
        if (nSize < nChunkSize)
            nChunkSize = nSize;
		
        RTMP_LogHexString(RTMP_LOGDEBUG2, (uint8_t *)header, hSize);
    b650:	e1a0200b 	mov	r2, fp
    b654:	e1a0100a 	mov	r1, sl
    b658:	e3a00005 	mov	r0, #5
    else
        m_priority_packet=0;
    
    ////////////////////////////////////////////////////////////////
    
    while (nSize + hSize)
    b65c:	0a000044 	beq	b774 <RTMP_SendPacket+0x378>
    b660:	e1540005 	cmp	r4, r5
    b664:	a1a04005 	movge	r4, r5
        int wrote;
        
        if (nSize < nChunkSize)
            nChunkSize = nSize;
		
        RTMP_LogHexString(RTMP_LOGDEBUG2, (uint8_t *)header, hSize);
    b668:	eb00291d 	bl	15ae4 <RTMP_LogHexString>
        RTMP_LogHexString(RTMP_LOGDEBUG2, (uint8_t *)buffer, nChunkSize);
    b66c:	e1a02004 	mov	r2, r4
    b670:	e3a00005 	mov	r0, #5
    b674:	e1a01006 	mov	r1, r6
    b678:	eb002919 	bl	15ae4 <RTMP_LogHexString>
        if (tbuf)//HTTP  and  UDT
    b67c:	e59d3004 	ldr	r3, [sp, #4]
        {
            memcpy(toff, header, nChunkSize + hSize);
    b680:	e08b7004 	add	r7, fp, r4
        if (nSize < nChunkSize)
            nChunkSize = nSize;
		
        RTMP_LogHexString(RTMP_LOGDEBUG2, (uint8_t *)header, hSize);
        RTMP_LogHexString(RTMP_LOGDEBUG2, (uint8_t *)buffer, nChunkSize);
        if (tbuf)//HTTP  and  UDT
    b684:	e3530000 	cmp	r3, #0
        {
            memcpy(toff, header, nChunkSize + hSize);
    b688:	e1a00008 	mov	r0, r8
    b68c:	e1a0100a 	mov	r1, sl
    b690:	e1a02007 	mov	r2, r7
        if (nSize < nChunkSize)
            nChunkSize = nSize;
		
        RTMP_LogHexString(RTMP_LOGDEBUG2, (uint8_t *)header, hSize);
        RTMP_LogHexString(RTMP_LOGDEBUG2, (uint8_t *)buffer, nChunkSize);
        if (tbuf)//HTTP  and  UDT
    b694:	0a000029 	beq	b740 <RTMP_SendPacket+0x344>
        {
            memcpy(toff, header, nChunkSize + hSize);
    b698:	ebffe6cb 	bl	51cc <memcpy@plt>
            toff += nChunkSize + hSize;
    b69c:	e0888007 	add	r8, r8, r7
            wrote = WriteN(r, header, nChunkSize + hSize,m_priority_packet);
            
            if (!wrote)
                return FALSE;
        }
        nSize -= nChunkSize;
    b6a0:	e0645005 	rsb	r5, r4, r5
        buffer += nChunkSize;
        hSize = 0;
        
        if (nSize > 0)
    b6a4:	e3550000 	cmp	r5, #0
            
            if (!wrote)
                return FALSE;
        }
        nSize -= nChunkSize;
        buffer += nChunkSize;
    b6a8:	e0866004 	add	r6, r6, r4
        hSize = 0;
    b6ac:	d3a0b000 	movle	fp, #0
        
        if (nSize > 0)
    b6b0:	daffffe5 	ble	b64c <RTMP_SendPacket+0x250>
        {
            header = buffer - 1;
            hSize = 1;
            if (cSize)
    b6b4:	e3590000 	cmp	r9, #0
        buffer += nChunkSize;
        hSize = 0;
        
        if (nSize > 0)
        {
            header = buffer - 1;
    b6b8:	e246a001 	sub	sl, r6, #1
            hSize = 1;
            if (cSize)
    b6bc:	0a000028 	beq	b764 <RTMP_SendPacket+0x368>
            {
                header -= cSize;
    b6c0:	e069a00a 	rsb	sl, r9, sl
                hSize += cSize;
            }
            *header = (0xc0 | c);
    b6c4:	e5dd300c 	ldrb	r3, [sp, #12]
    b6c8:	e5ca3000 	strb	r3, [sl]
            
            if (cSize)
            {
                int tmp = packet->m_nChannel - 64;
    b6cc:	e59d3008 	ldr	r3, [sp, #8]
                header[1] = tmp & 0xff;
                if (cSize == 2)
    b6d0:	e3590002 	cmp	r9, #2
            }
            *header = (0xc0 | c);
            
            if (cSize)
            {
                int tmp = packet->m_nChannel - 64;
    b6d4:	e5933004 	ldr	r3, [r3, #4]
            header = buffer - 1;
            hSize = 1;
            if (cSize)
            {
                header -= cSize;
                hSize += cSize;
    b6d8:	e289b001 	add	fp, r9, #1
            }
            *header = (0xc0 | c);
            
            if (cSize)
            {
                int tmp = packet->m_nChannel - 64;
    b6dc:	e2433040 	sub	r3, r3, #64	; 0x40
                header[1] = tmp & 0xff;
    b6e0:	e5ca3001 	strb	r3, [sl, #1]
                if (cSize == 2)
                    header[2] = tmp >> 8;
    b6e4:	01a03443 	asreq	r3, r3, #8
    b6e8:	05ca3002 	strbeq	r3, [sl, #2]
    b6ec:	03a0b003 	moveq	fp, #3
    b6f0:	eaffffd5 	b	b64c <RTMP_SendPacket+0x250>
    b6f4:	e3e03001 	mvn	r3, #1
        header = hbuf + 6;
        hend = hbuf + sizeof(hbuf);
    }
    
    if (packet->m_nChannel > 319)
        cSize = 2;
    b6f8:	e3a09002 	mov	r9, #2
    {
        header -= cSize;
        hSize += cSize;
    }
    
    if (nSize > 1 && t >= 0xffffff)
    b6fc:	e3560001 	cmp	r6, #1
    b700:	e59f5370 	ldr	r5, [pc, #880]	; ba78 <RTMP_SendPacket+0x67c>
    b704:	d3a01000 	movle	r1, #0
    b708:	c3a01001 	movgt	r1, #1
    b70c:	e1540005 	cmp	r4, r5
    b710:	93a05000 	movls	r5, #0
    b714:	82015001 	andhi	r5, r1, #1
    b718:	e3550000 	cmp	r5, #0
        cSize = 2;
    else if (packet->m_nChannel > 63)
        cSize = 1;
    if (cSize)
    {
        header -= cSize;
    b71c:	e0822003 	add	r2, r2, r3
        hSize += cSize;
    b720:	e089b006 	add	fp, r9, r6
    }
    
    if (nSize > 1 && t >= 0xffffff)
    b724:	1affff7a 	bne	b514 <RTMP_SendPacket+0x118>
    }
    
    hptr = header;
    c = packet->m_headerType << 6;// basic header fmt+cd id
    
    switch (cSize)
    b728:	e3590000 	cmp	r9, #0
    b72c:	0a00006d 	beq	b8e8 <RTMP_SendPacket+0x4ec>
    b730:	e3590002 	cmp	r9, #2
    b734:	1a0000b4 	bne	ba0c <RTMP_SendPacket+0x610>
        cSize = 2;
    else if (packet->m_nChannel > 63)
        cSize = 1;
    if (cSize)
    {
        header -= cSize;
    b738:	e1a0a002 	mov	sl, r2
    b73c:	eaffff7c 	b	b534 <RTMP_SendPacket+0x138>
            memcpy(toff, header, nChunkSize + hSize);
            toff += nChunkSize + hSize;
        }
        else//SOCKET
        {
            wrote = WriteN(r, header, nChunkSize + hSize,m_priority_packet);
    b740:	e08b2004 	add	r2, fp, r4
    b744:	e59d0010 	ldr	r0, [sp, #16]
    b748:	e1a0100a 	mov	r1, sl
    b74c:	ebfffe84 	bl	b164 <WriteN.isra.9>
            
            if (!wrote)
    b750:	e3500000 	cmp	r0, #0
    b754:	1affffd1 	bne	b6a0 <RTMP_SendPacket+0x2a4>
        if (chunks > 1)
        {
            tlen = chunks * (cSize + 1) + nSize + hSize;
            tbuf = malloc(tlen);
            if (!tbuf)
                return FALSE;
    b758:	e3a00000 	mov	r0, #0
    
    if (!r->m_vecChannelsOut[packet->m_nChannel])
        r->m_vecChannelsOut[packet->m_nChannel] = malloc(sizeof(RTMPPacket));
    memcpy(r->m_vecChannelsOut[packet->m_nChannel], packet, sizeof(RTMPPacket));
    return TRUE;
}
    b75c:	e28dd03c 	add	sp, sp, #60	; 0x3c
    b760:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
            if (cSize)
            {
                header -= cSize;
                hSize += cSize;
            }
            *header = (0xc0 | c);
    b764:	e5dd300c 	ldrb	r3, [sp, #12]
    b768:	e5463001 	strb	r3, [r6, #-1]
        hSize = 0;
        
        if (nSize > 0)
        {
            header = buffer - 1;
            hSize = 1;
    b76c:	e3a0b001 	mov	fp, #1
    b770:	eaffffb5 	b	b64c <RTMP_SendPacket+0x250>
                    header[2] = tmp >> 8;
            }
            //LOGE(" chunk fmt: %d  cs id: %d ",header[0] & 0xC0 ,packet->m_nChannel);
        }
    }
    if (tbuf )//HTTP
    b774:	e59d3004 	ldr	r3, [sp, #4]
    b778:	e3530000 	cmp	r3, #0
    b77c:	0a000009 	beq	b7a8 <RTMP_SendPacket+0x3ac>
    {
        int	wrote = WriteN(r, tbuf, toff-tbuf,m_priority_packet);
    b780:	e59d5004 	ldr	r5, [sp, #4]
    b784:	e59d0010 	ldr	r0, [sp, #16]
    b788:	e0652008 	rsb	r2, r5, r8
    b78c:	e1a01005 	mov	r1, r5
    b790:	ebfffe73 	bl	b164 <WriteN.isra.9>
    b794:	e1a04000 	mov	r4, r0
        free(tbuf);
    b798:	e1a00005 	mov	r0, r5
    b79c:	ebffe618 	bl	5004 <free@plt>
        tbuf = NULL;
        if (!wrote)
    b7a0:	e3540000 	cmp	r4, #0
    b7a4:	0affffeb 	beq	b758 <RTMP_SendPacket+0x35c>
            return FALSE;
    }
	
    /* we invoked a remote method */
    if (packet->m_packetType == RTMP_PACKET_TYPE_INVOKE)
    b7a8:	e59d3008 	ldr	r3, [sp, #8]
    b7ac:	e5d33001 	ldrb	r3, [r3, #1]
    b7b0:	e3530014 	cmp	r3, #20
    b7b4:	0a000064 	beq	b94c <RTMP_SendPacket+0x550>
            txn = (int)AMF_DecodeNumber(ptr);
            AV_queue(&r->m_methodCalls, &r->m_numCalls, &method, txn);
        }
    }
    
    if (!r->m_vecChannelsOut[packet->m_nChannel])
    b7b8:	e59d3008 	ldr	r3, [sp, #8]
    b7bc:	e5934004 	ldr	r4, [r3, #4]
    b7c0:	e59d3010 	ldr	r3, [sp, #16]
    b7c4:	e5935050 	ldr	r5, [r3, #80]	; 0x50
    b7c8:	e7950104 	ldr	r0, [r5, r4, lsl #2]
    b7cc:	e3500000 	cmp	r0, #0
    b7d0:	0a000090 	beq	ba18 <RTMP_SendPacket+0x61c>
        r->m_vecChannelsOut[packet->m_nChannel] = malloc(sizeof(RTMPPacket));
    memcpy(r->m_vecChannelsOut[packet->m_nChannel], packet, sizeof(RTMPPacket));
    b7d4:	e59d1008 	ldr	r1, [sp, #8]
    b7d8:	e3a02020 	mov	r2, #32
    b7dc:	ebffe67a 	bl	51cc <memcpy@plt>
    return TRUE;
    b7e0:	e3a00001 	mov	r0, #1
}
    b7e4:	e28dd03c 	add	sp, sp, #60	; 0x3c
    b7e8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    uint32_t last = 0;
    int nSize;
    int hSize, cSize;
    char *header, *hptr, *hend, hbuf[RTMP_MAX_HEADER_SIZE], c;
    uint32_t t;
    char *buffer, *tbuf = NULL, *toff = NULL;
    b7ec:	e3a03000 	mov	r3, #0
    b7f0:	e58d3004 	str	r3, [sp, #4]
    b7f4:	eaffff90 	b	b63c <RTMP_SendPacket+0x240>
    int nChunkSize;
    int tlen=0;
    
    if (packet->m_nChannel >= r->m_channelsAllocatedOut)
    {
        int n = packet->m_nChannel + 10;
    b7f8:	e288500a 	add	r5, r8, #10
        RTMPPacket **packets = realloc(r->m_vecChannelsOut, sizeof(RTMPPacket*) * n);
    b7fc:	e1a01105 	lsl	r1, r5, #2
    b800:	e5900050 	ldr	r0, [r0, #80]	; 0x50
    b804:	ebffe71e 	bl	5484 <realloc@plt>
        if (!packets) {
    b808:	e2504000 	subs	r4, r0, #0
    b80c:	0a000088 	beq	ba34 <RTMP_SendPacket+0x638>
            r->m_vecChannelsOut = NULL;
            r->m_channelsAllocatedOut = 0;
            return FALSE;
        }
        r->m_vecChannelsOut = packets;
        memset(r->m_vecChannelsOut + r->m_channelsAllocatedOut, 0, sizeof(RTMPPacket*) * (n - r->m_channelsAllocatedOut));
    b810:	e59d6010 	ldr	r6, [sp, #16]
    b814:	e3a01000 	mov	r1, #0
    b818:	e5960048 	ldr	r0, [r6, #72]	; 0x48
            free(r->m_vecChannelsOut);
            r->m_vecChannelsOut = NULL;
            r->m_channelsAllocatedOut = 0;
            return FALSE;
        }
        r->m_vecChannelsOut = packets;
    b81c:	e5864050 	str	r4, [r6, #80]	; 0x50
        memset(r->m_vecChannelsOut + r->m_channelsAllocatedOut, 0, sizeof(RTMPPacket*) * (n - r->m_channelsAllocatedOut));
    b820:	e0602005 	rsb	r2, r0, r5
    b824:	e1a02102 	lsl	r2, r2, #2
    b828:	e0840100 	add	r0, r4, r0, lsl #2
    b82c:	ebffe627 	bl	50d0 <memset@plt>
    b830:	e59d3008 	ldr	r3, [sp, #8]
    b834:	e5938004 	ldr	r8, [r3, #4]
        r->m_channelsAllocatedOut = n;
    b838:	e5865048 	str	r5, [r6, #72]	; 0x48
    b83c:	eafffef7 	b	b420 <RTMP_SendPacket+0x24>
        case 2:
            c |= 1;
            break;
    }
    *hptr++ = c;
    if (cSize)
    b840:	e3590000 	cmp	r9, #0
            break;
        case 2:
            c |= 1;
            break;
    }
    *hptr++ = c;
    b844:	e5427004 	strb	r7, [r2, #-4]
    b848:	03a05001 	moveq	r5, #1
    b84c:	02422003 	subeq	r2, r2, #3
    if (cSize)
    b850:	0affff43 	beq	b564 <RTMP_SendPacket+0x168>
    b854:	e3a01001 	mov	r1, #1
    b858:	e1a05001 	mov	r5, r1
    {
        int tmp = packet->m_nChannel - 64;
    b85c:	e59d3008 	ldr	r3, [sp, #8]
        *hptr++ = tmp & 0xff;
        if (cSize == 2)
    b860:	e3590002 	cmp	r9, #2
            break;
    }
    *hptr++ = c;
    if (cSize)
    {
        int tmp = packet->m_nChannel - 64;
    b864:	e5930004 	ldr	r0, [r3, #4]
        *hptr++ = tmp & 0xff;
    b868:	e28a2002 	add	r2, sl, #2
            break;
    }
    *hptr++ = c;
    if (cSize)
    {
        int tmp = packet->m_nChannel - 64;
    b86c:	e2400040 	sub	r0, r0, #64	; 0x40
        *hptr++ = tmp & 0xff;
    b870:	e5ca0001 	strb	r0, [sl, #1]
    b874:	13a09001 	movne	r9, #1
        if (cSize == 2)
    b878:	1affff37 	bne	b55c <RTMP_SendPacket+0x160>
    b87c:	eaffff33 	b	b550 <RTMP_SendPacket+0x154>
    }
    
    hptr = header;
    c = packet->m_headerType << 6;// basic header fmt+cd id
    
    switch (cSize)
    b880:	e3a05001 	mov	r5, #1
    b884:	e1a01005 	mov	r1, r5
    {
        case 0:
            c |= packet->m_nChannel;
    b888:	e1877008 	orr	r7, r7, r8
    b88c:	e20770ff 	and	r7, r7, #255	; 0xff
            break;
        case 2:
            c |= 1;
            break;
    }
    *hptr++ = c;
    b890:	e5ca7000 	strb	r7, [sl]
    b894:	e28a2001 	add	r2, sl, #1
    b898:	e3a09000 	mov	r9, #0
    b89c:	eaffff2e 	b	b55c <RTMP_SendPacket+0x160>
    //msg header: msg stream id
    if (nSize > 8)
        hptr += EncodeInt32LE(hptr, packet->m_nInfoField2);
    //msg header: À©Õ¹Ê±¼ä´Á
    if (nSize > 1 && t >= 0xffffff)
        hptr = AMF_EncodeInt32(hptr, hend, t);
    b8a0:	e1a00002 	mov	r0, r2
    b8a4:	e59d1004 	ldr	r1, [sp, #4]
    b8a8:	e1a02004 	mov	r2, r4
    b8ac:	eb0029be 	bl	15fac <AMF_EncodeInt32>
    b8b0:	eaffff4b 	b	b5e4 <RTMP_SendPacket+0x1e8>
        last = prevPacket->m_nTimeStamp;
    }
    
    if (packet->m_headerType > 3)	/* sanity */
    {
        RTMP_Log(RTMP_LOGERROR, "sanity failed!! trying to send header of type: 0x%02x.",
    b8b4:	e59f11c0 	ldr	r1, [pc, #448]	; ba7c <RTMP_SendPacket+0x680>
    b8b8:	e1a0200a 	mov	r2, sl
    b8bc:	e3a00001 	mov	r0, #1
    b8c0:	e08f1001 	add	r1, pc, r1
    b8c4:	eb002838 	bl	159ac <RTMP_Log>
                 (unsigned char)packet->m_headerType);
        return FALSE;
    b8c8:	e3a00000 	mov	r0, #0
    
    if (!r->m_vecChannelsOut[packet->m_nChannel])
        r->m_vecChannelsOut[packet->m_nChannel] = malloc(sizeof(RTMPPacket));
    memcpy(r->m_vecChannelsOut[packet->m_nChannel], packet, sizeof(RTMPPacket));
    return TRUE;
}
    b8cc:	e28dd03c 	add	sp, sp, #60	; 0x3c
    b8d0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b8d4:	e3e03000 	mvn	r3, #0
    }
    
    if (packet->m_nChannel > 319)
        cSize = 2;
    else if (packet->m_nChannel > 63)
        cSize = 1;
    b8d8:	e3a09001 	mov	r9, #1
    b8dc:	eaffff86 	b	b6fc <RTMP_SendPacket+0x300>

int
RTMP_SendPacket(RTMP *r, RTMPPacket *packet, int queue)
{
    const RTMPPacket *prevPacket;
    uint32_t last = 0;
    b8e0:	e1a0c003 	mov	ip, r3
    b8e4:	eafffedf 	b	b468 <RTMP_SendPacket+0x6c>
        cSize = 2;
    else if (packet->m_nChannel > 63)
        cSize = 1;
    if (cSize)
    {
        header -= cSize;
    b8e8:	e1a0a002 	mov	sl, r2
    b8ec:	eaffffe5 	b	b888 <RTMP_SendPacket+0x48c>
            && prevPacket->m_packetType == packet->m_packetType
            && packet->m_headerType == RTMP_PACKET_SIZE_MEDIUM)
            packet->m_headerType = RTMP_PACKET_SIZE_SMALL;
        
        if (prevPacket->m_nTimeStamp == packet->m_nTimeStamp
            && packet->m_headerType == RTMP_PACKET_SIZE_SMALL)
    b8f0:	e35a0002 	cmp	sl, #2
    b8f4:	1afffedb 	bne	b468 <RTMP_SendPacket+0x6c>
            packet->m_headerType = RTMP_PACKET_SIZE_MINIMUM;
    b8f8:	e59d3008 	ldr	r3, [sp, #8]
    b8fc:	e3a02003 	mov	r2, #3
    b900:	e5c32000 	strb	r2, [r3]
    b904:	e1a0400c 	mov	r4, ip
    b908:	e3a070c0 	mov	r7, #192	; 0xc0
    b90c:	eafffee2 	b	b49c <RTMP_SendPacket+0xa0>
    prevPacket = r->m_vecChannelsOut[packet->m_nChannel];
    if (prevPacket && packet->m_headerType != RTMP_PACKET_SIZE_LARGE)
    {
        /* compress a bit by using the prev packet's attributes */
        if (prevPacket->m_nBodySize == packet->m_nBodySize
            && prevPacket->m_packetType == packet->m_packetType
    b910:	e59d2008 	ldr	r2, [sp, #8]
    b914:	e5d31001 	ldrb	r1, [r3, #1]
    b918:	e5d22001 	ldrb	r2, [r2, #1]
            && packet->m_headerType == RTMP_PACKET_SIZE_MEDIUM)
    b91c:	e1510002 	cmp	r1, r2
    b920:	035a0001 	cmpeq	sl, #1
    b924:	1afffeca 	bne	b454 <RTMP_SendPacket+0x58>
            packet->m_headerType = RTMP_PACKET_SIZE_SMALL;
    b928:	e59d1008 	ldr	r1, [sp, #8]
    b92c:	e3a02002 	mov	r2, #2
    b930:	e5c12000 	strb	r2, [r1]
        
        if (prevPacket->m_nTimeStamp == packet->m_nTimeStamp
    b934:	e5914008 	ldr	r4, [r1, #8]
    b938:	e593c008 	ldr	ip, [r3, #8]
    b93c:	e15c0004 	cmp	ip, r4
    b940:	11a0a002 	movne	sl, r2
    b944:	1afffecc 	bne	b47c <RTMP_SendPacket+0x80>
    b948:	eaffffea 	b	b8f8 <RTMP_SendPacket+0x4fc>
    /* we invoked a remote method */
    if (packet->m_packetType == RTMP_PACKET_TYPE_INVOKE)
    {
        AVal method;
        char *ptr;
        ptr = packet->m_body + 1;
    b94c:	e59d3008 	ldr	r3, [sp, #8]
        AMF_DecodeString(ptr, &method);
    b950:	e28d101c 	add	r1, sp, #28
    /* we invoked a remote method */
    if (packet->m_packetType == RTMP_PACKET_TYPE_INVOKE)
    {
        AVal method;
        char *ptr;
        ptr = packet->m_body + 1;
    b954:	e593401c 	ldr	r4, [r3, #28]
    b958:	e2844001 	add	r4, r4, #1
        AMF_DecodeString(ptr, &method);
    b95c:	e1a00004 	mov	r0, r4
    b960:	eb002953 	bl	15eb4 <AMF_DecodeString>
        RTMP_Log(RTMP_LOGDEBUG, "Invoking %s", method.av_val);
    b964:	e59f1114 	ldr	r1, [pc, #276]	; ba80 <RTMP_SendPacket+0x684>
    b968:	e3a00004 	mov	r0, #4
    b96c:	e08f1001 	add	r1, pc, r1
    b970:	e59d201c 	ldr	r2, [sp, #28]
    b974:	eb00280c 	bl	159ac <RTMP_Log>
        /* keep it in call queue till result arrives */
        if (queue)
    b978:	e59d3014 	ldr	r3, [sp, #20]
    b97c:	e3530000 	cmp	r3, #0
    b980:	0affff8c 	beq	b7b8 <RTMP_SendPacket+0x3bc>
        {
            int txn;
            ptr += 3 + method.av_len;
    b984:	e59d0020 	ldr	r0, [sp, #32]
    b988:	e2800003 	add	r0, r0, #3
            txn = (int)AMF_DecodeNumber(ptr);
    b98c:	e0840000 	add	r0, r4, r0
    b990:	eb00295a 	bl	15f00 <AMF_DecodeNumber>
    b994:	eb0042aa 	bl	1c444 <__aeabi_d2iz>

static void
AV_queue(RTMP_METHOD **vals, int *num, AVal *av, int txn)
{
    char *tmp;
    if (!(*num & 0x0f))
    b998:	e59d3010 	ldr	r3, [sp, #16]
    b99c:	e593103c 	ldr	r1, [r3, #60]	; 0x3c
    b9a0:	e311000f 	tst	r1, #15
        /* keep it in call queue till result arrives */
        if (queue)
        {
            int txn;
            ptr += 3 + method.av_len;
            txn = (int)AMF_DecodeNumber(ptr);
    b9a4:	e1a05000 	mov	r5, r0

static void
AV_queue(RTMP_METHOD **vals, int *num, AVal *av, int txn)
{
    char *tmp;
    if (!(*num & 0x0f))
    b9a8:	0a000028 	beq	ba50 <RTMP_SendPacket+0x654>
    b9ac:	e5934040 	ldr	r4, [r3, #64]	; 0x40
        *vals = realloc(*vals, (*num + 16) * sizeof(RTMP_METHOD));
    tmp = malloc(av->av_len + 1);
    b9b0:	e59d6020 	ldr	r6, [sp, #32]
    b9b4:	e2860001 	add	r0, r6, #1
    b9b8:	ebffe597 	bl	501c <malloc@plt>
    memcpy(tmp, av->av_val, av->av_len);
    b9bc:	e1a02006 	mov	r2, r6
    b9c0:	e59d101c 	ldr	r1, [sp, #28]
    b9c4:	ebffe600 	bl	51cc <memcpy@plt>
    tmp[av->av_len] = '\0';
    (*vals)[*num].num = txn;
    b9c8:	e59d1010 	ldr	r1, [sp, #16]
    char *tmp;
    if (!(*num & 0x0f))
        *vals = realloc(*vals, (*num + 16) * sizeof(RTMP_METHOD));
    tmp = malloc(av->av_len + 1);
    memcpy(tmp, av->av_val, av->av_len);
    tmp[av->av_len] = '\0';
    b9cc:	e3a02000 	mov	r2, #0
    (*vals)[*num].num = txn;
    b9d0:	e591303c 	ldr	r3, [r1, #60]	; 0x3c
    b9d4:	e0833083 	add	r3, r3, r3, lsl #1
    b9d8:	e0843103 	add	r3, r4, r3, lsl #2
    char *tmp;
    if (!(*num & 0x0f))
        *vals = realloc(*vals, (*num + 16) * sizeof(RTMP_METHOD));
    tmp = malloc(av->av_len + 1);
    memcpy(tmp, av->av_val, av->av_len);
    tmp[av->av_len] = '\0';
    b9dc:	e7c02006 	strb	r2, [r0, r6]
    (*vals)[*num].num = txn;
    b9e0:	e5835008 	str	r5, [r3, #8]
    (*vals)[*num].name.av_len = av->av_len;
    b9e4:	e591303c 	ldr	r3, [r1, #60]	; 0x3c
    b9e8:	e0833083 	add	r3, r3, r3, lsl #1
    b9ec:	e0843103 	add	r3, r4, r3, lsl #2
    b9f0:	e5836004 	str	r6, [r3, #4]
    (*vals)[(*num)++].name.av_val = tmp;
    b9f4:	e591303c 	ldr	r3, [r1, #60]	; 0x3c
    b9f8:	e2832001 	add	r2, r3, #1
    b9fc:	e0833083 	add	r3, r3, r3, lsl #1
    ba00:	e581203c 	str	r2, [r1, #60]	; 0x3c
    ba04:	e7840103 	str	r0, [r4, r3, lsl #2]
    ba08:	eaffff6a 	b	b7b8 <RTMP_SendPacket+0x3bc>
            break;
        case 2:
            c |= 1;
            break;
    }
    *hptr++ = c;
    ba0c:	e5c27000 	strb	r7, [r2]
        cSize = 2;
    else if (packet->m_nChannel > 63)
        cSize = 1;
    if (cSize)
    {
        header -= cSize;
    ba10:	e1a0a002 	mov	sl, r2
    ba14:	eaffff90 	b	b85c <RTMP_SendPacket+0x460>
            AV_queue(&r->m_methodCalls, &r->m_numCalls, &method, txn);
        }
    }
    
    if (!r->m_vecChannelsOut[packet->m_nChannel])
        r->m_vecChannelsOut[packet->m_nChannel] = malloc(sizeof(RTMPPacket));
    ba18:	e3a00020 	mov	r0, #32
    ba1c:	ebffe57e 	bl	501c <malloc@plt>
    ba20:	e59d3010 	ldr	r3, [sp, #16]
    ba24:	e7850104 	str	r0, [r5, r4, lsl #2]
    ba28:	e5933050 	ldr	r3, [r3, #80]	; 0x50
    ba2c:	e7930104 	ldr	r0, [r3, r4, lsl #2]
    ba30:	eaffff67 	b	b7d4 <RTMP_SendPacket+0x3d8>
    if (packet->m_nChannel >= r->m_channelsAllocatedOut)
    {
        int n = packet->m_nChannel + 10;
        RTMPPacket **packets = realloc(r->m_vecChannelsOut, sizeof(RTMPPacket*) * n);
        if (!packets) {
            free(r->m_vecChannelsOut);
    ba34:	e59d5010 	ldr	r5, [sp, #16]
    ba38:	e5950050 	ldr	r0, [r5, #80]	; 0x50
    ba3c:	ebffe570 	bl	5004 <free@plt>
            r->m_vecChannelsOut = NULL;
    ba40:	e5854050 	str	r4, [r5, #80]	; 0x50
            r->m_channelsAllocatedOut = 0;
    ba44:	e5854048 	str	r4, [r5, #72]	; 0x48
            return FALSE;
    ba48:	e1a00004 	mov	r0, r4
    ba4c:	eaffff42 	b	b75c <RTMP_SendPacket+0x360>
static void
AV_queue(RTMP_METHOD **vals, int *num, AVal *av, int txn)
{
    char *tmp;
    if (!(*num & 0x0f))
        *vals = realloc(*vals, (*num + 16) * sizeof(RTMP_METHOD));
    ba50:	e59d6010 	ldr	r6, [sp, #16]
    ba54:	e2811010 	add	r1, r1, #16
    ba58:	e0811081 	add	r1, r1, r1, lsl #1
    ba5c:	e1a01101 	lsl	r1, r1, #2
    ba60:	e5960040 	ldr	r0, [r6, #64]	; 0x40
    ba64:	ebffe686 	bl	5484 <realloc@plt>
    ba68:	e1a04000 	mov	r4, r0
    ba6c:	e5860040 	str	r0, [r6, #64]	; 0x40
    ba70:	eaffffce 	b	b9b0 <RTMP_SendPacket+0x5b4>
    ba74:	0001333c 	.word	0x0001333c
    ba78:	00fffffe 	.word	0x00fffffe
    ba7c:	00013720 	.word	0x00013720
    ba80:	000136ac 	.word	0x000136ac

0000ba84 <SendBytesReceived>:
    return RTMP_SendPacket(r, &packet, FALSE);
}

static int
SendBytesReceived(RTMP *r)
{
    ba84:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    ba88:	e24ddf49 	sub	sp, sp, #292	; 0x124
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    packet.m_nBodySize = 4;
    
    AMF_EncodeInt32(packet.m_body, pend, r->m_nBytesIn);	/* hard coded for now */
    ba8c:	e28d3032 	add	r3, sp, #50	; 0x32
    return RTMP_SendPacket(r, &packet, FALSE);
}

static int
SendBytesReceived(RTMP *r)
{
    ba90:	e1a04000 	mov	r4, r0
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    
    packet.m_nChannel = 0x02;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_BYTES_READ_REPORT;
    packet.m_nTimeStamp = 0;
    ba94:	e3a05000 	mov	r5, #0
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    
    packet.m_nChannel = 0x02;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_BYTES_READ_REPORT;
    ba98:	e3a0e003 	mov	lr, #3
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    packet.m_nBodySize = 4;
    ba9c:	e3a0c004 	mov	ip, #4
    
    AMF_EncodeInt32(packet.m_body, pend, r->m_nBytesIn);	/* hard coded for now */
    baa0:	e590200c 	ldr	r2, [r0, #12]
    baa4:	e28d1e12 	add	r1, sp, #288	; 0x120
    baa8:	e1a00003 	mov	r0, r3
SendBytesReceived(RTMP *r)
{
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    
    packet.m_nChannel = 0x02;	/* control channel (invoke) */
    baac:	e3a07002 	mov	r7, #2
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    bab0:	e3a06001 	mov	r6, #1
    packet.m_packetType = RTMP_PACKET_TYPE_BYTES_READ_REPORT;
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    bab4:	e58d301c 	str	r3, [sp, #28]
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    
    packet.m_nChannel = 0x02;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_BYTES_READ_REPORT;
    bab8:	e5cde001 	strb	lr, [sp, #1]
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    packet.m_nBodySize = 4;
    babc:	e58dc010 	str	ip, [sp, #16]
SendBytesReceived(RTMP *r)
{
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    
    packet.m_nChannel = 0x02;	/* control channel (invoke) */
    bac0:	e58d7004 	str	r7, [sp, #4]
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    bac4:	e5cd6000 	strb	r6, [sp]
    packet.m_packetType = RTMP_PACKET_TYPE_BYTES_READ_REPORT;
    packet.m_nTimeStamp = 0;
    bac8:	e58d5008 	str	r5, [sp, #8]
    packet.m_nInfoField2 = 0;
    bacc:	e58d500c 	str	r5, [sp, #12]
    packet.m_hasAbsTimestamp = 0;
    bad0:	e5cd5002 	strb	r5, [sp, #2]
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    packet.m_nBodySize = 4;
    
    AMF_EncodeInt32(packet.m_body, pend, r->m_nBytesIn);	/* hard coded for now */
    bad4:	eb002934 	bl	15fac <AMF_EncodeInt32>
    r->m_nBytesInSent = r->m_nBytesIn;
    bad8:	e594300c 	ldr	r3, [r4, #12]
    
    /*RTMP_Log(RTMP_LOGDEBUG, "Send bytes report. 0x%x (%d bytes)", (unsigned int)m_nBytesIn, m_nBytesIn); */
    return RTMP_SendPacket(r, &packet, FALSE);
    badc:	e1a02005 	mov	r2, r5
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    packet.m_nBodySize = 4;
    
    AMF_EncodeInt32(packet.m_body, pend, r->m_nBytesIn);	/* hard coded for now */
    r->m_nBytesInSent = r->m_nBytesIn;
    bae0:	e5843010 	str	r3, [r4, #16]
    
    /*RTMP_Log(RTMP_LOGDEBUG, "Send bytes report. 0x%x (%d bytes)", (unsigned int)m_nBytesIn, m_nBytesIn); */
    return RTMP_SendPacket(r, &packet, FALSE);
    bae4:	e1a00004 	mov	r0, r4
    bae8:	e1a0100d 	mov	r1, sp
    baec:	ebfffe42 	bl	b3fc <RTMP_SendPacket>
}
    baf0:	e28ddf49 	add	sp, sp, #292	; 0x124
    baf4:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

0000baf8 <SendConnectPacket>:
SAVC(type);
SAVC(nonprivate);

static int
SendConnectPacket(RTMP *r, RTMPPacket *cp)
{
    baf8:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
    //LOGE(" SendConnectPacket() \n");
    RTMPPacket packet;
    char pbuf[4096], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    if (cp)
    bafc:	e2513000 	subs	r3, r1, #0
SAVC(type);
SAVC(nonprivate);

static int
SendConnectPacket(RTMP *r, RTMPPacket *cp)
{
    bb00:	e24dda01 	sub	sp, sp, #4096	; 0x1000
    bb04:	e24dd028 	sub	sp, sp, #40	; 0x28
    //LOGE(" SendConnectPacket() \n");
    RTMPPacket packet;
    char pbuf[4096], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    if (cp)
    bb08:	0a000004 	beq	bb20 <SendConnectPacket+0x28>
        return RTMP_SendPacket(r, cp, TRUE);
    bb0c:	e3a02001 	mov	r2, #1
    bb10:	ebfffe39 	bl	b3fc <RTMP_SendPacket>
        }
    }
    packet.m_nBodySize = enc - packet.m_body;
    
    return RTMP_SendPacket(r, &packet, TRUE);
}
    bb14:	e28dda01 	add	sp, sp, #4096	; 0x1000
    bb18:	e28dd028 	add	sp, sp, #40	; 0x28
    bb1c:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_connect);
    bb20:	e59f838c 	ldr	r8, [pc, #908]	; beb4 <SendConnectPacket+0x3bc>
    char *enc;
    
    if (cp)
        return RTMP_SendPacket(r, cp, TRUE);
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    bb24:	e28d7028 	add	r7, sp, #40	; 0x28
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    bb28:	e287c012 	add	ip, r7, #18
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_connect);
    bb2c:	e08f8008 	add	r8, pc, r8
    bb30:	e28d1a01 	add	r1, sp, #4096	; 0x1000
    if (cp)
        return RTMP_SendPacket(r, cp, TRUE);
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    bb34:	e3a0e014 	mov	lr, #20
    bb38:	e1a06000 	mov	r6, r0
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_connect);
    bb3c:	e2882f92 	add	r2, r8, #584	; 0x248
    bb40:	e1a0000c 	mov	r0, ip
    char *enc;
    
    if (cp)
        return RTMP_SendPacket(r, cp, TRUE);
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    bb44:	e3a04003 	mov	r4, #3
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_connect);
    bb48:	e2811028 	add	r1, r1, #40	; 0x28
    if (cp)
        return RTMP_SendPacket(r, cp, TRUE);
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    bb4c:	e547e01f 	strb	lr, [r7, #-31]	; 0xffffffe1
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    bb50:	e507c004 	str	ip, [r7, #-4]
    
    if (cp)
        return RTMP_SendPacket(r, cp, TRUE);
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
    bb54:	e5473020 	strb	r3, [r7, #-32]	; 0xffffffe0
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    bb58:	e5073018 	str	r3, [r7, #-24]	; 0xffffffe8
    packet.m_nInfoField2 = 0;
    bb5c:	e5073014 	str	r3, [r7, #-20]	; 0xffffffec
    packet.m_hasAbsTimestamp = 0;
    bb60:	e547301e 	strb	r3, [r7, #-30]	; 0xffffffe2
    char *enc;
    
    if (cp)
        return RTMP_SendPacket(r, cp, TRUE);
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    bb64:	e507401c 	str	r4, [r7, #-28]	; 0xffffffe4
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_connect);
    bb68:	eb00291e 	bl	15fe8 <AMF_EncodeString>
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    *enc++ = AMF_OBJECT;
    
    enc = AMF_EncodeNamedString(enc, pend, &av_app, &r->Link.app);
    bb6c:	e2865c41 	add	r5, r6, #16640	; 0x4100
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_connect);
    bb70:	e1a09000 	mov	r9, r0
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    bb74:	e5960038 	ldr	r0, [r6, #56]	; 0x38
    bb78:	e2800001 	add	r0, r0, #1
    bb7c:	e5860038 	str	r0, [r6, #56]	; 0x38
    bb80:	eb004091 	bl	1bdcc <__aeabi_i2d>
    bb84:	e1a03001 	mov	r3, r1
    bb88:	e28d1a01 	add	r1, sp, #4096	; 0x1000
    bb8c:	e1a02000 	mov	r2, r0
    bb90:	e2811028 	add	r1, r1, #40	; 0x28
    bb94:	e1a00009 	mov	r0, r9
    bb98:	eb002939 	bl	16084 <AMF_EncodeNumber>
    *enc++ = AMF_OBJECT;
    
    enc = AMF_EncodeNamedString(enc, pend, &av_app, &r->Link.app);
    bb9c:	e28d1a01 	add	r1, sp, #4096	; 0x1000
    bba0:	e2882e25 	add	r2, r8, #592	; 0x250
    bba4:	e285302c 	add	r3, r5, #44	; 0x2c
    bba8:	e2811028 	add	r1, r1, #40	; 0x28
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_connect);
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    *enc++ = AMF_OBJECT;
    bbac:	e5c04000 	strb	r4, [r0]
    
    enc = AMF_EncodeNamedString(enc, pend, &av_app, &r->Link.app);
    bbb0:	e2800001 	add	r0, r0, #1
    bbb4:	eb00295d 	bl	16130 <AMF_EncodeNamedString>
    if (!enc)
    bbb8:	e250a000 	subs	sl, r0, #0
    bbbc:	0a000037 	beq	bca0 <SendConnectPacket+0x1a8>
        return FALSE;
    if (r->Link.protocol & RTMP_FEATURE_WRITE)
    bbc0:	e2864901 	add	r4, r6, #16384	; 0x4000
    bbc4:	e5943188 	ldr	r3, [r4, #392]	; 0x188
    bbc8:	e3130010 	tst	r3, #16
    bbcc:	1a000042 	bne	bcdc <SendConnectPacket+0x1e4>
    {
        enc = AMF_EncodeNamedString(enc, pend, &av_type, &av_nonprivate);
        if (!enc)
            return FALSE;
    }
    if (r->Link.flashVer.av_len)
    bbd0:	e5943140 	ldr	r3, [r4, #320]	; 0x140
    bbd4:	e3530000 	cmp	r3, #0
    bbd8:	1a000047 	bne	bcfc <SendConnectPacket+0x204>
    {
        enc = AMF_EncodeNamedString(enc, pend, &av_flashVer, &r->Link.flashVer);
        if (!enc)
            return FALSE;
    }
    if (r->Link.swfUrl.av_len)
    bbdc:	e5943120 	ldr	r3, [r4, #288]	; 0x120
    bbe0:	e3530000 	cmp	r3, #0
    bbe4:	1a00004f 	bne	bd28 <SendConnectPacket+0x230>
    {
        enc = AMF_EncodeNamedString(enc, pend, &av_swfUrl, &r->Link.swfUrl);
        if (!enc)
            return FALSE;
    }
    if (r->Link.tcUrl.av_len)
    bbe8:	e5943118 	ldr	r3, [r4, #280]	; 0x118
    bbec:	e3530000 	cmp	r3, #0
    bbf0:	1a000057 	bne	bd54 <SendConnectPacket+0x25c>
    {
        enc = AMF_EncodeNamedString(enc, pend, &av_tcUrl, &r->Link.tcUrl);
        if (!enc)
            return FALSE;
    }
    if (!(r->Link.protocol & RTMP_FEATURE_WRITE))
    bbf4:	e5943188 	ldr	r3, [r4, #392]	; 0x188
    bbf8:	e2133010 	ands	r3, r3, #16
    bbfc:	0a00005f 	beq	bd80 <SendConnectPacket+0x288>
            enc = AMF_EncodeNamedString(enc, pend, &av_pageUrl, &r->Link.pageUrl);
            if (!enc)
                return FALSE;
        }
    }
    if (r->m_fEncoding != 0.0 || r->m_bSendEncoding)
    bc00:	e1c686d8 	ldrd	r8, [r6, #104]	; 0x68
    bc04:	e3a02000 	mov	r2, #0
    bc08:	e3a03000 	mov	r3, #0
    bc0c:	e1a00008 	mov	r0, r8
    bc10:	e1a01009 	mov	r1, r9
    bc14:	eb0041f1 	bl	1c3e0 <__aeabi_dcmpeq>
    bc18:	e3500000 	cmp	r0, #0
    bc1c:	0a000023 	beq	bcb0 <SendConnectPacket+0x1b8>
    bc20:	e5d63036 	ldrb	r3, [r6, #54]	; 0x36
    bc24:	e3530000 	cmp	r3, #0
    bc28:	1a000020 	bne	bcb0 <SendConnectPacket+0x1b8>
    {	/* AMF0, AMF3 not fully supported yet */
        enc = AMF_EncodeNamedNumber(enc, pend, &av_objectEncoding, r->m_fEncoding);
        if (!enc)
            return FALSE;
    }
    if (enc + 3 >= pend)
    bc2c:	e28d3a01 	add	r3, sp, #4096	; 0x1000
    bc30:	e28a1003 	add	r1, sl, #3
    bc34:	e2833028 	add	r3, r3, #40	; 0x28
    bc38:	e1530001 	cmp	r3, r1
    bc3c:	9a000017 	bls	bca0 <SendConnectPacket+0x1a8>
        return FALSE;
    *enc++ = 0;
    bc40:	e3a03000 	mov	r3, #0
    *enc++ = 0;			/* end of object - 0x00 0x00 0x09 */
    *enc++ = AMF_OBJECT_END;
    bc44:	e3a02009 	mov	r2, #9
        if (!enc)
            return FALSE;
    }
    if (enc + 3 >= pend)
        return FALSE;
    *enc++ = 0;
    bc48:	e5ca3000 	strb	r3, [sl]
    *enc++ = 0;			/* end of object - 0x00 0x00 0x09 */
    bc4c:	e5ca3001 	strb	r3, [sl, #1]
    *enc++ = AMF_OBJECT_END;
    bc50:	e5ca2002 	strb	r2, [sl, #2]
    
    /* add auth string */
    if (r->Link.auth.av_len)
    bc54:	e5943138 	ldr	r3, [r4, #312]	; 0x138
    bc58:	e3530000 	cmp	r3, #0
    bc5c:	1a000085 	bne	be78 <SendConnectPacket+0x380>
            return FALSE;
    }
    if (r->Link.extras.o_num)
    {
        int i;
        for (i = 0; i < r->Link.extras.o_num; i++)
    bc60:	e594316c 	ldr	r3, [r4, #364]	; 0x16c
    bc64:	e3530000 	cmp	r3, #0
    bc68:	da00007a 	ble	be58 <SendConnectPacket+0x360>
    bc6c:	e3a05000 	mov	r5, #0
    bc70:	ea000002 	b	bc80 <SendConnectPacket+0x188>
    bc74:	e594316c 	ldr	r3, [r4, #364]	; 0x16c
    bc78:	e1530005 	cmp	r3, r5
    bc7c:	da000075 	ble	be58 <SendConnectPacket+0x360>
        {
            enc = AMFProp_Encode(&r->Link.extras.o_props[i], enc, pend);
    bc80:	e5940170 	ldr	r0, [r4, #368]	; 0x170
    bc84:	e28d2a01 	add	r2, sp, #4096	; 0x1000
    bc88:	e0800285 	add	r0, r0, r5, lsl #5
    bc8c:	e2822028 	add	r2, r2, #40	; 0x28
    bc90:	eb002a06 	bl	164b0 <AMFProp_Encode>
            return FALSE;
    }
    if (r->Link.extras.o_num)
    {
        int i;
        for (i = 0; i < r->Link.extras.o_num; i++)
    bc94:	e2855001 	add	r5, r5, #1
        {
            enc = AMFProp_Encode(&r->Link.extras.o_props[i], enc, pend);
            if (!enc)
    bc98:	e2501000 	subs	r1, r0, #0
    bc9c:	1afffff4 	bne	bc74 <SendConnectPacket+0x17c>
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    *enc++ = AMF_OBJECT;
    
    enc = AMF_EncodeNamedString(enc, pend, &av_app, &r->Link.app);
    if (!enc)
        return FALSE;
    bca0:	e3a00000 	mov	r0, #0
        }
    }
    packet.m_nBodySize = enc - packet.m_body;
    
    return RTMP_SendPacket(r, &packet, TRUE);
}
    bca4:	e28dda01 	add	sp, sp, #4096	; 0x1000
    bca8:	e28dd028 	add	sp, sp, #40	; 0x28
    bcac:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
                return FALSE;
        }
    }
    if (r->m_fEncoding != 0.0 || r->m_bSendEncoding)
    {	/* AMF0, AMF3 not fully supported yet */
        enc = AMF_EncodeNamedNumber(enc, pend, &av_objectEncoding, r->m_fEncoding);
    bcb0:	e59f2200 	ldr	r2, [pc, #512]	; beb8 <SendConnectPacket+0x3c0>
    bcb4:	e28d1a01 	add	r1, sp, #4096	; 0x1000
    bcb8:	e08f2002 	add	r2, pc, r2
    bcbc:	e1a0000a 	mov	r0, sl
    bcc0:	e1cd80f0 	strd	r8, [sp]
    bcc4:	e2822e2b 	add	r2, r2, #688	; 0x2b0
    bcc8:	e2811028 	add	r1, r1, #40	; 0x28
    bccc:	eb00292e 	bl	1618c <AMF_EncodeNamedNumber>
        if (!enc)
    bcd0:	e250a000 	subs	sl, r0, #0
    bcd4:	1affffd4 	bne	bc2c <SendConnectPacket+0x134>
    bcd8:	eafffff0 	b	bca0 <SendConnectPacket+0x1a8>
    enc = AMF_EncodeNamedString(enc, pend, &av_app, &r->Link.app);
    if (!enc)
        return FALSE;
    if (r->Link.protocol & RTMP_FEATURE_WRITE)
    {
        enc = AMF_EncodeNamedString(enc, pend, &av_type, &av_nonprivate);
    bcdc:	e28d1a01 	add	r1, sp, #4096	; 0x1000
    bce0:	e2811028 	add	r1, r1, #40	; 0x28
    bce4:	e2882f96 	add	r2, r8, #600	; 0x258
    bce8:	e2883e26 	add	r3, r8, #608	; 0x260
    bcec:	eb00290f 	bl	16130 <AMF_EncodeNamedString>
        if (!enc)
    bcf0:	e250a000 	subs	sl, r0, #0
    bcf4:	1affffb5 	bne	bbd0 <SendConnectPacket+0xd8>
    bcf8:	eaffffe8 	b	bca0 <SendConnectPacket+0x1a8>
            return FALSE;
    }
    if (r->Link.flashVer.av_len)
    {
        enc = AMF_EncodeNamedString(enc, pend, &av_flashVer, &r->Link.flashVer);
    bcfc:	e59f21b8 	ldr	r2, [pc, #440]	; bebc <SendConnectPacket+0x3c4>
    bd00:	e28d1a01 	add	r1, sp, #4096	; 0x1000
    bd04:	e08f2002 	add	r2, pc, r2
    bd08:	e1a0000a 	mov	r0, sl
    bd0c:	e2822f9a 	add	r2, r2, #616	; 0x268
    bd10:	e2811028 	add	r1, r1, #40	; 0x28
    bd14:	e285303c 	add	r3, r5, #60	; 0x3c
    bd18:	eb002904 	bl	16130 <AMF_EncodeNamedString>
        if (!enc)
    bd1c:	e250a000 	subs	sl, r0, #0
    bd20:	1affffad 	bne	bbdc <SendConnectPacket+0xe4>
    bd24:	eaffffdd 	b	bca0 <SendConnectPacket+0x1a8>
            return FALSE;
    }
    if (r->Link.swfUrl.av_len)
    {
        enc = AMF_EncodeNamedString(enc, pend, &av_swfUrl, &r->Link.swfUrl);
    bd28:	e59f2190 	ldr	r2, [pc, #400]	; bec0 <SendConnectPacket+0x3c8>
    bd2c:	e28d1a01 	add	r1, sp, #4096	; 0x1000
    bd30:	e08f2002 	add	r2, pc, r2
    bd34:	e1a0000a 	mov	r0, sl
    bd38:	e2822e27 	add	r2, r2, #624	; 0x270
    bd3c:	e2811028 	add	r1, r1, #40	; 0x28
    bd40:	e285301c 	add	r3, r5, #28
    bd44:	eb0028f9 	bl	16130 <AMF_EncodeNamedString>
        if (!enc)
    bd48:	e250a000 	subs	sl, r0, #0
    bd4c:	1affffa5 	bne	bbe8 <SendConnectPacket+0xf0>
    bd50:	eaffffd2 	b	bca0 <SendConnectPacket+0x1a8>
            return FALSE;
    }
    if (r->Link.tcUrl.av_len)
    {
        enc = AMF_EncodeNamedString(enc, pend, &av_tcUrl, &r->Link.tcUrl);
    bd54:	e59f2168 	ldr	r2, [pc, #360]	; bec4 <SendConnectPacket+0x3cc>
    bd58:	e28d1a01 	add	r1, sp, #4096	; 0x1000
    bd5c:	e08f2002 	add	r2, pc, r2
    bd60:	e1a0000a 	mov	r0, sl
    bd64:	e2822f9e 	add	r2, r2, #632	; 0x278
    bd68:	e2811028 	add	r1, r1, #40	; 0x28
    bd6c:	e2853014 	add	r3, r5, #20
    bd70:	eb0028ee 	bl	16130 <AMF_EncodeNamedString>
        if (!enc)
    bd74:	e250a000 	subs	sl, r0, #0
    bd78:	1affff9d 	bne	bbf4 <SendConnectPacket+0xfc>
    bd7c:	eaffffc7 	b	bca0 <SendConnectPacket+0x1a8>
            return FALSE;
    }
    if (!(r->Link.protocol & RTMP_FEATURE_WRITE))
    {
        enc = AMF_EncodeNamedBoolean(enc, pend, &av_fpad, FALSE);
    bd80:	e59f8140 	ldr	r8, [pc, #320]	; bec8 <SendConnectPacket+0x3d0>
    bd84:	e28d1a01 	add	r1, sp, #4096	; 0x1000
    bd88:	e08f8008 	add	r8, pc, r8
    bd8c:	e1a0000a 	mov	r0, sl
    bd90:	e2882d0a 	add	r2, r8, #640	; 0x280
    bd94:	e2811028 	add	r1, r1, #40	; 0x28
    bd98:	eb002913 	bl	161ec <AMF_EncodeNamedBoolean>
        if (!enc)
    bd9c:	e3500000 	cmp	r0, #0
    bda0:	0affffbe 	beq	bca0 <SendConnectPacket+0x1a8>
            return FALSE;
        enc = AMF_EncodeNamedNumber(enc, pend, &av_capabilities, 15.0);
    bda4:	e59f3120 	ldr	r3, [pc, #288]	; becc <SendConnectPacket+0x3d4>
    bda8:	e3a02000 	mov	r2, #0
    bdac:	e28d1a01 	add	r1, sp, #4096	; 0x1000
    bdb0:	e1cd20f0 	strd	r2, [sp]
    bdb4:	e2811028 	add	r1, r1, #40	; 0x28
    bdb8:	e2882fa2 	add	r2, r8, #648	; 0x288
    bdbc:	eb0028f2 	bl	1618c <AMF_EncodeNamedNumber>
        if (!enc)
    bdc0:	e3500000 	cmp	r0, #0
    bdc4:	0affffb5 	beq	bca0 <SendConnectPacket+0x1a8>
            return FALSE;
        enc = AMF_EncodeNamedNumber(enc, pend, &av_audioCodecs, r->m_fAudioCodecs);
    bdc8:	e1c625d8 	ldrd	r2, [r6, #88]	; 0x58
    bdcc:	e28d1a01 	add	r1, sp, #4096	; 0x1000
    bdd0:	e1cd20f0 	strd	r2, [sp]
    bdd4:	e2811028 	add	r1, r1, #40	; 0x28
    bdd8:	e2882e29 	add	r2, r8, #656	; 0x290
    bddc:	eb0028ea 	bl	1618c <AMF_EncodeNamedNumber>
        if (!enc)
    bde0:	e3500000 	cmp	r0, #0
    bde4:	0affffad 	beq	bca0 <SendConnectPacket+0x1a8>
            return FALSE;
        enc = AMF_EncodeNamedNumber(enc, pend, &av_videoCodecs, r->m_fVideoCodecs);
    bde8:	e1c626d0 	ldrd	r2, [r6, #96]	; 0x60
    bdec:	e28d1a01 	add	r1, sp, #4096	; 0x1000
    bdf0:	e1cd20f0 	strd	r2, [sp]
    bdf4:	e2811028 	add	r1, r1, #40	; 0x28
    bdf8:	e2882fa6 	add	r2, r8, #664	; 0x298
    bdfc:	eb0028e2 	bl	1618c <AMF_EncodeNamedNumber>
        if (!enc)
    be00:	e3500000 	cmp	r0, #0
    be04:	0affffa5 	beq	bca0 <SendConnectPacket+0x1a8>
            return FALSE;
        enc = AMF_EncodeNamedNumber(enc, pend, &av_videoFunction, 1.0);
    be08:	e59f30c0 	ldr	r3, [pc, #192]	; bed0 <SendConnectPacket+0x3d8>
    be0c:	e3a02000 	mov	r2, #0
    be10:	e28d1a01 	add	r1, sp, #4096	; 0x1000
    be14:	e1cd20f0 	strd	r2, [sp]
    be18:	e2811028 	add	r1, r1, #40	; 0x28
    be1c:	e2882e2a 	add	r2, r8, #672	; 0x2a0
    be20:	eb0028d9 	bl	1618c <AMF_EncodeNamedNumber>
        if (!enc)
    be24:	e250a000 	subs	sl, r0, #0
    be28:	0affff9c 	beq	bca0 <SendConnectPacket+0x1a8>
            return FALSE;
        if (r->Link.pageUrl.av_len)
    be2c:	e5943128 	ldr	r3, [r4, #296]	; 0x128
    be30:	e3530000 	cmp	r3, #0
    be34:	0affff71 	beq	bc00 <SendConnectPacket+0x108>
        {
            enc = AMF_EncodeNamedString(enc, pend, &av_pageUrl, &r->Link.pageUrl);
    be38:	e28d1a01 	add	r1, sp, #4096	; 0x1000
    be3c:	e2882faa 	add	r2, r8, #680	; 0x2a8
    be40:	e2811028 	add	r1, r1, #40	; 0x28
    be44:	e2853024 	add	r3, r5, #36	; 0x24
    be48:	eb0028b8 	bl	16130 <AMF_EncodeNamedString>
            if (!enc)
    be4c:	e250a000 	subs	sl, r0, #0
    be50:	1affff6a 	bne	bc00 <SendConnectPacket+0x108>
    be54:	eaffff91 	b	bca0 <SendConnectPacket+0x1a8>
            enc = AMFProp_Encode(&r->Link.extras.o_props[i], enc, pend);
            if (!enc)
                return FALSE;
        }
    }
    packet.m_nBodySize = enc - packet.m_body;
    be58:	e5173004 	ldr	r3, [r7, #-4]
    
    return RTMP_SendPacket(r, &packet, TRUE);
    be5c:	e1a00006 	mov	r0, r6
            enc = AMFProp_Encode(&r->Link.extras.o_props[i], enc, pend);
            if (!enc)
                return FALSE;
        }
    }
    packet.m_nBodySize = enc - packet.m_body;
    be60:	e0633001 	rsb	r3, r3, r1
    
    return RTMP_SendPacket(r, &packet, TRUE);
    be64:	e3a02001 	mov	r2, #1
    be68:	e2471020 	sub	r1, r7, #32
            enc = AMFProp_Encode(&r->Link.extras.o_props[i], enc, pend);
            if (!enc)
                return FALSE;
        }
    }
    packet.m_nBodySize = enc - packet.m_body;
    be6c:	e5073010 	str	r3, [r7, #-16]
    
    return RTMP_SendPacket(r, &packet, TRUE);
    be70:	ebfffd61 	bl	b3fc <RTMP_SendPacket>
    be74:	eaffff26 	b	bb14 <SendConnectPacket+0x1c>
    *enc++ = AMF_OBJECT_END;
    
    /* add auth string */
    if (r->Link.auth.av_len)
    {
        enc = AMF_EncodeBoolean(enc, pend, r->Link.lFlags & RTMP_LF_AUTH);
    be78:	e5942180 	ldr	r2, [r4, #384]	; 0x180
    be7c:	e1a00001 	mov	r0, r1
    be80:	e28d1a01 	add	r1, sp, #4096	; 0x1000
    be84:	e2022001 	and	r2, r2, #1
    be88:	e2811028 	add	r1, r1, #40	; 0x28
    be8c:	eb00289a 	bl	160fc <AMF_EncodeBoolean>
        if (!enc)
    be90:	e3500000 	cmp	r0, #0
    be94:	0affff81 	beq	bca0 <SendConnectPacket+0x1a8>
            return FALSE;
        enc = AMF_EncodeString(enc, pend, &r->Link.auth);
    be98:	e28d1a01 	add	r1, sp, #4096	; 0x1000
    be9c:	e2811028 	add	r1, r1, #40	; 0x28
    bea0:	e2852034 	add	r2, r5, #52	; 0x34
    bea4:	eb00284f 	bl	15fe8 <AMF_EncodeString>
        if (!enc)
    bea8:	e2501000 	subs	r1, r0, #0
    beac:	1affff6b 	bne	bc60 <SendConnectPacket+0x168>
    beb0:	eaffff7a 	b	bca0 <SendConnectPacket+0x1a8>
    beb4:	00017d1c 	.word	0x00017d1c
    beb8:	00017b90 	.word	0x00017b90
    bebc:	00017b44 	.word	0x00017b44
    bec0:	00017b18 	.word	0x00017b18
    bec4:	00017aec 	.word	0x00017aec
    bec8:	00017ac0 	.word	0x00017ac0
    becc:	402e0000 	.word	0x402e0000
    bed0:	3ff00000 	.word	0x3ff00000

0000bed4 <SendDeleteStream>:
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_deleteStream);
    bed4:	e59f10bc 	ldr	r1, [pc, #188]	; bf98 <SendDeleteStream+0xc4>

SAVC(deleteStream);

static int
SendDeleteStream(RTMP *r, double dStreamId)
{
    bed8:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    bedc:	e24dde12 	sub	sp, sp, #288	; 0x120
    bee0:	e1a07003 	mov	r7, r3
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_deleteStream);
    bee4:	e08f1001 	add	r1, pc, r1
    bee8:	e28d3032 	add	r3, sp, #50	; 0x32
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    beec:	e3a0e001 	mov	lr, #1
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    bef0:	e3a0c014 	mov	ip, #20

SAVC(deleteStream);

static int
SendDeleteStream(RTMP *r, double dStreamId)
{
    bef4:	e1a05000 	mov	r5, r0
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    bef8:	e3a04000 	mov	r4, #0

SAVC(deleteStream);

static int
SendDeleteStream(RTMP *r, double dStreamId)
{
    befc:	e1a06002 	mov	r6, r2
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_deleteStream);
    bf00:	e1a00003 	mov	r0, r3
    bf04:	e2812fae 	add	r2, r1, #696	; 0x2b8
{
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    bf08:	e3a08003 	mov	r8, #3
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_deleteStream);
    bf0c:	e28d1e12 	add	r1, sp, #288	; 0x120
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    bf10:	e5cde000 	strb	lr, [sp]
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    bf14:	e5cdc001 	strb	ip, [sp, #1]
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    bf18:	e58d301c 	str	r3, [sp, #28]
{
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    bf1c:	e58d8004 	str	r8, [sp, #4]
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    bf20:	e58d4008 	str	r4, [sp, #8]
    packet.m_nInfoField2 = 0;
    bf24:	e58d400c 	str	r4, [sp, #12]
    packet.m_hasAbsTimestamp = 0;
    bf28:	e5cd4002 	strb	r4, [sp, #2]
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_deleteStream);
    bf2c:	eb00282d 	bl	15fe8 <AMF_EncodeString>
    bf30:	e1a08000 	mov	r8, r0
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    bf34:	e5950038 	ldr	r0, [r5, #56]	; 0x38
    bf38:	e2800001 	add	r0, r0, #1
    bf3c:	e5850038 	str	r0, [r5, #56]	; 0x38
    bf40:	eb003fa1 	bl	1bdcc <__aeabi_i2d>
    bf44:	e1a02000 	mov	r2, r0
    bf48:	e1a03001 	mov	r3, r1
    bf4c:	e1a00008 	mov	r0, r8
    bf50:	e28d1e12 	add	r1, sp, #288	; 0x120
    bf54:	eb00284a 	bl	16084 <AMF_EncodeNumber>
    *enc++ = AMF_NULL;
    bf58:	e3a01005 	mov	r1, #5
    enc = AMF_EncodeNumber(enc, pend, dStreamId);
    bf5c:	e1a02006 	mov	r2, r6
    bf60:	e1a03007 	mov	r3, r7
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_deleteStream);
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    *enc++ = AMF_NULL;
    bf64:	e5c01000 	strb	r1, [r0]
    enc = AMF_EncodeNumber(enc, pend, dStreamId);
    bf68:	e28d1e12 	add	r1, sp, #288	; 0x120
    bf6c:	e2800001 	add	r0, r0, #1
    bf70:	eb002843 	bl	16084 <AMF_EncodeNumber>
    
    packet.m_nBodySize = enc - packet.m_body;
    bf74:	e59d301c 	ldr	r3, [sp, #28]
    
    /* no response expected */
    return RTMP_SendPacket(r, &packet, FALSE);
    bf78:	e1a02004 	mov	r2, r4
    bf7c:	e1a0100d 	mov	r1, sp
    enc = AMF_EncodeString(enc, pend, &av_deleteStream);
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    *enc++ = AMF_NULL;
    enc = AMF_EncodeNumber(enc, pend, dStreamId);
    
    packet.m_nBodySize = enc - packet.m_body;
    bf80:	e0633000 	rsb	r3, r3, r0
    
    /* no response expected */
    return RTMP_SendPacket(r, &packet, FALSE);
    bf84:	e1a00005 	mov	r0, r5
    enc = AMF_EncodeString(enc, pend, &av_deleteStream);
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    *enc++ = AMF_NULL;
    enc = AMF_EncodeNumber(enc, pend, dStreamId);
    
    packet.m_nBodySize = enc - packet.m_body;
    bf88:	e58d3010 	str	r3, [sp, #16]
    
    /* no response expected */
    return RTMP_SendPacket(r, &packet, FALSE);
    bf8c:	ebfffd1a 	bl	b3fc <RTMP_SendPacket>
}
    bf90:	e28dde12 	add	sp, sp, #288	; 0x120
    bf94:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    bf98:	00017964 	.word	0x00017964

0000bf9c <RTMP_DeleteStream>:
}

void
RTMP_DeleteStream(RTMP *r)
{
    if (r->m_stream_id < 0)
    bf9c:	e5903018 	ldr	r3, [r0, #24]
    bfa0:	e3530000 	cmp	r3, #0
    bfa4:	b12fff1e 	bxlt	lr
    return res;
}

void
RTMP_DeleteStream(RTMP *r)
{
    bfa8:	e92d4010 	push	{r4, lr}
    if (r->m_stream_id < 0)
        return;
    
    r->m_bPlaying = FALSE;
    bfac:	e3a02000 	mov	r2, #0
    bfb0:	e1a04000 	mov	r4, r0
    bfb4:	e5c42035 	strb	r2, [r4, #53]	; 0x35
    
    SendDeleteStream(r, r->m_stream_id);
    bfb8:	e1a00003 	mov	r0, r3
    bfbc:	eb003f82 	bl	1bdcc <__aeabi_i2d>
    bfc0:	e1a02000 	mov	r2, r0
    bfc4:	e1a03001 	mov	r3, r1
    bfc8:	e1a00004 	mov	r0, r4
    bfcc:	ebffffc0 	bl	bed4 <SendDeleteStream>
    r->m_stream_id = -1;
    bfd0:	e3e03000 	mvn	r3, #0
    bfd4:	e5843018 	str	r3, [r4, #24]
    bfd8:	e8bd8010 	pop	{r4, pc}

0000bfdc <SendSecureTokenResponse>:
    return RTMP_SendPacket(r, &packet, TRUE);
}

static int
SendSecureTokenResponse(RTMP *r, AVal *resp)
{
    bfdc:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_secureTokenResponse);
    bfe0:	e59f20ac 	ldr	r2, [pc, #172]	; c094 <SendSecureTokenResponse+0xb8>
    return RTMP_SendPacket(r, &packet, TRUE);
}

static int
SendSecureTokenResponse(RTMP *r, AVal *resp)
{
    bfe4:	e24dde42 	sub	sp, sp, #1056	; 0x420
    bfe8:	e24dd004 	sub	sp, sp, #4
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    bfec:	e28d3032 	add	r3, sp, #50	; 0x32
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_secureTokenResponse);
    bff0:	e08f2002 	add	r2, pc, r2
    RTMPPacket packet;
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    bff4:	e3a0e001 	mov	lr, #1
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    bff8:	e3a0c014 	mov	ip, #20
    packet.m_nTimeStamp = 0;
    bffc:	e3a04000 	mov	r4, #0
    return RTMP_SendPacket(r, &packet, TRUE);
}

static int
SendSecureTokenResponse(RTMP *r, AVal *resp)
{
    c000:	e1a06001 	mov	r6, r1
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_secureTokenResponse);
    c004:	e2822d0b 	add	r2, r2, #704	; 0x2c0
    c008:	e28d1e42 	add	r1, sp, #1056	; 0x420
    return RTMP_SendPacket(r, &packet, TRUE);
}

static int
SendSecureTokenResponse(RTMP *r, AVal *resp)
{
    c00c:	e1a05000 	mov	r5, r0
    RTMPPacket packet;
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    c010:	e3a07003 	mov	r7, #3
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_secureTokenResponse);
    c014:	e1a00003 	mov	r0, r3
    RTMPPacket packet;
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    c018:	e5cde000 	strb	lr, [sp]
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    c01c:	e5cdc001 	strb	ip, [sp, #1]
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    c020:	e58d301c 	str	r3, [sp, #28]
{
    RTMPPacket packet;
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    c024:	e58d7004 	str	r7, [sp, #4]
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    c028:	e58d4008 	str	r4, [sp, #8]
    packet.m_nInfoField2 = 0;
    c02c:	e58d400c 	str	r4, [sp, #12]
    packet.m_hasAbsTimestamp = 0;
    c030:	e5cd4002 	strb	r4, [sp, #2]
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_secureTokenResponse);
    c034:	eb0027eb 	bl	15fe8 <AMF_EncodeString>
    enc = AMF_EncodeNumber(enc, pend, 0.0);
    c038:	e28d1e42 	add	r1, sp, #1056	; 0x420
    c03c:	e3a02000 	mov	r2, #0
    c040:	e3a03000 	mov	r3, #0
    c044:	eb00280e 	bl	16084 <AMF_EncodeNumber>
    *enc++ = AMF_NULL;
    c048:	e3a03005 	mov	r3, #5
    enc = AMF_EncodeString(enc, pend, resp);
    c04c:	e1a02006 	mov	r2, r6
    c050:	e28d1e42 	add	r1, sp, #1056	; 0x420
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_secureTokenResponse);
    enc = AMF_EncodeNumber(enc, pend, 0.0);
    *enc++ = AMF_NULL;
    c054:	e5c03000 	strb	r3, [r0]
    enc = AMF_EncodeString(enc, pend, resp);
    c058:	e2800001 	add	r0, r0, #1
    c05c:	eb0027e1 	bl	15fe8 <AMF_EncodeString>
    if (!enc)
    c060:	e2503000 	subs	r3, r0, #0
        return FALSE;
    c064:	01a00003 	moveq	r0, r3
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_secureTokenResponse);
    enc = AMF_EncodeNumber(enc, pend, 0.0);
    *enc++ = AMF_NULL;
    enc = AMF_EncodeString(enc, pend, resp);
    if (!enc)
    c068:	0a000006 	beq	c088 <SendSecureTokenResponse+0xac>
        return FALSE;
    
    packet.m_nBodySize = enc - packet.m_body;
    c06c:	e59d101c 	ldr	r1, [sp, #28]
    
    return RTMP_SendPacket(r, &packet, FALSE);
    c070:	e1a00005 	mov	r0, r5
    *enc++ = AMF_NULL;
    enc = AMF_EncodeString(enc, pend, resp);
    if (!enc)
        return FALSE;
    
    packet.m_nBodySize = enc - packet.m_body;
    c074:	e0613003 	rsb	r3, r1, r3
    
    return RTMP_SendPacket(r, &packet, FALSE);
    c078:	e1a02004 	mov	r2, r4
    c07c:	e1a0100d 	mov	r1, sp
    *enc++ = AMF_NULL;
    enc = AMF_EncodeString(enc, pend, resp);
    if (!enc)
        return FALSE;
    
    packet.m_nBodySize = enc - packet.m_body;
    c080:	e58d3010 	str	r3, [sp, #16]
    
    return RTMP_SendPacket(r, &packet, FALSE);
    c084:	ebfffcdc 	bl	b3fc <RTMP_SendPacket>
}
    c088:	e28dde42 	add	sp, sp, #1056	; 0x420
    c08c:	e28dd004 	add	sp, sp, #4
    c090:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    c094:	00017858 	.word	0x00017858

0000c098 <SendReleaseStream>:
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_releaseStream);
    c098:	e59f20c0 	ldr	r2, [pc, #192]	; c160 <SendReleaseStream+0xc8>

SAVC(releaseStream);

static int
SendReleaseStream(RTMP *r)
{
    c09c:	e92d4070 	push	{r4, r5, r6, lr}
    c0a0:	e24dde42 	sub	sp, sp, #1056	; 0x420
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    c0a4:	e28d3032 	add	r3, sp, #50	; 0x32
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_releaseStream);
    c0a8:	e08f2002 	add	r2, pc, r2
    RTMPPacket packet;
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    c0ac:	e3a0e001 	mov	lr, #1
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    c0b0:	e3a0c014 	mov	ip, #20

SAVC(releaseStream);

static int
SendReleaseStream(RTMP *r)
{
    c0b4:	e1a05000 	mov	r5, r0
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_releaseStream);
    c0b8:	e2822fb2 	add	r2, r2, #712	; 0x2c8
    c0bc:	e1a00003 	mov	r0, r3
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    c0c0:	e3a04000 	mov	r4, #0
{
    RTMPPacket packet;
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    c0c4:	e3a06003 	mov	r6, #3
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_releaseStream);
    c0c8:	e28d1e42 	add	r1, sp, #1056	; 0x420
    RTMPPacket packet;
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    c0cc:	e5cde000 	strb	lr, [sp]
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    c0d0:	e5cdc001 	strb	ip, [sp, #1]
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    c0d4:	e58d301c 	str	r3, [sp, #28]
{
    RTMPPacket packet;
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    c0d8:	e58d6004 	str	r6, [sp, #4]
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    c0dc:	e58d4008 	str	r4, [sp, #8]
    packet.m_nInfoField2 = 0;
    c0e0:	e58d400c 	str	r4, [sp, #12]
    packet.m_hasAbsTimestamp = 0;
    c0e4:	e5cd4002 	strb	r4, [sp, #2]
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_releaseStream);
    c0e8:	eb0027be 	bl	15fe8 <AMF_EncodeString>
    c0ec:	e1a06000 	mov	r6, r0
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    c0f0:	e5950038 	ldr	r0, [r5, #56]	; 0x38
    c0f4:	e2800001 	add	r0, r0, #1
    c0f8:	e5850038 	str	r0, [r5, #56]	; 0x38
    c0fc:	eb003f32 	bl	1bdcc <__aeabi_i2d>
    c100:	e1a02000 	mov	r2, r0
    c104:	e1a03001 	mov	r3, r1
    c108:	e1a00006 	mov	r0, r6
    c10c:	e28d1e42 	add	r1, sp, #1056	; 0x420
    c110:	eb0027db 	bl	16084 <AMF_EncodeNumber>
    *enc++ = AMF_NULL;
    c114:	e3a03005 	mov	r3, #5
    enc = AMF_EncodeString(enc, pend, &r->Link.playpath);
    c118:	e2852c41 	add	r2, r5, #16640	; 0x4100
    c11c:	e282200c 	add	r2, r2, #12
    c120:	e28d1e42 	add	r1, sp, #1056	; 0x420
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_releaseStream);
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    *enc++ = AMF_NULL;
    c124:	e5c03000 	strb	r3, [r0]
    enc = AMF_EncodeString(enc, pend, &r->Link.playpath);
    c128:	e2800001 	add	r0, r0, #1
    c12c:	eb0027ad 	bl	15fe8 <AMF_EncodeString>
    if (!enc)
    c130:	e2503000 	subs	r3, r0, #0
        return FALSE;
    c134:	01a00003 	moveq	r0, r3
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_releaseStream);
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    *enc++ = AMF_NULL;
    enc = AMF_EncodeString(enc, pend, &r->Link.playpath);
    if (!enc)
    c138:	0a000006 	beq	c158 <SendReleaseStream+0xc0>
        return FALSE;
    
    packet.m_nBodySize = enc - packet.m_body;
    c13c:	e59d101c 	ldr	r1, [sp, #28]
    
    return RTMP_SendPacket(r, &packet, FALSE);
    c140:	e1a00005 	mov	r0, r5
    *enc++ = AMF_NULL;
    enc = AMF_EncodeString(enc, pend, &r->Link.playpath);
    if (!enc)
        return FALSE;
    
    packet.m_nBodySize = enc - packet.m_body;
    c144:	e0613003 	rsb	r3, r1, r3
    
    return RTMP_SendPacket(r, &packet, FALSE);
    c148:	e1a02004 	mov	r2, r4
    c14c:	e1a0100d 	mov	r1, sp
    *enc++ = AMF_NULL;
    enc = AMF_EncodeString(enc, pend, &r->Link.playpath);
    if (!enc)
        return FALSE;
    
    packet.m_nBodySize = enc - packet.m_body;
    c150:	e58d3010 	str	r3, [sp, #16]
    
    return RTMP_SendPacket(r, &packet, FALSE);
    c154:	ebfffca8 	bl	b3fc <RTMP_SendPacket>
}
    c158:	e28dde42 	add	sp, sp, #1056	; 0x420
    c15c:	e8bd8070 	pop	{r4, r5, r6, pc}
    c160:	000177a0 	.word	0x000177a0

0000c164 <SendFCPublish>:
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_FCPublish);
    c164:	e59f20c0 	ldr	r2, [pc, #192]	; c22c <SendFCPublish+0xc8>

SAVC(FCPublish);

static int
SendFCPublish(RTMP *r)
{
    c168:	e92d4070 	push	{r4, r5, r6, lr}
    c16c:	e24dde42 	sub	sp, sp, #1056	; 0x420
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    c170:	e28d3032 	add	r3, sp, #50	; 0x32
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_FCPublish);
    c174:	e08f2002 	add	r2, pc, r2
    RTMPPacket packet;
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    c178:	e3a0e001 	mov	lr, #1
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    c17c:	e3a0c014 	mov	ip, #20

SAVC(FCPublish);

static int
SendFCPublish(RTMP *r)
{
    c180:	e1a05000 	mov	r5, r0
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_FCPublish);
    c184:	e2822e2d 	add	r2, r2, #720	; 0x2d0
    c188:	e1a00003 	mov	r0, r3
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    c18c:	e3a04000 	mov	r4, #0
{
    RTMPPacket packet;
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    c190:	e3a06003 	mov	r6, #3
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_FCPublish);
    c194:	e28d1e42 	add	r1, sp, #1056	; 0x420
    RTMPPacket packet;
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    c198:	e5cde000 	strb	lr, [sp]
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    c19c:	e5cdc001 	strb	ip, [sp, #1]
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    c1a0:	e58d301c 	str	r3, [sp, #28]
{
    RTMPPacket packet;
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    c1a4:	e58d6004 	str	r6, [sp, #4]
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    c1a8:	e58d4008 	str	r4, [sp, #8]
    packet.m_nInfoField2 = 0;
    c1ac:	e58d400c 	str	r4, [sp, #12]
    packet.m_hasAbsTimestamp = 0;
    c1b0:	e5cd4002 	strb	r4, [sp, #2]
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_FCPublish);
    c1b4:	eb00278b 	bl	15fe8 <AMF_EncodeString>
    c1b8:	e1a06000 	mov	r6, r0
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    c1bc:	e5950038 	ldr	r0, [r5, #56]	; 0x38
    c1c0:	e2800001 	add	r0, r0, #1
    c1c4:	e5850038 	str	r0, [r5, #56]	; 0x38
    c1c8:	eb003eff 	bl	1bdcc <__aeabi_i2d>
    c1cc:	e1a02000 	mov	r2, r0
    c1d0:	e1a03001 	mov	r3, r1
    c1d4:	e1a00006 	mov	r0, r6
    c1d8:	e28d1e42 	add	r1, sp, #1056	; 0x420
    c1dc:	eb0027a8 	bl	16084 <AMF_EncodeNumber>
    *enc++ = AMF_NULL;
    c1e0:	e3a03005 	mov	r3, #5
    enc = AMF_EncodeString(enc, pend, &r->Link.playpath);
    c1e4:	e2852c41 	add	r2, r5, #16640	; 0x4100
    c1e8:	e282200c 	add	r2, r2, #12
    c1ec:	e28d1e42 	add	r1, sp, #1056	; 0x420
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_FCPublish);
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    *enc++ = AMF_NULL;
    c1f0:	e5c03000 	strb	r3, [r0]
    enc = AMF_EncodeString(enc, pend, &r->Link.playpath);
    c1f4:	e2800001 	add	r0, r0, #1
    c1f8:	eb00277a 	bl	15fe8 <AMF_EncodeString>
    if (!enc)
    c1fc:	e2503000 	subs	r3, r0, #0
        return FALSE;
    c200:	01a00003 	moveq	r0, r3
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_FCPublish);
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    *enc++ = AMF_NULL;
    enc = AMF_EncodeString(enc, pend, &r->Link.playpath);
    if (!enc)
    c204:	0a000006 	beq	c224 <SendFCPublish+0xc0>
        return FALSE;
    
    packet.m_nBodySize = enc - packet.m_body;
    c208:	e59d101c 	ldr	r1, [sp, #28]
    
    return RTMP_SendPacket(r, &packet, FALSE);
    c20c:	e1a00005 	mov	r0, r5
    *enc++ = AMF_NULL;
    enc = AMF_EncodeString(enc, pend, &r->Link.playpath);
    if (!enc)
        return FALSE;
    
    packet.m_nBodySize = enc - packet.m_body;
    c210:	e0613003 	rsb	r3, r1, r3
    
    return RTMP_SendPacket(r, &packet, FALSE);
    c214:	e1a02004 	mov	r2, r4
    c218:	e1a0100d 	mov	r1, sp
    *enc++ = AMF_NULL;
    enc = AMF_EncodeString(enc, pend, &r->Link.playpath);
    if (!enc)
        return FALSE;
    
    packet.m_nBodySize = enc - packet.m_body;
    c21c:	e58d3010 	str	r3, [sp, #16]
    
    return RTMP_SendPacket(r, &packet, FALSE);
    c220:	ebfffc75 	bl	b3fc <RTMP_SendPacket>
}
    c224:	e28dde42 	add	sp, sp, #1056	; 0x420
    c228:	e8bd8070 	pop	{r4, r5, r6, pc}
    c22c:	000176d4 	.word	0x000176d4

0000c230 <SendUsherToken>:
/* Justin.tv specific authentication */
static const AVal av_NetStream_Authenticate_UsherToken = AVC("NetStream.Authenticate.UsherToken");

static int
SendUsherToken(RTMP *r, AVal *usherToken)
{
    c230:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    RTMP_Log(RTMP_LOGDEBUG, "UsherToken: %s", usherToken->av_val);
    c234:	e5912000 	ldr	r2, [r1]
/* Justin.tv specific authentication */
static const AVal av_NetStream_Authenticate_UsherToken = AVC("NetStream.Authenticate.UsherToken");

static int
SendUsherToken(RTMP *r, AVal *usherToken)
{
    c238:	e1a06001 	mov	r6, r1
    c23c:	e24dde42 	sub	sp, sp, #1056	; 0x420
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    RTMP_Log(RTMP_LOGDEBUG, "UsherToken: %s", usherToken->av_val);
    c240:	e59f10cc 	ldr	r1, [pc, #204]	; c314 <SendUsherToken+0xe4>
/* Justin.tv specific authentication */
static const AVal av_NetStream_Authenticate_UsherToken = AVC("NetStream.Authenticate.UsherToken");

static int
SendUsherToken(RTMP *r, AVal *usherToken)
{
    c244:	e24dd004 	sub	sp, sp, #4
    RTMPPacket packet;
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    c248:	e3a0e001 	mov	lr, #1
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    c24c:	e3a0c014 	mov	ip, #20
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    c250:	e28d3032 	add	r3, sp, #50	; 0x32
/* Justin.tv specific authentication */
static const AVal av_NetStream_Authenticate_UsherToken = AVC("NetStream.Authenticate.UsherToken");

static int
SendUsherToken(RTMP *r, AVal *usherToken)
{
    c254:	e1a05000 	mov	r5, r0
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    c258:	e3a04000 	mov	r4, #0
SendUsherToken(RTMP *r, AVal *usherToken)
{
    RTMPPacket packet;
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    c25c:	e3a07003 	mov	r7, #3
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    RTMP_Log(RTMP_LOGDEBUG, "UsherToken: %s", usherToken->av_val);
    c260:	e3a00004 	mov	r0, #4
    c264:	e08f1001 	add	r1, pc, r1
{
    RTMPPacket packet;
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    c268:	e5cde000 	strb	lr, [sp]
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    c26c:	e5cdc001 	strb	ip, [sp, #1]
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    c270:	e58d301c 	str	r3, [sp, #28]
SendUsherToken(RTMP *r, AVal *usherToken)
{
    RTMPPacket packet;
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    c274:	e58d7004 	str	r7, [sp, #4]
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    c278:	e58d4008 	str	r4, [sp, #8]
    packet.m_nInfoField2 = 0;
    c27c:	e58d400c 	str	r4, [sp, #12]
    packet.m_hasAbsTimestamp = 0;
    c280:	e5cd4002 	strb	r4, [sp, #2]
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    RTMP_Log(RTMP_LOGDEBUG, "UsherToken: %s", usherToken->av_val);
    c284:	eb0025c8 	bl	159ac <RTMP_Log>
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_NetStream_Authenticate_UsherToken);
    c288:	e59f2088 	ldr	r2, [pc, #136]	; c318 <SendUsherToken+0xe8>
    c28c:	e28d1e42 	add	r1, sp, #1056	; 0x420
    c290:	e08f2002 	add	r2, pc, r2
    c294:	e2822fb6 	add	r2, r2, #728	; 0x2d8
    c298:	e59d001c 	ldr	r0, [sp, #28]
    c29c:	eb002751 	bl	15fe8 <AMF_EncodeString>
    c2a0:	e1a07000 	mov	r7, r0
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    c2a4:	e5950038 	ldr	r0, [r5, #56]	; 0x38
    c2a8:	e2800001 	add	r0, r0, #1
    c2ac:	e5850038 	str	r0, [r5, #56]	; 0x38
    c2b0:	eb003ec5 	bl	1bdcc <__aeabi_i2d>
    c2b4:	e1a02000 	mov	r2, r0
    c2b8:	e1a03001 	mov	r3, r1
    c2bc:	e1a00007 	mov	r0, r7
    c2c0:	e28d1e42 	add	r1, sp, #1056	; 0x420
    c2c4:	eb00276e 	bl	16084 <AMF_EncodeNumber>
    *enc++ = AMF_NULL;
    c2c8:	e3a03005 	mov	r3, #5
    enc = AMF_EncodeString(enc, pend, usherToken);
    c2cc:	e1a02006 	mov	r2, r6
    c2d0:	e28d1e42 	add	r1, sp, #1056	; 0x420
    
    RTMP_Log(RTMP_LOGDEBUG, "UsherToken: %s", usherToken->av_val);
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_NetStream_Authenticate_UsherToken);
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    *enc++ = AMF_NULL;
    c2d4:	e5c03000 	strb	r3, [r0]
    enc = AMF_EncodeString(enc, pend, usherToken);
    c2d8:	e2800001 	add	r0, r0, #1
    c2dc:	eb002741 	bl	15fe8 <AMF_EncodeString>
    
    if (!enc)
    c2e0:	e2503000 	subs	r3, r0, #0
        return FALSE;
    c2e4:	01a00003 	moveq	r0, r3
    enc = AMF_EncodeString(enc, pend, &av_NetStream_Authenticate_UsherToken);
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    *enc++ = AMF_NULL;
    enc = AMF_EncodeString(enc, pend, usherToken);
    
    if (!enc)
    c2e8:	0a000006 	beq	c308 <SendUsherToken+0xd8>
        return FALSE;
    
    packet.m_nBodySize = enc - packet.m_body;
    c2ec:	e59d101c 	ldr	r1, [sp, #28]
    
    return RTMP_SendPacket(r, &packet, FALSE);
    c2f0:	e1a00005 	mov	r0, r5
    enc = AMF_EncodeString(enc, pend, usherToken);
    
    if (!enc)
        return FALSE;
    
    packet.m_nBodySize = enc - packet.m_body;
    c2f4:	e0613003 	rsb	r3, r1, r3
    
    return RTMP_SendPacket(r, &packet, FALSE);
    c2f8:	e1a02004 	mov	r2, r4
    c2fc:	e1a0100d 	mov	r1, sp
    enc = AMF_EncodeString(enc, pend, usherToken);
    
    if (!enc)
        return FALSE;
    
    packet.m_nBodySize = enc - packet.m_body;
    c300:	e58d3010 	str	r3, [sp, #16]
    
    return RTMP_SendPacket(r, &packet, FALSE);
    c304:	ebfffc3c 	bl	b3fc <RTMP_SendPacket>
}
    c308:	e28dde42 	add	sp, sp, #1056	; 0x420
    c30c:	e28dd004 	add	sp, sp, #4
    c310:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    c314:	00012dc0 	.word	0x00012dc0
    c318:	000175b8 	.word	0x000175b8

0000c31c <SendFCSubscribe>:

SAVC(FCSubscribe);

static int
SendFCSubscribe(RTMP *r, AVal *subscribepath)
{
    c31c:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    RTMP_Log(RTMP_LOGDEBUG, "FCSubscribe: %s", subscribepath->av_val);
    c320:	e5912000 	ldr	r2, [r1]

SAVC(FCSubscribe);

static int
SendFCSubscribe(RTMP *r, AVal *subscribepath)
{
    c324:	e1a05001 	mov	r5, r1
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    RTMP_Log(RTMP_LOGDEBUG, "FCSubscribe: %s", subscribepath->av_val);
    c328:	e59f10c8 	ldr	r1, [pc, #200]	; c3f8 <SendFCSubscribe+0xdc>

SAVC(FCSubscribe);

static int
SendFCSubscribe(RTMP *r, AVal *subscribepath)
{
    c32c:	e24ddf89 	sub	sp, sp, #548	; 0x224
    char pbuf[512], *pend = pbuf + sizeof(pbuf);
    char *enc;
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    c330:	e3a0c000 	mov	ip, #0
    RTMPPacket packet;
    char pbuf[512], *pend = pbuf + sizeof(pbuf);
    char *enc;
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    c334:	e3a0e014 	mov	lr, #20
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    c338:	e28d3032 	add	r3, sp, #50	; 0x32

SAVC(FCSubscribe);

static int
SendFCSubscribe(RTMP *r, AVal *subscribepath)
{
    c33c:	e1a04000 	mov	r4, r0
    RTMPPacket packet;
    char pbuf[512], *pend = pbuf + sizeof(pbuf);
    char *enc;
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    c340:	e3a06001 	mov	r6, #1
SendFCSubscribe(RTMP *r, AVal *subscribepath)
{
    RTMPPacket packet;
    char pbuf[512], *pend = pbuf + sizeof(pbuf);
    char *enc;
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    c344:	e3a07003 	mov	r7, #3
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    RTMP_Log(RTMP_LOGDEBUG, "FCSubscribe: %s", subscribepath->av_val);
    c348:	e3a00004 	mov	r0, #4
    c34c:	e08f1001 	add	r1, pc, r1
    RTMPPacket packet;
    char pbuf[512], *pend = pbuf + sizeof(pbuf);
    char *enc;
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    c350:	e5cde001 	strb	lr, [sp, #1]
    packet.m_nTimeStamp = 0;
    c354:	e58dc008 	str	ip, [sp, #8]
    packet.m_nInfoField2 = 0;
    c358:	e58dc00c 	str	ip, [sp, #12]
    packet.m_hasAbsTimestamp = 0;
    c35c:	e5cdc002 	strb	ip, [sp, #2]
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    c360:	e58d301c 	str	r3, [sp, #28]
SendFCSubscribe(RTMP *r, AVal *subscribepath)
{
    RTMPPacket packet;
    char pbuf[512], *pend = pbuf + sizeof(pbuf);
    char *enc;
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    c364:	e58d7004 	str	r7, [sp, #4]
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    c368:	e5cd6000 	strb	r6, [sp]
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    RTMP_Log(RTMP_LOGDEBUG, "FCSubscribe: %s", subscribepath->av_val);
    c36c:	eb00258e 	bl	159ac <RTMP_Log>
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_FCSubscribe);
    c370:	e59f2084 	ldr	r2, [pc, #132]	; c3fc <SendFCSubscribe+0xe0>
    c374:	e28d1e22 	add	r1, sp, #544	; 0x220
    c378:	e08f2002 	add	r2, pc, r2
    c37c:	e2822e2e 	add	r2, r2, #736	; 0x2e0
    c380:	e59d001c 	ldr	r0, [sp, #28]
    c384:	eb002717 	bl	15fe8 <AMF_EncodeString>
    c388:	e1a07000 	mov	r7, r0
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    c38c:	e5940038 	ldr	r0, [r4, #56]	; 0x38
    c390:	e0800006 	add	r0, r0, r6
    c394:	e5840038 	str	r0, [r4, #56]	; 0x38
    c398:	eb003e8b 	bl	1bdcc <__aeabi_i2d>
    c39c:	e1a02000 	mov	r2, r0
    c3a0:	e1a03001 	mov	r3, r1
    c3a4:	e1a00007 	mov	r0, r7
    c3a8:	e28d1e22 	add	r1, sp, #544	; 0x220
    c3ac:	eb002734 	bl	16084 <AMF_EncodeNumber>
    *enc++ = AMF_NULL;
    c3b0:	e3a03005 	mov	r3, #5
    enc = AMF_EncodeString(enc, pend, subscribepath);
    c3b4:	e1a02005 	mov	r2, r5
    c3b8:	e28d1e22 	add	r1, sp, #544	; 0x220
    
    RTMP_Log(RTMP_LOGDEBUG, "FCSubscribe: %s", subscribepath->av_val);
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_FCSubscribe);
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    *enc++ = AMF_NULL;
    c3bc:	e5c03000 	strb	r3, [r0]
    enc = AMF_EncodeString(enc, pend, subscribepath);
    c3c0:	e0800006 	add	r0, r0, r6
    c3c4:	eb002707 	bl	15fe8 <AMF_EncodeString>
    
    if (!enc)
    c3c8:	e2503000 	subs	r3, r0, #0
        return FALSE;
    c3cc:	01a00003 	moveq	r0, r3
    enc = AMF_EncodeString(enc, pend, &av_FCSubscribe);
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    *enc++ = AMF_NULL;
    enc = AMF_EncodeString(enc, pend, subscribepath);
    
    if (!enc)
    c3d0:	0a000006 	beq	c3f0 <SendFCSubscribe+0xd4>
        return FALSE;
    
    packet.m_nBodySize = enc - packet.m_body;
    c3d4:	e59d101c 	ldr	r1, [sp, #28]
    
    return RTMP_SendPacket(r, &packet, TRUE);
    c3d8:	e1a00004 	mov	r0, r4
    enc = AMF_EncodeString(enc, pend, subscribepath);
    
    if (!enc)
        return FALSE;
    
    packet.m_nBodySize = enc - packet.m_body;
    c3dc:	e0613003 	rsb	r3, r1, r3
    
    return RTMP_SendPacket(r, &packet, TRUE);
    c3e0:	e1a02006 	mov	r2, r6
    c3e4:	e1a0100d 	mov	r1, sp
    enc = AMF_EncodeString(enc, pend, subscribepath);
    
    if (!enc)
        return FALSE;
    
    packet.m_nBodySize = enc - packet.m_body;
    c3e8:	e58d3010 	str	r3, [sp, #16]
    
    return RTMP_SendPacket(r, &packet, TRUE);
    c3ec:	ebfffc02 	bl	b3fc <RTMP_SendPacket>
}
    c3f0:	e28ddf89 	add	sp, sp, #548	; 0x224
    c3f4:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    c3f8:	00012ce8 	.word	0x00012ce8
    c3fc:	000174d0 	.word	0x000174d0

0000c400 <SendPublish>:
SAVC(live);
SAVC(record);

static int
SendPublish(RTMP *r)
{
    c400:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    packet.m_nInfoField2 = r->m_stream_id;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_publish);
    c404:	e59f50e4 	ldr	r5, [pc, #228]	; c4f0 <SendPublish+0xf0>
SAVC(live);
SAVC(record);

static int
SendPublish(RTMP *r)
{
    c408:	e24dde42 	sub	sp, sp, #1056	; 0x420
    c40c:	e24dd004 	sub	sp, sp, #4
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = r->m_stream_id;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    c410:	e28d3032 	add	r3, sp, #50	; 0x32
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_publish);
    c414:	e08f5005 	add	r5, pc, r5
    RTMPPacket packet;
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x04;	/* source channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
    c418:	e3a0c000 	mov	ip, #0
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    c41c:	e3a0e014 	mov	lr, #20
SAVC(live);
SAVC(record);

static int
SendPublish(RTMP *r)
{
    c420:	e1a04000 	mov	r4, r0
    
    packet.m_nChannel = 0x04;	/* source channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = r->m_stream_id;
    c424:	e5907018 	ldr	r7, [r0, #24]
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_publish);
    c428:	e2852fba 	add	r2, r5, #744	; 0x2e8
    c42c:	e1a00003 	mov	r0, r3
{
    RTMPPacket packet;
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x04;	/* source channel (invoke) */
    c430:	e3a06004 	mov	r6, #4
    packet.m_nInfoField2 = r->m_stream_id;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_publish);
    c434:	e28d1e42 	add	r1, sp, #1056	; 0x420
    RTMPPacket packet;
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x04;	/* source channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
    c438:	e5cdc000 	strb	ip, [sp]
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    c43c:	e58dc008 	str	ip, [sp, #8]
    packet.m_nInfoField2 = r->m_stream_id;
    packet.m_hasAbsTimestamp = 0;
    c440:	e5cdc002 	strb	ip, [sp, #2]
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x04;	/* source channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    c444:	e5cde001 	strb	lr, [sp, #1]
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = r->m_stream_id;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    c448:	e58d301c 	str	r3, [sp, #28]
{
    RTMPPacket packet;
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x04;	/* source channel (invoke) */
    c44c:	e58d6004 	str	r6, [sp, #4]
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = r->m_stream_id;
    c450:	e58d700c 	str	r7, [sp, #12]
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_publish);
    c454:	eb0026e3 	bl	15fe8 <AMF_EncodeString>
    c458:	e1a06000 	mov	r6, r0
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    c45c:	e5940038 	ldr	r0, [r4, #56]	; 0x38
    c460:	e2800001 	add	r0, r0, #1
    c464:	e5840038 	str	r0, [r4, #56]	; 0x38
    c468:	eb003e57 	bl	1bdcc <__aeabi_i2d>
    c46c:	e1a02000 	mov	r2, r0
    c470:	e1a03001 	mov	r3, r1
    c474:	e1a00006 	mov	r0, r6
    c478:	e28d1e42 	add	r1, sp, #1056	; 0x420
    c47c:	eb002700 	bl	16084 <AMF_EncodeNumber>
    *enc++ = AMF_NULL;
    c480:	e3a03005 	mov	r3, #5
    enc = AMF_EncodeString(enc, pend, &r->Link.playpath);
    c484:	e2842c41 	add	r2, r4, #16640	; 0x4100
    c488:	e282200c 	add	r2, r2, #12
    c48c:	e28d1e42 	add	r1, sp, #1056	; 0x420
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_publish);
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    *enc++ = AMF_NULL;
    c490:	e5c03000 	strb	r3, [r0]
    enc = AMF_EncodeString(enc, pend, &r->Link.playpath);
    c494:	e2800001 	add	r0, r0, #1
    c498:	eb0026d2 	bl	15fe8 <AMF_EncodeString>
    if (!enc)
    c49c:	e3500000 	cmp	r0, #0
    c4a0:	0a00000e 	beq	c4e0 <SendPublish+0xe0>
        return FALSE;
    
    /* FIXME: should we choose live based on Link.lFlags & RTMP_LF_LIVE? */
    enc = AMF_EncodeString(enc, pend, &av_live);
    c4a4:	e2852e2f 	add	r2, r5, #752	; 0x2f0
    c4a8:	e28d1e42 	add	r1, sp, #1056	; 0x420
    c4ac:	eb0026cd 	bl	15fe8 <AMF_EncodeString>
    if (!enc)
    c4b0:	e2503000 	subs	r3, r0, #0
    c4b4:	0a000009 	beq	c4e0 <SendPublish+0xe0>
        return FALSE;
    
    packet.m_nBodySize = enc - packet.m_body;
    c4b8:	e59d201c 	ldr	r2, [sp, #28]
    
    return RTMP_SendPacket(r, &packet, TRUE);
    c4bc:	e1a00004 	mov	r0, r4
    /* FIXME: should we choose live based on Link.lFlags & RTMP_LF_LIVE? */
    enc = AMF_EncodeString(enc, pend, &av_live);
    if (!enc)
        return FALSE;
    
    packet.m_nBodySize = enc - packet.m_body;
    c4c0:	e0623003 	rsb	r3, r2, r3
    
    return RTMP_SendPacket(r, &packet, TRUE);
    c4c4:	e1a0100d 	mov	r1, sp
    c4c8:	e3a02001 	mov	r2, #1
    /* FIXME: should we choose live based on Link.lFlags & RTMP_LF_LIVE? */
    enc = AMF_EncodeString(enc, pend, &av_live);
    if (!enc)
        return FALSE;
    
    packet.m_nBodySize = enc - packet.m_body;
    c4cc:	e58d3010 	str	r3, [sp, #16]
    
    return RTMP_SendPacket(r, &packet, TRUE);
    c4d0:	ebfffbc9 	bl	b3fc <RTMP_SendPacket>
}
    c4d4:	e28dde42 	add	sp, sp, #1056	; 0x420
    c4d8:	e28dd004 	add	sp, sp, #4
    c4dc:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    enc = AMF_EncodeString(enc, pend, &av_publish);
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    *enc++ = AMF_NULL;
    enc = AMF_EncodeString(enc, pend, &r->Link.playpath);
    if (!enc)
        return FALSE;
    c4e0:	e3a00000 	mov	r0, #0
        return FALSE;
    
    packet.m_nBodySize = enc - packet.m_body;
    
    return RTMP_SendPacket(r, &packet, TRUE);
}
    c4e4:	e28dde42 	add	sp, sp, #1056	; 0x420
    c4e8:	e28dd004 	add	sp, sp, #4
    c4ec:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    c4f0:	00017434 	.word	0x00017434

0000c4f4 <SendPlaylist>:
SAVC(set_playlist);
SAVC(0);

static int
SendPlaylist(RTMP *r)
{
    c4f4:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    packet.m_nInfoField2 = r->m_stream_id;	/*0x01000000; */
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_set_playlist);
    c4f8:	e59f50e8 	ldr	r5, [pc, #232]	; c5e8 <SendPlaylist+0xf4>
SAVC(set_playlist);
SAVC(0);

static int
SendPlaylist(RTMP *r)
{
    c4fc:	e24dde42 	sub	sp, sp, #1056	; 0x420
    c500:	e24dd004 	sub	sp, sp, #4
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = r->m_stream_id;	/*0x01000000; */
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    c504:	e28d3032 	add	r3, sp, #50	; 0x32
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_set_playlist);
    c508:	e08f5005 	add	r5, pc, r5
    RTMPPacket packet;
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x08;	/* we make 8 our stream channel */
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
    c50c:	e3a04000 	mov	r4, #0
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = r->m_stream_id;	/*0x01000000; */
    c510:	e590e018 	ldr	lr, [r0, #24]
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x08;	/* we make 8 our stream channel */
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    c514:	e3a0c014 	mov	ip, #20
SAVC(set_playlist);
SAVC(0);

static int
SendPlaylist(RTMP *r)
{
    c518:	e1a06000 	mov	r6, r0
    packet.m_nInfoField2 = r->m_stream_id;	/*0x01000000; */
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_set_playlist);
    c51c:	e2852fbe 	add	r2, r5, #760	; 0x2f8
    c520:	e1a00003 	mov	r0, r3
{
    RTMPPacket packet;
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x08;	/* we make 8 our stream channel */
    c524:	e3a07008 	mov	r7, #8
    packet.m_nInfoField2 = r->m_stream_id;	/*0x01000000; */
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_set_playlist);
    c528:	e28d1e42 	add	r1, sp, #1056	; 0x420
    
    packet.m_nChannel = 0x08;	/* we make 8 our stream channel */
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = r->m_stream_id;	/*0x01000000; */
    c52c:	e58de00c 	str	lr, [sp, #12]
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x08;	/* we make 8 our stream channel */
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    c530:	e5cdc001 	strb	ip, [sp, #1]
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = r->m_stream_id;	/*0x01000000; */
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    c534:	e58d301c 	str	r3, [sp, #28]
{
    RTMPPacket packet;
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x08;	/* we make 8 our stream channel */
    c538:	e58d7004 	str	r7, [sp, #4]
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
    c53c:	e5cd4000 	strb	r4, [sp]
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    c540:	e58d4008 	str	r4, [sp, #8]
    packet.m_nInfoField2 = r->m_stream_id;	/*0x01000000; */
    packet.m_hasAbsTimestamp = 0;
    c544:	e5cd4002 	strb	r4, [sp, #2]
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_set_playlist);
    c548:	eb0026a6 	bl	15fe8 <AMF_EncodeString>
    enc = AMF_EncodeNumber(enc, pend, 0);
    c54c:	e28d1e42 	add	r1, sp, #1056	; 0x420
    c550:	e3a02000 	mov	r2, #0
    c554:	e3a03000 	mov	r3, #0
    c558:	eb0026c9 	bl	16084 <AMF_EncodeNumber>
    *enc++ = AMF_NULL;
    c55c:	e3a0c005 	mov	ip, #5
    *enc++ = AMF_ECMA_ARRAY;
    *enc++ = 0;
    *enc++ = 0;
    *enc++ = 0;
    *enc++ = AMF_OBJECT;
    c560:	e3a01003 	mov	r1, #3
    enc = AMF_EncodeNamedString(enc, pend, &av_0, &r->Link.playpath);
    c564:	e2863c41 	add	r3, r6, #16640	; 0x4100
    c568:	e2852c03 	add	r2, r5, #768	; 0x300
    c56c:	e283300c 	add	r3, r3, #12
    *enc++ = AMF_NULL;
    *enc++ = AMF_ECMA_ARRAY;
    *enc++ = 0;
    *enc++ = 0;
    *enc++ = 0;
    *enc++ = AMF_OBJECT;
    c570:	e5c01005 	strb	r1, [r0, #5]
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_set_playlist);
    enc = AMF_EncodeNumber(enc, pend, 0);
    *enc++ = AMF_NULL;
    *enc++ = AMF_ECMA_ARRAY;
    c574:	e5c07001 	strb	r7, [r0, #1]
    *enc++ = 0;
    c578:	e5c04002 	strb	r4, [r0, #2]
    *enc++ = 0;
    c57c:	e5c04003 	strb	r4, [r0, #3]
    *enc++ = 0;
    c580:	e5c04004 	strb	r4, [r0, #4]
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_set_playlist);
    enc = AMF_EncodeNumber(enc, pend, 0);
    *enc++ = AMF_NULL;
    c584:	e5c0c000 	strb	ip, [r0]
    *enc++ = AMF_ECMA_ARRAY;
    *enc++ = 0;
    *enc++ = 0;
    *enc++ = 0;
    *enc++ = AMF_OBJECT;
    enc = AMF_EncodeNamedString(enc, pend, &av_0, &r->Link.playpath);
    c588:	e28d1e42 	add	r1, sp, #1056	; 0x420
    c58c:	e2800006 	add	r0, r0, #6
    c590:	eb0026e6 	bl	16130 <AMF_EncodeNamedString>
    if (!enc)
    c594:	e3500000 	cmp	r0, #0
    c598:	0a00000f 	beq	c5dc <SendPlaylist+0xe8>
        return FALSE;
    if (enc + 3 >= pend)
    c59c:	e2803003 	add	r3, r0, #3
    c5a0:	e28d2e42 	add	r2, sp, #1056	; 0x420
    c5a4:	e1520003 	cmp	r2, r3
    *enc++ = 0;
    *enc++ = 0;
    *enc++ = AMF_OBJECT;
    enc = AMF_EncodeNamedString(enc, pend, &av_0, &r->Link.playpath);
    if (!enc)
        return FALSE;
    c5a8:	91a00004 	movls	r0, r4
    if (enc + 3 >= pend)
    c5ac:	9a00000a 	bls	c5dc <SendPlaylist+0xe8>
        return FALSE;
    *enc++ = 0;
    *enc++ = 0;
    *enc++ = AMF_OBJECT_END;
    c5b0:	e3a02009 	mov	r2, #9
    enc = AMF_EncodeNamedString(enc, pend, &av_0, &r->Link.playpath);
    if (!enc)
        return FALSE;
    if (enc + 3 >= pend)
        return FALSE;
    *enc++ = 0;
    c5b4:	e5c04000 	strb	r4, [r0]
    *enc++ = 0;
    c5b8:	e5c04001 	strb	r4, [r0, #1]
    *enc++ = AMF_OBJECT_END;
    c5bc:	e5c02002 	strb	r2, [r0, #2]
    
    packet.m_nBodySize = enc - packet.m_body;
    c5c0:	e59d201c 	ldr	r2, [sp, #28]
    
    return RTMP_SendPacket(r, &packet, TRUE);
    c5c4:	e1a00006 	mov	r0, r6
        return FALSE;
    *enc++ = 0;
    *enc++ = 0;
    *enc++ = AMF_OBJECT_END;
    
    packet.m_nBodySize = enc - packet.m_body;
    c5c8:	e0623003 	rsb	r3, r2, r3
    
    return RTMP_SendPacket(r, &packet, TRUE);
    c5cc:	e1a0100d 	mov	r1, sp
    c5d0:	e3a02001 	mov	r2, #1
        return FALSE;
    *enc++ = 0;
    *enc++ = 0;
    *enc++ = AMF_OBJECT_END;
    
    packet.m_nBodySize = enc - packet.m_body;
    c5d4:	e58d3010 	str	r3, [sp, #16]
    
    return RTMP_SendPacket(r, &packet, TRUE);
    c5d8:	ebfffb87 	bl	b3fc <RTMP_SendPacket>
}
    c5dc:	e28dde42 	add	sp, sp, #1056	; 0x420
    c5e0:	e28dd004 	add	sp, sp, #4
    c5e4:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    c5e8:	00017340 	.word	0x00017340

0000c5ec <SendPlay>:

SAVC(play);

static int
SendPlay(RTMP *r)
{
    c5ec:	e92d4370 	push	{r4, r5, r6, r8, r9, lr}
    packet.m_nInfoField2 = r->m_stream_id;	/*0x01000000; */
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_play);
    c5f0:	e59f21cc 	ldr	r2, [pc, #460]	; c7c4 <SendPlay+0x1d8>

SAVC(play);

static int
SendPlay(RTMP *r)
{
    c5f4:	e24dde42 	sub	sp, sp, #1056	; 0x420
    c5f8:	e24dd008 	sub	sp, sp, #8
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = r->m_stream_id;	/*0x01000000; */
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    c5fc:	e28d303a 	add	r3, sp, #58	; 0x3a
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_play);
    c600:	e08f2002 	add	r2, pc, r2
    c604:	e28d1e42 	add	r1, sp, #1056	; 0x420
    RTMPPacket packet;
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x08;	/* we make 8 our stream channel */
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
    c608:	e3a0c000 	mov	ip, #0
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    c60c:	e3a0e014 	mov	lr, #20

SAVC(play);

static int
SendPlay(RTMP *r)
{
    c610:	e1a04000 	mov	r4, r0
    
    packet.m_nChannel = 0x08;	/* we make 8 our stream channel */
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = r->m_stream_id;	/*0x01000000; */
    c614:	e5906018 	ldr	r6, [r0, #24]
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_play);
    c618:	e2822fc2 	add	r2, r2, #776	; 0x308
    c61c:	e1a00003 	mov	r0, r3
{
    RTMPPacket packet;
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x08;	/* we make 8 our stream channel */
    c620:	e3a05008 	mov	r5, #8
    packet.m_nInfoField2 = r->m_stream_id;	/*0x01000000; */
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_play);
    c624:	e2811008 	add	r1, r1, #8
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x08;	/* we make 8 our stream channel */
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    c628:	e5cde009 	strb	lr, [sp, #9]
    RTMPPacket packet;
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x08;	/* we make 8 our stream channel */
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
    c62c:	e5cdc008 	strb	ip, [sp, #8]
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    c630:	e58dc010 	str	ip, [sp, #16]
    packet.m_nInfoField2 = r->m_stream_id;	/*0x01000000; */
    packet.m_hasAbsTimestamp = 0;
    c634:	e5cdc00a 	strb	ip, [sp, #10]
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    c638:	e58d3024 	str	r3, [sp, #36]	; 0x24
    
    packet.m_nChannel = 0x08;	/* we make 8 our stream channel */
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = r->m_stream_id;	/*0x01000000; */
    c63c:	e58d6014 	str	r6, [sp, #20]
{
    RTMPPacket packet;
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x08;	/* we make 8 our stream channel */
    c640:	e58d500c 	str	r5, [sp, #12]
    packet.m_nInfoField2 = r->m_stream_id;	/*0x01000000; */
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_play);
    c644:	eb002667 	bl	15fe8 <AMF_EncodeString>
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    *enc++ = AMF_NULL;
    
    RTMP_Log(RTMP_LOGDEBUG, "%s, seekTime=%d, stopTime=%d, sending play: %s",
    c648:	e2845901 	add	r5, r4, #16384	; 0x4000
    packet.m_nInfoField2 = r->m_stream_id;	/*0x01000000; */
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_play);
    c64c:	e1a06000 	mov	r6, r0
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    c650:	e5940038 	ldr	r0, [r4, #56]	; 0x38
    c654:	e2800001 	add	r0, r0, #1
    c658:	e5840038 	str	r0, [r4, #56]	; 0x38
    c65c:	eb003dda 	bl	1bdcc <__aeabi_i2d>
    c660:	e1a03001 	mov	r3, r1
    c664:	e28d1e42 	add	r1, sp, #1056	; 0x420
    c668:	e1a02000 	mov	r2, r0
    c66c:	e2811008 	add	r1, r1, #8
    c670:	e1a00006 	mov	r0, r6
    c674:	eb002682 	bl	16084 <AMF_EncodeNumber>
    *enc++ = AMF_NULL;
    c678:	e3a03005 	mov	r3, #5
    
    RTMP_Log(RTMP_LOGDEBUG, "%s, seekTime=%d, stopTime=%d, sending play: %s",
    c67c:	e59f2144 	ldr	r2, [pc, #324]	; c7c8 <SendPlay+0x1dc>
    c680:	e08f2002 	add	r2, pc, r2
    c684:	e2422d31 	sub	r2, r2, #3136	; 0xc40
    c688:	e242200c 	sub	r2, r2, #12
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_play);
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    *enc++ = AMF_NULL;
    c68c:	e5c03000 	strb	r3, [r0]
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_play);
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    c690:	e1a0c000 	mov	ip, r0
    *enc++ = AMF_NULL;
    
    RTMP_Log(RTMP_LOGDEBUG, "%s, seekTime=%d, stopTime=%d, sending play: %s",
    c694:	e595110c 	ldr	r1, [r5, #268]	; 0x10c
    c698:	e595017c 	ldr	r0, [r5, #380]	; 0x17c
    c69c:	e5953178 	ldr	r3, [r5, #376]	; 0x178
    c6a0:	e88d0003 	stm	sp, {r0, r1}
    c6a4:	e59f1120 	ldr	r1, [pc, #288]	; c7cc <SendPlay+0x1e0>
    c6a8:	e3a00004 	mov	r0, #4
    c6ac:	e08f1001 	add	r1, pc, r1
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_play);
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    *enc++ = AMF_NULL;
    c6b0:	e28c6001 	add	r6, ip, #1
    
    RTMP_Log(RTMP_LOGDEBUG, "%s, seekTime=%d, stopTime=%d, sending play: %s",
    c6b4:	eb0024bc 	bl	159ac <RTMP_Log>
             __FUNCTION__, r->Link.seekTime, r->Link.stopTime,
             r->Link.playpath.av_val);
    enc = AMF_EncodeString(enc, pend, &r->Link.playpath);
    c6b8:	e2842c41 	add	r2, r4, #16640	; 0x4100
    c6bc:	e28d1e42 	add	r1, sp, #1056	; 0x420
    c6c0:	e1a00006 	mov	r0, r6
    c6c4:	e282200c 	add	r2, r2, #12
    c6c8:	e2811008 	add	r1, r1, #8
    c6cc:	eb002645 	bl	15fe8 <AMF_EncodeString>
    if (!enc)
    c6d0:	e2506000 	subs	r6, r0, #0
    c6d4:	0a00002f 	beq	c798 <SendPlay+0x1ac>
     *  -2: looks for a live stream, then a recorded stream,
     *      if not found any open a live stream
     *  -1: plays a live stream
     * >=0: plays a recorded streams from 'start' milliseconds
     */
    if (r->Link.lFlags & RTMP_LF_LIVE)
    c6d8:	e5953180 	ldr	r3, [r5, #384]	; 0x180
    c6dc:	e3130002 	tst	r3, #2
    c6e0:	1a000030 	bne	c7a8 <SendPlay+0x1bc>
        enc = AMF_EncodeNumber(enc, pend, -1000.0);
    else
    {
        if (r->Link.seekTime > 0.0)
    c6e4:	e5950178 	ldr	r0, [r5, #376]	; 0x178
    c6e8:	eb003db7 	bl	1bdcc <__aeabi_i2d>
    c6ec:	e3a02000 	mov	r2, #0
    c6f0:	e3a03000 	mov	r3, #0
    c6f4:	e1a09001 	mov	r9, r1
    c6f8:	e1a08000 	mov	r8, r0
    c6fc:	eb003f4b 	bl	1c430 <__aeabi_dcmpgt>
    c700:	e3500000 	cmp	r0, #0
            enc = AMF_EncodeNumber(enc, pend, r->Link.seekTime);	/* resume from here */
    c704:	128d1e42 	addne	r1, sp, #1056	; 0x420
        else
            enc = AMF_EncodeNumber(enc, pend, 0.0);	/*-2000.0);*/ /* recorded as default, -2000.0 is not reliable since that freezes the player if the stream is not found */
    c708:	028d1e42 	addeq	r1, sp, #1056	; 0x420
    if (r->Link.lFlags & RTMP_LF_LIVE)
        enc = AMF_EncodeNumber(enc, pend, -1000.0);
    else
    {
        if (r->Link.seekTime > 0.0)
            enc = AMF_EncodeNumber(enc, pend, r->Link.seekTime);	/* resume from here */
    c70c:	e1a00006 	mov	r0, r6
    c710:	11a02008 	movne	r2, r8
    c714:	11a03009 	movne	r3, r9
    c718:	12811008 	addne	r1, r1, #8
        else
            enc = AMF_EncodeNumber(enc, pend, 0.0);	/*-2000.0);*/ /* recorded as default, -2000.0 is not reliable since that freezes the player if the stream is not found */
    c71c:	02811008 	addeq	r1, r1, #8
    c720:	03a02000 	moveq	r2, #0
    c724:	03a03000 	moveq	r3, #0
    c728:	eb002655 	bl	16084 <AMF_EncodeNumber>
    c72c:	e1a06000 	mov	r6, r0
    }
    if (!enc)
    c730:	e3560000 	cmp	r6, #0
    c734:	0a000017 	beq	c798 <SendPlay+0x1ac>
     *  -1: plays live or recorded stream to the end (default)
     *   0: plays a frame 'start' ms away from the beginning
     *  >0: plays a live or recoded stream for 'len' milliseconds
     */
    /*enc += EncodeNumber(enc, -1.0); */ /* len */
    if (r->Link.stopTime)
    c738:	e595317c 	ldr	r3, [r5, #380]	; 0x17c
    c73c:	e3530000 	cmp	r3, #0
    c740:	1a000009 	bne	c76c <SendPlay+0x180>
        enc = AMF_EncodeNumber(enc, pend, r->Link.stopTime - r->Link.seekTime);
        if (!enc)
            return FALSE;
    }
    
    packet.m_nBodySize = enc - packet.m_body;
    c744:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    
    return RTMP_SendPacket(r, &packet, TRUE);
    c748:	e1a00004 	mov	r0, r4
        enc = AMF_EncodeNumber(enc, pend, r->Link.stopTime - r->Link.seekTime);
        if (!enc)
            return FALSE;
    }
    
    packet.m_nBodySize = enc - packet.m_body;
    c74c:	e0636006 	rsb	r6, r3, r6
    
    return RTMP_SendPacket(r, &packet, TRUE);
    c750:	e28d1008 	add	r1, sp, #8
    c754:	e3a02001 	mov	r2, #1
        enc = AMF_EncodeNumber(enc, pend, r->Link.stopTime - r->Link.seekTime);
        if (!enc)
            return FALSE;
    }
    
    packet.m_nBodySize = enc - packet.m_body;
    c758:	e58d6018 	str	r6, [sp, #24]
    
    return RTMP_SendPacket(r, &packet, TRUE);
    c75c:	ebfffb26 	bl	b3fc <RTMP_SendPacket>
}
    c760:	e28dde42 	add	sp, sp, #1056	; 0x420
    c764:	e28dd008 	add	sp, sp, #8
    c768:	e8bd8370 	pop	{r4, r5, r6, r8, r9, pc}
     *  >0: plays a live or recoded stream for 'len' milliseconds
     */
    /*enc += EncodeNumber(enc, -1.0); */ /* len */
    if (r->Link.stopTime)
    {
        enc = AMF_EncodeNumber(enc, pend, r->Link.stopTime - r->Link.seekTime);
    c76c:	e5950178 	ldr	r0, [r5, #376]	; 0x178
    c770:	e0600003 	rsb	r0, r0, r3
    c774:	eb003d94 	bl	1bdcc <__aeabi_i2d>
    c778:	e1a03001 	mov	r3, r1
    c77c:	e28d1e42 	add	r1, sp, #1056	; 0x420
    c780:	e1a02000 	mov	r2, r0
    c784:	e2811008 	add	r1, r1, #8
    c788:	e1a00006 	mov	r0, r6
    c78c:	eb00263c 	bl	16084 <AMF_EncodeNumber>
        if (!enc)
    c790:	e2506000 	subs	r6, r0, #0
    c794:	1affffea 	bne	c744 <SendPlay+0x158>
    RTMP_Log(RTMP_LOGDEBUG, "%s, seekTime=%d, stopTime=%d, sending play: %s",
             __FUNCTION__, r->Link.seekTime, r->Link.stopTime,
             r->Link.playpath.av_val);
    enc = AMF_EncodeString(enc, pend, &r->Link.playpath);
    if (!enc)
        return FALSE;
    c798:	e3a00000 	mov	r0, #0
    }
    
    packet.m_nBodySize = enc - packet.m_body;
    
    return RTMP_SendPacket(r, &packet, TRUE);
}
    c79c:	e28dde42 	add	sp, sp, #1056	; 0x420
    c7a0:	e28dd008 	add	sp, sp, #8
    c7a4:	e8bd8370 	pop	{r4, r5, r6, r8, r9, pc}
     *      if not found any open a live stream
     *  -1: plays a live stream
     * >=0: plays a recorded streams from 'start' milliseconds
     */
    if (r->Link.lFlags & RTMP_LF_LIVE)
        enc = AMF_EncodeNumber(enc, pend, -1000.0);
    c7a8:	e28d1e42 	add	r1, sp, #1056	; 0x420
    c7ac:	e2811008 	add	r1, r1, #8
    c7b0:	e3a02000 	mov	r2, #0
    c7b4:	e59f3014 	ldr	r3, [pc, #20]	; c7d0 <SendPlay+0x1e4>
    c7b8:	eb002631 	bl	16084 <AMF_EncodeNumber>
    c7bc:	e1a06000 	mov	r6, r0
    c7c0:	eaffffda 	b	c730 <SendPlay+0x144>
    c7c4:	00017248 	.word	0x00017248
    c7c8:	00012160 	.word	0x00012160
    c7cc:	00012998 	.word	0x00012998
    c7d0:	c08f4000 	.word	0xc08f4000

0000c7d4 <SendFCUnpublish>:
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_FCUnpublish);
    c7d4:	e59f20c0 	ldr	r2, [pc, #192]	; c89c <SendFCUnpublish+0xc8>

SAVC(FCUnpublish);

static int
SendFCUnpublish(RTMP *r)
{
    c7d8:	e92d4070 	push	{r4, r5, r6, lr}
    c7dc:	e24dde42 	sub	sp, sp, #1056	; 0x420
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    c7e0:	e28d3032 	add	r3, sp, #50	; 0x32
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_FCUnpublish);
    c7e4:	e08f2002 	add	r2, pc, r2
    RTMPPacket packet;
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    c7e8:	e3a0e001 	mov	lr, #1
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    c7ec:	e3a0c014 	mov	ip, #20

SAVC(FCUnpublish);

static int
SendFCUnpublish(RTMP *r)
{
    c7f0:	e1a05000 	mov	r5, r0
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_FCUnpublish);
    c7f4:	e2822e31 	add	r2, r2, #784	; 0x310
    c7f8:	e1a00003 	mov	r0, r3
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    c7fc:	e3a04000 	mov	r4, #0
{
    RTMPPacket packet;
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    c800:	e3a06003 	mov	r6, #3
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_FCUnpublish);
    c804:	e28d1e42 	add	r1, sp, #1056	; 0x420
    RTMPPacket packet;
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    c808:	e5cde000 	strb	lr, [sp]
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    c80c:	e5cdc001 	strb	ip, [sp, #1]
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    c810:	e58d301c 	str	r3, [sp, #28]
{
    RTMPPacket packet;
    char pbuf[1024], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    c814:	e58d6004 	str	r6, [sp, #4]
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    c818:	e58d4008 	str	r4, [sp, #8]
    packet.m_nInfoField2 = 0;
    c81c:	e58d400c 	str	r4, [sp, #12]
    packet.m_hasAbsTimestamp = 0;
    c820:	e5cd4002 	strb	r4, [sp, #2]
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_FCUnpublish);
    c824:	eb0025ef 	bl	15fe8 <AMF_EncodeString>
    c828:	e1a06000 	mov	r6, r0
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    c82c:	e5950038 	ldr	r0, [r5, #56]	; 0x38
    c830:	e2800001 	add	r0, r0, #1
    c834:	e5850038 	str	r0, [r5, #56]	; 0x38
    c838:	eb003d63 	bl	1bdcc <__aeabi_i2d>
    c83c:	e1a02000 	mov	r2, r0
    c840:	e1a03001 	mov	r3, r1
    c844:	e1a00006 	mov	r0, r6
    c848:	e28d1e42 	add	r1, sp, #1056	; 0x420
    c84c:	eb00260c 	bl	16084 <AMF_EncodeNumber>
    *enc++ = AMF_NULL;
    c850:	e3a03005 	mov	r3, #5
    enc = AMF_EncodeString(enc, pend, &r->Link.playpath);
    c854:	e2852c41 	add	r2, r5, #16640	; 0x4100
    c858:	e282200c 	add	r2, r2, #12
    c85c:	e28d1e42 	add	r1, sp, #1056	; 0x420
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_FCUnpublish);
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    *enc++ = AMF_NULL;
    c860:	e5c03000 	strb	r3, [r0]
    enc = AMF_EncodeString(enc, pend, &r->Link.playpath);
    c864:	e2800001 	add	r0, r0, #1
    c868:	eb0025de 	bl	15fe8 <AMF_EncodeString>
    if (!enc)
    c86c:	e2503000 	subs	r3, r0, #0
        return FALSE;
    c870:	01a00003 	moveq	r0, r3
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_FCUnpublish);
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    *enc++ = AMF_NULL;
    enc = AMF_EncodeString(enc, pend, &r->Link.playpath);
    if (!enc)
    c874:	0a000006 	beq	c894 <SendFCUnpublish+0xc0>
        return FALSE;
    
    packet.m_nBodySize = enc - packet.m_body;
    c878:	e59d101c 	ldr	r1, [sp, #28]
    
    return RTMP_SendPacket(r, &packet, FALSE);
    c87c:	e1a00005 	mov	r0, r5
    *enc++ = AMF_NULL;
    enc = AMF_EncodeString(enc, pend, &r->Link.playpath);
    if (!enc)
        return FALSE;
    
    packet.m_nBodySize = enc - packet.m_body;
    c880:	e0613003 	rsb	r3, r1, r3
    
    return RTMP_SendPacket(r, &packet, FALSE);
    c884:	e1a02004 	mov	r2, r4
    c888:	e1a0100d 	mov	r1, sp
    *enc++ = AMF_NULL;
    enc = AMF_EncodeString(enc, pend, &r->Link.playpath);
    if (!enc)
        return FALSE;
    
    packet.m_nBodySize = enc - packet.m_body;
    c88c:	e58d3010 	str	r3, [sp, #16]
    
    return RTMP_SendPacket(r, &packet, FALSE);
    c890:	ebfffad9 	bl	b3fc <RTMP_SendPacket>
}
    c894:	e28dde42 	add	sp, sp, #1056	; 0x420
    c898:	e8bd8070 	pop	{r4, r5, r6, pc}
    c89c:	00017064 	.word	0x00017064

0000c8a0 <RTMP_SendCreateStream>:
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_createStream);
    c8a0:	e59f20a4 	ldr	r2, [pc, #164]	; c94c <RTMP_SendCreateStream+0xac>

SAVC(createStream);

int
RTMP_SendCreateStream(RTMP *r)
{
    c8a4:	e92d4070 	push	{r4, r5, r6, lr}
    c8a8:	e24dde12 	sub	sp, sp, #288	; 0x120
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_createStream);
    c8ac:	e28d3032 	add	r3, sp, #50	; 0x32
    c8b0:	e08f2002 	add	r2, pc, r2
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    c8b4:	e3a0c000 	mov	ip, #0
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    c8b8:	e3a0e014 	mov	lr, #20

SAVC(createStream);

int
RTMP_SendCreateStream(RTMP *r)
{
    c8bc:	e1a04000 	mov	r4, r0
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    c8c0:	e3a05001 	mov	r5, #1
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_createStream);
    c8c4:	e2822fc6 	add	r2, r2, #792	; 0x318
    c8c8:	e1a00003 	mov	r0, r3
    c8cc:	e28d1e12 	add	r1, sp, #288	; 0x120
{
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    c8d0:	e3a06003 	mov	r6, #3
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    c8d4:	e5cde001 	strb	lr, [sp, #1]
    packet.m_nTimeStamp = 0;
    c8d8:	e58dc008 	str	ip, [sp, #8]
    packet.m_nInfoField2 = 0;
    c8dc:	e58dc00c 	str	ip, [sp, #12]
    packet.m_hasAbsTimestamp = 0;
    c8e0:	e5cdc002 	strb	ip, [sp, #2]
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    c8e4:	e58d301c 	str	r3, [sp, #28]
{
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    c8e8:	e58d6004 	str	r6, [sp, #4]
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    c8ec:	e5cd5000 	strb	r5, [sp]
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_createStream);
    c8f0:	eb0025bc 	bl	15fe8 <AMF_EncodeString>
    c8f4:	e1a06000 	mov	r6, r0
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    c8f8:	e5940038 	ldr	r0, [r4, #56]	; 0x38
    c8fc:	e0800005 	add	r0, r0, r5
    c900:	e5840038 	str	r0, [r4, #56]	; 0x38
    c904:	eb003d30 	bl	1bdcc <__aeabi_i2d>
    c908:	e1a02000 	mov	r2, r0
    c90c:	e1a03001 	mov	r3, r1
    c910:	e1a00006 	mov	r0, r6
    c914:	e28d1e12 	add	r1, sp, #288	; 0x120
    c918:	eb0025d9 	bl	16084 <AMF_EncodeNumber>
    *enc++ = AMF_NULL;		/* NULL */
    c91c:	e3a0c005 	mov	ip, #5
    
    packet.m_nBodySize = enc - packet.m_body;
    
    return RTMP_SendPacket(r, &packet, TRUE);
    c920:	e1a02005 	mov	r2, r5
    c924:	e1a0100d 	mov	r1, sp
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_createStream);
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    *enc++ = AMF_NULL;		/* NULL */
    c928:	e1a03000 	mov	r3, r0
    c92c:	e4c3c001 	strb	ip, [r3], #1
    
    packet.m_nBodySize = enc - packet.m_body;
    c930:	e59dc01c 	ldr	ip, [sp, #28]
    
    return RTMP_SendPacket(r, &packet, TRUE);
    c934:	e1a00004 	mov	r0, r4
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_createStream);
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    *enc++ = AMF_NULL;		/* NULL */
    
    packet.m_nBodySize = enc - packet.m_body;
    c938:	e06c3003 	rsb	r3, ip, r3
    c93c:	e58d3010 	str	r3, [sp, #16]
    
    return RTMP_SendPacket(r, &packet, TRUE);
    c940:	ebfffaad 	bl	b3fc <RTMP_SendPacket>
}
    c944:	e28dde12 	add	sp, sp, #288	; 0x120
    c948:	e8bd8070 	pop	{r4, r5, r6, pc}
    c94c:	00016f98 	.word	0x00016f98

0000c950 <RTMP_SendPause>:
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_pause);
    c950:	e59fc0fc 	ldr	ip, [pc, #252]	; ca54 <RTMP_SendPause+0x104>

SAVC(pause);

int
RTMP_SendPause(RTMP *r, int DoPause, int iTime)
{
    c954:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    c958:	e24ddf4a 	sub	sp, sp, #296	; 0x128
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_pause);
    c95c:	e28d303a 	add	r3, sp, #58	; 0x3a
    c960:	e08fc00c 	add	ip, pc, ip
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x08;	/* video channel */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    c964:	e3a0e014 	mov	lr, #20

SAVC(pause);

int
RTMP_SendPause(RTMP *r, int DoPause, int iTime)
{
    c968:	e1a04000 	mov	r4, r0
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x08;	/* video channel */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    c96c:	e3a05001 	mov	r5, #1

SAVC(pause);

int
RTMP_SendPause(RTMP *r, int DoPause, int iTime)
{
    c970:	e1a06001 	mov	r6, r1
    c974:	e1a07002 	mov	r7, r2
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_pause);
    c978:	e1a00003 	mov	r0, r3
    c97c:	e28c2e32 	add	r2, ip, #800	; 0x320
    c980:	e28d1f4a 	add	r1, sp, #296	; 0x128
    char *enc;
    
    packet.m_nChannel = 0x08;	/* video channel */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    c984:	e3a0c000 	mov	ip, #0
{
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x08;	/* video channel */
    c988:	e3a08008 	mov	r8, #8
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    c98c:	e5cde009 	strb	lr, [sp, #9]
    packet.m_nTimeStamp = 0;
    c990:	e58dc010 	str	ip, [sp, #16]
    packet.m_nInfoField2 = 0;
    c994:	e58dc014 	str	ip, [sp, #20]
    packet.m_hasAbsTimestamp = 0;
    c998:	e5cdc00a 	strb	ip, [sp, #10]
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    c99c:	e58d3024 	str	r3, [sp, #36]	; 0x24
{
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x08;	/* video channel */
    c9a0:	e58d800c 	str	r8, [sp, #12]
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    c9a4:	e5cd5008 	strb	r5, [sp, #8]
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_pause);
    c9a8:	eb00258e 	bl	15fe8 <AMF_EncodeString>
    c9ac:	e1a08000 	mov	r8, r0
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    c9b0:	e5940038 	ldr	r0, [r4, #56]	; 0x38
    c9b4:	e0800005 	add	r0, r0, r5
    c9b8:	e5840038 	str	r0, [r4, #56]	; 0x38
    c9bc:	eb003d02 	bl	1bdcc <__aeabi_i2d>
    c9c0:	e1a02000 	mov	r2, r0
    c9c4:	e1a03001 	mov	r3, r1
    c9c8:	e1a00008 	mov	r0, r8
    c9cc:	e28d1f4a 	add	r1, sp, #296	; 0x128
    c9d0:	eb0025ab 	bl	16084 <AMF_EncodeNumber>
    *enc++ = AMF_NULL;
    c9d4:	e3a03005 	mov	r3, #5
    enc = AMF_EncodeBoolean(enc, pend, DoPause);
    c9d8:	e1a02006 	mov	r2, r6
    c9dc:	e28d1f4a 	add	r1, sp, #296	; 0x128
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_pause);
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    *enc++ = AMF_NULL;
    c9e0:	e5c03000 	strb	r3, [r0]
    enc = AMF_EncodeBoolean(enc, pend, DoPause);
    c9e4:	e0800005 	add	r0, r0, r5
    c9e8:	eb0025c3 	bl	160fc <AMF_EncodeBoolean>
    c9ec:	e1a08000 	mov	r8, r0
    enc = AMF_EncodeNumber(enc, pend, (double)iTime);
    c9f0:	e1a00007 	mov	r0, r7
    c9f4:	eb003cf4 	bl	1bdcc <__aeabi_i2d>
    c9f8:	e1a02000 	mov	r2, r0
    c9fc:	e1a03001 	mov	r3, r1
    ca00:	e1a00008 	mov	r0, r8
    ca04:	e28d1f4a 	add	r1, sp, #296	; 0x128
    ca08:	eb00259d 	bl	16084 <AMF_EncodeNumber>
    
    packet.m_nBodySize = enc - packet.m_body;
    
    RTMP_Log(RTMP_LOGDEBUG, "%s, %d, pauseTime=%d", __FUNCTION__, DoPause, iTime);
    ca0c:	e59f2044 	ldr	r2, [pc, #68]	; ca58 <RTMP_SendPause+0x108>
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    *enc++ = AMF_NULL;
    enc = AMF_EncodeBoolean(enc, pend, DoPause);
    enc = AMF_EncodeNumber(enc, pend, (double)iTime);
    
    packet.m_nBodySize = enc - packet.m_body;
    ca10:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
    
    RTMP_Log(RTMP_LOGDEBUG, "%s, %d, pauseTime=%d", __FUNCTION__, DoPause, iTime);
    ca14:	e59f1040 	ldr	r1, [pc, #64]	; ca5c <RTMP_SendPause+0x10c>
    ca18:	e08f2002 	add	r2, pc, r2
    ca1c:	e1a03006 	mov	r3, r6
    ca20:	e58d7000 	str	r7, [sp]
    ca24:	e2422d31 	sub	r2, r2, #3136	; 0xc40
    ca28:	e08f1001 	add	r1, pc, r1
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    *enc++ = AMF_NULL;
    enc = AMF_EncodeBoolean(enc, pend, DoPause);
    enc = AMF_EncodeNumber(enc, pend, (double)iTime);
    
    packet.m_nBodySize = enc - packet.m_body;
    ca2c:	e06cc000 	rsb	ip, ip, r0
    
    RTMP_Log(RTMP_LOGDEBUG, "%s, %d, pauseTime=%d", __FUNCTION__, DoPause, iTime);
    ca30:	e3a00004 	mov	r0, #4
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    *enc++ = AMF_NULL;
    enc = AMF_EncodeBoolean(enc, pend, DoPause);
    enc = AMF_EncodeNumber(enc, pend, (double)iTime);
    
    packet.m_nBodySize = enc - packet.m_body;
    ca34:	e58dc018 	str	ip, [sp, #24]
    
    RTMP_Log(RTMP_LOGDEBUG, "%s, %d, pauseTime=%d", __FUNCTION__, DoPause, iTime);
    ca38:	eb0023db 	bl	159ac <RTMP_Log>
    return RTMP_SendPacket(r, &packet, TRUE);
    ca3c:	e1a00004 	mov	r0, r4
    ca40:	e1a02005 	mov	r2, r5
    ca44:	e28d1008 	add	r1, sp, #8
    ca48:	ebfffa6b 	bl	b3fc <RTMP_SendPacket>
}
    ca4c:	e28ddf4a 	add	sp, sp, #296	; 0x128
    ca50:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    ca54:	00016ee8 	.word	0x00016ee8
    ca58:	00011dc8 	.word	0x00011dc8
    ca5c:	0001264c 	.word	0x0001264c

0000ca60 <RTMP_ToggleStream>:
    return RTMP_ConnectStream(r, seekTime);
}

int
RTMP_ToggleStream(RTMP *r)
{
    ca60:	e92d4038 	push	{r3, r4, r5, lr}
    int res;
    
    if (!r->m_pausing)
    ca64:	e5905028 	ldr	r5, [r0, #40]	; 0x28
    return RTMP_ConnectStream(r, seekTime);
}

int
RTMP_ToggleStream(RTMP *r)
{
    ca68:	e1a04000 	mov	r4, r0
    int res;
    
    if (!r->m_pausing)
    ca6c:	e3550000 	cmp	r5, #0
    ca70:	1a000010 	bne	cab8 <RTMP_ToggleStream+0x58>
    {
        if (RTMP_IsTimedout(r) && r->m_read.status == RTMP_READ_EOF)
    ca74:	ebffefea 	bl	8a24 <RTMP_IsTimedout>
    ca78:	e3500000 	cmp	r0, #0
    ca7c:	0a000002 	beq	ca8c <RTMP_ToggleStream+0x2c>
    ca80:	e1d43ad2 	ldrsb	r3, [r4, #162]	; 0xa2
    ca84:	e3730001 	cmn	r3, #1
            r->m_read.status = 0;
    ca88:	05c450a2 	strbeq	r5, [r4, #162]	; 0xa2
        
        res = RTMP_SendPause(r, TRUE, r->m_pauseStamp);
    ca8c:	e1a00004 	mov	r0, r4
    ca90:	e3a01001 	mov	r1, #1
    ca94:	e5942024 	ldr	r2, [r4, #36]	; 0x24
    ca98:	ebffffac 	bl	c950 <RTMP_SendPause>
        if (!res)
    ca9c:	e3500000 	cmp	r0, #0
    caa0:	1a000001 	bne	caac <RTMP_ToggleStream+0x4c>
        sleep(1);
    }
    res = RTMP_SendPause(r, FALSE, r->m_pauseStamp);
    r->m_pausing = 3;
    return res;
}
    caa4:	e1a00005 	mov	r0, r5
    caa8:	e8bd8038 	pop	{r3, r4, r5, pc}
        
        res = RTMP_SendPause(r, TRUE, r->m_pauseStamp);
        if (!res)
            return res;
        
        r->m_pausing = 1;
    caac:	e3a00001 	mov	r0, #1
    cab0:	e5840028 	str	r0, [r4, #40]	; 0x28
        sleep(1);
    cab4:	ebffe275 	bl	5490 <sleep@plt>
    }
    res = RTMP_SendPause(r, FALSE, r->m_pauseStamp);
    cab8:	e1a00004 	mov	r0, r4
    cabc:	e3a01000 	mov	r1, #0
    cac0:	e5942024 	ldr	r2, [r4, #36]	; 0x24
    cac4:	ebffffa1 	bl	c950 <RTMP_SendPause>
    r->m_pausing = 3;
    cac8:	e3a03003 	mov	r3, #3
    cacc:	e5843028 	str	r3, [r4, #40]	; 0x28
    return res;
    cad0:	e1a05000 	mov	r5, r0
}
    cad4:	e1a00005 	mov	r0, r5
    cad8:	e8bd8038 	pop	{r3, r4, r5, pc}

0000cadc <RTMP_Pause>:
    return RTMP_SendPacket(r, &packet, TRUE);
}

int RTMP_Pause(RTMP *r, int DoPause)
{
    if (DoPause)
    cadc:	e3510000 	cmp	r1, #0
    cae0:	0a000007 	beq	cb04 <RTMP_Pause+0x28>
        r->m_pauseStamp = r->m_mediaChannel < r->m_channelsAllocatedIn ?
    cae4:	e5902044 	ldr	r2, [r0, #68]	; 0x44
    cae8:	e590301c 	ldr	r3, [r0, #28]
    caec:	e1530002 	cmp	r3, r2
        r->m_channelTimestamp[r->m_mediaChannel] : 0;
    caf0:	b5902054 	ldrlt	r2, [r0, #84]	; 0x54
    caf4:	a3a02000 	movge	r2, #0
    caf8:	b7922103 	ldrlt	r2, [r2, r3, lsl #2]
}

int RTMP_Pause(RTMP *r, int DoPause)
{
    if (DoPause)
        r->m_pauseStamp = r->m_mediaChannel < r->m_channelsAllocatedIn ?
    cafc:	e5802024 	str	r2, [r0, #36]	; 0x24
        r->m_channelTimestamp[r->m_mediaChannel] : 0;
    return RTMP_SendPause(r, DoPause, r->m_pauseStamp);
    cb00:	eaffff92 	b	c950 <RTMP_SendPause>
    cb04:	e5902024 	ldr	r2, [r0, #36]	; 0x24
    cb08:	eaffff90 	b	c950 <RTMP_SendPause>

0000cb0c <RTMP_SendSeek>:
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_seek);
    cb0c:	e59f20d8 	ldr	r2, [pc, #216]	; cbec <RTMP_SendSeek+0xe0>

SAVC(seek);

int
RTMP_SendSeek(RTMP *r, int iTime)
{
    cb10:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    cb14:	e24dde12 	sub	sp, sp, #288	; 0x120
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_seek);
    cb18:	e28d3032 	add	r3, sp, #50	; 0x32
    cb1c:	e08f2002 	add	r2, pc, r2

SAVC(seek);

int
RTMP_SendSeek(RTMP *r, int iTime)
{
    cb20:	e1a04000 	mov	r4, r0
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x08;	/* video channel */
    cb24:	e3a0e008 	mov	lr, #8
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    cb28:	e3a0c014 	mov	ip, #20
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x08;	/* video channel */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    cb2c:	e3a07001 	mov	r7, #1
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    cb30:	e3a05000 	mov	r5, #0

SAVC(seek);

int
RTMP_SendSeek(RTMP *r, int iTime)
{
    cb34:	e1a06001 	mov	r6, r1
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_seek);
    cb38:	e2822fca 	add	r2, r2, #808	; 0x328
    cb3c:	e1a00003 	mov	r0, r3
    cb40:	e28d1e12 	add	r1, sp, #288	; 0x120
{
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x08;	/* video channel */
    cb44:	e58de004 	str	lr, [sp, #4]
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    cb48:	e5cdc001 	strb	ip, [sp, #1]
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    cb4c:	e58d301c 	str	r3, [sp, #28]
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x08;	/* video channel */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    cb50:	e5cd7000 	strb	r7, [sp]
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;
    cb54:	e58d5008 	str	r5, [sp, #8]
    packet.m_nInfoField2 = 0;
    cb58:	e58d500c 	str	r5, [sp, #12]
    packet.m_hasAbsTimestamp = 0;
    cb5c:	e5cd5002 	strb	r5, [sp, #2]
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_seek);
    cb60:	eb002520 	bl	15fe8 <AMF_EncodeString>
    cb64:	e1a08000 	mov	r8, r0
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    cb68:	e5940038 	ldr	r0, [r4, #56]	; 0x38
    cb6c:	e0800007 	add	r0, r0, r7
    cb70:	e5840038 	str	r0, [r4, #56]	; 0x38
    cb74:	eb003c94 	bl	1bdcc <__aeabi_i2d>
    cb78:	e1a02000 	mov	r2, r0
    cb7c:	e1a03001 	mov	r3, r1
    cb80:	e1a00008 	mov	r0, r8
    cb84:	e28d1e12 	add	r1, sp, #288	; 0x120
    cb88:	eb00253d 	bl	16084 <AMF_EncodeNumber>
    *enc++ = AMF_NULL;
    cb8c:	e3a02005 	mov	r2, #5
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_seek);
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    cb90:	e1a03000 	mov	r3, r0
    *enc++ = AMF_NULL;
    cb94:	e5c32000 	strb	r2, [r3]
    enc = AMF_EncodeNumber(enc, pend, (double)iTime);
    cb98:	e1a00006 	mov	r0, r6
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_seek);
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    *enc++ = AMF_NULL;
    cb9c:	e0836007 	add	r6, r3, r7
    enc = AMF_EncodeNumber(enc, pend, (double)iTime);
    cba0:	eb003c89 	bl	1bdcc <__aeabi_i2d>
    cba4:	e1a02000 	mov	r2, r0
    cba8:	e1a03001 	mov	r3, r1
    cbac:	e1a00006 	mov	r0, r6
    cbb0:	e28d1e12 	add	r1, sp, #288	; 0x120
    cbb4:	eb002532 	bl	16084 <AMF_EncodeNumber>
    
    packet.m_nBodySize = enc - packet.m_body;
    
    r->m_read.flags |= RTMP_READ_SEEKING;
    cbb8:	e5d410a1 	ldrb	r1, [r4, #161]	; 0xa1
    enc = AMF_EncodeString(enc, pend, &av_seek);
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    *enc++ = AMF_NULL;
    enc = AMF_EncodeNumber(enc, pend, (double)iTime);
    
    packet.m_nBodySize = enc - packet.m_body;
    cbbc:	e59d301c 	ldr	r3, [sp, #28]
    
    r->m_read.flags |= RTMP_READ_SEEKING;
    cbc0:	e3811020 	orr	r1, r1, #32
    cbc4:	e5c410a1 	strb	r1, [r4, #161]	; 0xa1
    r->m_read.nResumeTS = 0;
    cbc8:	e58450a4 	str	r5, [r4, #164]	; 0xa4
    
    return RTMP_SendPacket(r, &packet, TRUE);
    cbcc:	e1a02007 	mov	r2, r7
    cbd0:	e1a0100d 	mov	r1, sp
    enc = AMF_EncodeString(enc, pend, &av_seek);
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    *enc++ = AMF_NULL;
    enc = AMF_EncodeNumber(enc, pend, (double)iTime);
    
    packet.m_nBodySize = enc - packet.m_body;
    cbd4:	e0633000 	rsb	r3, r3, r0
    
    r->m_read.flags |= RTMP_READ_SEEKING;
    r->m_read.nResumeTS = 0;
    
    return RTMP_SendPacket(r, &packet, TRUE);
    cbd8:	e1a00004 	mov	r0, r4
    enc = AMF_EncodeString(enc, pend, &av_seek);
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
    *enc++ = AMF_NULL;
    enc = AMF_EncodeNumber(enc, pend, (double)iTime);
    
    packet.m_nBodySize = enc - packet.m_body;
    cbdc:	e58d3010 	str	r3, [sp, #16]
    
    r->m_read.flags |= RTMP_READ_SEEKING;
    r->m_read.nResumeTS = 0;
    
    return RTMP_SendPacket(r, &packet, TRUE);
    cbe0:	ebfffa05 	bl	b3fc <RTMP_SendPacket>
}
    cbe4:	e28dde12 	add	sp, sp, #288	; 0x120
    cbe8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    cbec:	00016d2c 	.word	0x00016d2c

0000cbf0 <RTMP_SendServerBW>:

int
RTMP_SendServerBW(RTMP *r)
{
    cbf0:	e92d4070 	push	{r4, r5, r6, lr}
    cbf4:	e24dde12 	sub	sp, sp, #288	; 0x120
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    packet.m_nBodySize = 4;
    
    AMF_EncodeInt32(packet.m_body, pend, r->m_nServerBW);
    cbf8:	e28d3032 	add	r3, sp, #50	; 0x32
{
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    
    packet.m_nChannel = 0x02;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
    cbfc:	e3a04000 	mov	r4, #0
    packet.m_packetType = RTMP_PACKET_TYPE_SERVER_BW;
    cc00:	e3a0e005 	mov	lr, #5
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    packet.m_nBodySize = 4;
    cc04:	e3a0c004 	mov	ip, #4
    return RTMP_SendPacket(r, &packet, TRUE);
}

int
RTMP_SendServerBW(RTMP *r)
{
    cc08:	e1a05000 	mov	r5, r0
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    packet.m_nBodySize = 4;
    
    AMF_EncodeInt32(packet.m_body, pend, r->m_nServerBW);
    cc0c:	e590202c 	ldr	r2, [r0, #44]	; 0x2c
    cc10:	e28d1e12 	add	r1, sp, #288	; 0x120
    cc14:	e1a00003 	mov	r0, r3
RTMP_SendServerBW(RTMP *r)
{
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    
    packet.m_nChannel = 0x02;	/* control channel (invoke) */
    cc18:	e3a06002 	mov	r6, #2
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
    packet.m_packetType = RTMP_PACKET_TYPE_SERVER_BW;
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    cc1c:	e58d301c 	str	r3, [sp, #28]
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    
    packet.m_nChannel = 0x02;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
    packet.m_packetType = RTMP_PACKET_TYPE_SERVER_BW;
    cc20:	e5cde001 	strb	lr, [sp, #1]
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    packet.m_nBodySize = 4;
    cc24:	e58dc010 	str	ip, [sp, #16]
RTMP_SendServerBW(RTMP *r)
{
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    
    packet.m_nChannel = 0x02;	/* control channel (invoke) */
    cc28:	e58d6004 	str	r6, [sp, #4]
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
    cc2c:	e5cd4000 	strb	r4, [sp]
    packet.m_packetType = RTMP_PACKET_TYPE_SERVER_BW;
    packet.m_nTimeStamp = 0;
    cc30:	e58d4008 	str	r4, [sp, #8]
    packet.m_nInfoField2 = 0;
    cc34:	e58d400c 	str	r4, [sp, #12]
    packet.m_hasAbsTimestamp = 0;
    cc38:	e5cd4002 	strb	r4, [sp, #2]
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    packet.m_nBodySize = 4;
    
    AMF_EncodeInt32(packet.m_body, pend, r->m_nServerBW);
    cc3c:	eb0024da 	bl	15fac <AMF_EncodeInt32>
    return RTMP_SendPacket(r, &packet, FALSE);
    cc40:	e1a00005 	mov	r0, r5
    cc44:	e1a02004 	mov	r2, r4
    cc48:	e1a0100d 	mov	r1, sp
    cc4c:	ebfff9ea 	bl	b3fc <RTMP_SendPacket>
}
    cc50:	e28dde12 	add	sp, sp, #288	; 0x120
    cc54:	e8bd8070 	pop	{r4, r5, r6, pc}

0000cc58 <RTMP_SendClientBW>:

int
RTMP_SendClientBW(RTMP *r)
{
    cc58:	e92d4070 	push	{r4, r5, r6, lr}
    cc5c:	e24dde12 	sub	sp, sp, #288	; 0x120
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    packet.m_nBodySize = 5;
    
    AMF_EncodeInt32(packet.m_body, pend, r->m_nClientBW);
    cc60:	e28d3032 	add	r3, sp, #50	; 0x32
{
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    
    packet.m_nChannel = 0x02;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
    cc64:	e3a04000 	mov	r4, #0
    return RTMP_SendPacket(r, &packet, FALSE);
}

int
RTMP_SendClientBW(RTMP *r)
{
    cc68:	e1a05000 	mov	r5, r0
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    
    packet.m_nChannel = 0x02;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
    packet.m_packetType = RTMP_PACKET_TYPE_CLIENT_BW;
    cc6c:	e3a0e006 	mov	lr, #6
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    packet.m_nBodySize = 5;
    cc70:	e3a0c005 	mov	ip, #5
    
    AMF_EncodeInt32(packet.m_body, pend, r->m_nClientBW);
    cc74:	e5902030 	ldr	r2, [r0, #48]	; 0x30
    cc78:	e28d1e12 	add	r1, sp, #288	; 0x120
    cc7c:	e1a00003 	mov	r0, r3
RTMP_SendClientBW(RTMP *r)
{
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    
    packet.m_nChannel = 0x02;	/* control channel (invoke) */
    cc80:	e3a06002 	mov	r6, #2
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
    packet.m_packetType = RTMP_PACKET_TYPE_CLIENT_BW;
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    cc84:	e58d301c 	str	r3, [sp, #28]
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    
    packet.m_nChannel = 0x02;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
    packet.m_packetType = RTMP_PACKET_TYPE_CLIENT_BW;
    cc88:	e5cde001 	strb	lr, [sp, #1]
    packet.m_nTimeStamp = 0;
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    packet.m_nBodySize = 5;
    cc8c:	e58dc010 	str	ip, [sp, #16]
RTMP_SendClientBW(RTMP *r)
{
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    
    packet.m_nChannel = 0x02;	/* control channel (invoke) */
    cc90:	e58d6004 	str	r6, [sp, #4]
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
    cc94:	e5cd4000 	strb	r4, [sp]
    packet.m_packetType = RTMP_PACKET_TYPE_CLIENT_BW;
    packet.m_nTimeStamp = 0;
    cc98:	e58d4008 	str	r4, [sp, #8]
    packet.m_nInfoField2 = 0;
    cc9c:	e58d400c 	str	r4, [sp, #12]
    packet.m_hasAbsTimestamp = 0;
    cca0:	e5cd4002 	strb	r4, [sp, #2]
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    packet.m_nBodySize = 5;
    
    AMF_EncodeInt32(packet.m_body, pend, r->m_nClientBW);
    cca4:	eb0024c0 	bl	15fac <AMF_EncodeInt32>
    packet.m_body[4] = r->m_nClientBW2;
    cca8:	e59d301c 	ldr	r3, [sp, #28]
    ccac:	e5d51034 	ldrb	r1, [r5, #52]	; 0x34
    ccb0:	e5c31004 	strb	r1, [r3, #4]
    return RTMP_SendPacket(r, &packet, FALSE);
    ccb4:	e1a02004 	mov	r2, r4
    ccb8:	e1a00005 	mov	r0, r5
    ccbc:	e1a0100d 	mov	r1, sp
    ccc0:	ebfff9cd 	bl	b3fc <RTMP_SendPacket>
}
    ccc4:	e28dde12 	add	sp, sp, #288	; 0x120
    ccc8:	e8bd8070 	pop	{r4, r5, r6, pc}

0000cccc <RTMP_SendCtrl>:
 * type 26: SWFVerification request
 * type 27: SWFVerification response
 */
int
RTMP_SendCtrl(RTMP *r, short nType, unsigned int nObject, unsigned int nTime)
{
    cccc:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    int nSize;
    char *buf;
    
    RTMP_Log(RTMP_LOGDEBUG, "sending ctrl. type: 0x%04x", (unsigned short)nType);
    ccd0:	e1a04801 	lsl	r4, r1, #16
    ccd4:	e1a04824 	lsr	r4, r4, #16
 * type 26: SWFVerification request
 * type 27: SWFVerification response
 */
int
RTMP_SendCtrl(RTMP *r, short nType, unsigned int nObject, unsigned int nTime)
{
    ccd8:	e1a05001 	mov	r5, r1
    ccdc:	e1a07002 	mov	r7, r2
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    int nSize;
    char *buf;
    
    RTMP_Log(RTMP_LOGDEBUG, "sending ctrl. type: 0x%04x", (unsigned short)nType);
    cce0:	e59f112c 	ldr	r1, [pc, #300]	; ce14 <RTMP_SendCtrl+0x148>
    cce4:	e1a02004 	mov	r2, r4
    cce8:	e2444003 	sub	r4, r4, #3
    ccec:	e1a04804 	lsl	r4, r4, #16
 * type 26: SWFVerification request
 * type 27: SWFVerification response
 */
int
RTMP_SendCtrl(RTMP *r, short nType, unsigned int nObject, unsigned int nTime)
{
    ccf0:	e24ddf49 	sub	sp, sp, #292	; 0x124
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    int nSize;
    char *buf;
    
    RTMP_Log(RTMP_LOGDEBUG, "sending ctrl. type: 0x%04x", (unsigned short)nType);
    ccf4:	e08f1001 	add	r1, pc, r1
 * type 26: SWFVerification request
 * type 27: SWFVerification response
 */
int
RTMP_SendCtrl(RTMP *r, short nType, unsigned int nObject, unsigned int nTime)
{
    ccf8:	e1a06000 	mov	r6, r0
    ccfc:	e1a04824 	lsr	r4, r4, #16
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    int nSize;
    char *buf;
    
    RTMP_Log(RTMP_LOGDEBUG, "sending ctrl. type: 0x%04x", (unsigned short)nType);
    cd00:	e3a00004 	mov	r0, #4
 * type 26: SWFVerification request
 * type 27: SWFVerification response
 */
int
RTMP_SendCtrl(RTMP *r, short nType, unsigned int nObject, unsigned int nTime)
{
    cd04:	e1a08003 	mov	r8, r3
    
    RTMP_Log(RTMP_LOGDEBUG, "sending ctrl. type: 0x%04x", (unsigned short)nType);
    
    packet.m_nChannel = 0x02;	/* control channel (ping) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_CONTROL;
    cd08:	e3a09004 	mov	r9, #4
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    int nSize;
    char *buf;
    
    RTMP_Log(RTMP_LOGDEBUG, "sending ctrl. type: 0x%04x", (unsigned short)nType);
    cd0c:	eb002326 	bl	159ac <RTMP_Log>
    
    packet.m_nChannel = 0x02;	/* control channel (ping) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_CONTROL;
    packet.m_nTimeStamp = 0;	/* RTMP_GetTime(); */
    cd10:	e3a03000 	mov	r3, #0
    int nSize;
    char *buf;
    
    RTMP_Log(RTMP_LOGDEBUG, "sending ctrl. type: 0x%04x", (unsigned short)nType);
    
    packet.m_nChannel = 0x02;	/* control channel (ping) */
    cd14:	e3a01002 	mov	r1, #2
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    cd18:	e3a02001 	mov	r2, #1
    packet.m_packetType = RTMP_PACKET_TYPE_CONTROL;
    packet.m_nTimeStamp = 0;	/* RTMP_GetTime(); */
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    cd1c:	e28d0032 	add	r0, sp, #50	; 0x32
    cd20:	e3540018 	cmp	r4, #24
    int nSize;
    char *buf;
    
    RTMP_Log(RTMP_LOGDEBUG, "sending ctrl. type: 0x%04x", (unsigned short)nType);
    
    packet.m_nChannel = 0x02;	/* control channel (ping) */
    cd24:	e58d1004 	str	r1, [sp, #4]
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    cd28:	e5cd2000 	strb	r2, [sp]
    packet.m_packetType = RTMP_PACKET_TYPE_CONTROL;
    cd2c:	e5cd9001 	strb	r9, [sp, #1]
    packet.m_nTimeStamp = 0;	/* RTMP_GetTime(); */
    cd30:	e58d3008 	str	r3, [sp, #8]
    packet.m_nInfoField2 = 0;
    cd34:	e58d300c 	str	r3, [sp, #12]
    packet.m_hasAbsTimestamp = 0;
    cd38:	e5cd3002 	strb	r3, [sp, #2]
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    cd3c:	e58d001c 	str	r0, [sp, #28]
    cd40:	8a000014 	bhi	cd98 <RTMP_SendCtrl+0xcc>
    cd44:	e59f30cc 	ldr	r3, [pc, #204]	; ce18 <RTMP_SendCtrl+0x14c>
    }
    
    packet.m_nBodySize = nSize;
    
    buf = packet.m_body;
    buf = AMF_EncodeInt16(buf, pend, nType);
    cd48:	e28d1e12 	add	r1, sp, #288	; 0x120
    cd4c:	e08f3003 	add	r3, pc, r3
    cd50:	e0834104 	add	r4, r3, r4, lsl #2
    cd54:	e5144c30 	ldr	r4, [r4, #-3120]	; 0xfffff3d0
    cd58:	e1a02005 	mov	r2, r5
        case 0x1A: nSize = 3; break;	/* SWF verify request */
        case 0x1B: nSize = 44; break;	/* SWF verify response */
        default: nSize = 6; break;
    }
    
    packet.m_nBodySize = nSize;
    cd5c:	e58d4010 	str	r4, [sp, #16]
    
    buf = packet.m_body;
    buf = AMF_EncodeInt16(buf, pend, nType);
    cd60:	eb00247f 	bl	15f64 <AMF_EncodeInt16>
    
    if (nType == 0x1B)
    cd64:	e355001b 	cmp	r5, #27
    cd68:	0a000013 	beq	cdbc <RTMP_SendCtrl+0xf0>
        memcpy(buf, r->Link.SWFVerificationResponse, 42);
        RTMP_Log(RTMP_LOGDEBUG, "Sending SWFVerification response: ");
        RTMP_LogHex(RTMP_LOGDEBUG, (uint8_t *)packet.m_body, packet.m_nBodySize);
#endif
    }
    else if (nType == 0x1A)
    cd6c:	e355001a 	cmp	r5, #26
    {
        *buf = nObject & 0xff;
    cd70:	05c07000 	strbeq	r7, [r0]
        memcpy(buf, r->Link.SWFVerificationResponse, 42);
        RTMP_Log(RTMP_LOGDEBUG, "Sending SWFVerification response: ");
        RTMP_LogHex(RTMP_LOGDEBUG, (uint8_t *)packet.m_body, packet.m_nBodySize);
#endif
    }
    else if (nType == 0x1A)
    cd74:	0a000001 	beq	cd80 <RTMP_SendCtrl+0xb4>
    {
        *buf = nObject & 0xff;
    }
    else
    {
        if (nSize > 2)
    cd78:	e3540002 	cmp	r4, #2
    cd7c:	ca00001b 	bgt	cdf0 <RTMP_SendCtrl+0x124>
        
        if (nSize > 6)
            buf = AMF_EncodeInt32(buf, pend, nTime);
    }
    
    return RTMP_SendPacket(r, &packet, FALSE);
    cd80:	e1a00006 	mov	r0, r6
    cd84:	e1a0100d 	mov	r1, sp
    cd88:	e3a02000 	mov	r2, #0
    cd8c:	ebfff99a 	bl	b3fc <RTMP_SendPacket>
}
    cd90:	e28ddf49 	add	sp, sp, #292	; 0x124
    cd94:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
    }
    
    packet.m_nBodySize = nSize;
    
    buf = packet.m_body;
    buf = AMF_EncodeInt16(buf, pend, nType);
    cd98:	e1a02005 	mov	r2, r5
        case 0x1A: nSize = 3; break;	/* SWF verify request */
        case 0x1B: nSize = 44; break;	/* SWF verify response */
        default: nSize = 6; break;
    }
    
    packet.m_nBodySize = nSize;
    cd9c:	e3a03006 	mov	r3, #6
    
    buf = packet.m_body;
    buf = AMF_EncodeInt16(buf, pend, nType);
    cda0:	e28d1e12 	add	r1, sp, #288	; 0x120
        case 0x1A: nSize = 3; break;	/* SWF verify request */
        case 0x1B: nSize = 44; break;	/* SWF verify response */
        default: nSize = 6; break;
    }
    
    packet.m_nBodySize = nSize;
    cda4:	e58d3010 	str	r3, [sp, #16]
    
    buf = packet.m_body;
    buf = AMF_EncodeInt16(buf, pend, nType);
    cda8:	eb00246d 	bl	15f64 <AMF_EncodeInt16>
        *buf = nObject & 0xff;
    }
    else
    {
        if (nSize > 2)
            buf = AMF_EncodeInt32(buf, pend, nObject);
    cdac:	e28d1e12 	add	r1, sp, #288	; 0x120
    cdb0:	e1a02007 	mov	r2, r7
    cdb4:	eb00247c 	bl	15fac <AMF_EncodeInt32>
    cdb8:	eafffff0 	b	cd80 <RTMP_SendCtrl+0xb4>
    buf = AMF_EncodeInt16(buf, pend, nType);
    
    if (nType == 0x1B)
    {
#ifdef CRYPTO
        memcpy(buf, r->Link.SWFVerificationResponse, 42);
    cdbc:	e2861c41 	add	r1, r6, #16640	; 0x4100
    cdc0:	e3a0202a 	mov	r2, #42	; 0x2a
    cdc4:	e28110c8 	add	r1, r1, #200	; 0xc8
    cdc8:	ebffe0ff 	bl	51cc <memcpy@plt>
        RTMP_Log(RTMP_LOGDEBUG, "Sending SWFVerification response: ");
    cdcc:	e59f1048 	ldr	r1, [pc, #72]	; ce1c <RTMP_SendCtrl+0x150>
    cdd0:	e1a00009 	mov	r0, r9
    cdd4:	e08f1001 	add	r1, pc, r1
    cdd8:	eb0022f3 	bl	159ac <RTMP_Log>
        RTMP_LogHex(RTMP_LOGDEBUG, (uint8_t *)packet.m_body, packet.m_nBodySize);
    cddc:	e1a00009 	mov	r0, r9
    cde0:	e59d101c 	ldr	r1, [sp, #28]
    cde4:	e59d2010 	ldr	r2, [sp, #16]
    cde8:	eb0022ff 	bl	159ec <RTMP_LogHex>
    cdec:	eaffffe3 	b	cd80 <RTMP_SendCtrl+0xb4>
        *buf = nObject & 0xff;
    }
    else
    {
        if (nSize > 2)
            buf = AMF_EncodeInt32(buf, pend, nObject);
    cdf0:	e1a02007 	mov	r2, r7
    cdf4:	e28d1e12 	add	r1, sp, #288	; 0x120
    cdf8:	eb00246b 	bl	15fac <AMF_EncodeInt32>
        
        if (nSize > 6)
    cdfc:	e3540006 	cmp	r4, #6
    ce00:	daffffde 	ble	cd80 <RTMP_SendCtrl+0xb4>
            buf = AMF_EncodeInt32(buf, pend, nTime);
    ce04:	e1a02008 	mov	r2, r8
    ce08:	e28d1e12 	add	r1, sp, #288	; 0x120
    ce0c:	eb002466 	bl	15fac <AMF_EncodeInt32>
    ce10:	eaffffda 	b	cd80 <RTMP_SendCtrl+0xb4>
    ce14:	00012398 	.word	0x00012398
    ce18:	00011a94 	.word	0x00011a94
    ce1c:	000122d4 	.word	0x000122d4

0000ce20 <RTMP_UpdateBufferMS>:
}

void
RTMP_UpdateBufferMS(RTMP *r)
{
    RTMP_SendCtrl(r, 3, r->m_stream_id, r->m_nBufferMS);
    ce20:	e5902018 	ldr	r2, [r0, #24]
    ce24:	e5903014 	ldr	r3, [r0, #20]
    ce28:	e3a01003 	mov	r1, #3
    ce2c:	eaffffa6 	b	cccc <RTMP_SendCtrl>

0000ce30 <RTMP_SendChunkSize>:
        wrote = WriteN(r, chunk->c_header, chunk->c_headerSize,0);
    return wrote;
}

int RTMP_SendChunkSize(RTMP *r)
{
    ce30:	e92d4030 	push	{r4, r5, lr}
    ce34:	e24dd024 	sub	sp, sp, #36	; 0x24
    ce38:	e1a05000 	mov	r5, r0
    int ret = FALSE;
    RTMPPacket pack;
    
    RTMPPacket_Alloc(&pack, 4);
    ce3c:	e3a01004 	mov	r1, #4
    ce40:	e1a0000d 	mov	r0, sp
    ce44:	ebffee39 	bl	8730 <RTMPPacket_Alloc>
    pack.m_nTimeStamp = 0;
    pack.m_nInfoField2 = 0;
    pack.m_nBodySize = 4;
    
    int nVal = 32768; //希望指定的大小
    pack.m_body[3] = nVal & 0xff; //大字节序
    ce48:	e59d201c 	ldr	r2, [sp, #28]
    
    RTMPPacket_Alloc(&pack, 4);
    
    pack.m_packetType = RTMP_PACKET_TYPE_CHUNK_SIZE;
    pack.m_nChannel = 0x02;
    pack.m_headerType = RTMP_PACKET_SIZE_LARGE;
    ce4c:	e3a03000 	mov	r3, #0
    RTMPPacket pack;
    
    RTMPPacket_Alloc(&pack, 4);
    
    pack.m_packetType = RTMP_PACKET_TYPE_CHUNK_SIZE;
    pack.m_nChannel = 0x02;
    ce50:	e3a00002 	mov	r0, #2
    pack.m_headerType = RTMP_PACKET_SIZE_LARGE;
    pack.m_nTimeStamp = 0;
    pack.m_nInfoField2 = 0;
    pack.m_nBodySize = 4;
    ce54:	e3a01004 	mov	r1, #4
    RTMPPacket_Alloc(&pack, 4);
    
    pack.m_packetType = RTMP_PACKET_TYPE_CHUNK_SIZE;
    pack.m_nChannel = 0x02;
    pack.m_headerType = RTMP_PACKET_SIZE_LARGE;
    pack.m_nTimeStamp = 0;
    ce58:	e98d0009 	stmib	sp, {r0, r3}
    pack.m_nInfoField2 = 0;
    ce5c:	e58d300c 	str	r3, [sp, #12]
    pack.m_nBodySize = 4;
    ce60:	e58d1010 	str	r1, [sp, #16]
    
    int nVal = 32768; //希望指定的大小
    pack.m_body[3] = nVal & 0xff; //大字节序
    ce64:	e5c23003 	strb	r3, [r2, #3]
    pack.m_body[2] = nVal >> 8;
    ce68:	e59d201c 	ldr	r2, [sp, #28]
    ce6c:	e3e0107f 	mvn	r1, #127	; 0x7f
    ce70:	e5c21002 	strb	r1, [r2, #2]
    pack.m_body[1] = nVal >> 16;
    ce74:	e59d101c 	ldr	r1, [sp, #28]
    int ret = FALSE;
    RTMPPacket pack;
    
    RTMPPacket_Alloc(&pack, 4);
    
    pack.m_packetType = RTMP_PACKET_TYPE_CHUNK_SIZE;
    ce78:	e3a02001 	mov	r2, #1
    ce7c:	e5cd2001 	strb	r2, [sp, #1]
    pack.m_nBodySize = 4;
    
    int nVal = 32768; //希望指定的大小
    pack.m_body[3] = nVal & 0xff; //大字节序
    pack.m_body[2] = nVal >> 8;
    pack.m_body[1] = nVal >> 16;
    ce80:	e5c13001 	strb	r3, [r1, #1]
    pack.m_body[0] = nVal >> 24;
    ce84:	e59d001c 	ldr	r0, [sp, #28]
    
    r->m_outChunkSize = nVal;
    ce88:	e3a01902 	mov	r1, #32768	; 0x8000
    
    RTMPPacket_Alloc(&pack, 4);
    
    pack.m_packetType = RTMP_PACKET_TYPE_CHUNK_SIZE;
    pack.m_nChannel = 0x02;
    pack.m_headerType = RTMP_PACKET_SIZE_LARGE;
    ce8c:	e5cd3000 	strb	r3, [sp]
    
    int nVal = 32768; //希望指定的大小
    pack.m_body[3] = nVal & 0xff; //大字节序
    pack.m_body[2] = nVal >> 8;
    pack.m_body[1] = nVal >> 16;
    pack.m_body[0] = nVal >> 24;
    ce90:	e5c03000 	strb	r3, [r0]
    
    r->m_outChunkSize = nVal;
    ce94:	e5851004 	str	r1, [r5, #4]
	
    ret = RTMP_SendPacket(r,&pack,1);
    ce98:	e1a00005 	mov	r0, r5
    ce9c:	e1a0100d 	mov	r1, sp
    cea0:	ebfff955 	bl	b3fc <RTMP_SendPacket>
    cea4:	e1a05000 	mov	r5, r0
    
    RTMPPacket_Free(&pack);
    cea8:	e1a0000d 	mov	r0, sp
    ceac:	ebffee2b 	bl	8760 <RTMPPacket_Free>
    
    return ret;
}
    ceb0:	e1a00005 	mov	r0, r5
    ceb4:	e28dd024 	add	sp, sp, #36	; 0x24
    ceb8:	e8bd8030 	pop	{r4, r5, pc}

0000cebc <ReadN>:
extern FILE *netstackdump_read;
#endif

static int
ReadN(RTMP *r, char *buffer, int n)
{
    cebc:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
#ifdef _DEBUG
    memset(buffer, 0, n);
#endif
    
    ptr = buffer;
    while (n > 0)
    cec0:	e2527000 	subs	r7, r2, #0
extern FILE *netstackdump_read;
#endif

static int
ReadN(RTMP *r, char *buffer, int n)
{
    cec4:	e24dd024 	sub	sp, sp, #36	; 0x24
    int nOriginalSize = n;
    int avail;
    char *ptr;
    
    r->m_sb.sb_timedout = FALSE;
    cec8:	e2806901 	add	r6, r0, #16384	; 0x4000
    cecc:	e3a04000 	mov	r4, #0
extern FILE *netstackdump_read;
#endif

static int
ReadN(RTMP *r, char *buffer, int n)
{
    ced0:	e1a0b000 	mov	fp, r0
#ifdef _DEBUG
    memset(buffer, 0, n);
#endif
    
    ptr = buffer;
    while (n > 0)
    ced4:	e58d7010 	str	r7, [sp, #16]
{
    int nOriginalSize = n;
    int avail;
    char *ptr;
    
    r->m_sb.sb_timedout = FALSE;
    ced8:	e58640ec 	str	r4, [r6, #236]	; 0xec
#ifdef _DEBUG
    memset(buffer, 0, n);
#endif
    
    ptr = buffer;
    while (n > 0)
    cedc:	da00002e 	ble	cf9c <ReadN+0xe0>
            {
                int ret;
                if (r->m_sb.sb_size < 13 || refill)
                {
                    if (!r->m_unackd)
                        HTTP_Post(r, RTMPT_IDLE, "", 1);
    cee0:	e59f932c 	ldr	r9, [pc, #812]	; d214 <ReadN+0x358>
    cee4:	e2803c42 	add	r3, r0, #16896	; 0x4200
    cee8:	e1a0a001 	mov	sl, r1
    ceec:	e08f9009 	add	r9, pc, r9
						RTMP_Log(RTMP_LOGINFO, "rtmp recv timeout");
						RTMP_Close(r);
						return 0;
					}
					
					if (RTMPSockBuf_Fill(&r->m_sb) < 1)
    cef0:	e28050e0 	add	r5, r0, #224	; 0xe0
    cef4:	e58d300c 	str	r3, [sp, #12]
    
    ptr = buffer;
    while (n > 0)
    {
        int nBytes = 0, nRead;
        if (r->Link.protocol & RTMP_FEATURE_HTTP)
    cef8:	e5964188 	ldr	r4, [r6, #392]	; 0x188
    cefc:	e2144001 	ands	r4, r4, #1
    cf00:	0a000028 	beq	cfa8 <ReadN+0xec>
    cf04:	e3a00000 	mov	r0, #0
    cf08:	ea00000b 	b	cf3c <ReadN+0x80>
                int ret;
                if (r->m_sb.sb_size < 13 || refill)
                {
                    if (!r->m_unackd)
                        HTTP_Post(r, RTMPT_IDLE, "", 1);
                    if (RTMPSockBuf_Fill(&r->m_sb) < 1)
    cf0c:	e1a00005 	mov	r0, r5
    cf10:	ebfff393 	bl	9d64 <RTMPSockBuf_Fill>
    cf14:	e3500000 	cmp	r0, #0
    cf18:	da00001b 	ble	cf8c <ReadN+0xd0>
                        if (!r->m_sb.sb_timedout)
                            RTMP_Close(r);
                        return 0;
                    }
                }
                if ((ret = HTTP_read(r, 0)) == -1)
    cf1c:	e1a0000b 	mov	r0, fp
    cf20:	e3a01000 	mov	r1, #0
    cf24:	ebfff3c4 	bl	9e3c <HTTP_read>
    cf28:	e3700001 	cmn	r0, #1
    cf2c:	0a000068 	beq	d0d4 <ReadN+0x218>
                {
                    RTMP_Log(RTMP_LOGDEBUG, "%s, No valid HTTP response found", __FUNCTION__);
                    RTMP_Close(r);
                    return 0;
                }
                else if (ret == -2)
    cf30:	e3700002 	cmn	r0, #2
    cf34:	13a00000 	movne	r0, #0
    cf38:	03a00001 	moveq	r0, #1
    {
        int nBytes = 0, nRead;
        if (r->Link.protocol & RTMP_FEATURE_HTTP)
        {
            int refill = 0;
            while (!r->m_resplen)
    cf3c:	e59b4080 	ldr	r4, [fp, #128]	; 0x80
    cf40:	e3540000 	cmp	r4, #0
    cf44:	1a00004a 	bne	d074 <ReadN+0x1b8>
            {
                int ret;
                if (r->m_sb.sb_size < 13 || refill)
    cf48:	e59b30e4 	ldr	r3, [fp, #228]	; 0xe4
    cf4c:	e353000c 	cmp	r3, #12
    cf50:	d3800001 	orrle	r0, r0, #1
    cf54:	e3500000 	cmp	r0, #0
    cf58:	0affffef 	beq	cf1c <ReadN+0x60>
                {
                    if (!r->m_unackd)
    cf5c:	e59b3084 	ldr	r3, [fp, #132]	; 0x84
    cf60:	e3530000 	cmp	r3, #0
    cf64:	1affffe8 	bne	cf0c <ReadN+0x50>
                        HTTP_Post(r, RTMPT_IDLE, "", 1);
    cf68:	e3a01002 	mov	r1, #2
    cf6c:	e1a02009 	mov	r2, r9
    cf70:	e3a03001 	mov	r3, #1
    cf74:	e1a0000b 	mov	r0, fp
    cf78:	ebfff433 	bl	a04c <HTTP_Post>
                    if (RTMPSockBuf_Fill(&r->m_sb) < 1)
    cf7c:	e1a00005 	mov	r0, r5
    cf80:	ebfff377 	bl	9d64 <RTMPSockBuf_Fill>
    cf84:	e3500000 	cmp	r0, #0
    cf88:	caffffe3 	bgt	cf1c <ReadN+0x60>
                    {
                        if (!r->m_sb.sb_timedout)
    cf8c:	e59630ec 	ldr	r3, [r6, #236]	; 0xec
    cf90:	e3530000 	cmp	r3, #0
    cf94:	0a000083 	beq	d1a8 <ReadN+0x2ec>
                            RTMP_Close(r);
                        return 0;
    cf98:	e3a04000 	mov	r4, #0
        n -= nBytes;
        ptr += nBytes;
    }
    //RTMP_Log(RTMP_LOGINFO,"ReadN return :%d \n",nOriginalSize - n);
    return nOriginalSize - n;
}
    cf9c:	e1a00004 	mov	r0, r4
    cfa0:	e28dd024 	add	sp, sp, #36	; 0x24
    cfa4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
            if (avail > r->m_resplen)
                avail = r->m_resplen;
        }
        else
        {
            avail = r->m_sb.sb_size;
    cfa8:	e59b80e4 	ldr	r8, [fp, #228]	; 0xe4
            if (avail == 0)
    cfac:	e3580000 	cmp	r8, #0
    cfb0:	0a000054 	beq	d108 <ReadN+0x24c>
				
                avail = r->m_sb.sb_size;
            }
        }
		
        nRead = ((n < avail) ? n : avail);
    cfb4:	e1580007 	cmp	r8, r7
    cfb8:	a1a08007 	movge	r8, r7
        if (nRead > 0)
    cfbc:	e3580000 	cmp	r8, #0
    cfc0:	da000034 	ble	d098 <ReadN+0x1dc>
        {
            memcpy(ptr, r->m_sb.sb_start, nRead);
    cfc4:	e59b10e8 	ldr	r1, [fp, #232]	; 0xe8
    cfc8:	e1a02008 	mov	r2, r8
    cfcc:	e1a0000a 	mov	r0, sl
    cfd0:	ebffe07d 	bl	51cc <memcpy@plt>
            r->m_sb.sb_start += nRead;
    cfd4:	e59b10e8 	ldr	r1, [fp, #232]	; 0xe8
            r->m_sb.sb_size -= nRead;
    cfd8:	e59b30e4 	ldr	r3, [fp, #228]	; 0xe4
            nBytes = nRead;
            r->m_nBytesIn += nRead;
    cfdc:	e59b200c 	ldr	r2, [fp, #12]
            if (r->m_bSendCounter
    cfe0:	e5db0037 	ldrb	r0, [fp, #55]	; 0x37
		
        nRead = ((n < avail) ? n : avail);
        if (nRead > 0)
        {
            memcpy(ptr, r->m_sb.sb_start, nRead);
            r->m_sb.sb_start += nRead;
    cfe4:	e0811008 	add	r1, r1, r8
            r->m_sb.sb_size -= nRead;
    cfe8:	e0683003 	rsb	r3, r8, r3
            nBytes = nRead;
            r->m_nBytesIn += nRead;
    cfec:	e0882002 	add	r2, r8, r2
            if (r->m_bSendCounter
    cff0:	e3500000 	cmp	r0, #0
		
        nRead = ((n < avail) ? n : avail);
        if (nRead > 0)
        {
            memcpy(ptr, r->m_sb.sb_start, nRead);
            r->m_sb.sb_start += nRead;
    cff4:	e58b10e8 	str	r1, [fp, #232]	; 0xe8
            r->m_sb.sb_size -= nRead;
    cff8:	e58b30e4 	str	r3, [fp, #228]	; 0xe4
            nBytes = nRead;
            r->m_nBytesIn += nRead;
    cffc:	e58b200c 	str	r2, [fp, #12]
            if (r->m_bSendCounter
    d000:	0a000008 	beq	d028 <ReadN+0x16c>
                && r->m_nBytesIn > ( r->m_nBytesInSent + r->m_nClientBW / 10))
    d004:	e59b3030 	ldr	r3, [fp, #48]	; 0x30
    d008:	e59f0208 	ldr	r0, [pc, #520]	; d218 <ReadN+0x35c>
    d00c:	e59b1010 	ldr	r1, [fp, #16]
    d010:	e0c0c093 	smull	ip, r0, r3, r0
    d014:	e1a03fc3 	asr	r3, r3, #31
    d018:	e0633140 	rsb	r3, r3, r0, asr #2
    d01c:	e0833001 	add	r3, r3, r1
    d020:	e1520003 	cmp	r2, r3
    d024:	ca000062 	bgt	d1b4 <ReadN+0x2f8>
            /*goto again; */
            RTMP_Close(r);
            break;
        }
        
        if (r->Link.protocol & RTMP_FEATURE_HTTP)
    d028:	e5963188 	ldr	r3, [r6, #392]	; 0x188
    d02c:	e3130001 	tst	r3, #1
            r->m_resplen -= nBytes;
    d030:	159b3080 	ldrne	r3, [fp, #128]	; 0x80
    d034:	10683003 	rsbne	r3, r8, r3
    d038:	158b3080 	strne	r3, [fp, #128]	; 0x80
        
#ifdef CRYPTO
        if (r->Link.rc4keyIn)
    d03c:	e596019c 	ldr	r0, [r6, #412]	; 0x19c
    d040:	e3500000 	cmp	r0, #0
    d044:	0a000003 	beq	d058 <ReadN+0x19c>
        {
            RC4_encrypt(r->Link.rc4keyIn, nBytes, ptr);
    d048:	e1a01008 	mov	r1, r8
    d04c:	e1a0200a 	mov	r2, sl
    d050:	e1a0300a 	mov	r3, sl
    d054:	ebffe107 	bl	5478 <arc4_crypt@plt>
        }
#endif
        
        n -= nBytes;
    d058:	e0687007 	rsb	r7, r8, r7
#ifdef _DEBUG
    memset(buffer, 0, n);
#endif
    
    ptr = buffer;
    while (n > 0)
    d05c:	e3570000 	cmp	r7, #0
            RC4_encrypt(r->Link.rc4keyIn, nBytes, ptr);
        }
#endif
        
        n -= nBytes;
        ptr += nBytes;
    d060:	e08aa008 	add	sl, sl, r8
#ifdef _DEBUG
    memset(buffer, 0, n);
#endif
    
    ptr = buffer;
    while (n > 0)
    d064:	caffffa3 	bgt	cef8 <ReadN+0x3c>
    d068:	e59d3010 	ldr	r3, [sp, #16]
    d06c:	e0674003 	rsb	r4, r7, r3
    d070:	eaffffc9 	b	cf9c <ReadN+0xe0>
                else
                {
                    refill = 0;
                }
            }
            if (r->m_resplen && !r->m_sb.sb_size)
    d074:	e59b80e4 	ldr	r8, [fp, #228]	; 0xe4
    d078:	e3580000 	cmp	r8, #0
    d07c:	0a000051 	beq	d1c8 <ReadN+0x30c>
    d080:	e1580004 	cmp	r8, r4
    d084:	a1a08004 	movge	r8, r4
				
                avail = r->m_sb.sb_size;
            }
        }
		
        nRead = ((n < avail) ? n : avail);
    d088:	e1580007 	cmp	r8, r7
    d08c:	a1a08007 	movge	r8, r7
        if (nRead > 0)
    d090:	e3580000 	cmp	r8, #0
    d094:	caffffca 	bgt	cfc4 <ReadN+0x108>
        fwrite(ptr, 1, nBytes, netstackdump_read);
#endif
        
        if (nBytes == 0)
        {
            RTMP_Log(RTMP_LOGINFO, "%s, RTMP socket closed by peer", __FUNCTION__);
    d098:	e59f217c 	ldr	r2, [pc, #380]	; d21c <ReadN+0x360>
    d09c:	e59f117c 	ldr	r1, [pc, #380]	; d220 <ReadN+0x364>
    d0a0:	e08f2002 	add	r2, pc, r2
    d0a4:	e2422d2f 	sub	r2, r2, #3008	; 0xbc0
    d0a8:	e242200c 	sub	r2, r2, #12
    d0ac:	e08f1001 	add	r1, pc, r1
    d0b0:	e3a00003 	mov	r0, #3
    d0b4:	eb00223c 	bl	159ac <RTMP_Log>
    d0b8:	e59d3010 	ldr	r3, [sp, #16]
            /*goto again; */
            RTMP_Close(r);
    d0bc:	e1a0000b 	mov	r0, fp
    d0c0:	e0674003 	rsb	r4, r7, r3
    d0c4:	ebfff824 	bl	b15c <RTMP_Close>
        n -= nBytes;
        ptr += nBytes;
    }
    //RTMP_Log(RTMP_LOGINFO,"ReadN return :%d \n",nOriginalSize - n);
    return nOriginalSize - n;
}
    d0c8:	e1a00004 	mov	r0, r4
    d0cc:	e28dd024 	add	sp, sp, #36	; 0x24
    d0d0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
                        return 0;
                    }
                }
                if ((ret = HTTP_read(r, 0)) == -1)
                {
                    RTMP_Log(RTMP_LOGDEBUG, "%s, No valid HTTP response found", __FUNCTION__);
    d0d4:	e59f2148 	ldr	r2, [pc, #328]	; d224 <ReadN+0x368>
    d0d8:	e59f1148 	ldr	r1, [pc, #328]	; d228 <ReadN+0x36c>
    d0dc:	e08f2002 	add	r2, pc, r2
    d0e0:	e2422d2f 	sub	r2, r2, #3008	; 0xbc0
    d0e4:	e242200c 	sub	r2, r2, #12
    d0e8:	e08f1001 	add	r1, pc, r1
    d0ec:	e3a00004 	mov	r0, #4
    d0f0:	eb00222d 	bl	159ac <RTMP_Log>
                    RTMP_Close(r);
    d0f4:	e1a0000b 	mov	r0, fp
    d0f8:	ebfff817 	bl	b15c <RTMP_Close>
        n -= nBytes;
        ptr += nBytes;
    }
    //RTMP_Log(RTMP_LOGINFO,"ReadN return :%d \n",nOriginalSize - n);
    return nOriginalSize - n;
}
    d0fc:	e1a00004 	mov	r0, r4
    d100:	e28dd024 	add	sp, sp, #36	; 0x24
    d104:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        else
        {
            avail = r->m_sb.sb_size;
            if (avail == 0)
            {
				uint64_t timeStart = RTMP_GetTime_mill();
    d108:	ebffed49 	bl	8634 <RTMP_GetTime_mill>
    d10c:	e58d7018 	str	r7, [sp, #24]
    d110:	e59d700c 	ldr	r7, [sp, #12]
    d114:	e58db014 	str	fp, [sp, #20]
    d118:	e58da01c 	str	sl, [sp, #28]
    d11c:	e1cd00f0 	strd	r0, [sp]
				while (TRUE)
				{
					if (ff_check_interrupt_rtmp(&r->interrupt_callback))
    d120:	e1a00007 	mov	r0, r7
    d124:	ebffecfe 	bl	8524 <ff_check_interrupt_rtmp>
    d128:	e2508000 	subs	r8, r0, #0
    d12c:	1a000014 	bne	d184 <ReadN+0x2c8>
						RTMP_Log(RTMP_LOGINFO, "RTMP WAS interrupt");
						RTMP_Close(r);
						return 0;
					}
					
					uint64_t timeCurrent = RTMP_GetTime_mill();
    d130:	ebffed3f 	bl	8634 <RTMP_GetTime_mill>
					if (timeCurrent - timeStart >= 10 * 1000)
    d134:	e1cd20d0 	ldrd	r2, [sp]
    d138:	e59fa0ec 	ldr	sl, [pc, #236]	; d22c <ReadN+0x370>
    d13c:	e3a0b000 	mov	fp, #0
    d140:	e0502002 	subs	r2, r0, r2
    d144:	e0c13003 	sbc	r3, r1, r3
    d148:	e153000b 	cmp	r3, fp
    d14c:	0152000a 	cmpeq	r2, sl
						RTMP_Log(RTMP_LOGINFO, "rtmp recv timeout");
						RTMP_Close(r);
						return 0;
					}
					
					if (RTMPSockBuf_Fill(&r->m_sb) < 1)
    d150:	e1a00005 	mov	r0, r5
						RTMP_Close(r);
						return 0;
					}
					
					uint64_t timeCurrent = RTMP_GetTime_mill();
					if (timeCurrent - timeStart >= 10 * 1000)
    d154:	8a000020 	bhi	d1dc <ReadN+0x320>
						RTMP_Log(RTMP_LOGINFO, "rtmp recv timeout");
						RTMP_Close(r);
						return 0;
					}
					
					if (RTMPSockBuf_Fill(&r->m_sb) < 1)
    d158:	ebfff301 	bl	9d64 <RTMPSockBuf_Fill>
    d15c:	e3500000 	cmp	r0, #0
    d160:	ca000026 	bgt	d200 <ReadN+0x344>
					{
						if (r->m_sb.sb_timedout)
    d164:	e59630ec 	ldr	r3, [r6, #236]	; 0xec
    d168:	e3530000 	cmp	r3, #0
    d16c:	0a00000c 	beq	d1a4 <ReadN+0x2e8>
						{
							r->m_sb.sb_timedout = FALSE;
    d170:	e58680ec 	str	r8, [r6, #236]	; 0xec
            if (avail == 0)
            {
				uint64_t timeStart = RTMP_GetTime_mill();
				while (TRUE)
				{
					if (ff_check_interrupt_rtmp(&r->interrupt_callback))
    d174:	e1a00007 	mov	r0, r7
    d178:	ebffece9 	bl	8524 <ff_check_interrupt_rtmp>
    d17c:	e2508000 	subs	r8, r0, #0
    d180:	0affffea 	beq	d130 <ReadN+0x274>
					{
						RTMP_Log(RTMP_LOGINFO, "RTMP WAS interrupt");
    d184:	e59f10a4 	ldr	r1, [pc, #164]	; d230 <ReadN+0x374>
    d188:	e59db014 	ldr	fp, [sp, #20]
    d18c:	e3a00003 	mov	r0, #3
    d190:	e08f1001 	add	r1, pc, r1
    d194:	eb002204 	bl	159ac <RTMP_Log>
						RTMP_Close(r);
    d198:	e1a0000b 	mov	r0, fp
    d19c:	ebfff7ee 	bl	b15c <RTMP_Close>
						return 0;
    d1a0:	eaffff7d 	b	cf9c <ReadN+0xe0>
    d1a4:	e59db014 	ldr	fp, [sp, #20]
                    if (!r->m_unackd)
                        HTTP_Post(r, RTMPT_IDLE, "", 1);
                    if (RTMPSockBuf_Fill(&r->m_sb) < 1)
                    {
                        if (!r->m_sb.sb_timedout)
                            RTMP_Close(r);
    d1a8:	e1a0000b 	mov	r0, fp
    d1ac:	ebfff7ea 	bl	b15c <RTMP_Close>
    d1b0:	eaffff78 	b	cf98 <ReadN+0xdc>
            r->m_sb.sb_size -= nRead;
            nBytes = nRead;
            r->m_nBytesIn += nRead;
            if (r->m_bSendCounter
                && r->m_nBytesIn > ( r->m_nBytesInSent + r->m_nClientBW / 10))
                if (!SendBytesReceived(r))
    d1b4:	e1a0000b 	mov	r0, fp
    d1b8:	ebfffa31 	bl	ba84 <SendBytesReceived>
    d1bc:	e3500000 	cmp	r0, #0
    d1c0:	1affff98 	bne	d028 <ReadN+0x16c>
    d1c4:	eaffff73 	b	cf98 <ReadN+0xdc>
                {
                    refill = 0;
                }
            }
            if (r->m_resplen && !r->m_sb.sb_size)
                RTMPSockBuf_Fill(&r->m_sb);
    d1c8:	e1a00005 	mov	r0, r5
    d1cc:	ebfff2e4 	bl	9d64 <RTMPSockBuf_Fill>
    d1d0:	e59b80e4 	ldr	r8, [fp, #228]	; 0xe4
    d1d4:	e59b4080 	ldr	r4, [fp, #128]	; 0x80
    d1d8:	eaffffa8 	b	d080 <ReadN+0x1c4>
					}
					
					uint64_t timeCurrent = RTMP_GetTime_mill();
					if (timeCurrent - timeStart >= 10 * 1000)
					{
						RTMP_Log(RTMP_LOGINFO, "rtmp recv timeout");
    d1dc:	e59f1050 	ldr	r1, [pc, #80]	; d234 <ReadN+0x378>
    d1e0:	e59db014 	ldr	fp, [sp, #20]
    d1e4:	e3a00003 	mov	r0, #3
    d1e8:	e08f1001 	add	r1, pc, r1
    d1ec:	eb0021ee 	bl	159ac <RTMP_Log>
						RTMP_Close(r);
    d1f0:	e1a0000b 	mov	r0, fp
						return 0;
    d1f4:	e1a04008 	mov	r4, r8
					
					uint64_t timeCurrent = RTMP_GetTime_mill();
					if (timeCurrent - timeStart >= 10 * 1000)
					{
						RTMP_Log(RTMP_LOGINFO, "rtmp recv timeout");
						RTMP_Close(r);
    d1f8:	ebfff7d7 	bl	b15c <RTMP_Close>
						return 0;
    d1fc:	eaffff66 	b	cf9c <ReadN+0xe0>
    d200:	e59db014 	ldr	fp, [sp, #20]
    d204:	e59d7018 	ldr	r7, [sp, #24]
    d208:	e59da01c 	ldr	sl, [sp, #28]
					}
					else
						break;
				}
				
                avail = r->m_sb.sb_size;
    d20c:	e59b80e4 	ldr	r8, [fp, #228]	; 0xe4
    d210:	eaffff67 	b	cfb4 <ReadN+0xf8>
    d214:	00010f45 	.word	0x00010f45
    d218:	66666667 	.word	0x66666667
    d21c:	00011740 	.word	0x00011740
    d220:	0001206c 	.word	0x0001206c
    d224:	00011704 	.word	0x00011704
    d228:	00011fe4 	.word	0x00011fe4
    d22c:	0000270f 	.word	0x0000270f
    d230:	00011f60 	.word	0x00011f60
    d234:	00011f1c 	.word	0x00011f1c

0000d238 <HandShake.isra.11>:

static int
HandShake(RTMP * r, int FP9HandShake)
    d238:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
{
	//LOGE("HandShake \n");
  int i, offalg = 0;
  int dhposClient = 0;
  int digestPosClient = 0;
  int encrypted = r->Link.protocol & RTMP_FEATURE_ENC;
    d23c:	e2805901 	add	r5, r0, #16384	; 0x4000
  out[6] = (d[1] >> 16) & 0xff;
  out[7] = (d[1] >> 24) & 0xff;
}

static int
HandShake(RTMP * r, int FP9HandShake)
    d240:	e24ddd62 	sub	sp, sp, #6272	; 0x1880
    d244:	e24dd00c 	sub	sp, sp, #12
{
	//LOGE("HandShake \n");
  int i, offalg = 0;
  int dhposClient = 0;
  int digestPosClient = 0;
  int encrypted = r->Link.protocol & RTMP_FEATURE_ENC;
    d248:	e5954188 	ldr	r4, [r5, #392]	; 0x188

  RC4_handle keyIn = 0;
    d24c:	e28d8d22 	add	r8, sp, #2176	; 0x880
    d250:	e2888008 	add	r8, r8, #8
    d254:	e3a03000 	mov	r3, #0
  uint8_t clientbuf[RTMP_SIG_SIZE + 4], *clientsig=clientbuf+4;
  uint8_t serversig[RTMP_SIG_SIZE], client2[RTMP_SIG_SIZE], *reply;
  uint8_t type;
  getoff *getdh = NULL, *getdig = NULL;

  if (encrypted || r->Link.SWFSize)
    d258:	e2144002 	ands	r4, r4, #2
  out[6] = (d[1] >> 16) & 0xff;
  out[7] = (d[1] >> 24) & 0xff;
}

static int
HandShake(RTMP * r, int FP9HandShake)
    d25c:	e1a09000 	mov	r9, r0
  int i, offalg = 0;
  int dhposClient = 0;
  int digestPosClient = 0;
  int encrypted = r->Link.protocol & RTMP_FEATURE_ENC;

  RC4_handle keyIn = 0;
    d260:	e508384c 	str	r3, [r8, #-2124]	; 0xfffff7b4
  RC4_handle keyOut = 0;
    d264:	e5083848 	str	r3, [r8, #-2120]	; 0xfffff7b8
  uint8_t clientbuf[RTMP_SIG_SIZE + 4], *clientsig=clientbuf+4;
  uint8_t serversig[RTMP_SIG_SIZE], client2[RTMP_SIG_SIZE], *reply;
  uint8_t type;
  getoff *getdh = NULL, *getdig = NULL;

  if (encrypted || r->Link.SWFSize)
    d268:	1a000014 	bne	d2c0 <HandShake.isra.11+0x88>
    {
      clientsig[-1] = 0x06;	/* 0x08 is RTMPE as well */
      offalg = 1;
    }
  else
    clientsig[-1] = 0x03;
    d26c:	e28d2d4a 	add	r2, sp, #4736	; 0x1280
    d270:	e3a03003 	mov	r3, #3
    d274:	e2822007 	add	r2, r2, #7
    d278:	e5c23000 	strb	r3, [r2]
  if (encrypted || r->Link.SWFSize)
    FP9HandShake = TRUE;
  else
    FP9HandShake = FALSE;

  r->Link.rc4keyIn = r->Link.rc4keyOut = 0;
    d27c:	e58541a0 	str	r4, [r5, #416]	; 0x1a0
    d280:	e585419c 	str	r4, [r5, #412]	; 0x19c
  uint8_t clientbuf[RTMP_SIG_SIZE + 4], *clientsig=clientbuf+4;
  uint8_t serversig[RTMP_SIG_SIZE], client2[RTMP_SIG_SIZE], *reply;
  uint8_t type;
  getoff *getdh = NULL, *getdig = NULL;

  if (encrypted || r->Link.SWFSize)
    d284:	e59561a4 	ldr	r6, [r5, #420]	; 0x1a4
      offalg = 1;
    }
  else
    clientsig[-1] = 0x03;

  uptime = htonl(RTMP_GetTime());
    d288:	ebffecbe 	bl	8588 <RTMP_GetTime>
  memcpy(clientsig, &uptime, 4);
    d28c:	e28d2d4a 	add	r2, sp, #4736	; 0x1280
    d290:	e2822008 	add	r2, r2, #8

  if (FP9HandShake)
    d294:	e3560000 	cmp	r6, #0
      offalg = 1;
    }
  else
    clientsig[-1] = 0x03;

  uptime = htonl(RTMP_GetTime());
    d298:	e0203860 	eor	r3, r0, r0, ror #16
    d29c:	e1a03423 	lsr	r3, r3, #8
    d2a0:	e3c33cff 	bic	r3, r3, #65280	; 0xff00
    d2a4:	e0233460 	eor	r3, r3, r0, ror #8
  memcpy(clientsig, &uptime, 4);
    d2a8:	e5823000 	str	r3, [r2]

  if (FP9HandShake)
    d2ac:	0a0000a4 	beq	d544 <HandShake.isra.11+0x30c>

static int
HandShake(RTMP * r, int FP9HandShake)
{
	//LOGE("HandShake \n");
  int i, offalg = 0;
    d2b0:	e58d4018 	str	r4, [sp, #24]
	  clientsig[6] = 3;
	}
      else
        {
	  clientsig[4] = 10;
	  clientsig[6] = 45;
    d2b4:	e3a0e02d 	mov	lr, #45	; 0x2d
	  clientsig[4] = 128;
	  clientsig[6] = 3;
	}
      else
        {
	  clientsig[4] = 10;
    d2b8:	e3a0c00a 	mov	ip, #10
    d2bc:	ea000011 	b	d308 <HandShake.isra.11+0xd0>

  r->Link.rc4keyIn = r->Link.rc4keyOut = 0;

  if (encrypted)
    {
      clientsig[-1] = 0x06;	/* 0x08 is RTMPE as well */
    d2c0:	e28d2d4a 	add	r2, sp, #4736	; 0x1280
    d2c4:	e2822007 	add	r2, r2, #7
  if (encrypted || r->Link.SWFSize)
    FP9HandShake = TRUE;
  else
    FP9HandShake = FALSE;

  r->Link.rc4keyIn = r->Link.rc4keyOut = 0;
    d2c8:	e58531a0 	str	r3, [r5, #416]	; 0x1a0
    d2cc:	e585319c 	str	r3, [r5, #412]	; 0x19c

  if (encrypted)
    {
      clientsig[-1] = 0x06;	/* 0x08 is RTMPE as well */
    d2d0:	e3a03006 	mov	r3, #6
    d2d4:	e5c23000 	strb	r3, [r2]
      offalg = 1;
    }
  else
    clientsig[-1] = 0x03;

  uptime = htonl(RTMP_GetTime());
    d2d8:	ebffecaa 	bl	8588 <RTMP_GetTime>
  memcpy(clientsig, &uptime, 4);
    d2dc:	e28d2d4a 	add	r2, sp, #4736	; 0x1280
    d2e0:	e2822008 	add	r2, r2, #8
    {
      /* set version to at least 9.0.115.0 */
      if (encrypted)
	{
	  clientsig[4] = 128;
	  clientsig[6] = 3;
    d2e4:	e3a0e003 	mov	lr, #3
  if (FP9HandShake)
    {
      /* set version to at least 9.0.115.0 */
      if (encrypted)
	{
	  clientsig[4] = 128;
    d2e8:	e3a0c080 	mov	ip, #128	; 0x80
      offalg = 1;
    }
  else
    clientsig[-1] = 0x03;

  uptime = htonl(RTMP_GetTime());
    d2ec:	e0203860 	eor	r3, r0, r0, ror #16
    d2f0:	e1a03423 	lsr	r3, r3, #8
    d2f4:	e3c33cff 	bic	r3, r3, #65280	; 0xff00
    d2f8:	e0233460 	eor	r3, r3, r0, ror #8
  memcpy(clientsig, &uptime, 4);
    d2fc:	e5823000 	str	r3, [r2]
  r->Link.rc4keyIn = r->Link.rc4keyOut = 0;

  if (encrypted)
    {
      clientsig[-1] = 0x06;	/* 0x08 is RTMPE as well */
      offalg = 1;
    d300:	e3a03001 	mov	r3, #1
    d304:	e58d3018 	str	r3, [sp, #24]
    d308:	e28dad4a 	add	sl, sp, #4736	; 0x1280
    d30c:	e28aa00e 	add	sl, sl, #14
    d310:	e5cae000 	strb	lr, [sl]
    d314:	e28ded4a 	add	lr, sp, #4736	; 0x1280
    d318:	e28ee00c 	add	lr, lr, #12
    d31c:	e5cec000 	strb	ip, [lr]
	  clientsig[6] = 45;
	}
      clientsig[5] = 0;
      clientsig[7] = 2;

      RTMP_Log(RTMP_LOGDEBUG, "%s: Client type: %02X", __FUNCTION__, clientsig[-1]);
    d320:	e59f2a88 	ldr	r2, [pc, #2696]	; ddb0 <HandShake.isra.11+0xb78>
      else
        {
	  clientsig[4] = 10;
	  clientsig[6] = 45;
	}
      clientsig[5] = 0;
    d324:	e28dcd4a 	add	ip, sp, #4736	; 0x1280
    d328:	e28cc00d 	add	ip, ip, #13
    d32c:	e3a06000 	mov	r6, #0
    d330:	e5cc6000 	strb	r6, [ip]
      clientsig[7] = 2;

      RTMP_Log(RTMP_LOGDEBUG, "%s: Client type: %02X", __FUNCTION__, clientsig[-1]);
    d334:	e08f2002 	add	r2, pc, r2
        {
	  clientsig[4] = 10;
	  clientsig[6] = 45;
	}
      clientsig[5] = 0;
      clientsig[7] = 2;
    d338:	e28dcd4a 	add	ip, sp, #4736	; 0x1280

      RTMP_Log(RTMP_LOGDEBUG, "%s: Client type: %02X", __FUNCTION__, clientsig[-1]);
    d33c:	e59f1a70 	ldr	r1, [pc, #2672]	; ddb4 <HandShake.isra.11+0xb7c>
    d340:	e28d3d4a 	add	r3, sp, #4736	; 0x1280
        {
	  clientsig[4] = 10;
	  clientsig[6] = 45;
	}
      clientsig[5] = 0;
      clientsig[7] = 2;
    d344:	e28cc00f 	add	ip, ip, #15

      RTMP_Log(RTMP_LOGDEBUG, "%s: Client type: %02X", __FUNCTION__, clientsig[-1]);
    d348:	e2422d2f 	sub	r2, r2, #3008	; 0xbc0
        {
	  clientsig[4] = 10;
	  clientsig[6] = 45;
	}
      clientsig[5] = 0;
      clientsig[7] = 2;
    d34c:	e3a07002 	mov	r7, #2

      RTMP_Log(RTMP_LOGDEBUG, "%s: Client type: %02X", __FUNCTION__, clientsig[-1]);
    d350:	e2833007 	add	r3, r3, #7
    d354:	e2422004 	sub	r2, r2, #4
    d358:	e5d33000 	ldrb	r3, [r3]
    d35c:	e3a00004 	mov	r0, #4
    d360:	e08f1001 	add	r1, pc, r1
        {
	  clientsig[4] = 10;
	  clientsig[6] = 45;
	}
      clientsig[5] = 0;
      clientsig[7] = 2;
    d364:	e5cc7000 	strb	r7, [ip]

      RTMP_Log(RTMP_LOGDEBUG, "%s: Client type: %02X", __FUNCTION__, clientsig[-1]);
    d368:	eb00218f 	bl	159ac <RTMP_Log>
      getdig = digoff[offalg];
    d36c:	e59f3a44 	ldr	r3, [pc, #2628]	; ddb8 <HandShake.isra.11+0xb80>
    d370:	e59d2018 	ldr	r2, [sp, #24]
    d374:	e08f3003 	add	r3, pc, r3
    d378:	e0833102 	add	r3, r3, r2, lsl #2
    d37c:	e5932330 	ldr	r2, [r3, #816]	; 0x330
      getdh  = dhoff[offalg];
    d380:	e3a0a001 	mov	sl, #1
    d384:	e5933338 	ldr	r3, [r3, #824]	; 0x338
	}
      clientsig[5] = 0;
      clientsig[7] = 2;

      RTMP_Log(RTMP_LOGDEBUG, "%s: Client type: %02X", __FUNCTION__, clientsig[-1]);
      getdig = digoff[offalg];
    d388:	e58d201c 	str	r2, [sp, #28]
      getdh  = dhoff[offalg];
    d38c:	e58d3020 	str	r3, [sp, #32]

  /* generate random data */
#ifdef _DEBUG
  memset(clientsig+8, 0, RTMP_SIG_SIZE-8);
#else
  ip = (int32_t *)(clientsig+8);
    d390:	e28d6d4a 	add	r6, sp, #4736	; 0x1280
    d394:	e2866008 	add	r6, r6, #8
  for (i = 2; i < RTMP_SIG_SIZE/4; i++)
    d398:	e28d7d62 	add	r7, sp, #6272	; 0x1880

  /* generate random data */
#ifdef _DEBUG
  memset(clientsig+8, 0, RTMP_SIG_SIZE-8);
#else
  ip = (int32_t *)(clientsig+8);
    d39c:	e286b008 	add	fp, r6, #8
  for (i = 2; i < RTMP_SIG_SIZE/4; i++)
    d3a0:	e2877008 	add	r7, r7, #8
    d3a4:	ebffdf85 	bl	51c0 <lrand48@plt>
    *ip++ = rand();
    d3a8:	e48b0004 	str	r0, [fp], #4
  /* generate random data */
#ifdef _DEBUG
  memset(clientsig+8, 0, RTMP_SIG_SIZE-8);
#else
  ip = (int32_t *)(clientsig+8);
  for (i = 2; i < RTMP_SIG_SIZE/4; i++)
    d3ac:	e15b0007 	cmp	fp, r7
    d3b0:	1afffffb 	bne	d3a4 <HandShake.isra.11+0x16c>
    *ip++ = rand();
#endif

  /* set handshake digest */
  if (FP9HandShake)
    d3b4:	e35a0000 	cmp	sl, #0
    d3b8:	0a000071 	beq	d584 <HandShake.isra.11+0x34c>
    {
      if (encrypted)
    d3bc:	e3540000 	cmp	r4, #0
    d3c0:	1a00003b 	bne	d4b4 <HandShake.isra.11+0x27c>
static int
HandShake(RTMP * r, int FP9HandShake)
{
	//LOGE("HandShake \n");
  int i, offalg = 0;
  int dhposClient = 0;
    d3c4:	e58d4028 	str	r4, [sp, #40]	; 0x28
	      LOGE("%s: Couldn't write public key!", __FUNCTION__);
	      return FALSE;
	    }
	}

      digestPosClient = getdig(clientsig, RTMP_SIG_SIZE);	/* reuse this value in verification */
    d3c8:	e3a01c06 	mov	r1, #1536	; 0x600
    d3cc:	e59d301c 	ldr	r3, [sp, #28]
    d3d0:	e1a00006 	mov	r0, r6
    d3d4:	e12fff33 	blx	r3
      RTMP_Log(RTMP_LOGDEBUG, "%s: Client digest offset: %d", __FUNCTION__,
    d3d8:	e59f79dc 	ldr	r7, [pc, #2524]	; ddbc <HandShake.isra.11+0xb84>
    d3dc:	e59f19dc 	ldr	r1, [pc, #2524]	; ddc0 <HandShake.isra.11+0xb88>
    d3e0:	e08f7007 	add	r7, pc, r7
    d3e4:	e247bd2f 	sub	fp, r7, #3008	; 0xbc0
    d3e8:	e24bb004 	sub	fp, fp, #4
    d3ec:	e1a0200b 	mov	r2, fp
    d3f0:	e08f1001 	add	r1, pc, r1
    d3f4:	e1a03000 	mov	r3, r0
	      LOGE("%s: Couldn't write public key!", __FUNCTION__);
	      return FALSE;
	    }
	}

      digestPosClient = getdig(clientsig, RTMP_SIG_SIZE);	/* reuse this value in verification */
    d3f8:	e58d0014 	str	r0, [sp, #20]
      RTMP_Log(RTMP_LOGDEBUG, "%s: Client digest offset: %d", __FUNCTION__,
    d3fc:	e3a00004 	mov	r0, #4
    d400:	eb002169 	bl	159ac <RTMP_Log>
	  digestPosClient);

      CalculateDigest(digestPosClient, clientsig, GenuineFPKey, 30,
    d404:	e59d3014 	ldr	r3, [sp, #20]
    d408:	e2472ebb 	sub	r2, r7, #2992	; 0xbb0
    d40c:	e086c003 	add	ip, r6, r3
    d410:	e58dc000 	str	ip, [sp]
    d414:	e1a00003 	mov	r0, r3
    d418:	e2422008 	sub	r2, r2, #8
    d41c:	e1a01006 	mov	r1, r6
    d420:	e3a0301e 	mov	r3, #30
    d424:	e58dc024 	str	ip, [sp, #36]	; 0x24
    d428:	ebffe84e 	bl	7568 <CalculateDigest>
		      &clientsig[digestPosClient]);

      RTMP_Log(RTMP_LOGDEBUG, "%s: Initial client digest: ", __FUNCTION__);
    d42c:	e59f1990 	ldr	r1, [pc, #2448]	; ddc4 <HandShake.isra.11+0xb8c>
    d430:	e1a0200b 	mov	r2, fp
    d434:	e3a00004 	mov	r0, #4
    d438:	e08f1001 	add	r1, pc, r1
    d43c:	eb00215a 	bl	159ac <RTMP_Log>
      RTMP_LogHex(RTMP_LOGDEBUG, clientsig + digestPosClient,
    d440:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
    d444:	e3a00004 	mov	r0, #4
    d448:	e1a0100c 	mov	r1, ip
    d44c:	e3a02020 	mov	r2, #32
    d450:	eb002165 	bl	159ec <RTMP_LogHex>
  RTMP_Log(RTMP_LOGINFO, "Clientsig: ");
  RTMP_LogHex(RTMP_LOGINFO, clientsig, RTMP_SIG_SIZE);
#endif

    
  if (!WriteN(r, (char *)clientsig-1, RTMP_SIG_SIZE + 1,0))
    d454:	e1a00009 	mov	r0, r9
    d458:	e2461001 	sub	r1, r6, #1
    d45c:	e59f2964 	ldr	r2, [pc, #2404]	; ddc8 <HandShake.isra.11+0xb90>
    d460:	ebfff73f 	bl	b164 <WriteN.isra.9>
    d464:	e2507000 	subs	r7, r0, #0
    d468:	0a00003d 	beq	d564 <HandShake.isra.11+0x32c>
  {
  RTMP_Log(RTMP_LOGINFO," WriteN failed");
    return FALSE;
  }

  if (ReadN(r, (char *)&type, 1) != 1)	/* 0x03 or 0x06 */
    d46c:	e28d3048 	add	r3, sp, #72	; 0x48
    d470:	e28d103b 	add	r1, sp, #59	; 0x3b
    d474:	e1a00009 	mov	r0, r9
    d478:	e3a02001 	mov	r2, #1
    d47c:	e58d302c 	str	r3, [sp, #44]	; 0x2c
    d480:	ebfffe8d 	bl	cebc <ReadN>
    d484:	e3500001 	cmp	r0, #1
    d488:	e1a07000 	mov	r7, r0
    d48c:	0a00003f 	beq	d590 <HandShake.isra.11+0x358>
  {
    RTMP_Log(RTMP_LOGINFO,"ReadN s0 failed");
    d490:	e59f1934 	ldr	r1, [pc, #2356]	; ddcc <HandShake.isra.11+0xb94>
    d494:	e3a00003 	mov	r0, #3
    d498:	e08f1001 	add	r1, pc, r1
    d49c:	eb002142 	bl	159ac <RTMP_Log>
    return FALSE;
    d4a0:	e3a07000 	mov	r7, #0
	}
    }

  //LOGE( "%s: Handshaking finished....", __FUNCTION__);
  return TRUE;
}
    d4a4:	e1a00007 	mov	r0, r7
    d4a8:	e28ddd62 	add	sp, sp, #6272	; 0x1880
    d4ac:	e28dd00c 	add	sp, sp, #12
    d4b0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if (FP9HandShake)
    {
      if (encrypted)
	{
	  /* generate Diffie-Hellmann parameters */
	  r->Link.dh = DHInit(1024);
    d4b4:	ebffe379 	bl	62a0 <DHInit.constprop.14>
	  if (!r->Link.dh)
    d4b8:	e3500000 	cmp	r0, #0
  if (FP9HandShake)
    {
      if (encrypted)
	{
	  /* generate Diffie-Hellmann parameters */
	  r->Link.dh = DHInit(1024);
    d4bc:	e1a07000 	mov	r7, r0
    d4c0:	e5850198 	str	r0, [r5, #408]	; 0x198
	  if (!r->Link.dh)
    d4c4:	0a00015f 	beq	da48 <HandShake.isra.11+0x810>
	      LOGE( "%s: Couldn't initialize Diffie-Hellmann!",
		  __FUNCTION__);
	      return FALSE;
	    }

	  dhposClient = getdh(clientsig, RTMP_SIG_SIZE);
    d4c8:	e3a01c06 	mov	r1, #1536	; 0x600
    d4cc:	e59d3020 	ldr	r3, [sp, #32]
    d4d0:	e1a00006 	mov	r0, r6
    d4d4:	e12fff33 	blx	r3
	  RTMP_Log(RTMP_LOGDEBUG, "%s: DH pubkey position: %d", __FUNCTION__, dhposClient);
    d4d8:	e59fb8f0 	ldr	fp, [pc, #2288]	; ddd0 <HandShake.isra.11+0xb98>
    d4dc:	e59f18f0 	ldr	r1, [pc, #2288]	; ddd4 <HandShake.isra.11+0xb9c>
    d4e0:	e08fb00b 	add	fp, pc, fp
    d4e4:	e24bbd2f 	sub	fp, fp, #3008	; 0xbc0
    d4e8:	e24bb004 	sub	fp, fp, #4
    d4ec:	e1a0200b 	mov	r2, fp
    d4f0:	e08f1001 	add	r1, pc, r1
    d4f4:	e1a03000 	mov	r3, r0
    d4f8:	e58d0014 	str	r0, [sp, #20]
    d4fc:	e3a00004 	mov	r0, #4
    d500:	eb002129 	bl	159ac <RTMP_Log>

	  if (!DHGenerateKey(r->Link.dh))
    d504:	e5950198 	ldr	r0, [r5, #408]	; 0x198
    d508:	ebffe1ca 	bl	5c38 <DHGenerateKey>
	      LOGE( "%s: Couldn't initialize Diffie-Hellmann!",
		  __FUNCTION__);
	      return FALSE;
	    }

	  dhposClient = getdh(clientsig, RTMP_SIG_SIZE);
    d50c:	e59dc014 	ldr	ip, [sp, #20]
    d510:	e58dc028 	str	ip, [sp, #40]	; 0x28
	  RTMP_Log(RTMP_LOGDEBUG, "%s: DH pubkey position: %d", __FUNCTION__, dhposClient);

	  if (!DHGenerateKey(r->Link.dh))
    d514:	e2507000 	subs	r7, r0, #0
    d518:	0a000045 	beq	d634 <HandShake.isra.11+0x3fc>
	      LOGE( "%s: Couldn't generate Diffie-Hellmann public key!",
		  __FUNCTION__);
	      return FALSE;
	    }

	  if (!DHGetPublicKey(r->Link.dh, &clientsig[dhposClient], 128))
    d51c:	e086100c 	add	r1, r6, ip
    d520:	e5950198 	ldr	r0, [r5, #408]	; 0x198
    d524:	ebffe395 	bl	6380 <DHGetPublicKey.constprop.15>
    d528:	e2507000 	subs	r7, r0, #0
    d52c:	1affffa5 	bne	d3c8 <HandShake.isra.11+0x190>
	    {
	      LOGE("%s: Couldn't write public key!", __FUNCTION__);
    d530:	e59f08a0 	ldr	r0, [pc, #2208]	; ddd8 <HandShake.isra.11+0xba0>
    d534:	e1a0100b 	mov	r1, fp
    d538:	e08f0000 	add	r0, pc, r0
    d53c:	ebffdf70 	bl	5304 <printf@plt>
    d540:	eaffffd7 	b	d4a4 <HandShake.isra.11+0x26c>
      getdig = digoff[offalg];
      getdh  = dhoff[offalg];
    }
  else
    {
      memset(&clientsig[4], 0, 4);
    d544:	e28d3d4a 	add	r3, sp, #4736	; 0x1280
    d548:	e283300c 	add	r3, r3, #12
    d54c:	e1a0a004 	mov	sl, r4

static int
HandShake(RTMP * r, int FP9HandShake)
{
	//LOGE("HandShake \n");
  int i, offalg = 0;
    d550:	e58d4018 	str	r4, [sp, #24]
  uint32_t uptime;

  uint8_t clientbuf[RTMP_SIG_SIZE + 4], *clientsig=clientbuf+4;
  uint8_t serversig[RTMP_SIG_SIZE], client2[RTMP_SIG_SIZE], *reply;
  uint8_t type;
  getoff *getdh = NULL, *getdig = NULL;
    d554:	e58d401c 	str	r4, [sp, #28]
    d558:	e58d4020 	str	r4, [sp, #32]
      getdig = digoff[offalg];
      getdh  = dhoff[offalg];
    }
  else
    {
      memset(&clientsig[4], 0, 4);
    d55c:	e5834000 	str	r4, [r3]
    d560:	eaffff8a 	b	d390 <HandShake.isra.11+0x158>
#endif

    
  if (!WriteN(r, (char *)clientsig-1, RTMP_SIG_SIZE + 1,0))
  {
  RTMP_Log(RTMP_LOGINFO," WriteN failed");
    d564:	e59f1870 	ldr	r1, [pc, #2160]	; dddc <HandShake.isra.11+0xba4>
    d568:	e3a00003 	mov	r0, #3
    d56c:	e08f1001 	add	r1, pc, r1
    d570:	eb00210d 	bl	159ac <RTMP_Log>
	}
    }

  //LOGE( "%s: Handshaking finished....", __FUNCTION__);
  return TRUE;
}
    d574:	e1a00007 	mov	r0, r7
    d578:	e28ddd62 	add	sp, sp, #6272	; 0x1880
    d57c:	e28dd00c 	add	sp, sp, #12
    d580:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
HandShake(RTMP * r, int FP9HandShake)
{
	//LOGE("HandShake \n");
  int i, offalg = 0;
  int dhposClient = 0;
  int digestPosClient = 0;
    d584:	e58da014 	str	sl, [sp, #20]
static int
HandShake(RTMP * r, int FP9HandShake)
{
	//LOGE("HandShake \n");
  int i, offalg = 0;
  int dhposClient = 0;
    d588:	e58da028 	str	sl, [sp, #40]	; 0x28
    d58c:	eaffffb0 	b	d454 <HandShake.isra.11+0x21c>
  {
    RTMP_Log(RTMP_LOGINFO,"ReadN s0 failed");
    return FALSE;
  }

  RTMP_Log(RTMP_LOGINFO, "%s: Type Answer   : %02X", __FUNCTION__, type);
    d590:	e59fb848 	ldr	fp, [pc, #2120]	; dde0 <HandShake.isra.11+0xba8>
    d594:	e59f1848 	ldr	r1, [pc, #2120]	; dde4 <HandShake.isra.11+0xbac>
    d598:	e08fb00b 	add	fp, pc, fp
    d59c:	e24bbd2f 	sub	fp, fp, #3008	; 0xbc0
    d5a0:	e24bb004 	sub	fp, fp, #4
    d5a4:	e1a0200b 	mov	r2, fp
    d5a8:	e558384d 	ldrb	r3, [r8, #-2125]	; 0xfffff7b3
    d5ac:	e3a00003 	mov	r0, #3
    d5b0:	e08f1001 	add	r1, pc, r1
    d5b4:	eb0020fc 	bl	159ac <RTMP_Log>

  if (type != clientsig[-1])
    d5b8:	e28d3d4a 	add	r3, sp, #4736	; 0x1280
    d5bc:	e2833007 	add	r3, r3, #7
    d5c0:	e5d33000 	ldrb	r3, [r3]
    d5c4:	e558284d 	ldrb	r2, [r8, #-2125]	; 0xfffff7b3
    d5c8:	e1530002 	cmp	r3, r2
    d5cc:	0a000005 	beq	d5e8 <HandShake.isra.11+0x3b0>
    RTMP_Log(RTMP_LOGINFO, "%s: Type mismatch: client sent %d, server answered %d",
    d5d0:	e59f1810 	ldr	r1, [pc, #2064]	; dde8 <HandShake.isra.11+0xbb0>
    d5d4:	e58d2000 	str	r2, [sp]
    d5d8:	e3a00003 	mov	r0, #3
    d5dc:	e1a0200b 	mov	r2, fp
    d5e0:	e08f1001 	add	r1, pc, r1
    d5e4:	eb0020f0 	bl	159ac <RTMP_Log>
	__FUNCTION__, clientsig[-1], type);

  if (ReadN(r, (char *)serversig, RTMP_SIG_SIZE) != RTMP_SIG_SIZE)
    d5e8:	e28d3088 	add	r3, sp, #136	; 0x88
    d5ec:	e58d3034 	str	r3, [sp, #52]	; 0x34
    d5f0:	e28d3084 	add	r3, sp, #132	; 0x84
    d5f4:	e1a01003 	mov	r1, r3
    d5f8:	e1a00009 	mov	r0, r9
    d5fc:	e3a02c06 	mov	r2, #1536	; 0x600
    d600:	e58d3024 	str	r3, [sp, #36]	; 0x24
    d604:	ebfffe2c 	bl	cebc <ReadN>
    d608:	e3500c06 	cmp	r0, #1536	; 0x600
    d60c:	0a000010 	beq	d654 <HandShake.isra.11+0x41c>
  {
    RTMP_Log(RTMP_LOGINFO,"ReadN S1 failed");
    d610:	e59f17d4 	ldr	r1, [pc, #2004]	; ddec <HandShake.isra.11+0xbb4>
    d614:	e3a00003 	mov	r0, #3
    d618:	e08f1001 	add	r1, pc, r1
    d61c:	eb0020e2 	bl	159ac <RTMP_Log>
    return FALSE;
    d620:	e3a07000 	mov	r7, #0
	}
    }

  //LOGE( "%s: Handshaking finished....", __FUNCTION__);
  return TRUE;
}
    d624:	e1a00007 	mov	r0, r7
    d628:	e28ddd62 	add	sp, sp, #6272	; 0x1880
    d62c:	e28dd00c 	add	sp, sp, #12
    d630:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
	  dhposClient = getdh(clientsig, RTMP_SIG_SIZE);
	  RTMP_Log(RTMP_LOGDEBUG, "%s: DH pubkey position: %d", __FUNCTION__, dhposClient);

	  if (!DHGenerateKey(r->Link.dh))
	    {
	      LOGE( "%s: Couldn't generate Diffie-Hellmann public key!",
    d634:	e59f07b4 	ldr	r0, [pc, #1972]	; ddf0 <HandShake.isra.11+0xbb8>
    d638:	e1a0100b 	mov	r1, fp
    d63c:	e08f0000 	add	r0, pc, r0
    d640:	ebffdf2f 	bl	5304 <printf@plt>
	}
    }

  //LOGE( "%s: Handshaking finished....", __FUNCTION__);
  return TRUE;
}
    d644:	e1a00007 	mov	r0, r7
    d648:	e28ddd62 	add	sp, sp, #6272	; 0x1880
    d64c:	e28dd00c 	add	sp, sp, #12
    d650:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return FALSE;
  }

  /* decode server response */
  memcpy(&uptime, serversig, 4);
  uptime = ntohl(uptime);
    d654:	e5182804 	ldr	r2, [r8, #-2052]	; 0xfffff7fc

  RTMP_Log(RTMP_LOGINFO, "%s: Server Uptime : %d", __FUNCTION__, uptime);
    d658:	e59fb794 	ldr	fp, [pc, #1940]	; ddf4 <HandShake.isra.11+0xbbc>
    return FALSE;
  }

  /* decode server response */
  memcpy(&uptime, serversig, 4);
  uptime = ntohl(uptime);
    d65c:	e0223862 	eor	r3, r2, r2, ror #16

  RTMP_Log(RTMP_LOGINFO, "%s: Server Uptime : %d", __FUNCTION__, uptime);
    d660:	e08fb00b 	add	fp, pc, fp
    return FALSE;
  }

  /* decode server response */
  memcpy(&uptime, serversig, 4);
  uptime = ntohl(uptime);
    d664:	e1a03423 	lsr	r3, r3, #8

  RTMP_Log(RTMP_LOGINFO, "%s: Server Uptime : %d", __FUNCTION__, uptime);
    d668:	e24bbd2f 	sub	fp, fp, #3008	; 0xbc0
    d66c:	e59f1784 	ldr	r1, [pc, #1924]	; ddf8 <HandShake.isra.11+0xbc0>
    d670:	e24bb004 	sub	fp, fp, #4
    return FALSE;
  }

  /* decode server response */
  memcpy(&uptime, serversig, 4);
  uptime = ntohl(uptime);
    d674:	e3c33cff 	bic	r3, r3, #65280	; 0xff00

  RTMP_Log(RTMP_LOGINFO, "%s: Server Uptime : %d", __FUNCTION__, uptime);
    d678:	e0233462 	eor	r3, r3, r2, ror #8
    d67c:	e3a00003 	mov	r0, #3
    d680:	e1a0200b 	mov	r2, fp
    d684:	e08f1001 	add	r1, pc, r1
    d688:	eb0020c7 	bl	159ac <RTMP_Log>
  RTMP_Log(RTMP_LOGINFO, "%s: FMS Version   : %d.%d.%d.%d", __FUNCTION__, serversig[4],
    d68c:	e55807fe 	ldrb	r0, [r8, #-2046]	; 0xfffff802
    d690:	e55817fd 	ldrb	r1, [r8, #-2045]	; 0xfffff803
    d694:	e5583800 	ldrb	r3, [r8, #-2048]	; 0xfffff800
    d698:	e558c7ff 	ldrb	ip, [r8, #-2047]	; 0xfffff801
    d69c:	e98d0003 	stmib	sp, {r0, r1}
    d6a0:	e59f1754 	ldr	r1, [pc, #1876]	; ddfc <HandShake.isra.11+0xbc4>
    d6a4:	e1a0200b 	mov	r2, fp
    d6a8:	e58dc000 	str	ip, [sp]
    d6ac:	e3a00003 	mov	r0, #3
    d6b0:	e08f1001 	add	r1, pc, r1
    d6b4:	eb0020bc 	bl	159ac <RTMP_Log>
      serversig[5], serversig[6], serversig[7]);

  if (FP9HandShake && type == 3 && !serversig[4])
    d6b8:	e35a0000 	cmp	sl, #0
    d6bc:	0a000059 	beq	d828 <HandShake.isra.11+0x5f0>
    d6c0:	e558384d 	ldrb	r3, [r8, #-2125]	; 0xfffff7b3
    d6c4:	e3530003 	cmp	r3, #3
    d6c8:	0a000053 	beq	d81c <HandShake.isra.11+0x5e4>
    {
      uint8_t digestResp[SHA256_DIGEST_LENGTH];
      uint8_t *signatureResp = NULL;

      /* we have to use this signature now to find the correct algorithms for getting the digest and DH positions */
      int digestPosServer = getdig(serversig, RTMP_SIG_SIZE);
    d6cc:	e3a01c06 	mov	r1, #1536	; 0x600
    d6d0:	e59d301c 	ldr	r3, [sp, #28]
    d6d4:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
    d6d8:	e12fff33 	blx	r3

      if (!VerifyDigest(digestPosServer, serversig, GenuineFMSKey, 36))
    d6dc:	e59fb71c 	ldr	fp, [pc, #1820]	; de00 <HandShake.isra.11+0xbc8>
    d6e0:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
    d6e4:	e08fb00b 	add	fp, pc, fp
    d6e8:	e24bbeb7 	sub	fp, fp, #2928	; 0xb70
    d6ec:	e24bb008 	sub	fp, fp, #8
    d6f0:	e1a0200b 	mov	r2, fp
    d6f4:	e3a03024 	mov	r3, #36	; 0x24
    {
      uint8_t digestResp[SHA256_DIGEST_LENGTH];
      uint8_t *signatureResp = NULL;

      /* we have to use this signature now to find the correct algorithms for getting the digest and DH positions */
      int digestPosServer = getdig(serversig, RTMP_SIG_SIZE);
    d6f8:	e1a0a000 	mov	sl, r0

      if (!VerifyDigest(digestPosServer, serversig, GenuineFMSKey, 36))
    d6fc:	ebffe7b7 	bl	75e0 <VerifyDigest>
    d700:	e3500000 	cmp	r0, #0
    {
      uint8_t digestResp[SHA256_DIGEST_LENGTH];
      uint8_t *signatureResp = NULL;

      /* we have to use this signature now to find the correct algorithms for getting the digest and DH positions */
      int digestPosServer = getdig(serversig, RTMP_SIG_SIZE);
    d704:	158da030 	strne	sl, [sp, #48]	; 0x30

      if (!VerifyDigest(digestPosServer, serversig, GenuineFMSKey, 36))
    d708:	0a000136 	beq	dbe8 <HandShake.isra.11+0x9b0>
	      return FALSE;
	    }
	}

      /* generate SWFVerification token (SHA256 HMAC hash of decompressed SWF, key are the last 32 bytes of the server handshake) */
      if (r->Link.SWFSize)
    d70c:	e59531a4 	ldr	r3, [r5, #420]	; 0x1a4
    d710:	e3530000 	cmp	r3, #0
    d714:	1a00010e 	bne	db54 <HandShake.isra.11+0x91c>
    d718:	e28d3d32 	add	r3, sp, #3200	; 0xc80
    d71c:	e2833004 	add	r3, r3, #4
    d720:	e58d3018 	str	r3, [sp, #24]
		     SHA256_DIGEST_LENGTH,
		     (uint8_t *)&r->Link.SWFVerificationResponse[10]);
	}

      /* do Diffie-Hellmann Key exchange for encrypted RTMP */
      if (encrypted)
    d724:	e3540000 	cmp	r4, #0
    d728:	1a000149 	bne	dc54 <HandShake.isra.11+0xa1c>
static int
HandShake(RTMP * r, int FP9HandShake)
{
	//LOGE("HandShake \n");
  int i, offalg = 0;
  int dhposClient = 0;
    d72c:	e28dbd1a 	add	fp, sp, #1664	; 0x680
    d730:	e28bb008 	add	fp, fp, #8
    d734:	e24b3004 	sub	r3, fp, #4
    d738:	e1a0b003 	mov	fp, r3
      reply = client2;
#ifdef _DEBUG
      memset(reply, 0xff, RTMP_SIG_SIZE);
#else
      ip = (int32_t *)reply;
      for (i = 0; i < RTMP_SIG_SIZE/4; i++)
    d73c:	e283ac06 	add	sl, r3, #1536	; 0x600
static int
HandShake(RTMP * r, int FP9HandShake)
{
	//LOGE("HandShake \n");
  int i, offalg = 0;
  int dhposClient = 0;
    d740:	e58d301c 	str	r3, [sp, #28]
    d744:	ebffde9d 	bl	51c0 <lrand48@plt>
#ifdef _DEBUG
      memset(reply, 0xff, RTMP_SIG_SIZE);
#else
      ip = (int32_t *)reply;
      for (i = 0; i < RTMP_SIG_SIZE/4; i++)
        *ip++ = rand();
    d748:	e48b0004 	str	r0, [fp], #4
      reply = client2;
#ifdef _DEBUG
      memset(reply, 0xff, RTMP_SIG_SIZE);
#else
      ip = (int32_t *)reply;
      for (i = 0; i < RTMP_SIG_SIZE/4; i++)
    d74c:	e15b000a 	cmp	fp, sl
    d750:	1afffffb 	bne	d744 <HandShake.isra.11+0x50c>
        *ip++ = rand();
#endif
      /* calculate response now */
      signatureResp = reply+RTMP_SIG_SIZE-SHA256_DIGEST_LENGTH;

      HMACsha256(&serversig[digestPosServer], SHA256_DIGEST_LENGTH,
    d754:	e59fa6a8 	ldr	sl, [pc, #1704]	; de04 <HandShake.isra.11+0xbcc>
    d758:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    d75c:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
    d760:	e08fa00a 	add	sl, pc, sl
    d764:	e59db018 	ldr	fp, [sp, #24]
    d768:	e24a2ebb 	sub	r2, sl, #2992	; 0xbb0
    d76c:	e0830001 	add	r0, r3, r1
    d770:	e2422008 	sub	r2, r2, #8
    d774:	e3a01020 	mov	r1, #32
    d778:	e3a0303e 	mov	r3, #62	; 0x3e
    d77c:	e58db000 	str	fp, [sp]
    d780:	ebffe19d 	bl	5dfc <HMACsha256>
		 GenuineFPKey, sizeof(GenuineFPKey), digestResp);
      HMACsha256(reply, RTMP_SIG_SIZE - SHA256_DIGEST_LENGTH, digestResp,
    d784:	e59d001c 	ldr	r0, [sp, #28]
    d788:	e3a01e5e 	mov	r1, #1504	; 0x5e0
    d78c:	e2803e5e 	add	r3, r0, #1504	; 0x5e0
    d790:	e58d3000 	str	r3, [sp]
    d794:	e1a0200b 	mov	r2, fp
    d798:	e3a03020 	mov	r3, #32
    d79c:	ebffe196 	bl	5dfc <HMACsha256>
		 SHA256_DIGEST_LENGTH, signatureResp);

      /* some info output */
      RTMP_Log(RTMP_LOGDEBUG,
    d7a0:	e59f1660 	ldr	r1, [pc, #1632]	; de08 <HandShake.isra.11+0xbd0>
    d7a4:	e24a2d2f 	sub	r2, sl, #3008	; 0xbc0
    d7a8:	e2422004 	sub	r2, r2, #4
    d7ac:	e3a00004 	mov	r0, #4
    d7b0:	e08f1001 	add	r1, pc, r1
    d7b4:	eb00207c 	bl	159ac <RTMP_Log>
	  "%s: Calculated digest key from secure key and server digest: ",
	  __FUNCTION__);
      RTMP_LogHex(RTMP_LOGDEBUG, digestResp, SHA256_DIGEST_LENGTH);
    d7b8:	e3a00004 	mov	r0, #4
    d7bc:	e1a0100b 	mov	r1, fp
    d7c0:	e3a02020 	mov	r2, #32
    d7c4:	eb002088 	bl	159ec <RTMP_LogHex>

#ifdef FP10
      if (type == 8 )
    d7c8:	e558384d 	ldrb	r3, [r8, #-2125]	; 0xfffff7b3
    d7cc:	e3530008 	cmp	r3, #8
    d7d0:	0a0000bd 	beq	dacc <HandShake.isra.11+0x894>
	  uint8_t *sig = signatureResp;
	  /* encrypt signatureResp */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
	    rtmpe8_sig(sig+i, sig+i, dptr[i] % 15);
        }
      else if (type == 9)
    d7d4:	e3530009 	cmp	r3, #9
    d7d8:	0a0000a7 	beq	da7c <HandShake.isra.11+0x844>
	  /* encrypt signatureResp */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
            rtmpe9_sig(sig+i, sig+i, dptr[i] % 15);
        }
#endif
      RTMP_Log(RTMP_LOGDEBUG, "%s: Client signature calculated:", __FUNCTION__);
    d7dc:	e59f2628 	ldr	r2, [pc, #1576]	; de0c <HandShake.isra.11+0xbd4>
    d7e0:	e59f1628 	ldr	r1, [pc, #1576]	; de10 <HandShake.isra.11+0xbd8>
    d7e4:	e08f2002 	add	r2, pc, r2
    d7e8:	e2422d2f 	sub	r2, r2, #3008	; 0xbc0
    d7ec:	e3a00004 	mov	r0, #4
    d7f0:	e2422004 	sub	r2, r2, #4
    d7f4:	e08f1001 	add	r1, pc, r1
    d7f8:	eb00206b 	bl	159ac <RTMP_Log>
      RTMP_LogHex(RTMP_LOGDEBUG, signatureResp, SHA256_DIGEST_LENGTH);
    d7fc:	e59db01c 	ldr	fp, [sp, #28]
    d800:	e3a00004 	mov	r0, #4
    d804:	e28b1e5e 	add	r1, fp, #1504	; 0x5e0
    d808:	e3a02020 	mov	r2, #32
    d80c:	eb002076 	bl	159ec <RTMP_LogHex>
    d810:	e3a0a001 	mov	sl, #1
			    (uint8_t *) & clientsig[dhposClient],
			    &keyIn, &keyOut);
	}


      reply = client2;
    d814:	e1a0100b 	mov	r1, fp
    d818:	ea000003 	b	d82c <HandShake.isra.11+0x5f4>

  RTMP_Log(RTMP_LOGINFO, "%s: Server Uptime : %d", __FUNCTION__, uptime);
  RTMP_Log(RTMP_LOGINFO, "%s: FMS Version   : %d.%d.%d.%d", __FUNCTION__, serversig[4],
      serversig[5], serversig[6], serversig[7]);

  if (FP9HandShake && type == 3 && !serversig[4])
    d81c:	e558a800 	ldrb	sl, [r8, #-2048]	; 0xfffff800
    d820:	e35a0000 	cmp	sl, #0
    d824:	1affffa8 	bne	d6cc <HandShake.isra.11+0x494>
      RTMP_Log(RTMP_LOGDEBUG, "%s: Client signature calculated:", __FUNCTION__);
      RTMP_LogHex(RTMP_LOGDEBUG, signatureResp, SHA256_DIGEST_LENGTH);
    }
  else
    {
      reply = serversig;
    d828:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
#ifdef _DEBUG
  RTMP_Log(RTMP_LOGDEBUG, "%s: Sending handshake response: ",
    __FUNCTION__);
  RTMP_LogHex(RTMP_LOGDEBUG, reply, RTMP_SIG_SIZE);
#endif
  if (!WriteN(r, (char *)reply, RTMP_SIG_SIZE,0))
    d82c:	e1a00009 	mov	r0, r9
    d830:	e3a02c06 	mov	r2, #1536	; 0x600
    d834:	ebfff64a 	bl	b164 <WriteN.isra.9>
    d838:	e2503000 	subs	r3, r0, #0
    d83c:	0a00007c 	beq	da34 <HandShake.isra.11+0x7fc>
    LOGE(" WriteN C3 failed");
    return FALSE;
  }

  /* 2nd part of handshake */
  if (ReadN(r, (char *)serversig, RTMP_SIG_SIZE) != RTMP_SIG_SIZE)
    d840:	e3a02c06 	mov	r2, #1536	; 0x600
    d844:	e1a00009 	mov	r0, r9
    d848:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
    d84c:	ebfffd9a 	bl	cebc <ReadN>
    d850:	e3500c06 	cmp	r0, #1536	; 0x600
    d854:	e1a02000 	mov	r2, r0
    d858:	1a000082 	bne	da68 <HandShake.isra.11+0x830>
#ifdef _DEBUG
  RTMP_Log(RTMP_LOGDEBUG, "%s: 2nd handshake: ", __FUNCTION__);
  RTMP_LogHex(RTMP_LOGDEBUG, serversig, RTMP_SIG_SIZE);
#endif

  if (FP9HandShake)
    d85c:	e35a0000 	cmp	sl, #0
    d860:	0a0000ad 	beq	db1c <HandShake.isra.11+0x8e4>
    {
      uint8_t signature[SHA256_DIGEST_LENGTH];
      uint8_t digest[SHA256_DIGEST_LENGTH];

      if (serversig[4] == 0 && serversig[5] == 0 && serversig[6] == 0
    d864:	e5583800 	ldrb	r3, [r8, #-2048]	; 0xfffff800
    d868:	e3530000 	cmp	r3, #0
    d86c:	1a000010 	bne	d8b4 <HandShake.isra.11+0x67c>
    d870:	e55837ff 	ldrb	r3, [r8, #-2047]	; 0xfffff801
    d874:	e3530000 	cmp	r3, #0
    d878:	1a00000d 	bne	d8b4 <HandShake.isra.11+0x67c>
    d87c:	e55837fe 	ldrb	r3, [r8, #-2046]	; 0xfffff802
    d880:	e3530000 	cmp	r3, #0
    d884:	1a00000a 	bne	d8b4 <HandShake.isra.11+0x67c>
	  && serversig[7] == 0)
    d888:	e55837fd 	ldrb	r3, [r8, #-2045]	; 0xfffff803
    d88c:	e3530000 	cmp	r3, #0
    d890:	1a000007 	bne	d8b4 <HandShake.isra.11+0x67c>
	{
	  RTMP_Log(RTMP_LOGDEBUG,
    d894:	e59f2578 	ldr	r2, [pc, #1400]	; de14 <HandShake.isra.11+0xbdc>
    d898:	e59f1578 	ldr	r1, [pc, #1400]	; de18 <HandShake.isra.11+0xbe0>
    d89c:	e08f2002 	add	r2, pc, r2
    d8a0:	e2422d2f 	sub	r2, r2, #3008	; 0xbc0
    d8a4:	e3a00004 	mov	r0, #4
    d8a8:	e2422004 	sub	r2, r2, #4
    d8ac:	e08f1001 	add	r1, pc, r1
    d8b0:	eb00203d 	bl	159ac <RTMP_Log>
	      "%s: Wait, did the server just refuse signed authentication?",
	      __FUNCTION__);
	}
      RTMP_Log(RTMP_LOGDEBUG, "%s: Server sent signature:", __FUNCTION__);
    d8b4:	e59f9560 	ldr	r9, [pc, #1376]	; de1c <HandShake.isra.11+0xbe4>
    d8b8:	e59f1560 	ldr	r1, [pc, #1376]	; de20 <HandShake.isra.11+0xbe8>
    d8bc:	e08f9009 	add	r9, pc, r9
    d8c0:	e249bd2f 	sub	fp, r9, #3008	; 0xbc0
    d8c4:	e24bb004 	sub	fp, fp, #4
    d8c8:	e3a00004 	mov	r0, #4
    d8cc:	e1a0200b 	mov	r2, fp
    d8d0:	e08f1001 	add	r1, pc, r1
    d8d4:	eb002034 	bl	159ac <RTMP_Log>
      RTMP_LogHex(RTMP_LOGDEBUG, &serversig[RTMP_SIG_SIZE - SHA256_DIGEST_LENGTH],
    d8d8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
	     SHA256_DIGEST_LENGTH);

      /* verify server response */
      HMACsha256(&clientsig[digestPosClient], SHA256_DIGEST_LENGTH,
    d8dc:	e59dc034 	ldr	ip, [sp, #52]	; 0x34
	  RTMP_Log(RTMP_LOGDEBUG,
	      "%s: Wait, did the server just refuse signed authentication?",
	      __FUNCTION__);
	}
      RTMP_Log(RTMP_LOGDEBUG, "%s: Server sent signature:", __FUNCTION__);
      RTMP_LogHex(RTMP_LOGDEBUG, &serversig[RTMP_SIG_SIZE - SHA256_DIGEST_LENGTH],
    d8e0:	e2831e5e 	add	r1, r3, #1504	; 0x5e0
    d8e4:	e3a00004 	mov	r0, #4
    d8e8:	e3a02020 	mov	r2, #32
	     SHA256_DIGEST_LENGTH);

      /* verify server response */
      HMACsha256(&clientsig[digestPosClient], SHA256_DIGEST_LENGTH,
    d8ec:	e24ca024 	sub	sl, ip, #36	; 0x24
	  RTMP_Log(RTMP_LOGDEBUG,
	      "%s: Wait, did the server just refuse signed authentication?",
	      __FUNCTION__);
	}
      RTMP_Log(RTMP_LOGDEBUG, "%s: Server sent signature:", __FUNCTION__);
      RTMP_LogHex(RTMP_LOGDEBUG, &serversig[RTMP_SIG_SIZE - SHA256_DIGEST_LENGTH],
    d8f0:	eb00203d 	bl	159ec <RTMP_LogHex>
	     SHA256_DIGEST_LENGTH);

      /* verify server response */
      HMACsha256(&clientsig[digestPosClient], SHA256_DIGEST_LENGTH,
		 GenuineFMSKey, sizeof(GenuineFMSKey), digest);
      HMACsha256(serversig, RTMP_SIG_SIZE - SHA256_DIGEST_LENGTH, digest,
    d8f4:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
      RTMP_Log(RTMP_LOGDEBUG, "%s: Server sent signature:", __FUNCTION__);
      RTMP_LogHex(RTMP_LOGDEBUG, &serversig[RTMP_SIG_SIZE - SHA256_DIGEST_LENGTH],
	     SHA256_DIGEST_LENGTH);

      /* verify server response */
      HMACsha256(&clientsig[digestPosClient], SHA256_DIGEST_LENGTH,
    d8f8:	e2492eb7 	sub	r2, r9, #2928	; 0xb70
		 GenuineFMSKey, sizeof(GenuineFMSKey), digest);
      HMACsha256(serversig, RTMP_SIG_SIZE - SHA256_DIGEST_LENGTH, digest,
    d8fc:	e2419004 	sub	r9, r1, #4
      RTMP_Log(RTMP_LOGDEBUG, "%s: Server sent signature:", __FUNCTION__);
      RTMP_LogHex(RTMP_LOGDEBUG, &serversig[RTMP_SIG_SIZE - SHA256_DIGEST_LENGTH],
	     SHA256_DIGEST_LENGTH);

      /* verify server response */
      HMACsha256(&clientsig[digestPosClient], SHA256_DIGEST_LENGTH,
    d900:	e59d1014 	ldr	r1, [sp, #20]
    d904:	e2422008 	sub	r2, r2, #8
    d908:	e0860001 	add	r0, r6, r1
    d90c:	e3a03044 	mov	r3, #68	; 0x44
    d910:	e3a01020 	mov	r1, #32
    d914:	e58da000 	str	sl, [sp]
    d918:	ebffe137 	bl	5dfc <HMACsha256>
		 GenuineFMSKey, sizeof(GenuineFMSKey), digest);
      HMACsha256(serversig, RTMP_SIG_SIZE - SHA256_DIGEST_LENGTH, digest,
    d91c:	e3a03020 	mov	r3, #32
    d920:	e1a0200a 	mov	r2, sl
    d924:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
    d928:	e3a01e5e 	mov	r1, #1504	; 0x5e0
    d92c:	e58d9000 	str	r9, [sp]
    d930:	ebffe131 	bl	5dfc <HMACsha256>
		 SHA256_DIGEST_LENGTH, signature);

      /* show some information */
      RTMP_Log(RTMP_LOGDEBUG, "%s: Digest key: ", __FUNCTION__);
    d934:	e59f14e8 	ldr	r1, [pc, #1256]	; de24 <HandShake.isra.11+0xbec>
    d938:	e1a0200b 	mov	r2, fp
    d93c:	e3a00004 	mov	r0, #4
    d940:	e08f1001 	add	r1, pc, r1
    d944:	eb002018 	bl	159ac <RTMP_Log>
      RTMP_LogHex(RTMP_LOGDEBUG, digest, SHA256_DIGEST_LENGTH);
    d948:	e1a0100a 	mov	r1, sl
    d94c:	e3a00004 	mov	r0, #4
    d950:	e3a02020 	mov	r2, #32
    d954:	eb002024 	bl	159ec <RTMP_LogHex>

#ifdef FP10
      if (type == 8 )
    d958:	e558384d 	ldrb	r3, [r8, #-2125]	; 0xfffff7b3
    d95c:	e3530008 	cmp	r3, #8
    d960:	0a0000f8 	beq	dd48 <HandShake.isra.11+0xb10>
	  uint8_t *sig = signature;
	  /* encrypt signature */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
	    rtmpe8_sig(sig+i, sig+i, dptr[i] % 15);
        }
      else if (type == 9)
    d964:	e3530009 	cmp	r3, #9
    d968:	0a0000e7 	beq	dd0c <HandShake.isra.11+0xad4>
	  /* encrypt signatureResp */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
            rtmpe9_sig(sig+i, sig+i, dptr[i] % 15);
        }
#endif
      RTMP_Log(RTMP_LOGDEBUG, "%s: Signature calculated:", __FUNCTION__);
    d96c:	e59f64b4 	ldr	r6, [pc, #1204]	; de28 <HandShake.isra.11+0xbf0>
    d970:	e59f14b4 	ldr	r1, [pc, #1204]	; de2c <HandShake.isra.11+0xbf4>
    d974:	e08f6006 	add	r6, pc, r6
    d978:	e2466d2f 	sub	r6, r6, #3008	; 0xbc0
    d97c:	e2466004 	sub	r6, r6, #4
    d980:	e3a00004 	mov	r0, #4
    d984:	e1a02006 	mov	r2, r6
    d988:	e08f1001 	add	r1, pc, r1
    d98c:	eb002006 	bl	159ac <RTMP_Log>
      RTMP_LogHex(RTMP_LOGDEBUG, signature, SHA256_DIGEST_LENGTH);
    d990:	e3a00004 	mov	r0, #4
    d994:	e1a01009 	mov	r1, r9
    d998:	e3a02020 	mov	r2, #32
    d99c:	eb002012 	bl	159ec <RTMP_LogHex>
      if (memcmp
    d9a0:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    d9a4:	e1a00009 	mov	r0, r9
    d9a8:	e2831e5e 	add	r1, r3, #1504	; 0x5e0
    d9ac:	e3a02020 	mov	r2, #32
    d9b0:	ebffde08 	bl	51d8 <memcmp@plt>
    d9b4:	e3500000 	cmp	r0, #0
    d9b8:	1a0000f1 	bne	dd84 <HandShake.isra.11+0xb4c>
	  LOGE( "%s: Server not genuine Adobe!", __FUNCTION__);
	  return FALSE;
	}
      else
	{
	  RTMP_Log(RTMP_LOGDEBUG, "%s: Genuine Adobe Flash Media Server", __FUNCTION__);
    d9bc:	e59f146c 	ldr	r1, [pc, #1132]	; de30 <HandShake.isra.11+0xbf8>
    d9c0:	e1a02006 	mov	r2, r6
    d9c4:	e3a00004 	mov	r0, #4
    d9c8:	e08f1001 	add	r1, pc, r1
    d9cc:	eb001ff6 	bl	159ac <RTMP_Log>
	}

      if (encrypted)
    d9d0:	e3540000 	cmp	r4, #0
    d9d4:	0afffeb2 	beq	d4a4 <HandShake.isra.11+0x26c>
	{
	  char buff[RTMP_SIG_SIZE];
	  /* set keys for encryption from now on */
	  r->Link.rc4keyIn = keyIn;
    d9d8:	e518084c 	ldr	r0, [r8, #-2124]	; 0xfffff7b4
	  r->Link.rc4keyOut = keyOut;
    d9dc:	e5183848 	ldr	r3, [r8, #-2120]	; 0xfffff7b8


	  /* update the keystreams */
	  if (r->Link.rc4keyIn)
    d9e0:	e3500000 	cmp	r0, #0

      if (encrypted)
	{
	  char buff[RTMP_SIG_SIZE];
	  /* set keys for encryption from now on */
	  r->Link.rc4keyIn = keyIn;
    d9e4:	e585019c 	str	r0, [r5, #412]	; 0x19c
	  r->Link.rc4keyOut = keyOut;
    d9e8:	e58531a0 	str	r3, [r5, #416]	; 0x1a0


	  /* update the keystreams */
	  if (r->Link.rc4keyIn)
    d9ec:	01a00003 	moveq	r0, r3
    d9f0:	0a000006 	beq	da10 <HandShake.isra.11+0x7d8>
	    {
	      RC4_encrypt(r->Link.rc4keyIn, RTMP_SIG_SIZE, (uint8_t *) buff);
    d9f4:	e28d2d32 	add	r2, sp, #3200	; 0xc80
    d9f8:	e2822008 	add	r2, r2, #8
    d9fc:	e2422004 	sub	r2, r2, #4
    da00:	e1a03002 	mov	r3, r2
    da04:	e3a01c06 	mov	r1, #1536	; 0x600
    da08:	ebffde9a 	bl	5478 <arc4_crypt@plt>
    da0c:	e59501a0 	ldr	r0, [r5, #416]	; 0x1a0
	    }

	  if (r->Link.rc4keyOut)
    da10:	e3500000 	cmp	r0, #0
    da14:	0afffea2 	beq	d4a4 <HandShake.isra.11+0x26c>
	    {
	      RC4_encrypt(r->Link.rc4keyOut, RTMP_SIG_SIZE, (uint8_t *) buff);
    da18:	e28d2d32 	add	r2, sp, #3200	; 0xc80
    da1c:	e2822008 	add	r2, r2, #8
    da20:	e2422004 	sub	r2, r2, #4
    da24:	e1a03002 	mov	r3, r2
    da28:	e3a01c06 	mov	r1, #1536	; 0x600
    da2c:	ebffde91 	bl	5478 <arc4_crypt@plt>
    da30:	eafffe9b 	b	d4a4 <HandShake.isra.11+0x26c>
    __FUNCTION__);
  RTMP_LogHex(RTMP_LOGDEBUG, reply, RTMP_SIG_SIZE);
#endif
  if (!WriteN(r, (char *)reply, RTMP_SIG_SIZE,0))
  {
    LOGE(" WriteN C3 failed");
    da34:	e59f03f8 	ldr	r0, [pc, #1016]	; de34 <HandShake.isra.11+0xbfc>
    return FALSE;
    da38:	e1a07003 	mov	r7, r3
    __FUNCTION__);
  RTMP_LogHex(RTMP_LOGDEBUG, reply, RTMP_SIG_SIZE);
#endif
  if (!WriteN(r, (char *)reply, RTMP_SIG_SIZE,0))
  {
    LOGE(" WriteN C3 failed");
    da3c:	e08f0000 	add	r0, pc, r0
    da40:	ebffde02 	bl	5250 <puts@plt>
    da44:	eafffe96 	b	d4a4 <HandShake.isra.11+0x26c>
	{
	  /* generate Diffie-Hellmann parameters */
	  r->Link.dh = DHInit(1024);
	  if (!r->Link.dh)
	    {
	      LOGE( "%s: Couldn't initialize Diffie-Hellmann!",
    da48:	e59f13e8 	ldr	r1, [pc, #1000]	; de38 <HandShake.isra.11+0xc00>
    da4c:	e59f03e8 	ldr	r0, [pc, #1000]	; de3c <HandShake.isra.11+0xc04>
    da50:	e08f1001 	add	r1, pc, r1
    da54:	e2411d2f 	sub	r1, r1, #3008	; 0xbc0
    da58:	e2411004 	sub	r1, r1, #4
    da5c:	e08f0000 	add	r0, pc, r0
    da60:	ebffde27 	bl	5304 <printf@plt>
    da64:	eafffe8e 	b	d4a4 <HandShake.isra.11+0x26c>
  }

  /* 2nd part of handshake */
  if (ReadN(r, (char *)serversig, RTMP_SIG_SIZE) != RTMP_SIG_SIZE)
  {
    LOGE("ReadN S3 failed");
    da68:	e59f03d0 	ldr	r0, [pc, #976]	; de40 <HandShake.isra.11+0xc08>
    da6c:	e08f0000 	add	r0, pc, r0
    da70:	ebffddf6 	bl	5250 <puts@plt>
    return FALSE;
    da74:	e3a07000 	mov	r7, #0
    da78:	eafffe89 	b	d4a4 <HandShake.isra.11+0x26c>
        {
	  uint8_t *dptr = digestResp;
	  uint8_t *sig = signatureResp;
	  /* encrypt signatureResp */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
            rtmpe9_sig(sig+i, sig+i, dptr[i] % 15);
    da7c:	e59f33c0 	ldr	r3, [pc, #960]	; de44 <HandShake.isra.11+0xc0c>
	  uint8_t *sig = signatureResp;
	  /* encrypt signatureResp */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
	    rtmpe8_sig(sig+i, sig+i, dptr[i] % 15);
        }
      else if (type == 9)
    da80:	e3a0a000 	mov	sl, #0
        {
	  uint8_t *dptr = digestResp;
	  uint8_t *sig = signatureResp;
	  /* encrypt signatureResp */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
            rtmpe9_sig(sig+i, sig+i, dptr[i] % 15);
    da84:	e59d2018 	ldr	r2, [sp, #24]
    da88:	e58d3020 	str	r3, [sp, #32]
    da8c:	e7d2100a 	ldrb	r1, [r2, sl]
    da90:	e28a0e5e 	add	r0, sl, #1504	; 0x5e0
    da94:	e082c193 	umull	ip, r2, r3, r1
    da98:	e59d301c 	ldr	r3, [sp, #28]
    da9c:	e1a021a2 	lsr	r2, r2, #3
    daa0:	e0622202 	rsb	r2, r2, r2, lsl #4
    daa4:	e0830000 	add	r0, r3, r0
    daa8:	e0622001 	rsb	r2, r2, r1
    daac:	e20220ff 	and	r2, r2, #255	; 0xff
      else if (type == 9)
        {
	  uint8_t *dptr = digestResp;
	  uint8_t *sig = signatureResp;
	  /* encrypt signatureResp */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
    dab0:	e28aa008 	add	sl, sl, #8
            rtmpe9_sig(sig+i, sig+i, dptr[i] % 15);
    dab4:	e1a01000 	mov	r1, r0
    dab8:	ebffe6d7 	bl	761c <rtmpe9_sig>
      else if (type == 9)
        {
	  uint8_t *dptr = digestResp;
	  uint8_t *sig = signatureResp;
	  /* encrypt signatureResp */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
    dabc:	e35a0020 	cmp	sl, #32
    dac0:	e59d3020 	ldr	r3, [sp, #32]
    dac4:	1affffee 	bne	da84 <HandShake.isra.11+0x84c>
    dac8:	eaffff43 	b	d7dc <HandShake.isra.11+0x5a4>
        {
	  uint8_t *dptr = digestResp;
	  uint8_t *sig = signatureResp;
	  /* encrypt signatureResp */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
	    rtmpe8_sig(sig+i, sig+i, dptr[i] % 15);
    dacc:	e59f3370 	ldr	r3, [pc, #880]	; de44 <HandShake.isra.11+0xc0c>
	  "%s: Calculated digest key from secure key and server digest: ",
	  __FUNCTION__);
      RTMP_LogHex(RTMP_LOGDEBUG, digestResp, SHA256_DIGEST_LENGTH);

#ifdef FP10
      if (type == 8 )
    dad0:	e3a0a000 	mov	sl, #0
        {
	  uint8_t *dptr = digestResp;
	  uint8_t *sig = signatureResp;
	  /* encrypt signatureResp */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
	    rtmpe8_sig(sig+i, sig+i, dptr[i] % 15);
    dad4:	e59d2018 	ldr	r2, [sp, #24]
    dad8:	e58d3020 	str	r3, [sp, #32]
    dadc:	e7d2100a 	ldrb	r1, [r2, sl]
    dae0:	e28a0e5e 	add	r0, sl, #1504	; 0x5e0
    dae4:	e082c193 	umull	ip, r2, r3, r1
    dae8:	e59d301c 	ldr	r3, [sp, #28]
    daec:	e1a021a2 	lsr	r2, r2, #3
    daf0:	e0622202 	rsb	r2, r2, r2, lsl #4
    daf4:	e0830000 	add	r0, r3, r0
    daf8:	e0622001 	rsb	r2, r2, r1
    dafc:	e20220ff 	and	r2, r2, #255	; 0xff
      if (type == 8 )
        {
	  uint8_t *dptr = digestResp;
	  uint8_t *sig = signatureResp;
	  /* encrypt signatureResp */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
    db00:	e28aa008 	add	sl, sl, #8
	    rtmpe8_sig(sig+i, sig+i, dptr[i] % 15);
    db04:	e1a01000 	mov	r1, r0
    db08:	ebffdeed 	bl	56c4 <rtmpe8_sig>
      if (type == 8 )
        {
	  uint8_t *dptr = digestResp;
	  uint8_t *sig = signatureResp;
	  /* encrypt signatureResp */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
    db0c:	e35a0020 	cmp	sl, #32
    db10:	e59d3020 	ldr	r3, [sp, #32]
    db14:	1affffee 	bne	dad4 <HandShake.isra.11+0x89c>
    db18:	eaffff2f 	b	d7dc <HandShake.isra.11+0x5a4>
	    }
	}
    }
  else
    {
      if (memcmp(serversig, clientsig, RTMP_SIG_SIZE) != 0)
    db1c:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
    db20:	e1a01006 	mov	r1, r6
    db24:	ebffddab 	bl	51d8 <memcmp@plt>
    db28:	e3500000 	cmp	r0, #0
    db2c:	0afffe5c 	beq	d4a4 <HandShake.isra.11+0x26c>
	{
	  RTMP_Log(RTMP_LOGWARNING, "%s: client signature does not match!",
    db30:	e59f2310 	ldr	r2, [pc, #784]	; de48 <HandShake.isra.11+0xc10>
    db34:	e59f1310 	ldr	r1, [pc, #784]	; de4c <HandShake.isra.11+0xc14>
    db38:	e08f2002 	add	r2, pc, r2
    db3c:	e2422d2f 	sub	r2, r2, #3008	; 0xbc0
    db40:	e3a00002 	mov	r0, #2
    db44:	e2422004 	sub	r2, r2, #4
    db48:	e08f1001 	add	r1, pc, r1
    db4c:	eb001f96 	bl	159ac <RTMP_Log>
    db50:	eafffe53 	b	d4a4 <HandShake.isra.11+0x26c>
	}

      /* generate SWFVerification token (SHA256 HMAC hash of decompressed SWF, key are the last 32 bytes of the server handshake) */
      if (r->Link.SWFSize)
	{
	  const char swfVerify[] = { 0x01, 0x01 };
    db54:	e59fa2f4 	ldr	sl, [pc, #756]	; de50 <HandShake.isra.11+0xc18>
    db58:	e28d2d32 	add	r2, sp, #3200	; 0xc80
    db5c:	e08fa00a 	add	sl, pc, sl
    db60:	e2822008 	add	r2, r2, #8
    db64:	e58d301c 	str	r3, [sp, #28]
    db68:	e24a1eb3 	sub	r1, sl, #2864	; 0xb30
    db6c:	e2423004 	sub	r3, r2, #4
    db70:	e1a0a003 	mov	sl, r3
    db74:	e1a00003 	mov	r0, r3
    db78:	e2411004 	sub	r1, r1, #4
    db7c:	e3a02002 	mov	r2, #2
    db80:	e58d3018 	str	r3, [sp, #24]
    db84:	ebffdd90 	bl	51cc <memcpy@plt>
	  char *vend = r->Link.SWFVerificationResponse+sizeof(r->Link.SWFVerificationResponse);

	  memcpy(r->Link.SWFVerificationResponse, swfVerify, 2);
    db88:	e1a0100a 	mov	r1, sl
    db8c:	e2850f72 	add	r0, r5, #456	; 0x1c8
    db90:	e3a02002 	mov	r2, #2

      /* generate SWFVerification token (SHA256 HMAC hash of decompressed SWF, key are the last 32 bytes of the server handshake) */
      if (r->Link.SWFSize)
	{
	  const char swfVerify[] = { 0x01, 0x01 };
	  char *vend = r->Link.SWFVerificationResponse+sizeof(r->Link.SWFVerificationResponse);
    db94:	e289bc41 	add	fp, r9, #16640	; 0x4100

	  memcpy(r->Link.SWFVerificationResponse, swfVerify, 2);
    db98:	ebffdd8b 	bl	51cc <memcpy@plt>
	  AMF_EncodeInt32(&r->Link.SWFVerificationResponse[2], vend, r->Link.SWFSize);
    db9c:	e59d301c 	ldr	r3, [sp, #28]

      /* generate SWFVerification token (SHA256 HMAC hash of decompressed SWF, key are the last 32 bytes of the server handshake) */
      if (r->Link.SWFSize)
	{
	  const char swfVerify[] = { 0x01, 0x01 };
	  char *vend = r->Link.SWFVerificationResponse+sizeof(r->Link.SWFVerificationResponse);
    dba0:	e28ba0f2 	add	sl, fp, #242	; 0xf2

	  memcpy(r->Link.SWFVerificationResponse, swfVerify, 2);
	  AMF_EncodeInt32(&r->Link.SWFVerificationResponse[2], vend, r->Link.SWFSize);
    dba4:	e1a02003 	mov	r2, r3
    dba8:	e1a0100a 	mov	r1, sl
    dbac:	e28b00ca 	add	r0, fp, #202	; 0xca
    dbb0:	eb0020fd 	bl	15fac <AMF_EncodeInt32>
	  AMF_EncodeInt32(&r->Link.SWFVerificationResponse[6], vend, r->Link.SWFSize);
    dbb4:	e1a0100a 	mov	r1, sl
    dbb8:	e59521a4 	ldr	r2, [r5, #420]	; 0x1a4
    dbbc:	e28b00ce 	add	r0, fp, #206	; 0xce
    dbc0:	eb0020f9 	bl	15fac <AMF_EncodeInt32>
	  HMACsha256(r->Link.SWFHash, SHA256_DIGEST_LENGTH,
    dbc4:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
		     &serversig[RTMP_SIG_SIZE - SHA256_DIGEST_LENGTH],
		     SHA256_DIGEST_LENGTH,
		     (uint8_t *)&r->Link.SWFVerificationResponse[10]);
    dbc8:	e28b30d2 	add	r3, fp, #210	; 0xd2
	  char *vend = r->Link.SWFVerificationResponse+sizeof(r->Link.SWFVerificationResponse);

	  memcpy(r->Link.SWFVerificationResponse, swfVerify, 2);
	  AMF_EncodeInt32(&r->Link.SWFVerificationResponse[2], vend, r->Link.SWFSize);
	  AMF_EncodeInt32(&r->Link.SWFVerificationResponse[6], vend, r->Link.SWFSize);
	  HMACsha256(r->Link.SWFHash, SHA256_DIGEST_LENGTH,
    dbcc:	e3a01020 	mov	r1, #32
    dbd0:	e58d3000 	str	r3, [sp]
    dbd4:	e28b00a8 	add	r0, fp, #168	; 0xa8
    dbd8:	e1a03001 	mov	r3, r1
    dbdc:	e2822e5e 	add	r2, r2, #1504	; 0x5e0
    dbe0:	ebffe085 	bl	5dfc <HMACsha256>
    dbe4:	eafffece 	b	d724 <HandShake.isra.11+0x4ec>
      /* we have to use this signature now to find the correct algorithms for getting the digest and DH positions */
      int digestPosServer = getdig(serversig, RTMP_SIG_SIZE);

      if (!VerifyDigest(digestPosServer, serversig, GenuineFMSKey, 36))
	{
	  RTMP_Log(RTMP_LOGWARNING, "Trying different position for server digest!");
    dbe8:	e59f1264 	ldr	r1, [pc, #612]	; de54 <HandShake.isra.11+0xc1c>
    dbec:	e3a00002 	mov	r0, #2
    dbf0:	e08f1001 	add	r1, pc, r1
    dbf4:	eb001f6c 	bl	159ac <RTMP_Log>
	  offalg ^= 1;
    dbf8:	e59d3018 	ldr	r3, [sp, #24]
	  getdig = digoff[offalg];
	  getdh  = dhoff[offalg];
    dbfc:	e59fc254 	ldr	ip, [pc, #596]	; de58 <HandShake.isra.11+0xc20>
	  digestPosServer = getdig(serversig, RTMP_SIG_SIZE);
    dc00:	e59da024 	ldr	sl, [sp, #36]	; 0x24
      if (!VerifyDigest(digestPosServer, serversig, GenuineFMSKey, 36))
	{
	  RTMP_Log(RTMP_LOGWARNING, "Trying different position for server digest!");
	  offalg ^= 1;
	  getdig = digoff[offalg];
	  getdh  = dhoff[offalg];
    dc04:	e08fc00c 	add	ip, pc, ip
      int digestPosServer = getdig(serversig, RTMP_SIG_SIZE);

      if (!VerifyDigest(digestPosServer, serversig, GenuineFMSKey, 36))
	{
	  RTMP_Log(RTMP_LOGWARNING, "Trying different position for server digest!");
	  offalg ^= 1;
    dc08:	e2233001 	eor	r3, r3, #1
	  getdig = digoff[offalg];
	  getdh  = dhoff[offalg];
    dc0c:	e08c3103 	add	r3, ip, r3, lsl #2
	  digestPosServer = getdig(serversig, RTMP_SIG_SIZE);
    dc10:	e5932330 	ldr	r2, [r3, #816]	; 0x330
    dc14:	e3a01c06 	mov	r1, #1536	; 0x600
      if (!VerifyDigest(digestPosServer, serversig, GenuineFMSKey, 36))
	{
	  RTMP_Log(RTMP_LOGWARNING, "Trying different position for server digest!");
	  offalg ^= 1;
	  getdig = digoff[offalg];
	  getdh  = dhoff[offalg];
    dc18:	e5933338 	ldr	r3, [r3, #824]	; 0x338
	  digestPosServer = getdig(serversig, RTMP_SIG_SIZE);
    dc1c:	e1a0000a 	mov	r0, sl
      if (!VerifyDigest(digestPosServer, serversig, GenuineFMSKey, 36))
	{
	  RTMP_Log(RTMP_LOGWARNING, "Trying different position for server digest!");
	  offalg ^= 1;
	  getdig = digoff[offalg];
	  getdh  = dhoff[offalg];
    dc20:	e58d3020 	str	r3, [sp, #32]
	  digestPosServer = getdig(serversig, RTMP_SIG_SIZE);
    dc24:	e12fff32 	blx	r2

	  if (!VerifyDigest(digestPosServer, serversig, GenuineFMSKey, 36))
    dc28:	e1a0100a 	mov	r1, sl
    dc2c:	e1a0200b 	mov	r2, fp
    dc30:	e3a03024 	mov	r3, #36	; 0x24
	{
	  RTMP_Log(RTMP_LOGWARNING, "Trying different position for server digest!");
	  offalg ^= 1;
	  getdig = digoff[offalg];
	  getdh  = dhoff[offalg];
	  digestPosServer = getdig(serversig, RTMP_SIG_SIZE);
    dc34:	e58d0030 	str	r0, [sp, #48]	; 0x30

	  if (!VerifyDigest(digestPosServer, serversig, GenuineFMSKey, 36))
    dc38:	ebffe668 	bl	75e0 <VerifyDigest>
    dc3c:	e3500000 	cmp	r0, #0
    dc40:	1afffeb1 	bne	d70c <HandShake.isra.11+0x4d4>
	    {
	      LOGE( "Couldn't verify the server digest");	/* continuing anyway will probably fail */
    dc44:	e59f0210 	ldr	r0, [pc, #528]	; de5c <HandShake.isra.11+0xc24>
    dc48:	e08f0000 	add	r0, pc, r0
    dc4c:	ebffdd7f 	bl	5250 <puts@plt>
    dc50:	eaffff87 	b	da74 <HandShake.isra.11+0x83c>

      /* do Diffie-Hellmann Key exchange for encrypted RTMP */
      if (encrypted)
	{
	  /* compute secret key */
	  uint8_t secretKey[128] = { 0 };
    dc54:	e3a02080 	mov	r2, #128	; 0x80
    dc58:	e3a01000 	mov	r1, #0
    dc5c:	e59d0018 	ldr	r0, [sp, #24]
    dc60:	ebffdd1a 	bl	50d0 <memset@plt>
	  int len, dhposServer;

	  dhposServer = getdh(serversig, RTMP_SIG_SIZE);
    dc64:	e59da024 	ldr	sl, [sp, #36]	; 0x24
    dc68:	e3a01c06 	mov	r1, #1536	; 0x600
    dc6c:	e1a0000a 	mov	r0, sl
    dc70:	e59d3020 	ldr	r3, [sp, #32]
    dc74:	e12fff33 	blx	r3
	  RTMP_Log(RTMP_LOGDEBUG, "%s: Server DH public key offset: %d", __FUNCTION__,
    dc78:	e59fb1e0 	ldr	fp, [pc, #480]	; de60 <HandShake.isra.11+0xc28>
    dc7c:	e59f11e0 	ldr	r1, [pc, #480]	; de64 <HandShake.isra.11+0xc2c>
    dc80:	e08fb00b 	add	fp, pc, fp
    dc84:	e24bbd2f 	sub	fp, fp, #3008	; 0xbc0
    dc88:	e24bb004 	sub	fp, fp, #4
    dc8c:	e1a0200b 	mov	r2, fp
    dc90:	e08f1001 	add	r1, pc, r1
	{
	  /* compute secret key */
	  uint8_t secretKey[128] = { 0 };
	  int len, dhposServer;

	  dhposServer = getdh(serversig, RTMP_SIG_SIZE);
    dc94:	e1a03000 	mov	r3, r0
	  RTMP_Log(RTMP_LOGDEBUG, "%s: Server DH public key offset: %d", __FUNCTION__,
	    dhposServer);
	  len = DHComputeSharedSecretKey(r->Link.dh, &serversig[dhposServer],
    dc98:	e08aa000 	add	sl, sl, r0
	  /* compute secret key */
	  uint8_t secretKey[128] = { 0 };
	  int len, dhposServer;

	  dhposServer = getdh(serversig, RTMP_SIG_SIZE);
	  RTMP_Log(RTMP_LOGDEBUG, "%s: Server DH public key offset: %d", __FUNCTION__,
    dc9c:	e3a00004 	mov	r0, #4
    dca0:	eb001f41 	bl	159ac <RTMP_Log>
	    dhposServer);
	  len = DHComputeSharedSecretKey(r->Link.dh, &serversig[dhposServer],
    dca4:	e1a0100a 	mov	r1, sl
    dca8:	e5950198 	ldr	r0, [r5, #408]	; 0x198
    dcac:	e59d2018 	ldr	r2, [sp, #24]
    dcb0:	ebffe1ce 	bl	63f0 <DHComputeSharedSecretKey.constprop.16>
	  				128, secretKey);
	  if (len < 0)
    dcb4:	e3500000 	cmp	r0, #0
    dcb8:	ba000037 	blt	dd9c <HandShake.isra.11+0xb64>
	    {
	      LOGE("%s: Wrong secret key position!", __FUNCTION__);
	      return FALSE;
	    }

	  RTMP_Log(RTMP_LOGDEBUG, "%s: Secret key: ", __FUNCTION__);
    dcbc:	e59f11a4 	ldr	r1, [pc, #420]	; de68 <HandShake.isra.11+0xc30>
    dcc0:	e1a0200b 	mov	r2, fp
    dcc4:	e3a00004 	mov	r0, #4
    dcc8:	e08f1001 	add	r1, pc, r1
    dccc:	eb001f36 	bl	159ac <RTMP_Log>
	  RTMP_LogHex(RTMP_LOGDEBUG, secretKey, 128);
    dcd0:	e59db018 	ldr	fp, [sp, #24]
    dcd4:	e3a00004 	mov	r0, #4
    dcd8:	e1a0100b 	mov	r1, fp
    dcdc:	e3a02080 	mov	r2, #128	; 0x80
    dce0:	eb001f41 	bl	159ec <RTMP_LogHex>

	  InitRC4Encryption(secretKey,
    dce4:	e59dc02c 	ldr	ip, [sp, #44]	; 0x2c
    dce8:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
    dcec:	e24c3008 	sub	r3, ip, #8
    dcf0:	e58d3000 	str	r3, [sp]
    dcf4:	e1a0100a 	mov	r1, sl
    dcf8:	e0862002 	add	r2, r6, r2
    dcfc:	e1a0000b 	mov	r0, fp
    dd00:	e24c300c 	sub	r3, ip, #12
    dd04:	ebffe04f 	bl	5e48 <InitRC4Encryption>
    dd08:	eafffe87 	b	d72c <HandShake.isra.11+0x4f4>
        {
	  uint8_t *dptr = digest;
	  uint8_t *sig = signature;
	  /* encrypt signatureResp */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
            rtmpe9_sig(sig+i, sig+i, dptr[i] % 15);
    dd0c:	e59fb130 	ldr	fp, [pc, #304]	; de44 <HandShake.isra.11+0xc0c>
	  uint8_t *sig = signature;
	  /* encrypt signature */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
	    rtmpe8_sig(sig+i, sig+i, dptr[i] % 15);
        }
      else if (type == 9)
    dd10:	e3a06000 	mov	r6, #0
        {
	  uint8_t *dptr = digest;
	  uint8_t *sig = signature;
	  /* encrypt signatureResp */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
            rtmpe9_sig(sig+i, sig+i, dptr[i] % 15);
    dd14:	e7da2006 	ldrb	r2, [sl, r6]
    dd18:	e0890006 	add	r0, r9, r6
    dd1c:	e083129b 	umull	r1, r3, fp, r2
      else if (type == 9)
        {
	  uint8_t *dptr = digest;
	  uint8_t *sig = signature;
	  /* encrypt signatureResp */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
    dd20:	e2866008 	add	r6, r6, #8
            rtmpe9_sig(sig+i, sig+i, dptr[i] % 15);
    dd24:	e1a031a3 	lsr	r3, r3, #3
    dd28:	e0633203 	rsb	r3, r3, r3, lsl #4
    dd2c:	e0632002 	rsb	r2, r3, r2
    dd30:	e20220ff 	and	r2, r2, #255	; 0xff
    dd34:	e1a01000 	mov	r1, r0
    dd38:	ebffe637 	bl	761c <rtmpe9_sig>
      else if (type == 9)
        {
	  uint8_t *dptr = digest;
	  uint8_t *sig = signature;
	  /* encrypt signatureResp */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
    dd3c:	e3560020 	cmp	r6, #32
    dd40:	1afffff3 	bne	dd14 <HandShake.isra.11+0xadc>
    dd44:	eaffff08 	b	d96c <HandShake.isra.11+0x734>
        {
	  uint8_t *dptr = digest;
	  uint8_t *sig = signature;
	  /* encrypt signature */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
	    rtmpe8_sig(sig+i, sig+i, dptr[i] % 15);
    dd48:	e59fb0f4 	ldr	fp, [pc, #244]	; de44 <HandShake.isra.11+0xc0c>
      /* show some information */
      RTMP_Log(RTMP_LOGDEBUG, "%s: Digest key: ", __FUNCTION__);
      RTMP_LogHex(RTMP_LOGDEBUG, digest, SHA256_DIGEST_LENGTH);

#ifdef FP10
      if (type == 8 )
    dd4c:	e3a06000 	mov	r6, #0
        {
	  uint8_t *dptr = digest;
	  uint8_t *sig = signature;
	  /* encrypt signature */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
	    rtmpe8_sig(sig+i, sig+i, dptr[i] % 15);
    dd50:	e7da2006 	ldrb	r2, [sl, r6]
    dd54:	e0890006 	add	r0, r9, r6
    dd58:	e083129b 	umull	r1, r3, fp, r2
      if (type == 8 )
        {
	  uint8_t *dptr = digest;
	  uint8_t *sig = signature;
	  /* encrypt signature */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
    dd5c:	e2866008 	add	r6, r6, #8
	    rtmpe8_sig(sig+i, sig+i, dptr[i] % 15);
    dd60:	e1a031a3 	lsr	r3, r3, #3
    dd64:	e0633203 	rsb	r3, r3, r3, lsl #4
    dd68:	e0632002 	rsb	r2, r3, r2
    dd6c:	e20220ff 	and	r2, r2, #255	; 0xff
    dd70:	e1a01000 	mov	r1, r0
    dd74:	ebffde52 	bl	56c4 <rtmpe8_sig>
      if (type == 8 )
        {
	  uint8_t *dptr = digest;
	  uint8_t *sig = signature;
	  /* encrypt signature */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
    dd78:	e3560020 	cmp	r6, #32
    dd7c:	1afffff3 	bne	dd50 <HandShake.isra.11+0xb18>
    dd80:	eafffef9 	b	d96c <HandShake.isra.11+0x734>
      RTMP_LogHex(RTMP_LOGDEBUG, signature, SHA256_DIGEST_LENGTH);
      if (memcmp
	  (signature, &serversig[RTMP_SIG_SIZE - SHA256_DIGEST_LENGTH],
	   SHA256_DIGEST_LENGTH) != 0)
	{
	  LOGE( "%s: Server not genuine Adobe!", __FUNCTION__);
    dd84:	e59f00e0 	ldr	r0, [pc, #224]	; de6c <HandShake.isra.11+0xc34>
    dd88:	e1a01006 	mov	r1, r6
    dd8c:	e08f0000 	add	r0, pc, r0
    dd90:	ebffdd5b 	bl	5304 <printf@plt>
	  return FALSE;
    dd94:	e3a07000 	mov	r7, #0
    dd98:	eafffdc1 	b	d4a4 <HandShake.isra.11+0x26c>
	    dhposServer);
	  len = DHComputeSharedSecretKey(r->Link.dh, &serversig[dhposServer],
	  				128, secretKey);
	  if (len < 0)
	    {
	      LOGE("%s: Wrong secret key position!", __FUNCTION__);
    dd9c:	e59f00cc 	ldr	r0, [pc, #204]	; de70 <HandShake.isra.11+0xc38>
    dda0:	e1a0100b 	mov	r1, fp
    dda4:	e08f0000 	add	r0, pc, r0
    dda8:	ebffdd55 	bl	5304 <printf@plt>
    ddac:	eaffff30 	b	da74 <HandShake.isra.11+0x83c>
    ddb0:	000114ac 	.word	0x000114ac
    ddb4:	00011dd8 	.word	0x00011dd8
    ddb8:	000164d4 	.word	0x000164d4
    ddbc:	00011400 	.word	0x00011400
    ddc0:	00011e10 	.word	0x00011e10
    ddc4:	00011de8 	.word	0x00011de8
    ddc8:	00000601 	.word	0x00000601
    ddcc:	00011db4 	.word	0x00011db4
    ddd0:	00011300 	.word	0x00011300
    ddd4:	00011c90 	.word	0x00011c90
    ddd8:	00011ca0 	.word	0x00011ca0
    dddc:	00011cd0 	.word	0x00011cd0
    dde0:	00011248 	.word	0x00011248
    dde4:	00011cac 	.word	0x00011cac
    dde8:	00011c98 	.word	0x00011c98
    ddec:	00011c98 	.word	0x00011c98
    ddf0:	00011b60 	.word	0x00011b60
    ddf4:	00011180 	.word	0x00011180
    ddf8:	00011c3c 	.word	0x00011c3c
    ddfc:	00011c28 	.word	0x00011c28
    de00:	000110fc 	.word	0x000110fc
    de04:	00011080 	.word	0x00011080
    de08:	00011c00 	.word	0x00011c00
    de0c:	00010ffc 	.word	0x00010ffc
    de10:	00011bfc 	.word	0x00011bfc
    de14:	00010f44 	.word	0x00010f44
    de18:	00011b98 	.word	0x00011b98
    de1c:	00010f24 	.word	0x00010f24
    de20:	00011bb0 	.word	0x00011bb0
    de24:	00011b5c 	.word	0x00011b5c
    de28:	00010e6c 	.word	0x00010e6c
    de2c:	00011b28 	.word	0x00011b28
    de30:	00011b2c 	.word	0x00011b2c
    de34:	000119d8 	.word	0x000119d8
    de38:	00010d90 	.word	0x00010d90
    de3c:	000116f4 	.word	0x000116f4
    de40:	000119c0 	.word	0x000119c0
    de44:	88888889 	.word	0x88888889
    de48:	00010ca8 	.word	0x00010ca8
    de4c:	000119d4 	.word	0x000119d4
    de50:	00010c84 	.word	0x00010c84
    de54:	00011708 	.word	0x00011708
    de58:	00015c44 	.word	0x00015c44
    de5c:	000116e0 	.word	0x000116e0
    de60:	00010b60 	.word	0x00010b60
    de64:	000116c0 	.word	0x000116c0
    de68:	000116d4 	.word	0x000116d4
    de6c:	00011740 	.word	0x00011740
    de70:	000115d0 	.word	0x000115d0

0000de74 <RTMP_ReadPacket>:
    return 4;
}

int
RTMP_ReadPacket(RTMP *r, RTMPPacket *packet)
{
    de74:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    de78:	e24dd01c 	sub	sp, sp, #28
    int didAlloc = FALSE;
    int extendedTimestamp;
    
//    RTMP_Log(RTMP_LOGDEBUG2, "%s: fd=%d", __FUNCTION__, r->m_sb.sb_socket);
    
    if (ReadN(r, (char *)hbuf, 1) == 0)
    de7c:	e28d8004 	add	r8, sp, #4
}

int
RTMP_ReadPacket(RTMP *r, RTMPPacket *packet)
{
    uint8_t hbuf[RTMP_MAX_HEADER_SIZE] = { 0 };
    de80:	e3a06000 	mov	r6, #0
    return 4;
}

int
RTMP_ReadPacket(RTMP *r, RTMPPacket *packet)
{
    de84:	e1a05001 	mov	r5, r1
    int didAlloc = FALSE;
    int extendedTimestamp;
    
//    RTMP_Log(RTMP_LOGDEBUG2, "%s: fd=%d", __FUNCTION__, r->m_sb.sb_socket);
    
    if (ReadN(r, (char *)hbuf, 1) == 0)
    de88:	e3a02001 	mov	r2, #1
    de8c:	e1a01008 	mov	r1, r8
}

int
RTMP_ReadPacket(RTMP *r, RTMPPacket *packet)
{
    uint8_t hbuf[RTMP_MAX_HEADER_SIZE] = { 0 };
    de90:	e58d6004 	str	r6, [sp, #4]
    de94:	e58d6008 	str	r6, [sp, #8]
    de98:	e58d600c 	str	r6, [sp, #12]
    de9c:	e58d6010 	str	r6, [sp, #16]
    dea0:	e1cd61b4 	strh	r6, [sp, #20]
    return 4;
}

int
RTMP_ReadPacket(RTMP *r, RTMPPacket *packet)
{
    dea4:	e1a07000 	mov	r7, r0
    int didAlloc = FALSE;
    int extendedTimestamp;
    
//    RTMP_Log(RTMP_LOGDEBUG2, "%s: fd=%d", __FUNCTION__, r->m_sb.sb_socket);
    
    if (ReadN(r, (char *)hbuf, 1) == 0)
    dea8:	ebfffc03 	bl	cebc <ReadN>
    deac:	e2504000 	subs	r4, r0, #0
    deb0:	0a00009b 	beq	e124 <RTMP_ReadPacket+0x2b0>
    {
        RTMP_Log(RTMP_LOGERROR, "%s, failed to read RTMP packet header", __FUNCTION__);
        return FALSE;
    }
    
    packet->m_headerType = (hbuf[0] & 0xc0) >> 6;//basic header: chunk header type
    deb4:	e5dd3004 	ldrb	r3, [sp, #4]
    packet->m_nChannel = (hbuf[0] & 0x3f);//basic header: cs id
    deb8:	e203403f 	and	r4, r3, #63	; 0x3f
    header++;
    if (packet->m_nChannel == 0)
    debc:	e3540000 	cmp	r4, #0
    {
        RTMP_Log(RTMP_LOGERROR, "%s, failed to read RTMP packet header", __FUNCTION__);
        return FALSE;
    }
    
    packet->m_headerType = (hbuf[0] & 0xc0) >> 6;//basic header: chunk header type
    dec0:	e1a03323 	lsr	r3, r3, #6
    packet->m_nChannel = (hbuf[0] & 0x3f);//basic header: cs id
    dec4:	e5854004 	str	r4, [r5, #4]
    {
        RTMP_Log(RTMP_LOGERROR, "%s, failed to read RTMP packet header", __FUNCTION__);
        return FALSE;
    }
    
    packet->m_headerType = (hbuf[0] & 0xc0) >> 6;//basic header: chunk header type
    dec8:	e5c53000 	strb	r3, [r5]
    packet->m_nChannel = (hbuf[0] & 0x3f);//basic header: cs id
    header++;
    if (packet->m_nChannel == 0)
    decc:	0a000088 	beq	e0f4 <RTMP_ReadPacket+0x280>
        }
        packet->m_nChannel = hbuf[1];
        packet->m_nChannel += 64;
        header++;
    }
    else if (packet->m_nChannel == 1)
    ded0:	e3540001 	cmp	r4, #1
        return FALSE;
    }
    
    packet->m_headerType = (hbuf[0] & 0xc0) >> 6;//basic header: chunk header type
    packet->m_nChannel = (hbuf[0] & 0x3f);//basic header: cs id
    header++;
    ded4:	128d6005 	addne	r6, sp, #5
        }
        packet->m_nChannel = hbuf[1];
        packet->m_nChannel += 64;
        header++;
    }
    else if (packet->m_nChannel == 1)
    ded8:	0a000118 	beq	e340 <RTMP_ReadPacket+0x4cc>
        packet->m_nChannel = tmp + 64;
        RTMP_Log(RTMP_LOGDEBUG, "%s, m_nChannel: %0x", __FUNCTION__, packet->m_nChannel);
        header += 2;
    }
    
    nSize = packetSize[packet->m_headerType];
    dedc:	e59f254c 	ldr	r2, [pc, #1356]	; e430 <RTMP_ReadPacket+0x5bc>
    
    if (packet->m_nChannel >= r->m_channelsAllocatedIn)
    dee0:	e5971044 	ldr	r1, [r7, #68]	; 0x44
        packet->m_nChannel = tmp + 64;
        RTMP_Log(RTMP_LOGDEBUG, "%s, m_nChannel: %0x", __FUNCTION__, packet->m_nChannel);
        header += 2;
    }
    
    nSize = packetSize[packet->m_headerType];
    dee4:	e08f2002 	add	r2, pc, r2
    dee8:	e0823103 	add	r3, r2, r3, lsl #2
    
    if (packet->m_nChannel >= r->m_channelsAllocatedIn)
    deec:	e1510004 	cmp	r1, r4
        packet->m_nChannel = tmp + 64;
        RTMP_Log(RTMP_LOGDEBUG, "%s, m_nChannel: %0x", __FUNCTION__, packet->m_nChannel);
        header += 2;
    }
    
    nSize = packetSize[packet->m_headerType];
    def0:	e5139c5c 	ldr	r9, [r3, #-3164]	; 0xfffff3a4
    
    if (packet->m_nChannel >= r->m_channelsAllocatedIn)
    def4:	da00009d 	ble	e170 <RTMP_ReadPacket+0x2fc>
        memset(r->m_channelTimestamp + r->m_channelsAllocatedIn, 0, sizeof(int) * (n - r->m_channelsAllocatedIn));
        memset(r->m_vecChannelsIn + r->m_channelsAllocatedIn, 0, sizeof(RTMPPacket*) * (n - r->m_channelsAllocatedIn));
        r->m_channelsAllocatedIn = n;
    }
    
    if (nSize == RTMP_LARGE_HEADER_SIZE)	/* if we get a full header the timestamp is absolute */
    def8:	e359000c 	cmp	r9, #12
        packet->m_hasAbsTimestamp = TRUE;
    defc:	03a03001 	moveq	r3, #1
    df00:	05c53002 	strbeq	r3, [r5, #2]
    {				/* using values from the last message of this channel */
        if (r->m_vecChannelsIn[packet->m_nChannel])
            memcpy(packet, r->m_vecChannelsIn[packet->m_nChannel],sizeof(RTMPPacket));
    }
    
    nSize--;
    df04:	03a0400b 	moveq	r4, #11
        memset(r->m_channelTimestamp + r->m_channelsAllocatedIn, 0, sizeof(int) * (n - r->m_channelsAllocatedIn));
        memset(r->m_vecChannelsIn + r->m_channelsAllocatedIn, 0, sizeof(RTMPPacket*) * (n - r->m_channelsAllocatedIn));
        r->m_channelsAllocatedIn = n;
    }
    
    if (nSize == RTMP_LARGE_HEADER_SIZE)	/* if we get a full header the timestamp is absolute */
    df08:	0a000020 	beq	df90 <RTMP_ReadPacket+0x11c>
        packet->m_hasAbsTimestamp = TRUE;
    
    else if (nSize < RTMP_LARGE_HEADER_SIZE)
    df0c:	e359000b 	cmp	r9, #11
    df10:	da00008d 	ble	e14c <RTMP_ReadPacket+0x2d8>
    {				/* using values from the last message of this channel */
        if (r->m_vecChannelsIn[packet->m_nChannel])
            memcpy(packet, r->m_vecChannelsIn[packet->m_nChannel],sizeof(RTMPPacket));
    }
    
    nSize--;
    df14:	e2494001 	sub	r4, r9, #1
    // msg header
    if (nSize > 0 && ReadN(r, header, nSize) != nSize)
    df18:	e3540000 	cmp	r4, #0
    df1c:	ca00001b 	bgt	df90 <RTMP_ReadPacket+0x11c>
        RTMP_Log(RTMP_LOGERROR, "%s, failed to read RTMP packet header. type: %x",
                 __FUNCTION__, (unsigned int)hbuf[0]);
        return FALSE;
    }
    
    hSize = nSize + (header - (char *)hbuf);
    df20:	e0689006 	rsb	r9, r8, r6
    df24:	e0899004 	add	r9, r9, r4
    df28:	e1a0b004 	mov	fp, r4
    df2c:	e5950008 	ldr	r0, [r5, #8]
                    packet->m_nInfoField2 = DecodeInt32LE(header + 7);
            }
        }
    }
    
    extendedTimestamp = packet->m_nTimeStamp == 0xffffff;
    df30:	e3e0a4ff 	mvn	sl, #-16777216	; 0xff000000
    df34:	e06aa000 	rsb	sl, sl, r0
    df38:	e16faf1a 	clz	sl, sl
    df3c:	e1a0a2aa 	lsr	sl, sl, #5
    if (extendedTimestamp)
    df40:	e35a0000 	cmp	sl, #0
    df44:	0a00003d 	beq	e040 <RTMP_ReadPacket+0x1cc>
    {
        if (ReadN(r, header + nSize, 4) != 4)
    df48:	e086600b 	add	r6, r6, fp
    df4c:	e1a01006 	mov	r1, r6
    df50:	e1a00007 	mov	r0, r7
    df54:	e3a02004 	mov	r2, #4
    df58:	ebfffbd7 	bl	cebc <ReadN>
    df5c:	e3500004 	cmp	r0, #4
    df60:	0a000032 	beq	e030 <RTMP_ReadPacket+0x1bc>
        {
            RTMP_Log(RTMP_LOGERROR, "%s, failed to read extended timestamp",
    df64:	e59f24c8 	ldr	r2, [pc, #1224]	; e434 <RTMP_ReadPacket+0x5c0>
    df68:	e59f14c8 	ldr	r1, [pc, #1224]	; e438 <RTMP_ReadPacket+0x5c4>
    df6c:	e08f2002 	add	r2, pc, r2
    df70:	e3a00001 	mov	r0, #1
    df74:	e2422eb3 	sub	r2, r2, #2864	; 0xb30
    df78:	e08f1001 	add	r1, pc, r1
    df7c:	eb001e8a 	bl	159ac <RTMP_Log>
                     __FUNCTION__);
            return FALSE;
    df80:	e3a04000 	mov	r4, #0
    {
        packet->m_body = NULL;	/* so it won't be erased on free */
    }
    
    return TRUE;
}
    df84:	e1a00004 	mov	r0, r4
    df88:	e28dd01c 	add	sp, sp, #28
    df8c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
            memcpy(packet, r->m_vecChannelsIn[packet->m_nChannel],sizeof(RTMPPacket));
    }
    
    nSize--;
    // msg header
    if (nSize > 0 && ReadN(r, header, nSize) != nSize)
    df90:	e1a00007 	mov	r0, r7
    df94:	e1a01006 	mov	r1, r6
    df98:	e1a02004 	mov	r2, r4
    df9c:	ebfffbc6 	bl	cebc <ReadN>
    dfa0:	e1500004 	cmp	r0, r4
    dfa4:	e1a0b000 	mov	fp, r0
    dfa8:	1a00009c 	bne	e220 <RTMP_ReadPacket+0x3ac>
        RTMP_Log(RTMP_LOGERROR, "%s, failed to read RTMP packet header. type: %x",
                 __FUNCTION__, (unsigned int)hbuf[0]);
        return FALSE;
    }
    
    hSize = nSize + (header - (char *)hbuf);
    dfac:	e0689006 	rsb	r9, r8, r6
    
    if (nSize >= 3)
    dfb0:	e3540002 	cmp	r4, #2
        RTMP_Log(RTMP_LOGERROR, "%s, failed to read RTMP packet header. type: %x",
                 __FUNCTION__, (unsigned int)hbuf[0]);
        return FALSE;
    }
    
    hSize = nSize + (header - (char *)hbuf);
    dfb4:	e0849009 	add	r9, r4, r9
    
    if (nSize >= 3)
    dfb8:	daffffdb 	ble	df2c <RTMP_ReadPacket+0xb8>
    {
        packet->m_nTimeStamp = AMF_DecodeInt24(header);
    dfbc:	e1a00006 	mov	r0, r6
    dfc0:	eb001fab 	bl	15e74 <AMF_DecodeInt24>
        
        /*RTMP_Log(RTMP_LOGDEBUG, "%s, reading RTMP packet chunk on channel %x, headersz %i, timestamp %i, abs timestamp %i", __FUNCTION__, packet.m_nChannel, nSize, packet.m_nTimeStamp, packet.m_hasAbsTimestamp); */
        
        if (nSize >= 6)
    dfc4:	e3540005 	cmp	r4, #5
    
    hSize = nSize + (header - (char *)hbuf);
    
    if (nSize >= 3)
    {
        packet->m_nTimeStamp = AMF_DecodeInt24(header);
    dfc8:	e5850008 	str	r0, [r5, #8]
        
        /*RTMP_Log(RTMP_LOGDEBUG, "%s, reading RTMP packet chunk on channel %x, headersz %i, timestamp %i, abs timestamp %i", __FUNCTION__, packet.m_nChannel, nSize, packet.m_nTimeStamp, packet.m_hasAbsTimestamp); */
        
        if (nSize >= 6)
    dfcc:	daffffd7 	ble	df30 <RTMP_ReadPacket+0xbc>
        {
            packet->m_nBodySize = AMF_DecodeInt24(header + 3);
    dfd0:	e2860003 	add	r0, r6, #3
    dfd4:	eb001fa6 	bl	15e74 <AMF_DecodeInt24>
            packet->m_nBytesRead = 0;
    dfd8:	e3a03000 	mov	r3, #0
    dfdc:	e5853014 	str	r3, [r5, #20]
        
        /*RTMP_Log(RTMP_LOGDEBUG, "%s, reading RTMP packet chunk on channel %x, headersz %i, timestamp %i, abs timestamp %i", __FUNCTION__, packet.m_nChannel, nSize, packet.m_nTimeStamp, packet.m_hasAbsTimestamp); */
        
        if (nSize >= 6)
        {
            packet->m_nBodySize = AMF_DecodeInt24(header + 3);
    dfe0:	e5850010 	str	r0, [r5, #16]
            packet->m_nBytesRead = 0;
            RTMPPacket_Free(packet);
    dfe4:	e1a00005 	mov	r0, r5
    dfe8:	ebffe9dc 	bl	8760 <RTMPPacket_Free>
            
            if (nSize > 6)
    dfec:	e3540006 	cmp	r4, #6
    dff0:	0affffcd 	beq	df2c <RTMP_ReadPacket+0xb8>
            {
                packet->m_packetType = header[6];
    dff4:	e5d63006 	ldrb	r3, [r6, #6]
                
                if (nSize == 11)
    dff8:	e354000b 	cmp	r4, #11
            packet->m_nBytesRead = 0;
            RTMPPacket_Free(packet);
            
            if (nSize > 6)
            {
                packet->m_packetType = header[6];
    dffc:	e5c53001 	strb	r3, [r5, #1]
                
                if (nSize == 11)
    e000:	1affffc9 	bne	df2c <RTMP_ReadPacket+0xb8>
DecodeInt32LE(const char *data)
{
    unsigned char *c = (unsigned char *)data;
    unsigned int val;
    
    val = (c[3] << 24) | (c[2] << 16) | (c[1] << 8) | c[0];
    e004:	e5d62009 	ldrb	r2, [r6, #9]
    e008:	e5d6100a 	ldrb	r1, [r6, #10]
    e00c:	e1a02802 	lsl	r2, r2, #16
    e010:	e5d63007 	ldrb	r3, [r6, #7]
    e014:	e1822c01 	orr	r2, r2, r1, lsl #24
    e018:	e5d61008 	ldrb	r1, [r6, #8]
    e01c:	e1823003 	orr	r3, r2, r3
    e020:	e1833401 	orr	r3, r3, r1, lsl #8
    e024:	e5950008 	ldr	r0, [r5, #8]
            if (nSize > 6)
            {
                packet->m_packetType = header[6];
                
                if (nSize == 11)
                    packet->m_nInfoField2 = DecodeInt32LE(header + 7);
    e028:	e585300c 	str	r3, [r5, #12]
    e02c:	eaffffbf 	b	df30 <RTMP_ReadPacket+0xbc>
        {
            RTMP_Log(RTMP_LOGERROR, "%s, failed to read extended timestamp",
                     __FUNCTION__);
            return FALSE;
        }
        packet->m_nTimeStamp = AMF_DecodeInt32(header + nSize);
    e030:	e1a00006 	mov	r0, r6
    e034:	eb001f95 	bl	15e90 <AMF_DecodeInt32>
        hSize += 4;
    e038:	e2899004 	add	r9, r9, #4
        {
            RTMP_Log(RTMP_LOGERROR, "%s, failed to read extended timestamp",
                     __FUNCTION__);
            return FALSE;
        }
        packet->m_nTimeStamp = AMF_DecodeInt32(header + nSize);
    e03c:	e5850008 	str	r0, [r5, #8]
        hSize += 4;
    }
    
    RTMP_LogHexString(RTMP_LOGDEBUG2, (uint8_t *)hbuf, hSize);
    e040:	e3a00005 	mov	r0, #5
    e044:	e1a01008 	mov	r1, r8
    e048:	e1a02009 	mov	r2, r9
    e04c:	eb001ea4 	bl	15ae4 <RTMP_LogHexString>
    
    if (packet->m_nBodySize > 0 && packet->m_body == NULL)
    e050:	e5954010 	ldr	r4, [r5, #16]
    e054:	e3540000 	cmp	r4, #0
    e058:	1a000063 	bne	e1ec <RTMP_ReadPacket+0x378>
        }
        didAlloc = TRUE;
        packet->m_headerType = (hbuf[0] & 0xc0) >> 6;
    }
    
    nToRead = packet->m_nBodySize - packet->m_nBytesRead;
    e05c:	e5951014 	ldr	r1, [r5, #20]
    nChunk = r->m_inChunkSize;
    e060:	e5973000 	ldr	r3, [r7]
        }
        didAlloc = TRUE;
        packet->m_headerType = (hbuf[0] & 0xc0) >> 6;
    }
    
    nToRead = packet->m_nBodySize - packet->m_nBytesRead;
    e064:	e0614004 	rsb	r4, r1, r4
    nChunk = r->m_inChunkSize;
    if (nToRead < nChunk)
        nChunk = nToRead;
    
    /* Does the caller want the raw chunk? */
    if (packet->m_chunk)
    e068:	e5950018 	ldr	r0, [r5, #24]
    e06c:	e1540003 	cmp	r4, r3
    e070:	a1a04003 	movge	r4, r3
    e074:	e3500000 	cmp	r0, #0
    e078:	0595301c 	ldreq	r3, [r5, #28]
    e07c:	0a00000a 	beq	e0ac <RTMP_ReadPacket+0x238>
    {
        packet->m_chunk->c_headerSize = hSize;
        memcpy(packet->m_chunk->c_header, hbuf, hSize);
    e080:	e1a01008 	mov	r1, r8
    e084:	e1a02009 	mov	r2, r9
        nChunk = nToRead;
    
    /* Does the caller want the raw chunk? */
    if (packet->m_chunk)
    {
        packet->m_chunk->c_headerSize = hSize;
    e088:	e480900c 	str	r9, [r0], #12
        memcpy(packet->m_chunk->c_header, hbuf, hSize);
    e08c:	ebffdc4e 	bl	51cc <memcpy@plt>
        packet->m_chunk->c_chunk = packet->m_body + packet->m_nBytesRead;
    e090:	e5952014 	ldr	r2, [r5, #20]
    e094:	e595301c 	ldr	r3, [r5, #28]
    e098:	e5950018 	ldr	r0, [r5, #24]
    e09c:	e1a01002 	mov	r1, r2
    e0a0:	e0832002 	add	r2, r3, r2
    e0a4:	e5802008 	str	r2, [r0, #8]
        packet->m_chunk->c_chunkSize = nChunk;
    e0a8:	e5804004 	str	r4, [r0, #4]
    }
    
    if (ReadN(r, packet->m_body + packet->m_nBytesRead, nChunk) != nChunk)
    e0ac:	e0831001 	add	r1, r3, r1
    e0b0:	e1a00007 	mov	r0, r7
    e0b4:	e1a02004 	mov	r2, r4
    e0b8:	ebfffb7f 	bl	cebc <ReadN>
    e0bc:	e1500004 	cmp	r0, r4
    e0c0:	0a000062 	beq	e250 <RTMP_ReadPacket+0x3dc>
    {
        RTMP_Log(RTMP_LOGERROR, "%s, failed to read RTMP packet body. len: %u",
    e0c4:	e59f2370 	ldr	r2, [pc, #880]	; e43c <RTMP_ReadPacket+0x5c8>
    e0c8:	e59f1370 	ldr	r1, [pc, #880]	; e440 <RTMP_ReadPacket+0x5cc>
    e0cc:	e08f2002 	add	r2, pc, r2
    e0d0:	e5953010 	ldr	r3, [r5, #16]
    e0d4:	e2422eb3 	sub	r2, r2, #2864	; 0xb30
    e0d8:	e3a00001 	mov	r0, #1
    e0dc:	e08f1001 	add	r1, pc, r1
    e0e0:	eb001e31 	bl	159ac <RTMP_Log>
                 __FUNCTION__, packet->m_nBodySize);
        return FALSE;
    e0e4:	e3a04000 	mov	r4, #0
    {
        packet->m_body = NULL;	/* so it won't be erased on free */
    }
    
    return TRUE;
}
    e0e8:	e1a00004 	mov	r0, r4
    e0ec:	e28dd01c 	add	sp, sp, #28
    e0f0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    packet->m_headerType = (hbuf[0] & 0xc0) >> 6;//basic header: chunk header type
    packet->m_nChannel = (hbuf[0] & 0x3f);//basic header: cs id
    header++;
    if (packet->m_nChannel == 0)
    {
        if (ReadN(r, (char *)&hbuf[1], 1) != 1)
    e0f4:	e1a00007 	mov	r0, r7
    e0f8:	e28d1005 	add	r1, sp, #5
    e0fc:	e3a02001 	mov	r2, #1
    e100:	ebfffb6d 	bl	cebc <ReadN>
    e104:	e3500001 	cmp	r0, #1
    e108:	1a000084 	bne	e320 <RTMP_ReadPacket+0x4ac>
        {
            RTMP_Log(RTMP_LOGERROR, "%s, failed to read RTMP packet header 2nd byte",
                     __FUNCTION__);
            return FALSE;
        }
        packet->m_nChannel = hbuf[1];
    e10c:	e5dd4005 	ldrb	r4, [sp, #5]
    e110:	e5d53000 	ldrb	r3, [r5]
        packet->m_nChannel += 64;
    e114:	e2844040 	add	r4, r4, #64	; 0x40
    e118:	e5854004 	str	r4, [r5, #4]
        header++;
    e11c:	e28d6006 	add	r6, sp, #6
    e120:	eaffff6d 	b	dedc <RTMP_ReadPacket+0x68>
    
//    RTMP_Log(RTMP_LOGDEBUG2, "%s: fd=%d", __FUNCTION__, r->m_sb.sb_socket);
    
    if (ReadN(r, (char *)hbuf, 1) == 0)
    {
        RTMP_Log(RTMP_LOGERROR, "%s, failed to read RTMP packet header", __FUNCTION__);
    e124:	e59f2318 	ldr	r2, [pc, #792]	; e444 <RTMP_ReadPacket+0x5d0>
    e128:	e59f1318 	ldr	r1, [pc, #792]	; e448 <RTMP_ReadPacket+0x5d4>
    e12c:	e08f2002 	add	r2, pc, r2
    e130:	e3a00001 	mov	r0, #1
    e134:	e2422eb3 	sub	r2, r2, #2864	; 0xb30
    e138:	e08f1001 	add	r1, pc, r1
    e13c:	eb001e1a 	bl	159ac <RTMP_Log>
    {
        packet->m_body = NULL;	/* so it won't be erased on free */
    }
    
    return TRUE;
}
    e140:	e1a00004 	mov	r0, r4
    e144:	e28dd01c 	add	sp, sp, #28
    e148:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (nSize == RTMP_LARGE_HEADER_SIZE)	/* if we get a full header the timestamp is absolute */
        packet->m_hasAbsTimestamp = TRUE;
    
    else if (nSize < RTMP_LARGE_HEADER_SIZE)
    {				/* using values from the last message of this channel */
        if (r->m_vecChannelsIn[packet->m_nChannel])
    e14c:	e5952004 	ldr	r2, [r5, #4]
    e150:	e597304c 	ldr	r3, [r7, #76]	; 0x4c
    e154:	e7931102 	ldr	r1, [r3, r2, lsl #2]
    e158:	e3510000 	cmp	r1, #0
    e15c:	0affff6c 	beq	df14 <RTMP_ReadPacket+0xa0>
            memcpy(packet, r->m_vecChannelsIn[packet->m_nChannel],sizeof(RTMPPacket));
    e160:	e1a00005 	mov	r0, r5
    e164:	e3a02020 	mov	r2, #32
    e168:	ebffdc17 	bl	51cc <memcpy@plt>
    e16c:	eaffff68 	b	df14 <RTMP_ReadPacket+0xa0>
    
    nSize = packetSize[packet->m_headerType];
    
    if (packet->m_nChannel >= r->m_channelsAllocatedIn)
    {
        int n = packet->m_nChannel + 10;
    e170:	e284400a 	add	r4, r4, #10
        int *timestamp = realloc(r->m_channelTimestamp, sizeof(int) * n);
    e174:	e1a0b104 	lsl	fp, r4, #2
    e178:	e1a0100b 	mov	r1, fp
    e17c:	e5970054 	ldr	r0, [r7, #84]	; 0x54
    e180:	ebffdcbf 	bl	5484 <realloc@plt>
        RTMPPacket **packets = realloc(r->m_vecChannelsIn, sizeof(RTMPPacket*) * n);
    e184:	e1a0100b 	mov	r1, fp
    nSize = packetSize[packet->m_headerType];
    
    if (packet->m_nChannel >= r->m_channelsAllocatedIn)
    {
        int n = packet->m_nChannel + 10;
        int *timestamp = realloc(r->m_channelTimestamp, sizeof(int) * n);
    e188:	e1a0a000 	mov	sl, r0
        RTMPPacket **packets = realloc(r->m_vecChannelsIn, sizeof(RTMPPacket*) * n);
    e18c:	e597004c 	ldr	r0, [r7, #76]	; 0x4c
    e190:	ebffdcbb 	bl	5484 <realloc@plt>
        if (!timestamp)
    e194:	e35a0000 	cmp	sl, #0
    
    if (packet->m_nChannel >= r->m_channelsAllocatedIn)
    {
        int n = packet->m_nChannel + 10;
        int *timestamp = realloc(r->m_channelTimestamp, sizeof(int) * n);
        RTMPPacket **packets = realloc(r->m_vecChannelsIn, sizeof(RTMPPacket*) * n);
    e198:	e1a0b000 	mov	fp, r0
        if (!timestamp)
    e19c:	0a000086 	beq	e3bc <RTMP_ReadPacket+0x548>
            free(r->m_channelTimestamp);
        if (!packets)
    e1a0:	e3500000 	cmp	r0, #0
    e1a4:	0a00008a 	beq	e3d4 <RTMP_ReadPacket+0x560>
        r->m_vecChannelsIn = packets;
        if (!timestamp || !packets) {
            r->m_channelsAllocatedIn = 0;
            return FALSE;
        }
        memset(r->m_channelTimestamp + r->m_channelsAllocatedIn, 0, sizeof(int) * (n - r->m_channelsAllocatedIn));
    e1a8:	e5970044 	ldr	r0, [r7, #68]	; 0x44
    e1ac:	e3a01000 	mov	r1, #0
    e1b0:	e0602004 	rsb	r2, r0, r4
    e1b4:	e1a02102 	lsl	r2, r2, #2
        RTMPPacket **packets = realloc(r->m_vecChannelsIn, sizeof(RTMPPacket*) * n);
        if (!timestamp)
            free(r->m_channelTimestamp);
        if (!packets)
            free(r->m_vecChannelsIn);
        r->m_channelTimestamp = timestamp;
    e1b8:	e587a054 	str	sl, [r7, #84]	; 0x54
        r->m_vecChannelsIn = packets;
    e1bc:	e587b04c 	str	fp, [r7, #76]	; 0x4c
        if (!timestamp || !packets) {
            r->m_channelsAllocatedIn = 0;
            return FALSE;
        }
        memset(r->m_channelTimestamp + r->m_channelsAllocatedIn, 0, sizeof(int) * (n - r->m_channelsAllocatedIn));
    e1c0:	e08a0100 	add	r0, sl, r0, lsl #2
    e1c4:	ebffdbc1 	bl	50d0 <memset@plt>
        memset(r->m_vecChannelsIn + r->m_channelsAllocatedIn, 0, sizeof(RTMPPacket*) * (n - r->m_channelsAllocatedIn));
    e1c8:	e5973044 	ldr	r3, [r7, #68]	; 0x44
    e1cc:	e597004c 	ldr	r0, [r7, #76]	; 0x4c
    e1d0:	e0632004 	rsb	r2, r3, r4
    e1d4:	e1a02102 	lsl	r2, r2, #2
    e1d8:	e0800103 	add	r0, r0, r3, lsl #2
    e1dc:	e3a01000 	mov	r1, #0
    e1e0:	ebffdbba 	bl	50d0 <memset@plt>
        r->m_channelsAllocatedIn = n;
    e1e4:	e5874044 	str	r4, [r7, #68]	; 0x44
    e1e8:	eaffff42 	b	def8 <RTMP_ReadPacket+0x84>
        hSize += 4;
    }
    
    RTMP_LogHexString(RTMP_LOGDEBUG2, (uint8_t *)hbuf, hSize);
    
    if (packet->m_nBodySize > 0 && packet->m_body == NULL)
    e1ec:	e595301c 	ldr	r3, [r5, #28]
    e1f0:	e3530000 	cmp	r3, #0
    e1f4:	1affff98 	bne	e05c <RTMP_ReadPacket+0x1e8>
    {
        if (!RTMPPacket_Alloc(packet, packet->m_nBodySize))
    e1f8:	e1a01004 	mov	r1, r4
    e1fc:	e1a00005 	mov	r0, r5
    e200:	ebffe94a 	bl	8730 <RTMPPacket_Alloc>
    e204:	e2504000 	subs	r4, r0, #0
    e208:	0a000080 	beq	e410 <RTMP_ReadPacket+0x59c>
        {
            RTMP_Log(RTMP_LOGDEBUG, "%s, failed to allocate packet", __FUNCTION__);
            return FALSE;
        }
        didAlloc = TRUE;
        packet->m_headerType = (hbuf[0] & 0xc0) >> 6;
    e20c:	e5dd3004 	ldrb	r3, [sp, #4]
    e210:	e5954010 	ldr	r4, [r5, #16]
    e214:	e1a03323 	lsr	r3, r3, #6
    e218:	e5c53000 	strb	r3, [r5]
    e21c:	eaffff8e 	b	e05c <RTMP_ReadPacket+0x1e8>
    
    nSize--;
    // msg header
    if (nSize > 0 && ReadN(r, header, nSize) != nSize)
    {
        RTMP_Log(RTMP_LOGERROR, "%s, failed to read RTMP packet header. type: %x",
    e220:	e59f2224 	ldr	r2, [pc, #548]	; e44c <RTMP_ReadPacket+0x5d8>
    e224:	e59f1224 	ldr	r1, [pc, #548]	; e450 <RTMP_ReadPacket+0x5dc>
    e228:	e08f2002 	add	r2, pc, r2
    e22c:	e3a00001 	mov	r0, #1
    e230:	e2422eb3 	sub	r2, r2, #2864	; 0xb30
    e234:	e08f1001 	add	r1, pc, r1
    e238:	e5dd3004 	ldrb	r3, [sp, #4]
    e23c:	eb001dda 	bl	159ac <RTMP_Log>
                 __FUNCTION__, (unsigned int)hbuf[0]);
        return FALSE;
    e240:	e3a04000 	mov	r4, #0
    {
        packet->m_body = NULL;	/* so it won't be erased on free */
    }
    
    return TRUE;
}
    e244:	e1a00004 	mov	r0, r4
    e248:	e28dd01c 	add	sp, sp, #28
    e24c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        RTMP_Log(RTMP_LOGERROR, "%s, failed to read RTMP packet body. len: %u",
                 __FUNCTION__, packet->m_nBodySize);
        return FALSE;
    }
    
    RTMP_LogHexString(RTMP_LOGDEBUG2, (uint8_t *)packet->m_body + packet->m_nBytesRead, nChunk);
    e250:	e5953014 	ldr	r3, [r5, #20]
    e254:	e595101c 	ldr	r1, [r5, #28]
    e258:	e3a00005 	mov	r0, #5
    e25c:	e0811003 	add	r1, r1, r3
    e260:	e1a02004 	mov	r2, r4
    e264:	eb001e1e 	bl	15ae4 <RTMP_LogHexString>
    
    packet->m_nBytesRead += nChunk;
    
    /* keep the packet as ref for other packets on this channel */
    if (!r->m_vecChannelsIn[packet->m_nChannel])
    e268:	e597804c 	ldr	r8, [r7, #76]	; 0x4c
    e26c:	e5956004 	ldr	r6, [r5, #4]
        return FALSE;
    }
    
    RTMP_LogHexString(RTMP_LOGDEBUG2, (uint8_t *)packet->m_body + packet->m_nBytesRead, nChunk);
    
    packet->m_nBytesRead += nChunk;
    e270:	e5953014 	ldr	r3, [r5, #20]
    
    /* keep the packet as ref for other packets on this channel */
    if (!r->m_vecChannelsIn[packet->m_nChannel])
    e274:	e7980106 	ldr	r0, [r8, r6, lsl #2]
        return FALSE;
    }
    
    RTMP_LogHexString(RTMP_LOGDEBUG2, (uint8_t *)packet->m_body + packet->m_nBytesRead, nChunk);
    
    packet->m_nBytesRead += nChunk;
    e278:	e0834004 	add	r4, r3, r4
    
    /* keep the packet as ref for other packets on this channel */
    if (!r->m_vecChannelsIn[packet->m_nChannel])
    e27c:	e3500000 	cmp	r0, #0
        return FALSE;
    }
    
    RTMP_LogHexString(RTMP_LOGDEBUG2, (uint8_t *)packet->m_body + packet->m_nBytesRead, nChunk);
    
    packet->m_nBytesRead += nChunk;
    e280:	e5854014 	str	r4, [r5, #20]
    
    /* keep the packet as ref for other packets on this channel */
    if (!r->m_vecChannelsIn[packet->m_nChannel])
    e284:	0a00005b 	beq	e3f8 <RTMP_ReadPacket+0x584>
        r->m_vecChannelsIn[packet->m_nChannel] = malloc(sizeof(RTMPPacket));
    memcpy(r->m_vecChannelsIn[packet->m_nChannel], packet, sizeof(RTMPPacket));
    e288:	e3a02020 	mov	r2, #32
    e28c:	e1a01005 	mov	r1, r5
    e290:	ebffdbcd 	bl	51cc <memcpy@plt>
    if (extendedTimestamp)
    e294:	e35a0000 	cmp	sl, #0
    {
        r->m_vecChannelsIn[packet->m_nChannel]->m_nTimeStamp = 0xffffff;
    e298:	1597304c 	ldrne	r3, [r7, #76]	; 0x4c
    e29c:	15951004 	ldrne	r1, [r5, #4]
    e2a0:	13e024ff 	mvnne	r2, #-16777216	; 0xff000000
    e2a4:	17933101 	ldrne	r3, [r3, r1, lsl #2]
    e2a8:	15832008 	strne	r2, [r3, #8]
    }
    
    if (RTMPPacket_IsReady(packet))
    e2ac:	e5953010 	ldr	r3, [r5, #16]
    e2b0:	e5952014 	ldr	r2, [r5, #20]
    e2b4:	e1520003 	cmp	r2, r3
        r->m_vecChannelsIn[packet->m_nChannel]->m_nBytesRead = 0;
        r->m_vecChannelsIn[packet->m_nChannel]->m_hasAbsTimestamp = FALSE;	/* can only be false if we reuse header */
    }
    else
    {
        packet->m_body = NULL;	/* so it won't be erased on free */
    e2b8:	13a03000 	movne	r3, #0
    e2bc:	1585301c 	strne	r3, [r5, #28]
    }
    
    return TRUE;
    e2c0:	13a04001 	movne	r4, #1
    if (extendedTimestamp)
    {
        r->m_vecChannelsIn[packet->m_nChannel]->m_nTimeStamp = 0xffffff;
    }
    
    if (RTMPPacket_IsReady(packet))
    e2c4:	1affff9d 	bne	e140 <RTMP_ReadPacket+0x2cc>
    {
        /* make packet's timestamp absolute */
        if (!packet->m_hasAbsTimestamp)
    e2c8:	e5d53002 	ldrb	r3, [r5, #2]
            packet->m_nTimeStamp += r->m_channelTimestamp[packet->m_nChannel];	/* timestamps seem to be always relative!! */
    e2cc:	e5951004 	ldr	r1, [r5, #4]
    }
    
    if (RTMPPacket_IsReady(packet))
    {
        /* make packet's timestamp absolute */
        if (!packet->m_hasAbsTimestamp)
    e2d0:	e3530000 	cmp	r3, #0
            packet->m_nTimeStamp += r->m_channelTimestamp[packet->m_nChannel];	/* timestamps seem to be always relative!! */
    e2d4:	e5973054 	ldr	r3, [r7, #84]	; 0x54
    e2d8:	05950008 	ldreq	r0, [r5, #8]
    e2dc:	07932101 	ldreq	r2, [r3, r1, lsl #2]
    e2e0:	15952008 	ldrne	r2, [r5, #8]
    e2e4:	00822000 	addeq	r2, r2, r0
    e2e8:	10833101 	addne	r3, r3, r1, lsl #2
    e2ec:	00833101 	addeq	r3, r3, r1, lsl #2
    e2f0:	05852008 	streq	r2, [r5, #8]
        
        r->m_channelTimestamp[packet->m_nChannel] = packet->m_nTimeStamp;
    e2f4:	e5832000 	str	r2, [r3]
        
        /* reset the data from the stored packet. we keep the header since we may use it later if a new packet for this channel */
        /* arrives and requests to re-use some info (small packet header) */
        r->m_vecChannelsIn[packet->m_nChannel]->m_body = NULL;
    e2f8:	e597204c 	ldr	r2, [r7, #76]	; 0x4c
    e2fc:	e5951004 	ldr	r1, [r5, #4]
    e300:	e3a03000 	mov	r3, #0
    e304:	e7920101 	ldr	r0, [r2, r1, lsl #2]
    else
    {
        packet->m_body = NULL;	/* so it won't be erased on free */
    }
    
    return TRUE;
    e308:	e3a04001 	mov	r4, #1
        
        r->m_channelTimestamp[packet->m_nChannel] = packet->m_nTimeStamp;
        
        /* reset the data from the stored packet. we keep the header since we may use it later if a new packet for this channel */
        /* arrives and requests to re-use some info (small packet header) */
        r->m_vecChannelsIn[packet->m_nChannel]->m_body = NULL;
    e30c:	e580301c 	str	r3, [r0, #28]
        r->m_vecChannelsIn[packet->m_nChannel]->m_nBytesRead = 0;
    e310:	e7922101 	ldr	r2, [r2, r1, lsl #2]
    e314:	e5823014 	str	r3, [r2, #20]
        r->m_vecChannelsIn[packet->m_nChannel]->m_hasAbsTimestamp = FALSE;	/* can only be false if we reuse header */
    e318:	e5c23002 	strb	r3, [r2, #2]
    e31c:	eaffff87 	b	e140 <RTMP_ReadPacket+0x2cc>
    header++;
    if (packet->m_nChannel == 0)
    {
        if (ReadN(r, (char *)&hbuf[1], 1) != 1)
        {
            RTMP_Log(RTMP_LOGERROR, "%s, failed to read RTMP packet header 2nd byte",
    e320:	e59f212c 	ldr	r2, [pc, #300]	; e454 <RTMP_ReadPacket+0x5e0>
    e324:	e59f112c 	ldr	r1, [pc, #300]	; e458 <RTMP_ReadPacket+0x5e4>
    e328:	e08f2002 	add	r2, pc, r2
    e32c:	e3a00001 	mov	r0, #1
    e330:	e2422eb3 	sub	r2, r2, #2864	; 0xb30
    e334:	e08f1001 	add	r1, pc, r1
    e338:	eb001d9b 	bl	159ac <RTMP_Log>
                     __FUNCTION__);
            return FALSE;
    e33c:	eaffff7f 	b	e140 <RTMP_ReadPacket+0x2cc>
        header++;
    }
    else if (packet->m_nChannel == 1)
    {
        int tmp;
        if (ReadN(r, (char *)&hbuf[1], 2) != 2)
    e340:	e1a00007 	mov	r0, r7
    e344:	e28d1005 	add	r1, sp, #5
    e348:	e3a02002 	mov	r2, #2
    e34c:	ebfffada 	bl	cebc <ReadN>
    e350:	e3500002 	cmp	r0, #2
    e354:	0a000008 	beq	e37c <RTMP_ReadPacket+0x508>
        {
            RTMP_Log(RTMP_LOGERROR, "%s, failed to read RTMP packet header 3nd byte",
    e358:	e59f20fc 	ldr	r2, [pc, #252]	; e45c <RTMP_ReadPacket+0x5e8>
    e35c:	e59f10fc 	ldr	r1, [pc, #252]	; e460 <RTMP_ReadPacket+0x5ec>
    e360:	e08f2002 	add	r2, pc, r2
    e364:	e1a00004 	mov	r0, r4
    e368:	e2422eb3 	sub	r2, r2, #2864	; 0xb30
    e36c:	e08f1001 	add	r1, pc, r1
                     __FUNCTION__);
            return FALSE;
    e370:	e1a04006 	mov	r4, r6
    else if (packet->m_nChannel == 1)
    {
        int tmp;
        if (ReadN(r, (char *)&hbuf[1], 2) != 2)
        {
            RTMP_Log(RTMP_LOGERROR, "%s, failed to read RTMP packet header 3nd byte",
    e374:	eb001d8c 	bl	159ac <RTMP_Log>
                     __FUNCTION__);
            return FALSE;
    e378:	eaffff70 	b	e140 <RTMP_ReadPacket+0x2cc>
        }
        tmp = (hbuf[2] << 8) + hbuf[1];
    e37c:	e5dd1006 	ldrb	r1, [sp, #6]
    e380:	e5dd3005 	ldrb	r3, [sp, #5]
        packet->m_nChannel = tmp + 64;
        RTMP_Log(RTMP_LOGDEBUG, "%s, m_nChannel: %0x", __FUNCTION__, packet->m_nChannel);
    e384:	e59f20d8 	ldr	r2, [pc, #216]	; e464 <RTMP_ReadPacket+0x5f0>
        {
            RTMP_Log(RTMP_LOGERROR, "%s, failed to read RTMP packet header 3nd byte",
                     __FUNCTION__);
            return FALSE;
        }
        tmp = (hbuf[2] << 8) + hbuf[1];
    e388:	e0833401 	add	r3, r3, r1, lsl #8
        packet->m_nChannel = tmp + 64;
        RTMP_Log(RTMP_LOGDEBUG, "%s, m_nChannel: %0x", __FUNCTION__, packet->m_nChannel);
    e38c:	e59f10d4 	ldr	r1, [pc, #212]	; e468 <RTMP_ReadPacket+0x5f4>
            RTMP_Log(RTMP_LOGERROR, "%s, failed to read RTMP packet header 3nd byte",
                     __FUNCTION__);
            return FALSE;
        }
        tmp = (hbuf[2] << 8) + hbuf[1];
        packet->m_nChannel = tmp + 64;
    e390:	e2833040 	add	r3, r3, #64	; 0x40
        RTMP_Log(RTMP_LOGDEBUG, "%s, m_nChannel: %0x", __FUNCTION__, packet->m_nChannel);
    e394:	e08f2002 	add	r2, pc, r2
            RTMP_Log(RTMP_LOGERROR, "%s, failed to read RTMP packet header 3nd byte",
                     __FUNCTION__);
            return FALSE;
        }
        tmp = (hbuf[2] << 8) + hbuf[1];
        packet->m_nChannel = tmp + 64;
    e398:	e5853004 	str	r3, [r5, #4]
        RTMP_Log(RTMP_LOGDEBUG, "%s, m_nChannel: %0x", __FUNCTION__, packet->m_nChannel);
    e39c:	e2422eb3 	sub	r2, r2, #2864	; 0xb30
    e3a0:	e3a00004 	mov	r0, #4
    e3a4:	e08f1001 	add	r1, pc, r1
    e3a8:	eb001d7f 	bl	159ac <RTMP_Log>
        header += 2;
    e3ac:	e28d6007 	add	r6, sp, #7
    e3b0:	e5d53000 	ldrb	r3, [r5]
    e3b4:	e5954004 	ldr	r4, [r5, #4]
    e3b8:	eafffec7 	b	dedc <RTMP_ReadPacket+0x68>
    {
        int n = packet->m_nChannel + 10;
        int *timestamp = realloc(r->m_channelTimestamp, sizeof(int) * n);
        RTMPPacket **packets = realloc(r->m_vecChannelsIn, sizeof(RTMPPacket*) * n);
        if (!timestamp)
            free(r->m_channelTimestamp);
    e3bc:	e5970054 	ldr	r0, [r7, #84]	; 0x54
    e3c0:	ebffdb0f 	bl	5004 <free@plt>
        if (!packets)
    e3c4:	e35b0000 	cmp	fp, #0
            free(r->m_vecChannelsIn);
        r->m_channelTimestamp = timestamp;
    e3c8:	1587a054 	strne	sl, [r7, #84]	; 0x54
        r->m_vecChannelsIn = packets;
    e3cc:	1587b04c 	strne	fp, [r7, #76]	; 0x4c
        int n = packet->m_nChannel + 10;
        int *timestamp = realloc(r->m_channelTimestamp, sizeof(int) * n);
        RTMPPacket **packets = realloc(r->m_vecChannelsIn, sizeof(RTMPPacket*) * n);
        if (!timestamp)
            free(r->m_channelTimestamp);
        if (!packets)
    e3d0:	1a000003 	bne	e3e4 <RTMP_ReadPacket+0x570>
            free(r->m_vecChannelsIn);
    e3d4:	e597004c 	ldr	r0, [r7, #76]	; 0x4c
    e3d8:	ebffdb09 	bl	5004 <free@plt>
        r->m_channelTimestamp = timestamp;
    e3dc:	e587a054 	str	sl, [r7, #84]	; 0x54
        r->m_vecChannelsIn = packets;
    e3e0:	e587b04c 	str	fp, [r7, #76]	; 0x4c
        if (!timestamp || !packets) {
            r->m_channelsAllocatedIn = 0;
    e3e4:	e3a04000 	mov	r4, #0
    {
        packet->m_body = NULL;	/* so it won't be erased on free */
    }
    
    return TRUE;
}
    e3e8:	e1a00004 	mov	r0, r4
        if (!packets)
            free(r->m_vecChannelsIn);
        r->m_channelTimestamp = timestamp;
        r->m_vecChannelsIn = packets;
        if (!timestamp || !packets) {
            r->m_channelsAllocatedIn = 0;
    e3ec:	e5874044 	str	r4, [r7, #68]	; 0x44
    {
        packet->m_body = NULL;	/* so it won't be erased on free */
    }
    
    return TRUE;
}
    e3f0:	e28dd01c 	add	sp, sp, #28
    e3f4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    
    packet->m_nBytesRead += nChunk;
    
    /* keep the packet as ref for other packets on this channel */
    if (!r->m_vecChannelsIn[packet->m_nChannel])
        r->m_vecChannelsIn[packet->m_nChannel] = malloc(sizeof(RTMPPacket));
    e3f8:	e3a00020 	mov	r0, #32
    e3fc:	ebffdb06 	bl	501c <malloc@plt>
    e400:	e7880106 	str	r0, [r8, r6, lsl #2]
    e404:	e597304c 	ldr	r3, [r7, #76]	; 0x4c
    e408:	e7930106 	ldr	r0, [r3, r6, lsl #2]
    e40c:	eaffff9d 	b	e288 <RTMP_ReadPacket+0x414>
    
    if (packet->m_nBodySize > 0 && packet->m_body == NULL)
    {
        if (!RTMPPacket_Alloc(packet, packet->m_nBodySize))
        {
            RTMP_Log(RTMP_LOGDEBUG, "%s, failed to allocate packet", __FUNCTION__);
    e410:	e59f2054 	ldr	r2, [pc, #84]	; e46c <RTMP_ReadPacket+0x5f8>
    e414:	e59f1054 	ldr	r1, [pc, #84]	; e470 <RTMP_ReadPacket+0x5fc>
    e418:	e08f2002 	add	r2, pc, r2
    e41c:	e3a00004 	mov	r0, #4
    e420:	e2422eb3 	sub	r2, r2, #2864	; 0xb30
    e424:	e08f1001 	add	r1, pc, r1
    e428:	eb001d5f 	bl	159ac <RTMP_Log>
            return FALSE;
    e42c:	eaffff43 	b	e140 <RTMP_ReadPacket+0x2cc>
    e430:	000108fc 	.word	0x000108fc
    e434:	00010874 	.word	0x00010874
    e438:	00011698 	.word	0x00011698
    e43c:	00010714 	.word	0x00010714
    e440:	0001157c 	.word	0x0001157c
    e444:	000106b4 	.word	0x000106b4
    e448:	0001140c 	.word	0x0001140c
    e44c:	000105b8 	.word	0x000105b8
    e450:	000113ac 	.word	0x000113ac
    e454:	000104b8 	.word	0x000104b8
    e458:	00011238 	.word	0x00011238
    e45c:	00010480 	.word	0x00010480
    e460:	00011230 	.word	0x00011230
    e464:	0001044c 	.word	0x0001044c
    e468:	00011228 	.word	0x00011228
    e46c:	000103c8 	.word	0x000103c8
    e470:	00011214 	.word	0x00011214

0000e474 <SHandShake>:
  return TRUE;
}

static int
SHandShake(RTMP * r)
{
    e474:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e478:	e24ddd4a 	sub	sp, sp, #4736	; 0x1280
    e47c:	e24dd00c 	sub	sp, sp, #12
  uint8_t serverbuf[RTMP_SIG_SIZE + 4], *serversig = serverbuf+4;
  uint8_t type;
  uint32_t uptime;
  getoff *getdh = NULL, *getdig = NULL;

  if (ReadN(r, (char *)&type, 1) != 1)	/* 0x03 or 0x06 */
    e480:	e28d6048 	add	r6, sp, #72	; 0x48
SHandShake(RTMP * r)
{
  int i, offalg = 0;
  int dhposServer = 0;
  int digestPosServer = 0;
  RC4_handle keyIn = 0;
    e484:	e28d5fa2 	add	r5, sp, #648	; 0x288
    e488:	e3a0a000 	mov	sl, #0
  uint8_t serverbuf[RTMP_SIG_SIZE + 4], *serversig = serverbuf+4;
  uint8_t type;
  uint32_t uptime;
  getoff *getdh = NULL, *getdig = NULL;

  if (ReadN(r, (char *)&type, 1) != 1)	/* 0x03 or 0x06 */
    e48c:	e246100d 	sub	r1, r6, #13
    e490:	e3a02001 	mov	r2, #1
SHandShake(RTMP * r)
{
  int i, offalg = 0;
  int dhposServer = 0;
  int digestPosServer = 0;
  RC4_handle keyIn = 0;
    e494:	e505a24c 	str	sl, [r5, #-588]	; 0xfffffdb4
  RC4_handle keyOut = 0;
    e498:	e505a248 	str	sl, [r5, #-584]	; 0xfffffdb8
  return TRUE;
}

static int
SHandShake(RTMP * r)
{
    e49c:	e1a07000 	mov	r7, r0
  uint8_t serverbuf[RTMP_SIG_SIZE + 4], *serversig = serverbuf+4;
  uint8_t type;
  uint32_t uptime;
  getoff *getdh = NULL, *getdig = NULL;

  if (ReadN(r, (char *)&type, 1) != 1)	/* 0x03 or 0x06 */
    e4a0:	ebfffa85 	bl	cebc <ReadN>
    e4a4:	e3500001 	cmp	r0, #1
    e4a8:	e1a04000 	mov	r4, r0
    e4ac:	0a000004 	beq	e4c4 <SHandShake+0x50>
      if (memcmp
	  (signature, &clientsig[RTMP_SIG_SIZE - SHA256_DIGEST_LENGTH],
	   SHA256_DIGEST_LENGTH) != 0)
	{
	  RTMP_Log(RTMP_LOGWARNING, "%s: Client not genuine Adobe!", __FUNCTION__);
	  return FALSE;
    e4b0:	e3a04000 	mov	r4, #0
	}
    }

  RTMP_Log(RTMP_LOGDEBUG, "%s: Handshaking finished....", __FUNCTION__);
  return TRUE;
}
    e4b4:	e1a00004 	mov	r0, r4
    e4b8:	e28ddd4a 	add	sp, sp, #4736	; 0x1280
    e4bc:	e28dd00c 	add	sp, sp, #12
    e4c0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  getoff *getdh = NULL, *getdig = NULL;

  if (ReadN(r, (char *)&type, 1) != 1)	/* 0x03 or 0x06 */
    return FALSE;

  if (ReadN(r, (char *)clientsig, RTMP_SIG_SIZE) != RTMP_SIG_SIZE)
    e4c4:	e28d9088 	add	r9, sp, #136	; 0x88
    e4c8:	e2498004 	sub	r8, r9, #4
    e4cc:	e1a01008 	mov	r1, r8
    e4d0:	e1a00007 	mov	r0, r7
    e4d4:	e3a02c06 	mov	r2, #1536	; 0x600
    e4d8:	ebfffa77 	bl	cebc <ReadN>
    e4dc:	e3500c06 	cmp	r0, #1536	; 0x600
    e4e0:	e1a0b000 	mov	fp, r0
    e4e4:	1afffff1 	bne	e4b0 <SHandShake+0x3c>
    return FALSE;

  RTMP_Log(RTMP_LOGDEBUG, "%s: Type Requested : %02X", __FUNCTION__, type);
    e4e8:	e59fc9c4 	ldr	ip, [pc, #2500]	; eeb4 <SHandShake+0xa40>
    e4ec:	e59f19c4 	ldr	r1, [pc, #2500]	; eeb8 <SHandShake+0xa44>
    e4f0:	e08fc00c 	add	ip, pc, ip
    e4f4:	e24cceb2 	sub	ip, ip, #2848	; 0xb20
    e4f8:	e1a0200c 	mov	r2, ip
    e4fc:	e555324d 	ldrb	r3, [r5, #-589]	; 0xfffffdb3
    e500:	e3a00004 	mov	r0, #4
    e504:	e08f1001 	add	r1, pc, r1
    e508:	e58dc010 	str	ip, [sp, #16]
    e50c:	eb001d26 	bl	159ac <RTMP_Log>
  RTMP_LogHex(RTMP_LOGDEBUG2, clientsig, RTMP_SIG_SIZE);
    e510:	e1a0200b 	mov	r2, fp
    e514:	e3a00005 	mov	r0, #5
    e518:	e1a01008 	mov	r1, r8
    e51c:	eb001d32 	bl	159ec <RTMP_LogHex>

  if (type == 3)
    e520:	e555324d 	ldrb	r3, [r5, #-589]	; 0xfffffdb3
    e524:	e3530003 	cmp	r3, #3
    e528:	0a000147 	beq	ea4c <SHandShake+0x5d8>
    {
      encrypted = FALSE;
    }
  else if (type == 6 || type == 8)
    e52c:	e2432006 	sub	r2, r3, #6
    e530:	e31200fd 	tst	r2, #253	; 0xfd
    e534:	e59dc010 	ldr	ip, [sp, #16]
    e538:	1a000160 	bne	eac0 <SHandShake+0x64c>
    {
      offalg = 1;
      encrypted = TRUE;
      FP9HandShake = TRUE;
      r->Link.protocol |= RTMP_FEATURE_ENC;
    e53c:	e287a901 	add	sl, r7, #16384	; 0x4000
    e540:	e59a2188 	ldr	r2, [sl, #392]	; 0x188
      /* use FP10 if client is capable */
      if (clientsig[4] == 128)
    e544:	e5551200 	ldrb	r1, [r5, #-512]	; 0xfffffe00
  else if (type == 6 || type == 8)
    {
      offalg = 1;
      encrypted = TRUE;
      FP9HandShake = TRUE;
      r->Link.protocol |= RTMP_FEATURE_ENC;
    e548:	e3822002 	orr	r2, r2, #2
      /* use FP10 if client is capable */
      if (clientsig[4] == 128)
    e54c:	e3510080 	cmp	r1, #128	; 0x80
  else if (type == 6 || type == 8)
    {
      offalg = 1;
      encrypted = TRUE;
      FP9HandShake = TRUE;
      r->Link.protocol |= RTMP_FEATURE_ENC;
    e550:	e58a2188 	str	r2, [sl, #392]	; 0x188
      /* use FP10 if client is capable */
      if (clientsig[4] == 128)
	type = 8;
    e554:	03a03008 	moveq	r3, #8
}

static int
SHandShake(RTMP * r)
{
  int i, offalg = 0;
    e558:	e3a02001 	mov	r2, #1
      encrypted = TRUE;
      FP9HandShake = TRUE;
      r->Link.protocol |= RTMP_FEATURE_ENC;
      /* use FP10 if client is capable */
      if (clientsig[4] == 128)
	type = 8;
    e55c:	0545324d 	strbeq	r3, [r5, #-589]	; 0xfffffdb3
}

static int
SHandShake(RTMP * r)
{
  int i, offalg = 0;
    e560:	e58d2014 	str	r2, [sp, #20]
  if (!FP9HandShake && clientsig[4])
    FP9HandShake = TRUE;

  serversig[-1] = type;

  r->Link.rc4keyIn = r->Link.rc4keyOut = 0;
    e564:	e3a02000 	mov	r2, #0
    e568:	e58a21a0 	str	r2, [sl, #416]	; 0x1a0
    e56c:	e58a219c 	str	r2, [sl, #412]	; 0x19c
    }

  if (!FP9HandShake && clientsig[4])
    FP9HandShake = TRUE;

  serversig[-1] = type;
    e570:	e5cd3c87 	strb	r3, [sp, #3207]	; 0xc87

  r->Link.rc4keyIn = r->Link.rc4keyOut = 0;

  uptime = htonl(RTMP_GetTime());
    e574:	ebffe803 	bl	8588 <RTMP_GetTime>
      serversig[4] = 3;
      serversig[5] = 5;
      serversig[6] = 1;
      serversig[7] = 1;

      getdig = digoff[offalg];
    e578:	e59fb93c 	ldr	fp, [pc, #2364]	; eebc <SHandShake+0xa48>
  memcpy(serversig, &uptime, 4);

  if (FP9HandShake)
    {
      /* Server version */
      serversig[4] = 3;
    e57c:	e3a01003 	mov	r1, #3
      serversig[5] = 5;
      serversig[6] = 1;
      serversig[7] = 1;

      getdig = digoff[offalg];
    e580:	e08fb00b 	add	fp, pc, fp

  if (FP9HandShake)
    {
      /* Server version */
      serversig[4] = 3;
      serversig[5] = 5;
    e584:	e3a02005 	mov	r2, #5
  memcpy(serversig, &uptime, 4);

  if (FP9HandShake)
    {
      /* Server version */
      serversig[4] = 3;
    e588:	e5cd1c8c 	strb	r1, [sp, #3212]	; 0xc8c
      serversig[5] = 5;
    e58c:	e5cd2c8d 	strb	r2, [sp, #3213]	; 0xc8d

  serversig[-1] = type;

  r->Link.rc4keyIn = r->Link.rc4keyOut = 0;

  uptime = htonl(RTMP_GetTime());
    e590:	e0203860 	eor	r3, r0, r0, ror #16
    e594:	e1a03423 	lsr	r3, r3, #8
    e598:	e3c33cff 	bic	r3, r3, #65280	; 0xff00
    e59c:	e0234460 	eor	r4, r3, r0, ror #8
      serversig[4] = 3;
      serversig[5] = 5;
      serversig[6] = 1;
      serversig[7] = 1;

      getdig = digoff[offalg];
    e5a0:	e59d3014 	ldr	r3, [sp, #20]
  serversig[-1] = type;

  r->Link.rc4keyIn = r->Link.rc4keyOut = 0;

  uptime = htonl(RTMP_GetTime());
  memcpy(serversig, &uptime, 4);
    e5a4:	e58d4c88 	str	r4, [sp, #3208]	; 0xc88
      serversig[4] = 3;
      serversig[5] = 5;
      serversig[6] = 1;
      serversig[7] = 1;

      getdig = digoff[offalg];
    e5a8:	e08bb103 	add	fp, fp, r3, lsl #2
    e5ac:	e59b0330 	ldr	r0, [fp, #816]	; 0x330
  if (FP9HandShake)
    {
      /* Server version */
      serversig[4] = 3;
      serversig[5] = 5;
      serversig[6] = 1;
    e5b0:	e3a03001 	mov	r3, #1
      serversig[7] = 1;

      getdig = digoff[offalg];
    e5b4:	e58d001c 	str	r0, [sp, #28]
      getdh  = dhoff[offalg];
    e5b8:	e59b0338 	ldr	r0, [fp, #824]	; 0x338
    e5bc:	e58d0020 	str	r0, [sp, #32]
  if (FP9HandShake)
    {
      /* Server version */
      serversig[4] = 3;
      serversig[5] = 5;
      serversig[6] = 1;
    e5c0:	e5cd3c8e 	strb	r3, [sp, #3214]	; 0xc8e
      serversig[7] = 1;
    e5c4:	e5cd3c8f 	strb	r3, [sp, #3215]	; 0xc8f
    e5c8:	e58d3018 	str	r3, [sp, #24]

  /* generate random data */
#ifdef _DEBUG
  memset(serversig+8, 0, RTMP_SIG_SIZE-8);
#else
  ip = (int32_t *)(serversig+8);
    e5cc:	e28d3d32 	add	r3, sp, #3200	; 0xc80
    e5d0:	e2833008 	add	r3, r3, #8
    e5d4:	e58d3010 	str	r3, [sp, #16]
  for (i = 2; i < RTMP_SIG_SIZE/4; i++)
    e5d8:	e28d4d4a 	add	r4, sp, #4736	; 0x1280
    e5dc:	e28d3d32 	add	r3, sp, #3200	; 0xc80
    e5e0:	e2833004 	add	r3, r3, #4

  /* generate random data */
#ifdef _DEBUG
  memset(serversig+8, 0, RTMP_SIG_SIZE-8);
#else
  ip = (int32_t *)(serversig+8);
    e5e4:	e28dbec9 	add	fp, sp, #3216	; 0xc90
  for (i = 2; i < RTMP_SIG_SIZE/4; i++)
    e5e8:	e2844008 	add	r4, r4, #8
    e5ec:	e58d3024 	str	r3, [sp, #36]	; 0x24
    e5f0:	ebffdaf2 	bl	51c0 <lrand48@plt>
    *ip++ = rand();
    e5f4:	e48b0004 	str	r0, [fp], #4
  /* generate random data */
#ifdef _DEBUG
  memset(serversig+8, 0, RTMP_SIG_SIZE-8);
#else
  ip = (int32_t *)(serversig+8);
  for (i = 2; i < RTMP_SIG_SIZE/4; i++)
    e5f8:	e15b0004 	cmp	fp, r4
    e5fc:	1afffffb 	bne	e5f0 <SHandShake+0x17c>
    *ip++ = rand();
#endif

  /* set handshake digest */
  if (FP9HandShake)
    e600:	e59d3018 	ldr	r3, [sp, #24]
    e604:	e3530000 	cmp	r3, #0
    e608:	0a000118 	beq	ea70 <SHandShake+0x5fc>
    {
      if (encrypted)
    e60c:	e59d3014 	ldr	r3, [sp, #20]
    e610:	e3530000 	cmp	r3, #0
    e614:	0a000112 	beq	ea64 <SHandShake+0x5f0>
	{
	  /* generate Diffie-Hellmann parameters */
	  r->Link.dh = DHInit(1024);
    e618:	ebffdf20 	bl	62a0 <DHInit.constprop.14>
	  if (!r->Link.dh)
    e61c:	e3500000 	cmp	r0, #0
  if (FP9HandShake)
    {
      if (encrypted)
	{
	  /* generate Diffie-Hellmann parameters */
	  r->Link.dh = DHInit(1024);
    e620:	e1a04000 	mov	r4, r0
    e624:	e58a0198 	str	r0, [sl, #408]	; 0x198
	  if (!r->Link.dh)
    e628:	0a000177 	beq	ec0c <SHandShake+0x798>
	      RTMP_Log(RTMP_LOGERROR, "%s: Couldn't initialize Diffie-Hellmann!",
		  __FUNCTION__);
	      return FALSE;
	    }

	  dhposServer = getdh(serversig, RTMP_SIG_SIZE);
    e62c:	e3a01c06 	mov	r1, #1536	; 0x600
    e630:	e59d3020 	ldr	r3, [sp, #32]
    e634:	e59d0010 	ldr	r0, [sp, #16]
    e638:	e12fff33 	blx	r3
	  RTMP_Log(RTMP_LOGDEBUG, "%s: DH pubkey position: %d", __FUNCTION__, dhposServer);
    e63c:	e59fb87c 	ldr	fp, [pc, #2172]	; eec0 <SHandShake+0xa4c>
    e640:	e59f187c 	ldr	r1, [pc, #2172]	; eec4 <SHandShake+0xa50>
    e644:	e08fb00b 	add	fp, pc, fp
    e648:	e24bbeb2 	sub	fp, fp, #2848	; 0xb20
    e64c:	e1a0200b 	mov	r2, fp
    e650:	e08f1001 	add	r1, pc, r1
    e654:	e1a03000 	mov	r3, r0
    e658:	e58d0028 	str	r0, [sp, #40]	; 0x28
    e65c:	e3a00004 	mov	r0, #4
    e660:	eb001cd1 	bl	159ac <RTMP_Log>

	  if (!DHGenerateKey(r->Link.dh))
    e664:	e59a0198 	ldr	r0, [sl, #408]	; 0x198
    e668:	ebffdd72 	bl	5c38 <DHGenerateKey>
	      RTMP_Log(RTMP_LOGERROR, "%s: Couldn't initialize Diffie-Hellmann!",
		  __FUNCTION__);
	      return FALSE;
	    }

	  dhposServer = getdh(serversig, RTMP_SIG_SIZE);
    e66c:	e59dc028 	ldr	ip, [sp, #40]	; 0x28
    e670:	e58dc02c 	str	ip, [sp, #44]	; 0x2c
	  RTMP_Log(RTMP_LOGDEBUG, "%s: DH pubkey position: %d", __FUNCTION__, dhposServer);

	  if (!DHGenerateKey(r->Link.dh))
    e674:	e2504000 	subs	r4, r0, #0
    e678:	0a000117 	beq	eadc <SHandShake+0x668>
	      RTMP_Log(RTMP_LOGERROR, "%s: Couldn't generate Diffie-Hellmann public key!",
		  __FUNCTION__);
	      return FALSE;
	    }

	  if (!DHGetPublicKey
    e67c:	e59d3010 	ldr	r3, [sp, #16]
    e680:	e59a0198 	ldr	r0, [sl, #408]	; 0x198
    e684:	e083100c 	add	r1, r3, ip
    e688:	ebffdf3c 	bl	6380 <DHGetPublicKey.constprop.15>
    e68c:	e2504000 	subs	r4, r0, #0
    e690:	0a000132 	beq	eb60 <SHandShake+0x6ec>
	      RTMP_Log(RTMP_LOGERROR, "%s: Couldn't write public key!", __FUNCTION__);
	      return FALSE;
	    }
	}

      digestPosServer = getdig(serversig, RTMP_SIG_SIZE);	/* reuse this value in verification */
    e694:	e3a01c06 	mov	r1, #1536	; 0x600
    e698:	e59d301c 	ldr	r3, [sp, #28]
    e69c:	e59d0010 	ldr	r0, [sp, #16]
    e6a0:	e12fff33 	blx	r3
      RTMP_Log(RTMP_LOGDEBUG, "%s: Server digest offset: %d", __FUNCTION__,
    e6a4:	e59f481c 	ldr	r4, [pc, #2076]	; eec8 <SHandShake+0xa54>
    e6a8:	e59f181c 	ldr	r1, [pc, #2076]	; eecc <SHandShake+0xa58>
    e6ac:	e08f4004 	add	r4, pc, r4
    e6b0:	e244ceb2 	sub	ip, r4, #2848	; 0xb20
    e6b4:	e1a0200c 	mov	r2, ip
    e6b8:	e08f1001 	add	r1, pc, r1
    e6bc:	e58dc028 	str	ip, [sp, #40]	; 0x28
	      RTMP_Log(RTMP_LOGERROR, "%s: Couldn't write public key!", __FUNCTION__);
	      return FALSE;
	    }
	}

      digestPosServer = getdig(serversig, RTMP_SIG_SIZE);	/* reuse this value in verification */
    e6c0:	e1a0b000 	mov	fp, r0
      RTMP_Log(RTMP_LOGDEBUG, "%s: Server digest offset: %d", __FUNCTION__,
    e6c4:	e1a03000 	mov	r3, r0
	      RTMP_Log(RTMP_LOGERROR, "%s: Couldn't write public key!", __FUNCTION__);
	      return FALSE;
	    }
	}

      digestPosServer = getdig(serversig, RTMP_SIG_SIZE);	/* reuse this value in verification */
    e6c8:	e58d0030 	str	r0, [sp, #48]	; 0x30
      RTMP_Log(RTMP_LOGDEBUG, "%s: Server digest offset: %d", __FUNCTION__,
    e6cc:	e3a00004 	mov	r0, #4
    e6d0:	eb001cb5 	bl	159ac <RTMP_Log>
	  digestPosServer);

      CalculateDigest(digestPosServer, serversig, GenuineFMSKey, 36,
    e6d4:	e59d1010 	ldr	r1, [sp, #16]
    e6d8:	e1a0300b 	mov	r3, fp
    e6dc:	e2442eb7 	sub	r2, r4, #2928	; 0xb70
    e6e0:	e081b00b 	add	fp, r1, fp
    e6e4:	e1a00003 	mov	r0, r3
    e6e8:	e2422008 	sub	r2, r2, #8
    e6ec:	e3a03024 	mov	r3, #36	; 0x24
    e6f0:	e58db000 	str	fp, [sp]
    e6f4:	ebffe39b 	bl	7568 <CalculateDigest>
		      &serversig[digestPosServer]);

      RTMP_Log(RTMP_LOGDEBUG, "%s: Initial server digest: ", __FUNCTION__);
    e6f8:	e59dc028 	ldr	ip, [sp, #40]	; 0x28
    e6fc:	e59f17cc 	ldr	r1, [pc, #1996]	; eed0 <SHandShake+0xa5c>
    e700:	e1a0200c 	mov	r2, ip
    e704:	e3a00004 	mov	r0, #4
    e708:	e08f1001 	add	r1, pc, r1
    e70c:	eb001ca6 	bl	159ac <RTMP_Log>
      RTMP_LogHex(RTMP_LOGDEBUG, serversig + digestPosServer,
    e710:	e1a0100b 	mov	r1, fp
    e714:	e3a00004 	mov	r0, #4
    e718:	e3a02020 	mov	r2, #32
    e71c:	eb001cb2 	bl	159ec <RTMP_LogHex>
	     SHA256_DIGEST_LENGTH);
    }

  RTMP_Log(RTMP_LOGDEBUG2, "Serversig: ");
    e720:	e59f17ac 	ldr	r1, [pc, #1964]	; eed4 <SHandShake+0xa60>
    e724:	e3a00005 	mov	r0, #5
    e728:	e08f1001 	add	r1, pc, r1
    e72c:	eb001c9e 	bl	159ac <RTMP_Log>
  RTMP_LogHex(RTMP_LOGDEBUG2, serversig, RTMP_SIG_SIZE);
    e730:	e59d4010 	ldr	r4, [sp, #16]
    e734:	e3a00005 	mov	r0, #5
    e738:	e1a01004 	mov	r1, r4
    e73c:	e3a02c06 	mov	r2, #1536	; 0x600
    e740:	eb001ca9 	bl	159ec <RTMP_LogHex>

  if (!WriteN(r, (char *)serversig-1, RTMP_SIG_SIZE + 1,0))
    e744:	e1a00007 	mov	r0, r7
    e748:	e2441001 	sub	r1, r4, #1
    e74c:	e59f2784 	ldr	r2, [pc, #1924]	; eed8 <SHandShake+0xa64>
    e750:	ebfff283 	bl	b164 <WriteN.isra.9>
    e754:	e3500000 	cmp	r0, #0
    e758:	0affff54 	beq	e4b0 <SHandShake+0x3c>
    return FALSE;

  /* decode client response */
  memcpy(&uptime, clientsig, 4);
    e75c:	e5152204 	ldr	r2, [r5, #-516]	; 0xfffffdfc
  uptime = ntohl(uptime);

  RTMP_Log(RTMP_LOGDEBUG, "%s: Client Uptime : %d", __FUNCTION__, uptime);
    e760:	e59f4774 	ldr	r4, [pc, #1908]	; eedc <SHandShake+0xa68>
  if (!WriteN(r, (char *)serversig-1, RTMP_SIG_SIZE + 1,0))
    return FALSE;

  /* decode client response */
  memcpy(&uptime, clientsig, 4);
  uptime = ntohl(uptime);
    e764:	e0223862 	eor	r3, r2, r2, ror #16

  RTMP_Log(RTMP_LOGDEBUG, "%s: Client Uptime : %d", __FUNCTION__, uptime);
    e768:	e08f4004 	add	r4, pc, r4
  if (!WriteN(r, (char *)serversig-1, RTMP_SIG_SIZE + 1,0))
    return FALSE;

  /* decode client response */
  memcpy(&uptime, clientsig, 4);
  uptime = ntohl(uptime);
    e76c:	e1a03423 	lsr	r3, r3, #8

  RTMP_Log(RTMP_LOGDEBUG, "%s: Client Uptime : %d", __FUNCTION__, uptime);
    e770:	e59f1768 	ldr	r1, [pc, #1896]	; eee0 <SHandShake+0xa6c>
    e774:	e244beb2 	sub	fp, r4, #2848	; 0xb20
  if (!WriteN(r, (char *)serversig-1, RTMP_SIG_SIZE + 1,0))
    return FALSE;

  /* decode client response */
  memcpy(&uptime, clientsig, 4);
  uptime = ntohl(uptime);
    e778:	e3c33cff 	bic	r3, r3, #65280	; 0xff00

  RTMP_Log(RTMP_LOGDEBUG, "%s: Client Uptime : %d", __FUNCTION__, uptime);
    e77c:	e0233462 	eor	r3, r3, r2, ror #8
    e780:	e3a00004 	mov	r0, #4
    e784:	e1a0200b 	mov	r2, fp
    e788:	e08f1001 	add	r1, pc, r1
    e78c:	eb001c86 	bl	159ac <RTMP_Log>
  RTMP_Log(RTMP_LOGDEBUG, "%s: Player Version: %d.%d.%d.%d", __FUNCTION__, clientsig[4],
    e790:	e55501fe 	ldrb	r0, [r5, #-510]	; 0xfffffe02
    e794:	e55511fd 	ldrb	r1, [r5, #-509]	; 0xfffffe03
    e798:	e5553200 	ldrb	r3, [r5, #-512]	; 0xfffffe00
    e79c:	e555c1ff 	ldrb	ip, [r5, #-511]	; 0xfffffe01
    e7a0:	e98d0003 	stmib	sp, {r0, r1}
    e7a4:	e59f1738 	ldr	r1, [pc, #1848]	; eee4 <SHandShake+0xa70>
    e7a8:	e1a0200b 	mov	r2, fp
    e7ac:	e58dc000 	str	ip, [sp]
    e7b0:	e3a00004 	mov	r0, #4
    e7b4:	e08f1001 	add	r1, pc, r1
    e7b8:	eb001c7b 	bl	159ac <RTMP_Log>
      clientsig[5], clientsig[6], clientsig[7]);

  if (FP9HandShake)
    e7bc:	e59d3018 	ldr	r3, [sp, #24]
    e7c0:	e3530000 	cmp	r3, #0
    e7c4:	0a00006c 	beq	e97c <SHandShake+0x508>
    {
      uint8_t digestResp[SHA256_DIGEST_LENGTH];
      uint8_t *signatureResp = NULL;

      /* we have to use this signature now to find the correct algorithms for getting the digest and DH positions */
      int digestPosClient = getdig(clientsig, RTMP_SIG_SIZE);
    e7c8:	e3a01c06 	mov	r1, #1536	; 0x600
    e7cc:	e59d301c 	ldr	r3, [sp, #28]
    e7d0:	e1a00008 	mov	r0, r8
    e7d4:	e12fff33 	blx	r3

      if (!VerifyDigest(digestPosClient, clientsig, GenuineFPKey, 30))
    e7d8:	e2444ebb 	sub	r4, r4, #2992	; 0xbb0
    e7dc:	e2444008 	sub	r4, r4, #8
    e7e0:	e1a02004 	mov	r2, r4
    e7e4:	e1a01008 	mov	r1, r8
    e7e8:	e3a0301e 	mov	r3, #30
    {
      uint8_t digestResp[SHA256_DIGEST_LENGTH];
      uint8_t *signatureResp = NULL;

      /* we have to use this signature now to find the correct algorithms for getting the digest and DH positions */
      int digestPosClient = getdig(clientsig, RTMP_SIG_SIZE);
    e7ec:	e1a0b000 	mov	fp, r0

      if (!VerifyDigest(digestPosClient, clientsig, GenuineFPKey, 30))
    e7f0:	ebffe37a 	bl	75e0 <VerifyDigest>
    e7f4:	e3500000 	cmp	r0, #0
    {
      uint8_t digestResp[SHA256_DIGEST_LENGTH];
      uint8_t *signatureResp = NULL;

      /* we have to use this signature now to find the correct algorithms for getting the digest and DH positions */
      int digestPosClient = getdig(clientsig, RTMP_SIG_SIZE);
    e7f8:	158db01c 	strne	fp, [sp, #28]

      if (!VerifyDigest(digestPosClient, clientsig, GenuineFPKey, 30))
    e7fc:	0a0000bc 	beq	eaf4 <SHandShake+0x680>
	      return FALSE;
	    }
	}

      /* generate SWFVerification token (SHA256 HMAC hash of decompressed SWF, key are the last 32 bytes of the server handshake) */
      if (r->Link.SWFSize)
    e800:	e59ac1a4 	ldr	ip, [sl, #420]	; 0x1a4
    e804:	e35c0000 	cmp	ip, #0
    e808:	1a0000da 	bne	eb78 <SHandShake+0x704>
    e80c:	e28dbd1a 	add	fp, sp, #1664	; 0x680
    e810:	e28bb004 	add	fp, fp, #4
		     SHA256_DIGEST_LENGTH,
		     (uint8_t *)&r->Link.SWFVerificationResponse[10]);
	}

      /* do Diffie-Hellmann Key exchange for encrypted RTMP */
      if (encrypted)
    e814:	e59d3014 	ldr	r3, [sp, #20]
    e818:	e3530000 	cmp	r3, #0
    e81c:	0a00002b 	beq	e8d0 <SHandShake+0x45c>
	{
	  int dhposClient, len;
	  /* compute secret key */
	  uint8_t secretKey[128] = { 0 };
    e820:	e3a02080 	mov	r2, #128	; 0x80
    e824:	e3a01000 	mov	r1, #0
    e828:	e1a0000b 	mov	r0, fp
    e82c:	ebffda27 	bl	50d0 <memset@plt>

	  dhposClient = getdh(clientsig, RTMP_SIG_SIZE);
    e830:	e3a01c06 	mov	r1, #1536	; 0x600
    e834:	e59d3020 	ldr	r3, [sp, #32]
    e838:	e1a00008 	mov	r0, r8
    e83c:	e12fff33 	blx	r3
	  RTMP_Log(RTMP_LOGDEBUG, "%s: Client DH public key offset: %d", __FUNCTION__,
    e840:	e59fc6a0 	ldr	ip, [pc, #1696]	; eee8 <SHandShake+0xa74>
    e844:	e59f16a0 	ldr	r1, [pc, #1696]	; eeec <SHandShake+0xa78>
    e848:	e08fc00c 	add	ip, pc, ip
    e84c:	e24cceb2 	sub	ip, ip, #2848	; 0xb20
    e850:	e1a0200c 	mov	r2, ip
    e854:	e08f1001 	add	r1, pc, r1
    e858:	e58dc020 	str	ip, [sp, #32]
	{
	  int dhposClient, len;
	  /* compute secret key */
	  uint8_t secretKey[128] = { 0 };

	  dhposClient = getdh(clientsig, RTMP_SIG_SIZE);
    e85c:	e1a03000 	mov	r3, r0
	  RTMP_Log(RTMP_LOGDEBUG, "%s: Client DH public key offset: %d", __FUNCTION__,
	    dhposClient);
	  len =
	    DHComputeSharedSecretKey(r->Link.dh,
    e860:	e0884000 	add	r4, r8, r0
	  int dhposClient, len;
	  /* compute secret key */
	  uint8_t secretKey[128] = { 0 };

	  dhposClient = getdh(clientsig, RTMP_SIG_SIZE);
	  RTMP_Log(RTMP_LOGDEBUG, "%s: Client DH public key offset: %d", __FUNCTION__,
    e864:	e3a00004 	mov	r0, #4
    e868:	eb001c4f 	bl	159ac <RTMP_Log>
	    dhposClient);
	  len =
    e86c:	e1a0200b 	mov	r2, fp
    e870:	e1a01004 	mov	r1, r4
    e874:	e59a0198 	ldr	r0, [sl, #408]	; 0x198
    e878:	ebffdedc 	bl	63f0 <DHComputeSharedSecretKey.constprop.16>
	    DHComputeSharedSecretKey(r->Link.dh,
				     (uint8_t *) &clientsig[dhposClient], 128,
				     secretKey);
	  if (len < 0)
    e87c:	e59dc020 	ldr	ip, [sp, #32]
	    {
	      RTMP_Log(RTMP_LOGDEBUG, "%s: Wrong secret key position!", __FUNCTION__);
    e880:	e1a0200c 	mov	r2, ip
	    dhposClient);
	  len =
	    DHComputeSharedSecretKey(r->Link.dh,
				     (uint8_t *) &clientsig[dhposClient], 128,
				     secretKey);
	  if (len < 0)
    e884:	e3500000 	cmp	r0, #0
	    {
	      RTMP_Log(RTMP_LOGDEBUG, "%s: Wrong secret key position!", __FUNCTION__);
    e888:	e3a00004 	mov	r0, #4
	    dhposClient);
	  len =
	    DHComputeSharedSecretKey(r->Link.dh,
				     (uint8_t *) &clientsig[dhposClient], 128,
				     secretKey);
	  if (len < 0)
    e88c:	ba00010a 	blt	ecbc <SHandShake+0x848>
	    {
	      RTMP_Log(RTMP_LOGDEBUG, "%s: Wrong secret key position!", __FUNCTION__);
	      return FALSE;
	    }

	  RTMP_Log(RTMP_LOGDEBUG, "%s: Secret key: ", __FUNCTION__);
    e890:	e59f1658 	ldr	r1, [pc, #1624]	; eef0 <SHandShake+0xa7c>
    e894:	e08f1001 	add	r1, pc, r1
    e898:	eb001c43 	bl	159ac <RTMP_Log>
	  RTMP_LogHex(RTMP_LOGDEBUG, secretKey, 128);
    e89c:	e3a00004 	mov	r0, #4
    e8a0:	e1a0100b 	mov	r1, fp
    e8a4:	e3a02080 	mov	r2, #128	; 0x80
    e8a8:	eb001c4f 	bl	159ec <RTMP_LogHex>

	  InitRC4Encryption(secretKey,
    e8ac:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
    e8b0:	e59d2010 	ldr	r2, [sp, #16]
    e8b4:	e2463008 	sub	r3, r6, #8
    e8b8:	e0822000 	add	r2, r2, r0
    e8bc:	e58d3000 	str	r3, [sp]
    e8c0:	e1a01004 	mov	r1, r4
    e8c4:	e1a0000b 	mov	r0, fp
    e8c8:	e246300c 	sub	r3, r6, #12
    e8cc:	ebffdd5d 	bl	5e48 <InitRC4Encryption>


      /* calculate response now */
      signatureResp = clientsig+RTMP_SIG_SIZE-SHA256_DIGEST_LENGTH;

      HMACsha256(&clientsig[digestPosClient], SHA256_DIGEST_LENGTH,
    e8d0:	e59f261c 	ldr	r2, [pc, #1564]	; eef4 <SHandShake+0xa80>
    e8d4:	e59d301c 	ldr	r3, [sp, #28]
    e8d8:	e08f2002 	add	r2, pc, r2
    e8dc:	e2422eb7 	sub	r2, r2, #2928	; 0xb70
    e8e0:	e0880003 	add	r0, r8, r3
    e8e4:	e2422008 	sub	r2, r2, #8
    e8e8:	e3a01020 	mov	r1, #32
    e8ec:	e3a03044 	mov	r3, #68	; 0x44
    e8f0:	e58db000 	str	fp, [sp]
    e8f4:	ebffdd40 	bl	5dfc <HMACsha256>
		 GenuineFMSKey, sizeof(GenuineFMSKey), digestResp);
      HMACsha256(clientsig, RTMP_SIG_SIZE - SHA256_DIGEST_LENGTH, digestResp,
    e8f8:	e2883e5e 	add	r3, r8, #1504	; 0x5e0
    e8fc:	e58d3000 	str	r3, [sp]
    e900:	e1a00008 	mov	r0, r8
    e904:	e3a03020 	mov	r3, #32
    e908:	e3a01e5e 	mov	r1, #1504	; 0x5e0
    e90c:	e1a0200b 	mov	r2, fp
    e910:	ebffdd39 	bl	5dfc <HMACsha256>
		 SHA256_DIGEST_LENGTH, signatureResp);
#ifdef FP10
      if (type == 8 )
    e914:	e555324d 	ldrb	r3, [r5, #-589]	; 0xfffffdb3
    e918:	e3530008 	cmp	r3, #8
    e91c:	0a0000d4 	beq	ec74 <SHandShake+0x800>
	  uint8_t *sig = signatureResp;
	  /* encrypt signatureResp */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
	    rtmpe8_sig(sig+i, sig+i, dptr[i] % 15);
        }
      else if (type == 9)
    e920:	e3530009 	cmp	r3, #9
    e924:	0a0000c0 	beq	ec2c <SHandShake+0x7b8>
            rtmpe9_sig(sig+i, sig+i, dptr[i] % 15);
        }
#endif

      /* some info output */
      RTMP_Log(RTMP_LOGDEBUG,
    e928:	e59f45c8 	ldr	r4, [pc, #1480]	; eef8 <SHandShake+0xa84>
    e92c:	e59f15c8 	ldr	r1, [pc, #1480]	; eefc <SHandShake+0xa88>
    e930:	e08f4004 	add	r4, pc, r4
    e934:	e2444eb2 	sub	r4, r4, #2848	; 0xb20
    e938:	e3a00004 	mov	r0, #4
    e93c:	e1a02004 	mov	r2, r4
    e940:	e08f1001 	add	r1, pc, r1
    e944:	eb001c18 	bl	159ac <RTMP_Log>
	  "%s: Calculated digest key from secure key and server digest: ",
	  __FUNCTION__);
      RTMP_LogHex(RTMP_LOGDEBUG, digestResp, SHA256_DIGEST_LENGTH);
    e948:	e1a0100b 	mov	r1, fp
    e94c:	e3a00004 	mov	r0, #4
    e950:	e3a02020 	mov	r2, #32
    e954:	eb001c24 	bl	159ec <RTMP_LogHex>

      RTMP_Log(RTMP_LOGDEBUG, "%s: Server signature calculated:", __FUNCTION__);
    e958:	e59f15a0 	ldr	r1, [pc, #1440]	; ef00 <SHandShake+0xa8c>
    e95c:	e1a02004 	mov	r2, r4
    e960:	e3a00004 	mov	r0, #4
    e964:	e08f1001 	add	r1, pc, r1
    e968:	eb001c0f 	bl	159ac <RTMP_Log>
      RTMP_LogHex(RTMP_LOGDEBUG, signatureResp, SHA256_DIGEST_LENGTH);
    e96c:	e3a00004 	mov	r0, #4
    e970:	e2881e5e 	add	r1, r8, #1504	; 0x5e0
    e974:	e3a02020 	mov	r2, #32
    e978:	eb001c1b 	bl	159ec <RTMP_LogHex>
      uptime = htonl(RTMP_GetTime());
      memcpy(clientsig+4, &uptime, 4);
    }
#endif

  RTMP_Log(RTMP_LOGDEBUG2, "%s: Sending handshake response: ",
    e97c:	e59fb580 	ldr	fp, [pc, #1408]	; ef04 <SHandShake+0xa90>
    e980:	e59f1580 	ldr	r1, [pc, #1408]	; ef08 <SHandShake+0xa94>
    e984:	e08fb00b 	add	fp, pc, fp
    e988:	e24b4eb2 	sub	r4, fp, #2848	; 0xb20
    e98c:	e3a00005 	mov	r0, #5
    e990:	e1a02004 	mov	r2, r4
    e994:	e08f1001 	add	r1, pc, r1
    e998:	eb001c03 	bl	159ac <RTMP_Log>
    __FUNCTION__);
  RTMP_LogHex(RTMP_LOGDEBUG2, clientsig, RTMP_SIG_SIZE);
    e99c:	e3a00005 	mov	r0, #5
    e9a0:	e1a01008 	mov	r1, r8
    e9a4:	e3a02c06 	mov	r2, #1536	; 0x600
    e9a8:	eb001c0f 	bl	159ec <RTMP_LogHex>

  if (!WriteN(r, (char *)clientsig, RTMP_SIG_SIZE,0))
    e9ac:	e1a00007 	mov	r0, r7
    e9b0:	e1a01008 	mov	r1, r8
    e9b4:	e3a02c06 	mov	r2, #1536	; 0x600
    e9b8:	ebfff1e9 	bl	b164 <WriteN.isra.9>
    e9bc:	e3500000 	cmp	r0, #0
    e9c0:	0afffeba 	beq	e4b0 <SHandShake+0x3c>
    return FALSE;

  /* 2nd part of handshake */
  if (ReadN(r, (char *)clientsig, RTMP_SIG_SIZE) != RTMP_SIG_SIZE)
    e9c4:	e1a00007 	mov	r0, r7
    e9c8:	e1a01008 	mov	r1, r8
    e9cc:	e3a02c06 	mov	r2, #1536	; 0x600
    e9d0:	ebfff939 	bl	cebc <ReadN>
    e9d4:	e3500c06 	cmp	r0, #1536	; 0x600
    e9d8:	e1a07000 	mov	r7, r0
    e9dc:	1afffeb3 	bne	e4b0 <SHandShake+0x3c>
    return FALSE;

  RTMP_Log(RTMP_LOGDEBUG2, "%s: 2nd handshake: ", __FUNCTION__);
    e9e0:	e59f1524 	ldr	r1, [pc, #1316]	; ef0c <SHandShake+0xa98>
    e9e4:	e3a00005 	mov	r0, #5
    e9e8:	e08f1001 	add	r1, pc, r1
    e9ec:	e1a02004 	mov	r2, r4
    e9f0:	eb001bed 	bl	159ac <RTMP_Log>
  RTMP_LogHex(RTMP_LOGDEBUG2, clientsig, RTMP_SIG_SIZE);
    e9f4:	e3a00005 	mov	r0, #5
    e9f8:	e1a01008 	mov	r1, r8
    e9fc:	e1a02007 	mov	r2, r7
    ea00:	eb001bf9 	bl	159ec <RTMP_LogHex>

  if (FP9HandShake)
    ea04:	e59d3018 	ldr	r3, [sp, #24]
    ea08:	e3530000 	cmp	r3, #0
    ea0c:	1a0000ae 	bne	eccc <SHandShake+0x858>
	    }
	}
    }
  else
    {
      if (memcmp(serversig, clientsig, RTMP_SIG_SIZE) != 0)
    ea10:	e59d0010 	ldr	r0, [sp, #16]
    ea14:	e1a01008 	mov	r1, r8
    ea18:	e1a02007 	mov	r2, r7
    ea1c:	ebffd9ed 	bl	51d8 <memcmp@plt>
    ea20:	e3500000 	cmp	r0, #0
    ea24:	1a00011c 	bne	ee9c <SHandShake+0xa28>
	  RTMP_Log(RTMP_LOGWARNING, "%s: client signature does not match!",
	      __FUNCTION__);
	}
    }

  RTMP_Log(RTMP_LOGDEBUG, "%s: Handshaking finished....", __FUNCTION__);
    ea28:	e59f24e0 	ldr	r2, [pc, #1248]	; ef10 <SHandShake+0xa9c>
    ea2c:	e59f14e0 	ldr	r1, [pc, #1248]	; ef14 <SHandShake+0xaa0>
    ea30:	e08f2002 	add	r2, pc, r2
    ea34:	e3a00004 	mov	r0, #4
    ea38:	e2422eb2 	sub	r2, r2, #2848	; 0xb20
    ea3c:	e08f1001 	add	r1, pc, r1
    ea40:	eb001bd9 	bl	159ac <RTMP_Log>
  return TRUE;
    ea44:	e3a04001 	mov	r4, #1
    ea48:	eafffe99 	b	e4b4 <SHandShake+0x40>
      RTMP_Log(RTMP_LOGERROR, "%s: Unknown version %02x",
	  __FUNCTION__, type);
      return FALSE;
    }

  if (!FP9HandShake && clientsig[4])
    ea4c:	e5554200 	ldrb	r4, [r5, #-512]	; 0xfffffe00
    ea50:	e3540000 	cmp	r4, #0
    ea54:	0a000009 	beq	ea80 <SHandShake+0x60c>
}

static int
SHandShake(RTMP * r)
{
  int i, offalg = 0;
    ea58:	e58da014 	str	sl, [sp, #20]
    ea5c:	e287a901 	add	sl, r7, #16384	; 0x4000
    ea60:	eafffebf 	b	e564 <SHandShake+0xf0>
  int dhposServer = 0;
    ea64:	e59d3014 	ldr	r3, [sp, #20]
    ea68:	e58d302c 	str	r3, [sp, #44]	; 0x2c
    ea6c:	eaffff08 	b	e694 <SHandShake+0x220>
  int digestPosServer = 0;
    ea70:	e59d3018 	ldr	r3, [sp, #24]
    ea74:	e58d3030 	str	r3, [sp, #48]	; 0x30

static int
SHandShake(RTMP * r)
{
  int i, offalg = 0;
  int dhposServer = 0;
    ea78:	e58d302c 	str	r3, [sp, #44]	; 0x2c
    ea7c:	eaffff27 	b	e720 <SHandShake+0x2ac>
  if (!FP9HandShake && clientsig[4])
    FP9HandShake = TRUE;

  serversig[-1] = type;

  r->Link.rc4keyIn = r->Link.rc4keyOut = 0;
    ea80:	e287a901 	add	sl, r7, #16384	; 0x4000
    ea84:	e58a41a0 	str	r4, [sl, #416]	; 0x1a0
    ea88:	e58a419c 	str	r4, [sl, #412]	; 0x19c
    }

  if (!FP9HandShake && clientsig[4])
    FP9HandShake = TRUE;

  serversig[-1] = type;
    ea8c:	e5cd3c87 	strb	r3, [sp, #3207]	; 0xc87

  r->Link.rc4keyIn = r->Link.rc4keyOut = 0;

  uptime = htonl(RTMP_GetTime());
    ea90:	ebffe6bc 	bl	8588 <RTMP_GetTime>
      getdig = digoff[offalg];
      getdh  = dhoff[offalg];
    }
  else
    {
      memset(&serversig[4], 0, 4);
    ea94:	e58d4018 	str	r4, [sp, #24]
    ea98:	e58d4c8c 	str	r4, [sp, #3212]	; 0xc8c
}

static int
SHandShake(RTMP * r)
{
  int i, offalg = 0;
    ea9c:	e58d4014 	str	r4, [sp, #20]

  uint8_t clientsig[RTMP_SIG_SIZE];
  uint8_t serverbuf[RTMP_SIG_SIZE + 4], *serversig = serverbuf+4;
  uint8_t type;
  uint32_t uptime;
  getoff *getdh = NULL, *getdig = NULL;
    eaa0:	e58d401c 	str	r4, [sp, #28]
    eaa4:	e58d4020 	str	r4, [sp, #32]

  serversig[-1] = type;

  r->Link.rc4keyIn = r->Link.rc4keyOut = 0;

  uptime = htonl(RTMP_GetTime());
    eaa8:	e0203860 	eor	r3, r0, r0, ror #16
    eaac:	e1a03423 	lsr	r3, r3, #8
    eab0:	e3c33cff 	bic	r3, r3, #65280	; 0xff00
    eab4:	e0233460 	eor	r3, r3, r0, ror #8
  memcpy(serversig, &uptime, 4);
    eab8:	e58d3c88 	str	r3, [sp, #3208]	; 0xc88
    eabc:	eafffec2 	b	e5cc <SHandShake+0x158>
      if (clientsig[4] == 128)
	type = 8;
    }
  else
    {
      RTMP_Log(RTMP_LOGERROR, "%s: Unknown version %02x",
    eac0:	e59f1450 	ldr	r1, [pc, #1104]	; ef18 <SHandShake+0xaa4>
    eac4:	e1a00004 	mov	r0, r4
    eac8:	e1a0200c 	mov	r2, ip
    eacc:	e08f1001 	add	r1, pc, r1
	  __FUNCTION__, type);
      return FALSE;
    ead0:	e1a0400a 	mov	r4, sl
      if (clientsig[4] == 128)
	type = 8;
    }
  else
    {
      RTMP_Log(RTMP_LOGERROR, "%s: Unknown version %02x",
    ead4:	eb001bb4 	bl	159ac <RTMP_Log>
	  __FUNCTION__, type);
      return FALSE;
    ead8:	eafffe75 	b	e4b4 <SHandShake+0x40>
	  dhposServer = getdh(serversig, RTMP_SIG_SIZE);
	  RTMP_Log(RTMP_LOGDEBUG, "%s: DH pubkey position: %d", __FUNCTION__, dhposServer);

	  if (!DHGenerateKey(r->Link.dh))
	    {
	      RTMP_Log(RTMP_LOGERROR, "%s: Couldn't generate Diffie-Hellmann public key!",
    eadc:	e59f1438 	ldr	r1, [pc, #1080]	; ef1c <SHandShake+0xaa8>
    eae0:	e1a0200b 	mov	r2, fp
    eae4:	e3a00001 	mov	r0, #1
    eae8:	e08f1001 	add	r1, pc, r1
    eaec:	eb001bae 	bl	159ac <RTMP_Log>
		  __FUNCTION__);
	      return FALSE;
    eaf0:	eafffe6f 	b	e4b4 <SHandShake+0x40>
      /* we have to use this signature now to find the correct algorithms for getting the digest and DH positions */
      int digestPosClient = getdig(clientsig, RTMP_SIG_SIZE);

      if (!VerifyDigest(digestPosClient, clientsig, GenuineFPKey, 30))
	{
	  RTMP_Log(RTMP_LOGWARNING, "Trying different position for client digest!");
    eaf4:	e59f1424 	ldr	r1, [pc, #1060]	; ef20 <SHandShake+0xaac>
    eaf8:	e3a00002 	mov	r0, #2
    eafc:	e08f1001 	add	r1, pc, r1
    eb00:	eb001ba9 	bl	159ac <RTMP_Log>
	  offalg ^= 1;
    eb04:	e59d2014 	ldr	r2, [sp, #20]
	  getdig = digoff[offalg];
	  getdh  = dhoff[offalg];
    eb08:	e59f3414 	ldr	r3, [pc, #1044]	; ef24 <SHandShake+0xab0>
      int digestPosClient = getdig(clientsig, RTMP_SIG_SIZE);

      if (!VerifyDigest(digestPosClient, clientsig, GenuineFPKey, 30))
	{
	  RTMP_Log(RTMP_LOGWARNING, "Trying different position for client digest!");
	  offalg ^= 1;
    eb0c:	e2222001 	eor	r2, r2, #1
	  getdig = digoff[offalg];
	  getdh  = dhoff[offalg];
    eb10:	e08f3003 	add	r3, pc, r3
    eb14:	e0833102 	add	r3, r3, r2, lsl #2

	  digestPosClient = getdig(clientsig, RTMP_SIG_SIZE);
    eb18:	e5932330 	ldr	r2, [r3, #816]	; 0x330
    eb1c:	e3a01c06 	mov	r1, #1536	; 0x600
      if (!VerifyDigest(digestPosClient, clientsig, GenuineFPKey, 30))
	{
	  RTMP_Log(RTMP_LOGWARNING, "Trying different position for client digest!");
	  offalg ^= 1;
	  getdig = digoff[offalg];
	  getdh  = dhoff[offalg];
    eb20:	e5933338 	ldr	r3, [r3, #824]	; 0x338

	  digestPosClient = getdig(clientsig, RTMP_SIG_SIZE);
    eb24:	e1a00008 	mov	r0, r8
      if (!VerifyDigest(digestPosClient, clientsig, GenuineFPKey, 30))
	{
	  RTMP_Log(RTMP_LOGWARNING, "Trying different position for client digest!");
	  offalg ^= 1;
	  getdig = digoff[offalg];
	  getdh  = dhoff[offalg];
    eb28:	e58d3020 	str	r3, [sp, #32]

	  digestPosClient = getdig(clientsig, RTMP_SIG_SIZE);
    eb2c:	e12fff32 	blx	r2

	  if (!VerifyDigest(digestPosClient, clientsig, GenuineFPKey, 30))
    eb30:	e1a01008 	mov	r1, r8
    eb34:	e1a02004 	mov	r2, r4
    eb38:	e3a0301e 	mov	r3, #30
	  RTMP_Log(RTMP_LOGWARNING, "Trying different position for client digest!");
	  offalg ^= 1;
	  getdig = digoff[offalg];
	  getdh  = dhoff[offalg];

	  digestPosClient = getdig(clientsig, RTMP_SIG_SIZE);
    eb3c:	e58d001c 	str	r0, [sp, #28]

	  if (!VerifyDigest(digestPosClient, clientsig, GenuineFPKey, 30))
    eb40:	ebffe2a6 	bl	75e0 <VerifyDigest>
    eb44:	e3500000 	cmp	r0, #0
    eb48:	1affff2c 	bne	e800 <SHandShake+0x38c>
	    {
	      RTMP_Log(RTMP_LOGERROR, "Couldn't verify the client digest");	/* continuing anyway will probably fail */
    eb4c:	e59f13d4 	ldr	r1, [pc, #980]	; ef28 <SHandShake+0xab4>
    eb50:	e3a00001 	mov	r0, #1
    eb54:	e08f1001 	add	r1, pc, r1
    eb58:	eb001b93 	bl	159ac <RTMP_Log>
	      return FALSE;
    eb5c:	eafffe53 	b	e4b0 <SHandShake+0x3c>
	    }

	  if (!DHGetPublicKey
	      (r->Link.dh, (uint8_t *) &serversig[dhposServer], 128))
	    {
	      RTMP_Log(RTMP_LOGERROR, "%s: Couldn't write public key!", __FUNCTION__);
    eb60:	e59f13c4 	ldr	r1, [pc, #964]	; ef2c <SHandShake+0xab8>
    eb64:	e1a0200b 	mov	r2, fp
    eb68:	e3a00001 	mov	r0, #1
    eb6c:	e08f1001 	add	r1, pc, r1
    eb70:	eb001b8d 	bl	159ac <RTMP_Log>
	      return FALSE;
    eb74:	eafffe4e 	b	e4b4 <SHandShake+0x40>
	}

      /* generate SWFVerification token (SHA256 HMAC hash of decompressed SWF, key are the last 32 bytes of the server handshake) */
      if (r->Link.SWFSize)
	{
	  const char swfVerify[] = { 0x01, 0x01 };
    eb78:	e59f13b0 	ldr	r1, [pc, #944]	; ef30 <SHandShake+0xabc>
    eb7c:	e28dbd1a 	add	fp, sp, #1664	; 0x680
    eb80:	e08f1001 	add	r1, pc, r1
    eb84:	e28bb008 	add	fp, fp, #8
    eb88:	e24bb004 	sub	fp, fp, #4
    eb8c:	e2411eb3 	sub	r1, r1, #2864	; 0xb30
          char *vend = r->Link.SWFVerificationResponse+sizeof(r->Link.SWFVerificationResponse);
    eb90:	e2874c41 	add	r4, r7, #16640	; 0x4100
	}

      /* generate SWFVerification token (SHA256 HMAC hash of decompressed SWF, key are the last 32 bytes of the server handshake) */
      if (r->Link.SWFSize)
	{
	  const char swfVerify[] = { 0x01, 0x01 };
    eb94:	e2411004 	sub	r1, r1, #4
    eb98:	e1a0000b 	mov	r0, fp
    eb9c:	e3a02002 	mov	r2, #2
    eba0:	e58dc034 	str	ip, [sp, #52]	; 0x34
    eba4:	ebffd988 	bl	51cc <memcpy@plt>
          char *vend = r->Link.SWFVerificationResponse+sizeof(r->Link.SWFVerificationResponse);
    eba8:	e28430f2 	add	r3, r4, #242	; 0xf2

	  memcpy(r->Link.SWFVerificationResponse, swfVerify, 2);
    ebac:	e1a0100b 	mov	r1, fp
    ebb0:	e28a0f72 	add	r0, sl, #456	; 0x1c8
    ebb4:	e3a02002 	mov	r2, #2

      /* generate SWFVerification token (SHA256 HMAC hash of decompressed SWF, key are the last 32 bytes of the server handshake) */
      if (r->Link.SWFSize)
	{
	  const char swfVerify[] = { 0x01, 0x01 };
          char *vend = r->Link.SWFVerificationResponse+sizeof(r->Link.SWFVerificationResponse);
    ebb8:	e58d3028 	str	r3, [sp, #40]	; 0x28

	  memcpy(r->Link.SWFVerificationResponse, swfVerify, 2);
    ebbc:	ebffd982 	bl	51cc <memcpy@plt>
	  AMF_EncodeInt32(&r->Link.SWFVerificationResponse[2], vend, r->Link.SWFSize);
    ebc0:	e59dc034 	ldr	ip, [sp, #52]	; 0x34
    ebc4:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
    ebc8:	e1a0200c 	mov	r2, ip
    ebcc:	e28400ca 	add	r0, r4, #202	; 0xca
    ebd0:	eb001cf5 	bl	15fac <AMF_EncodeInt32>
	  AMF_EncodeInt32(&r->Link.SWFVerificationResponse[6], vend, r->Link.SWFSize);
    ebd4:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
    ebd8:	e59a21a4 	ldr	r2, [sl, #420]	; 0x1a4
    ebdc:	e28400ce 	add	r0, r4, #206	; 0xce
    ebe0:	eb001cf1 	bl	15fac <AMF_EncodeInt32>
	  HMACsha256(r->Link.SWFHash, SHA256_DIGEST_LENGTH,
    ebe4:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
		     &serversig[RTMP_SIG_SIZE - SHA256_DIGEST_LENGTH],
		     SHA256_DIGEST_LENGTH,
		     (uint8_t *)&r->Link.SWFVerificationResponse[10]);
    ebe8:	e28400d2 	add	r0, r4, #210	; 0xd2
          char *vend = r->Link.SWFVerificationResponse+sizeof(r->Link.SWFVerificationResponse);

	  memcpy(r->Link.SWFVerificationResponse, swfVerify, 2);
	  AMF_EncodeInt32(&r->Link.SWFVerificationResponse[2], vend, r->Link.SWFSize);
	  AMF_EncodeInt32(&r->Link.SWFVerificationResponse[6], vend, r->Link.SWFSize);
	  HMACsha256(r->Link.SWFHash, SHA256_DIGEST_LENGTH,
    ebec:	e2832e5e 	add	r2, r3, #1504	; 0x5e0
    ebf0:	e3a01020 	mov	r1, #32
    ebf4:	e58d0000 	str	r0, [sp]
    ebf8:	e2822004 	add	r2, r2, #4
    ebfc:	e28400a8 	add	r0, r4, #168	; 0xa8
    ec00:	e1a03001 	mov	r3, r1
    ec04:	ebffdc7c 	bl	5dfc <HMACsha256>
    ec08:	eaffff01 	b	e814 <SHandShake+0x3a0>
	{
	  /* generate Diffie-Hellmann parameters */
	  r->Link.dh = DHInit(1024);
	  if (!r->Link.dh)
	    {
	      RTMP_Log(RTMP_LOGERROR, "%s: Couldn't initialize Diffie-Hellmann!",
    ec0c:	e59f2320 	ldr	r2, [pc, #800]	; ef34 <SHandShake+0xac0>
    ec10:	e59f1320 	ldr	r1, [pc, #800]	; ef38 <SHandShake+0xac4>
    ec14:	e08f2002 	add	r2, pc, r2
    ec18:	e3a00001 	mov	r0, #1
    ec1c:	e2422eb2 	sub	r2, r2, #2848	; 0xb20
    ec20:	e08f1001 	add	r1, pc, r1
    ec24:	eb001b60 	bl	159ac <RTMP_Log>
		  __FUNCTION__);
	      return FALSE;
    ec28:	eafffe21 	b	e4b4 <SHandShake+0x40>
        {
	  uint8_t *dptr = digestResp;
	  uint8_t *sig = signatureResp;
	  /* encrypt signatureResp */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
            rtmpe9_sig(sig+i, sig+i, dptr[i] % 15);
    ec2c:	e59f3308 	ldr	r3, [pc, #776]	; ef3c <SHandShake+0xac8>
    ec30:	e3a04000 	mov	r4, #0
    ec34:	e7db1004 	ldrb	r1, [fp, r4]
    ec38:	e2840e5e 	add	r0, r4, #1504	; 0x5e0
    ec3c:	e082c193 	umull	ip, r2, r3, r1
    ec40:	e0880000 	add	r0, r8, r0
    ec44:	e1a021a2 	lsr	r2, r2, #3
    ec48:	e0622202 	rsb	r2, r2, r2, lsl #4
    ec4c:	e0622001 	rsb	r2, r2, r1
    ec50:	e20220ff 	and	r2, r2, #255	; 0xff
      else if (type == 9)
        {
	  uint8_t *dptr = digestResp;
	  uint8_t *sig = signatureResp;
	  /* encrypt signatureResp */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
    ec54:	e2844008 	add	r4, r4, #8
            rtmpe9_sig(sig+i, sig+i, dptr[i] % 15);
    ec58:	e1a01000 	mov	r1, r0
    ec5c:	e58d301c 	str	r3, [sp, #28]
    ec60:	ebffe26d 	bl	761c <rtmpe9_sig>
      else if (type == 9)
        {
	  uint8_t *dptr = digestResp;
	  uint8_t *sig = signatureResp;
	  /* encrypt signatureResp */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
    ec64:	e3540020 	cmp	r4, #32
    ec68:	e59d301c 	ldr	r3, [sp, #28]
    ec6c:	1afffff0 	bne	ec34 <SHandShake+0x7c0>
    ec70:	eaffff2c 	b	e928 <SHandShake+0x4b4>
        {
	  uint8_t *dptr = digestResp;
	  uint8_t *sig = signatureResp;
	  /* encrypt signatureResp */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
	    rtmpe8_sig(sig+i, sig+i, dptr[i] % 15);
    ec74:	e59f32c0 	ldr	r3, [pc, #704]	; ef3c <SHandShake+0xac8>
    ec78:	e3a04000 	mov	r4, #0
    ec7c:	e7db1004 	ldrb	r1, [fp, r4]
    ec80:	e2840e5e 	add	r0, r4, #1504	; 0x5e0
    ec84:	e082c193 	umull	ip, r2, r3, r1
    ec88:	e0880000 	add	r0, r8, r0
    ec8c:	e1a021a2 	lsr	r2, r2, #3
    ec90:	e0622202 	rsb	r2, r2, r2, lsl #4
    ec94:	e0622001 	rsb	r2, r2, r1
    ec98:	e20220ff 	and	r2, r2, #255	; 0xff
      if (type == 8 )
        {
	  uint8_t *dptr = digestResp;
	  uint8_t *sig = signatureResp;
	  /* encrypt signatureResp */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
    ec9c:	e2844008 	add	r4, r4, #8
	    rtmpe8_sig(sig+i, sig+i, dptr[i] % 15);
    eca0:	e1a01000 	mov	r1, r0
    eca4:	e58d301c 	str	r3, [sp, #28]
    eca8:	ebffda85 	bl	56c4 <rtmpe8_sig>
      if (type == 8 )
        {
	  uint8_t *dptr = digestResp;
	  uint8_t *sig = signatureResp;
	  /* encrypt signatureResp */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
    ecac:	e3540020 	cmp	r4, #32
    ecb0:	e59d301c 	ldr	r3, [sp, #28]
    ecb4:	1afffff0 	bne	ec7c <SHandShake+0x808>
    ecb8:	eaffff1a 	b	e928 <SHandShake+0x4b4>
	    DHComputeSharedSecretKey(r->Link.dh,
				     (uint8_t *) &clientsig[dhposClient], 128,
				     secretKey);
	  if (len < 0)
	    {
	      RTMP_Log(RTMP_LOGDEBUG, "%s: Wrong secret key position!", __FUNCTION__);
    ecbc:	e59f127c 	ldr	r1, [pc, #636]	; ef40 <SHandShake+0xacc>
    ecc0:	e08f1001 	add	r1, pc, r1
    ecc4:	eb001b38 	bl	159ac <RTMP_Log>
    ecc8:	eafffdf8 	b	e4b0 <SHandShake+0x3c>
  if (FP9HandShake)
    {
      uint8_t signature[SHA256_DIGEST_LENGTH];
      uint8_t digest[SHA256_DIGEST_LENGTH];

      RTMP_Log(RTMP_LOGDEBUG, "%s: Client sent signature:", __FUNCTION__);
    eccc:	e59f1270 	ldr	r1, [pc, #624]	; ef44 <SHandShake+0xad0>
    ecd0:	e1a02004 	mov	r2, r4
    ecd4:	e3a00004 	mov	r0, #4
    ecd8:	e08f1001 	add	r1, pc, r1
    ecdc:	eb001b32 	bl	159ac <RTMP_Log>
      RTMP_LogHex(RTMP_LOGDEBUG, &clientsig[RTMP_SIG_SIZE - SHA256_DIGEST_LENGTH],
    ece0:	e3a00004 	mov	r0, #4
    ece4:	e2881e5e 	add	r1, r8, #1504	; 0x5e0
    ece8:	e3a02020 	mov	r2, #32
    ecec:	eb001b3e 	bl	159ec <RTMP_LogHex>
	     SHA256_DIGEST_LENGTH);

      /* verify client response */
      HMACsha256(&serversig[digestPosServer], SHA256_DIGEST_LENGTH,
    ecf0:	e59d3010 	ldr	r3, [sp, #16]
    ecf4:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
    ecf8:	e2499024 	sub	r9, r9, #36	; 0x24
    ecfc:	e24b2ebb 	sub	r2, fp, #2992	; 0xbb0
    ed00:	e0830001 	add	r0, r3, r1
    ed04:	e2422008 	sub	r2, r2, #8
    ed08:	e3a01020 	mov	r1, #32
    ed0c:	e3a0303e 	mov	r3, #62	; 0x3e
		 GenuineFPKey, sizeof(GenuineFPKey), digest);
      HMACsha256(clientsig, RTMP_SIG_SIZE - SHA256_DIGEST_LENGTH, digest,
    ed10:	e2466004 	sub	r6, r6, #4
      RTMP_Log(RTMP_LOGDEBUG, "%s: Client sent signature:", __FUNCTION__);
      RTMP_LogHex(RTMP_LOGDEBUG, &clientsig[RTMP_SIG_SIZE - SHA256_DIGEST_LENGTH],
	     SHA256_DIGEST_LENGTH);

      /* verify client response */
      HMACsha256(&serversig[digestPosServer], SHA256_DIGEST_LENGTH,
    ed14:	e58d9000 	str	r9, [sp]
    ed18:	ebffdc37 	bl	5dfc <HMACsha256>
		 GenuineFPKey, sizeof(GenuineFPKey), digest);
      HMACsha256(clientsig, RTMP_SIG_SIZE - SHA256_DIGEST_LENGTH, digest,
    ed1c:	e3a03020 	mov	r3, #32
    ed20:	e58d6000 	str	r6, [sp]
    ed24:	e1a02009 	mov	r2, r9
    ed28:	e1a00008 	mov	r0, r8
    ed2c:	e3a01e5e 	mov	r1, #1504	; 0x5e0
    ed30:	ebffdc31 	bl	5dfc <HMACsha256>
		 SHA256_DIGEST_LENGTH, signature);
#ifdef FP10
      if (type == 8 )
    ed34:	e555324d 	ldrb	r3, [r5, #-589]	; 0xfffffdb3
    ed38:	e3530008 	cmp	r3, #8
    ed3c:	0a00004a 	beq	ee6c <SHandShake+0x9f8>
	  uint8_t *sig = signature;
	  /* encrypt signatureResp */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
	    rtmpe8_sig(sig+i, sig+i, dptr[i] % 15);
        }
      else if (type == 9)
    ed40:	e3530009 	cmp	r3, #9
    ed44:	0a00003c 	beq	ee3c <SHandShake+0x9c8>
            rtmpe9_sig(sig+i, sig+i, dptr[i] % 15);
        }
#endif

      /* show some information */
      RTMP_Log(RTMP_LOGDEBUG, "%s: Digest key: ", __FUNCTION__);
    ed48:	e59f41f8 	ldr	r4, [pc, #504]	; ef48 <SHandShake+0xad4>
    ed4c:	e59f11f8 	ldr	r1, [pc, #504]	; ef4c <SHandShake+0xad8>
    ed50:	e08f4004 	add	r4, pc, r4
    ed54:	e2444eb2 	sub	r4, r4, #2848	; 0xb20
    ed58:	e3a00004 	mov	r0, #4
    ed5c:	e1a02004 	mov	r2, r4
    ed60:	e08f1001 	add	r1, pc, r1
    ed64:	eb001b10 	bl	159ac <RTMP_Log>
      RTMP_LogHex(RTMP_LOGDEBUG, digest, SHA256_DIGEST_LENGTH);
    ed68:	e1a01009 	mov	r1, r9
    ed6c:	e3a00004 	mov	r0, #4
    ed70:	e3a02020 	mov	r2, #32
    ed74:	eb001b1c 	bl	159ec <RTMP_LogHex>

      RTMP_Log(RTMP_LOGDEBUG, "%s: Signature calculated:", __FUNCTION__);
    ed78:	e59f11d0 	ldr	r1, [pc, #464]	; ef50 <SHandShake+0xadc>
    ed7c:	e1a02004 	mov	r2, r4
    ed80:	e3a00004 	mov	r0, #4
    ed84:	e08f1001 	add	r1, pc, r1
    ed88:	eb001b07 	bl	159ac <RTMP_Log>
      RTMP_LogHex(RTMP_LOGDEBUG, signature, SHA256_DIGEST_LENGTH);
    ed8c:	e3a00004 	mov	r0, #4
    ed90:	e1a01006 	mov	r1, r6
    ed94:	e3a02020 	mov	r2, #32
    ed98:	eb001b13 	bl	159ec <RTMP_LogHex>
      if (memcmp
    ed9c:	e1a00006 	mov	r0, r6
    eda0:	e2881e5e 	add	r1, r8, #1504	; 0x5e0
    eda4:	e3a02020 	mov	r2, #32
    eda8:	ebffd90a 	bl	51d8 <memcmp@plt>
    edac:	e3500000 	cmp	r0, #0
    edb0:	1a00001b 	bne	ee24 <SHandShake+0x9b0>
	  RTMP_Log(RTMP_LOGWARNING, "%s: Client not genuine Adobe!", __FUNCTION__);
	  return FALSE;
	}
      else
	{
	  RTMP_Log(RTMP_LOGDEBUG, "%s: Genuine Adobe Flash Player", __FUNCTION__);
    edb4:	e59f1198 	ldr	r1, [pc, #408]	; ef54 <SHandShake+0xae0>
    edb8:	e1a02004 	mov	r2, r4
    edbc:	e3a00004 	mov	r0, #4
    edc0:	e08f1001 	add	r1, pc, r1
    edc4:	eb001af8 	bl	159ac <RTMP_Log>
	}

      if (encrypted)
    edc8:	e59d3014 	ldr	r3, [sp, #20]
    edcc:	e3530000 	cmp	r3, #0
    edd0:	0affff14 	beq	ea28 <SHandShake+0x5b4>
	{
	  char buff[RTMP_SIG_SIZE];
	  /* set keys for encryption from now on */
	  r->Link.rc4keyIn = keyIn;
    edd4:	e515024c 	ldr	r0, [r5, #-588]	; 0xfffffdb4
	  r->Link.rc4keyOut = keyOut;
    edd8:	e5153248 	ldr	r3, [r5, #-584]	; 0xfffffdb8

	  /* update the keystreams */
	  if (r->Link.rc4keyIn)
    eddc:	e3500000 	cmp	r0, #0

      if (encrypted)
	{
	  char buff[RTMP_SIG_SIZE];
	  /* set keys for encryption from now on */
	  r->Link.rc4keyIn = keyIn;
    ede0:	e58a019c 	str	r0, [sl, #412]	; 0x19c
	  r->Link.rc4keyOut = keyOut;
    ede4:	e58a31a0 	str	r3, [sl, #416]	; 0x1a0

	  /* update the keystreams */
	  if (r->Link.rc4keyIn)
    ede8:	0a000004 	beq	ee00 <SHandShake+0x98c>
	    {
	      RC4_encrypt(r->Link.rc4keyIn, RTMP_SIG_SIZE, (uint8_t *) buff);
    edec:	e28d2d1a 	add	r2, sp, #1664	; 0x680
    edf0:	e2822004 	add	r2, r2, #4
    edf4:	e1a03002 	mov	r3, r2
    edf8:	e3a01c06 	mov	r1, #1536	; 0x600
    edfc:	ebffd99d 	bl	5478 <arc4_crypt@plt>
	    }

	  if (r->Link.rc4keyOut)
    ee00:	e59a01a0 	ldr	r0, [sl, #416]	; 0x1a0
    ee04:	e3500000 	cmp	r0, #0
    ee08:	0affff06 	beq	ea28 <SHandShake+0x5b4>
	    {
	      RC4_encrypt(r->Link.rc4keyOut, RTMP_SIG_SIZE, (uint8_t *) buff);
    ee0c:	e28d2d1a 	add	r2, sp, #1664	; 0x680
    ee10:	e2822004 	add	r2, r2, #4
    ee14:	e1a03002 	mov	r3, r2
    ee18:	e3a01c06 	mov	r1, #1536	; 0x600
    ee1c:	ebffd995 	bl	5478 <arc4_crypt@plt>
    ee20:	eaffff00 	b	ea28 <SHandShake+0x5b4>
      RTMP_LogHex(RTMP_LOGDEBUG, signature, SHA256_DIGEST_LENGTH);
      if (memcmp
	  (signature, &clientsig[RTMP_SIG_SIZE - SHA256_DIGEST_LENGTH],
	   SHA256_DIGEST_LENGTH) != 0)
	{
	  RTMP_Log(RTMP_LOGWARNING, "%s: Client not genuine Adobe!", __FUNCTION__);
    ee24:	e59f112c 	ldr	r1, [pc, #300]	; ef58 <SHandShake+0xae4>
    ee28:	e1a02004 	mov	r2, r4
    ee2c:	e3a00002 	mov	r0, #2
    ee30:	e08f1001 	add	r1, pc, r1
    ee34:	eb001adc 	bl	159ac <RTMP_Log>
    ee38:	eafffd9c 	b	e4b0 <SHandShake+0x3c>
    ee3c:	e3a04000 	mov	r4, #0
        {
	  uint8_t *dptr = digest;
	  uint8_t *sig = signature;
	  /* encrypt signatureResp */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
            rtmpe9_sig(sig+i, sig+i, dptr[i] % 15);
    ee40:	e7d90004 	ldrb	r0, [r9, r4]
    ee44:	e3a0100f 	mov	r1, #15
    ee48:	ebffd993 	bl	549c <__aeabi_uidivmod@plt>
    ee4c:	e0860004 	add	r0, r6, r4
      else if (type == 9)
        {
	  uint8_t *dptr = digest;
	  uint8_t *sig = signature;
	  /* encrypt signatureResp */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
    ee50:	e2844008 	add	r4, r4, #8
            rtmpe9_sig(sig+i, sig+i, dptr[i] % 15);
    ee54:	e20120ff 	and	r2, r1, #255	; 0xff
    ee58:	e1a01000 	mov	r1, r0
    ee5c:	ebffe1ee 	bl	761c <rtmpe9_sig>
      else if (type == 9)
        {
	  uint8_t *dptr = digest;
	  uint8_t *sig = signature;
	  /* encrypt signatureResp */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
    ee60:	e3540020 	cmp	r4, #32
    ee64:	1afffff5 	bne	ee40 <SHandShake+0x9cc>
    ee68:	eaffffb6 	b	ed48 <SHandShake+0x8d4>
    ee6c:	e3a04000 	mov	r4, #0
        {
	  uint8_t *dptr = digest;
	  uint8_t *sig = signature;
	  /* encrypt signatureResp */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
	    rtmpe8_sig(sig+i, sig+i, dptr[i] % 15);
    ee70:	e7d90004 	ldrb	r0, [r9, r4]
    ee74:	e3a0100f 	mov	r1, #15
    ee78:	ebffd987 	bl	549c <__aeabi_uidivmod@plt>
    ee7c:	e0860004 	add	r0, r6, r4
      if (type == 8 )
        {
	  uint8_t *dptr = digest;
	  uint8_t *sig = signature;
	  /* encrypt signatureResp */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
    ee80:	e2844008 	add	r4, r4, #8
	    rtmpe8_sig(sig+i, sig+i, dptr[i] % 15);
    ee84:	e20120ff 	and	r2, r1, #255	; 0xff
    ee88:	e1a01000 	mov	r1, r0
    ee8c:	ebffda0c 	bl	56c4 <rtmpe8_sig>
      if (type == 8 )
        {
	  uint8_t *dptr = digest;
	  uint8_t *sig = signature;
	  /* encrypt signatureResp */
          for (i=0; i<SHA256_DIGEST_LENGTH; i+=8)
    ee90:	e3540020 	cmp	r4, #32
    ee94:	1afffff5 	bne	ee70 <SHandShake+0x9fc>
    ee98:	eaffffaa 	b	ed48 <SHandShake+0x8d4>
    }
  else
    {
      if (memcmp(serversig, clientsig, RTMP_SIG_SIZE) != 0)
	{
	  RTMP_Log(RTMP_LOGWARNING, "%s: client signature does not match!",
    ee9c:	e59f10b8 	ldr	r1, [pc, #184]	; ef5c <SHandShake+0xae8>
    eea0:	e1a02004 	mov	r2, r4
    eea4:	e3a00002 	mov	r0, #2
    eea8:	e08f1001 	add	r1, pc, r1
    eeac:	eb001abe 	bl	159ac <RTMP_Log>
    eeb0:	eafffedc 	b	ea28 <SHandShake+0x5b4>
    eeb4:	000102f0 	.word	0x000102f0
    eeb8:	00011184 	.word	0x00011184
    eebc:	000152c8 	.word	0x000152c8
    eec0:	0001019c 	.word	0x0001019c
    eec4:	00010b30 	.word	0x00010b30
    eec8:	00010134 	.word	0x00010134
    eecc:	00011088 	.word	0x00011088
    eed0:	00011058 	.word	0x00011058
    eed4:	00011054 	.word	0x00011054
    eed8:	00000601 	.word	0x00000601
    eedc:	00010078 	.word	0x00010078
    eee0:	00011000 	.word	0x00011000
    eee4:	00010fec 	.word	0x00010fec
    eee8:	0000ff98 	.word	0x0000ff98
    eeec:	00010fc0 	.word	0x00010fc0
    eef0:	00010b08 	.word	0x00010b08
    eef4:	0000ff08 	.word	0x0000ff08
    eef8:	0000feb0 	.word	0x0000feb0
    eefc:	00010a70 	.word	0x00010a70
    ef00:	00010ef4 	.word	0x00010ef4
    ef04:	0000fe5c 	.word	0x0000fe5c
    ef08:	00010ee8 	.word	0x00010ee8
    ef0c:	00010eb8 	.word	0x00010eb8
    ef10:	0000fdb0 	.word	0x0000fdb0
    ef14:	00010ed4 	.word	0x00010ed4
    ef18:	00010bd8 	.word	0x00010bd8
    ef1c:	00010c04 	.word	0x00010c04
    ef20:	00010cc4 	.word	0x00010cc4
    ef24:	00014d38 	.word	0x00014d38
    ef28:	00010c9c 	.word	0x00010c9c
    ef2c:	00010bb4 	.word	0x00010bb4
    ef30:	0000fc60 	.word	0x0000fc60
    ef34:	0000fbcc 	.word	0x0000fbcc
    ef38:	00010aa0 	.word	0x00010aa0
    ef3c:	88888889 	.word	0x88888889
    ef40:	00010b78 	.word	0x00010b78
    ef44:	00010bdc 	.word	0x00010bdc
    ef48:	0000fa90 	.word	0x0000fa90
    ef4c:	0001073c 	.word	0x0001073c
    ef50:	0001072c 	.word	0x0001072c
    ef54:	00010b30 	.word	0x00010b30
    ef58:	00010aa0 	.word	0x00010aa0
    ef5c:	00010674 	.word	0x00010674

0000ef60 <RTMP_Serve>:
}

int
RTMP_Serve(RTMP *r)
{
    return SHandShake(r);
    ef60:	eafffd43 	b	e474 <SHandShake>

0000ef64 <RTMP_Connect0>:
        free(hostname);
    return ret;
}

int RTMP_Connect0(RTMP *r)
{
    ef64:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int on = 1;
    r->m_sb.sb_timedout = FALSE;
    ef68:	e2803901 	add	r3, r0, #16384	; 0x4000
        free(hostname);
    return ret;
}

int RTMP_Connect0(RTMP *r)
{
    ef6c:	e24ddf71 	sub	sp, sp, #452	; 0x1c4
    int on = 1;
    r->m_sb.sb_timedout = FALSE;
    ef70:	e3a04000 	mov	r4, #0
    ef74:	e1a0c003 	mov	ip, r3
    ef78:	e58d3014 	str	r3, [sp, #20]
    r->m_pausing = 0;
    r->m_fDuration = 0.0;
    ef7c:	e3a02000 	mov	r2, #0
    ef80:	e3a03000 	mov	r3, #0
	
	struct addrinfo hints, *res, *aip;
	int error = 0, sockfd = -1;
	char hostname[100] = { '\0' };
    ef84:	e28d505c 	add	r5, sp, #92	; 0x5c
}

int RTMP_Connect0(RTMP *r)
{
    int on = 1;
    r->m_sb.sb_timedout = FALSE;
    ef88:	e58c40ec 	str	r4, [ip, #236]	; 0xec
        free(hostname);
    return ret;
}

int RTMP_Connect0(RTMP *r)
{
    ef8c:	e58d0010 	str	r0, [sp, #16]
    int on = 1;
    r->m_sb.sb_timedout = FALSE;
    r->m_pausing = 0;
    r->m_fDuration = 0.0;
    ef90:	e1c027f0 	strd	r2, [r0, #112]	; 0x70

int RTMP_Connect0(RTMP *r)
{
    int on = 1;
    r->m_sb.sb_timedout = FALSE;
    r->m_pausing = 0;
    ef94:	e5804028 	str	r4, [r0, #40]	; 0x28
    return ret;
}

int RTMP_Connect0(RTMP *r)
{
    int on = 1;
    ef98:	e3a06001 	mov	r6, #1
	
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;

	if (r->Link.socksport)
    ef9c:	e28c7f65 	add	r7, ip, #404	; 0x194
    r->m_pausing = 0;
    r->m_fDuration = 0.0;
	
	struct addrinfo hints, *res, *aip;
	int error = 0, sockfd = -1;
	char hostname[100] = { '\0' };
    efa0:	e1a01004 	mov	r1, r4
    efa4:	e1a00005 	mov	r0, r5
    efa8:	e3a02064 	mov	r2, #100	; 0x64
    return ret;
}

int RTMP_Connect0(RTMP *r)
{
    int on = 1;
    efac:	e58d601c 	str	r6, [sp, #28]
    r->m_pausing = 0;
    r->m_fDuration = 0.0;
	
	struct addrinfo hints, *res, *aip;
	int error = 0, sockfd = -1;
	char hostname[100] = { '\0' };
    efb0:	ebffd846 	bl	50d0 <memset@plt>
	
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;

	if (r->Link.socksport)
    efb4:	e1d730b0 	ldrh	r3, [r7]
    r->m_fDuration = 0.0;
	
	struct addrinfo hints, *res, *aip;
	int error = 0, sockfd = -1;
	char hostname[100] = { '\0' };
	char servname[16] = { '\0' };
    efb8:	e58d402c 	str	r4, [sp, #44]	; 0x2c
	
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;

	if (r->Link.socksport)
    efbc:	e1530004 	cmp	r3, r4
	{
		sprintf(hostname, "%.*s", r->Link.sockshost.av_len, r->Link.sockshost.av_val);
    efc0:	e1a00005 	mov	r0, r5
    r->m_fDuration = 0.0;
	
	struct addrinfo hints, *res, *aip;
	int error = 0, sockfd = -1;
	char hostname[100] = { '\0' };
	char servname[16] = { '\0' };
    efc4:	e58d4030 	str	r4, [sp, #48]	; 0x30
    efc8:	e58d4034 	str	r4, [sp, #52]	; 0x34
    efcc:	e58d4038 	str	r4, [sp, #56]	; 0x38
	
	memset(&hints, 0, sizeof(hints));
    efd0:	e58d403c 	str	r4, [sp, #60]	; 0x3c
    efd4:	e58d4040 	str	r4, [sp, #64]	; 0x40
    efd8:	e58d4048 	str	r4, [sp, #72]	; 0x48
    efdc:	e58d404c 	str	r4, [sp, #76]	; 0x4c
    efe0:	e58d4050 	str	r4, [sp, #80]	; 0x50
    efe4:	e58d4054 	str	r4, [sp, #84]	; 0x54
    efe8:	e58d4058 	str	r4, [sp, #88]	; 0x58
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
    efec:	e58d6044 	str	r6, [sp, #68]	; 0x44

	if (r->Link.socksport)
    eff0:	0a0000fe 	beq	f3f0 <RTMP_Connect0+0x48c>
	{
		sprintf(hostname, "%.*s", r->Link.sockshost.av_len, r->Link.sockshost.av_val);
    eff4:	e59d3014 	ldr	r3, [sp, #20]
    eff8:	e59f1624 	ldr	r1, [pc, #1572]	; f624 <RTMP_Connect0+0x6c0>
    effc:	e5932100 	ldr	r2, [r3, #256]	; 0x100
    f000:	e08f1001 	add	r1, pc, r1
    f004:	e59330fc 	ldr	r3, [r3, #252]	; 0xfc
    f008:	ebffd857 	bl	516c <sprintf@plt>
		sprintf(servname, "%d", r->Link.socksport);
    f00c:	e59f1614 	ldr	r1, [pc, #1556]	; f628 <RTMP_Connect0+0x6c4>
    f010:	e28d402c 	add	r4, sp, #44	; 0x2c
    f014:	e1d720b0 	ldrh	r2, [r7]
    f018:	e1a00004 	mov	r0, r4
    f01c:	e08f1001 	add	r1, pc, r1
    f020:	ebffd851 	bl	516c <sprintf@plt>
	{
		sprintf(hostname, "%.*s", r->Link.hostname.av_len, r->Link.hostname.av_val);
		sprintf(servname, "%d", r->Link.port);
	}

	error = getaddrinfo(hostname, servname, &hints, &res);
    f024:	e1a00005 	mov	r0, r5
    f028:	e1a01004 	mov	r1, r4
    f02c:	e28d203c 	add	r2, sp, #60	; 0x3c
    f030:	e28d3020 	add	r3, sp, #32
    f034:	ebffd8f7 	bl	5418 <getaddrinfo@plt>
	if (error != 0)
    f038:	e3500000 	cmp	r0, #0
    f03c:	1a0000e8 	bne	f3e4 <RTMP_Connect0+0x480>
	{
		return FALSE;
	}

	for (aip = res; aip != NULL; aip = aip->ai_next)
    f040:	e59d4020 	ldr	r4, [sp, #32]
    f044:	e3540000 	cmp	r4, #0
    f048:	0a00016a 	beq	f5f8 <RTMP_Connect0+0x694>
    f04c:	e59d3010 	ldr	r3, [sp, #16]
    f050:	e2833c42 	add	r3, r3, #16896	; 0x4200
    f054:	e58d300c 	str	r3, [sp, #12]
	{
		sockfd = socket(aip->ai_family, aip->ai_socktype, aip->ai_protocol);
    f058:	e9940007 	ldmib	r4, {r0, r1, r2}
    f05c:	ebffd8f6 	bl	543c <socket@plt>

		if (sockfd < 0)
    f060:	e2505000 	subs	r5, r0, #0
    f064:	ba00004d 	blt	f1a0 <RTMP_Connect0+0x23c>
		{
#ifdef PLATFORM_IOS
			int set = 1;
			setsockopt(r->m_sb.sb_socket, SOL_SOCKET, SO_NOSIGPIPE, (void *)&set, sizeof(int));
#endif
			int flags = fcntl(sockfd, F_GETFL, 0);
    f068:	e3a01003 	mov	r1, #3
    f06c:	e3a02000 	mov	r2, #0
    f070:	ebffd8eb 	bl	5424 <fcntl@plt>
			fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);
    f074:	e3a01004 	mov	r1, #4
    f078:	e3802b02 	orr	r2, r0, #2048	; 0x800
    f07c:	e1a00005 	mov	r0, r5
    f080:	ebffd8e7 	bl	5424 <fcntl@plt>
			connect(sockfd, aip->ai_addr, aip->ai_addrlen);
    f084:	e5941018 	ldr	r1, [r4, #24]
    f088:	e5942010 	ldr	r2, [r4, #16]
    f08c:	e1a00005 	mov	r0, r5
    f090:	ebffd8e6 	bl	5430 <connect@plt>

			int connected = FALSE;
			if (errno == 0 || errno == EINPROGRESS)
    f094:	ebffd8c1 	bl	53a0 <__errno@plt>
    f098:	e5903000 	ldr	r3, [r0]
    f09c:	e3530000 	cmp	r3, #0
    f0a0:	1a000041 	bne	f1ac <RTMP_Connect0+0x248>
					tm.tv_sec = 1;
					tm.tv_usec = 0;
					
					fd_set set;
					FD_ZERO(&set);
					FD_SET(sockfd, &set);
    f0a4:	e28d3d07 	add	r3, sp, #448	; 0x1c0
    f0a8:	e1a082c5 	asr	r8, r5, #5
    f0ac:	e205901f 	and	r9, r5, #31
    f0b0:	e0838108 	add	r8, r3, r8, lsl #2
    f0b4:	e3a03001 	mov	r3, #1
    f0b8:	e1a09913 	lsl	r9, r3, r9
    f0bc:	e59da00c 	ldr	sl, [sp, #12]
    f0c0:	e3a06005 	mov	r6, #5
					struct timeval tm;
					tm.tv_sec = 1;
					tm.tv_usec = 0;
					
					fd_set set;
					FD_ZERO(&set);
    f0c4:	e28db0c0 	add	fp, sp, #192	; 0xc0
    f0c8:	e58d4008 	str	r4, [sp, #8]

			int connected = FALSE;
			if (errno == 0 || errno == EINPROGRESS)
			{
				int i = 0;
				for (i = 0; i < 5 && !ff_check_interrupt_rtmp(&r->interrupt_callback); ++i)
    f0cc:	e1a0000a 	mov	r0, sl
    f0d0:	ebffe513 	bl	8524 <ff_check_interrupt_rtmp>
					struct timeval tm;
					tm.tv_sec = 1;
					tm.tv_usec = 0;
					
					fd_set set;
					FD_ZERO(&set);
    f0d4:	e1a0700b 	mov	r7, fp
    f0d8:	e3a02080 	mov	r2, #128	; 0x80

			int connected = FALSE;
			if (errno == 0 || errno == EINPROGRESS)
			{
				int i = 0;
				for (i = 0; i < 5 && !ff_check_interrupt_rtmp(&r->interrupt_callback); ++i)
    f0dc:	e2504000 	subs	r4, r0, #0
					struct timeval tm;
					tm.tv_sec = 1;
					tm.tv_usec = 0;
					
					fd_set set;
					FD_ZERO(&set);
    f0e0:	e1a01004 	mov	r1, r4
    f0e4:	e1a0000b 	mov	r0, fp

			int connected = FALSE;
			if (errno == 0 || errno == EINPROGRESS)
			{
				int i = 0;
				for (i = 0; i < 5 && !ff_check_interrupt_rtmp(&r->interrupt_callback); ++i)
    f0e8:	1a000012 	bne	f138 <RTMP_Connect0+0x1d4>
				{
					struct timeval tm;
					tm.tv_sec = 1;
    f0ec:	e3a03001 	mov	r3, #1
    f0f0:	e58d3024 	str	r3, [sp, #36]	; 0x24
					tm.tv_usec = 0;
    f0f4:	e58d4028 	str	r4, [sp, #40]	; 0x28
					
					fd_set set;
					FD_ZERO(&set);
    f0f8:	ebffd7f4 	bl	50d0 <memset@plt>
					FD_SET(sockfd, &set);
					
					if (select(sockfd + 1, NULL, &set, NULL, &tm) > 0)
    f0fc:	e28d3024 	add	r3, sp, #36	; 0x24
    f100:	e58d3000 	str	r3, [sp]
    f104:	e2850001 	add	r0, r5, #1
    f108:	e1a01004 	mov	r1, r4
    f10c:	e1a02007 	mov	r2, r7
    f110:	e1a03004 	mov	r3, r4
					tm.tv_sec = 1;
					tm.tv_usec = 0;
					
					fd_set set;
					FD_ZERO(&set);
					FD_SET(sockfd, &set);
    f114:	e5089100 	str	r9, [r8, #-256]	; 0xffffff00
					
					if (select(sockfd + 1, NULL, &set, NULL, &tm) > 0)
    f118:	ebffd8ca 	bl	5448 <select@plt>
    f11c:	e3500000 	cmp	r0, #0
    f120:	da000002 	ble	f130 <RTMP_Connect0+0x1cc>
					{
						if (FD_ISSET(sockfd, &set))
    f124:	e5183100 	ldr	r3, [r8, #-256]	; 0xffffff00
    f128:	e1190003 	tst	r9, r3
    f12c:	1a000023 	bne	f1c0 <RTMP_Connect0+0x25c>

			int connected = FALSE;
			if (errno == 0 || errno == EINPROGRESS)
			{
				int i = 0;
				for (i = 0; i < 5 && !ff_check_interrupt_rtmp(&r->interrupt_callback); ++i)
    f130:	e2566001 	subs	r6, r6, #1
    f134:	1affffe4 	bne	f0cc <RTMP_Connect0+0x168>
    f138:	e59d4008 	ldr	r4, [sp, #8]
				{
					break;
				}
			}
			
			close(sockfd);
    f13c:	e1a00005 	mov	r0, r5
    f140:	ebffd8ae 	bl	5400 <close@plt>
			sockfd = -1;
    f144:	e3e05000 	mvn	r5, #0
	if (error != 0)
	{
		return FALSE;
	}

	for (aip = res; aip != NULL; aip = aip->ai_next)
    f148:	e594401c 	ldr	r4, [r4, #28]
    f14c:	e3540000 	cmp	r4, #0
    f150:	1affffc0 	bne	f058 <RTMP_Connect0+0xf4>
			close(sockfd);
			sockfd = -1;
		}
	}
	
	freeaddrinfo(res);
    f154:	e59d0020 	ldr	r0, [sp, #32]
    f158:	ebffd8bd 	bl	5454 <freeaddrinfo@plt>
	
	//////////////////////////////////////////////////////////////////
	r->m_sb.sb_socket = sockfd;
    f15c:	e59d3010 	ldr	r3, [sp, #16]
	if (r->m_sb.sb_socket != -1)
    f160:	e3750001 	cmn	r5, #1
	}
	
	freeaddrinfo(res);
	
	//////////////////////////////////////////////////////////////////
	r->m_sb.sb_socket = sockfd;
    f164:	e58350e0 	str	r5, [r3, #224]	; 0xe0
	if (r->m_sb.sb_socket != -1)
    f168:	1a000109 	bne	f594 <RTMP_Connect0+0x630>
        }
    }
    else
    {
        RTMP_Log(RTMP_LOGERROR, "%s, failed to create socket. Error: %d", __FUNCTION__,
                 GetSockError());
    f16c:	ebffd88b 	bl	53a0 <__errno@plt>
            }
        }
    }
    else
    {
        RTMP_Log(RTMP_LOGERROR, "%s, failed to create socket. Error: %d", __FUNCTION__,
    f170:	e59f24b4 	ldr	r2, [pc, #1204]	; f62c <RTMP_Connect0+0x6c8>
    f174:	e59f14b4 	ldr	r1, [pc, #1204]	; f630 <RTMP_Connect0+0x6cc>
    f178:	e08f2002 	add	r2, pc, r2
    f17c:	e2422eb1 	sub	r2, r2, #2832	; 0xb10
    f180:	e2422004 	sub	r2, r2, #4
    f184:	e08f1001 	add	r1, pc, r1
    f188:	e5903000 	ldr	r3, [r0]
    f18c:	e3a00001 	mov	r0, #1
    f190:	eb001a05 	bl	159ac <RTMP_Log>
                 GetSockError());
        return FALSE;
    f194:	e3a00000 	mov	r0, #0
	
	getsockopt(r->m_sb.sb_socket, SOL_SOCKET, SO_SNDBUF, &onb_sbuf, &sock_buf_size);
	RTMP_Log(RTMP_LOGINFO,"SEND socket buf new:%d", onb_sbuf);
	
    return TRUE;
}
    f198:	e28ddf71 	add	sp, sp, #452	; 0x1c4
    f19c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
	{
		sockfd = socket(aip->ai_family, aip->ai_socktype, aip->ai_protocol);

		if (sockfd < 0)
		{
			switch (errno)
    f1a0:	ebffd87e 	bl	53a0 <__errno@plt>
    f1a4:	e5903000 	ldr	r3, [r0]
    f1a8:	eaffffe6 	b	f148 <RTMP_Connect0+0x1e4>
			int flags = fcntl(sockfd, F_GETFL, 0);
			fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);
			connect(sockfd, aip->ai_addr, aip->ai_addrlen);

			int connected = FALSE;
			if (errno == 0 || errno == EINPROGRESS)
    f1ac:	ebffd87b 	bl	53a0 <__errno@plt>
    f1b0:	e5903000 	ldr	r3, [r0]
    f1b4:	e3530073 	cmp	r3, #115	; 0x73
    f1b8:	1affffdf 	bne	f13c <RTMP_Connect0+0x1d8>
    f1bc:	eaffffb8 	b	f0a4 <RTMP_Connect0+0x140>
    f1c0:	e1a0a004 	mov	sl, r4
					
					if (select(sockfd + 1, NULL, &set, NULL, &tm) > 0)
					{
						if (FD_ISSET(sockfd, &set))
						{
							char addrStr[128] = { '\0' };
    f1c4:	e28d6d05 	add	r6, sp, #320	; 0x140
    f1c8:	e59d4008 	ldr	r4, [sp, #8]
    f1cc:	e1a0100a 	mov	r1, sl
    f1d0:	e1a00006 	mov	r0, r6
    f1d4:	e3a02080 	mov	r2, #128	; 0x80
    f1d8:	ebffd7bc 	bl	50d0 <memset@plt>
							if (aip->ai_family == AF_INET)
    f1dc:	e5940004 	ldr	r0, [r4, #4]
    f1e0:	e3500002 	cmp	r0, #2
    f1e4:	0a0000f2 	beq	f5b4 <RTMP_Connect0+0x650>
							{
								struct sockaddr_in *sinp = (struct sockaddr_in *)aip->ai_addr;
								inet_ntop(aip->ai_family, &sinp->sin_addr, addrStr, sizeof(addrStr));
							}
							else if (aip->ai_family == AF_INET6)
    f1e8:	e350000a 	cmp	r0, #10
    f1ec:	0a0000ea 	beq	f59c <RTMP_Connect0+0x638>
							{
								struct sockaddr_in6 *sinp = (struct sockaddr_in6 *)aip->ai_addr;
								inet_ntop(aip->ai_family, &sinp->sin6_addr, addrStr, sizeof(addrStr));
							}
							RTMP_Log(RTMP_LOGINFO, "rtmp_connect_ip: %s", addrStr);
    f1f0:	e59f143c 	ldr	r1, [pc, #1084]	; f634 <RTMP_Connect0+0x6d0>
    f1f4:	e1a02006 	mov	r2, r6
    f1f8:	e3a00003 	mov	r0, #3
    f1fc:	e08f1001 	add	r1, pc, r1
    f200:	eb0019e9 	bl	159ac <RTMP_Log>
			close(sockfd);
			sockfd = -1;
		}
	}
	
	freeaddrinfo(res);
    f204:	e59d0020 	ldr	r0, [sp, #32]
    f208:	ebffd891 	bl	5454 <freeaddrinfo@plt>
	
	//////////////////////////////////////////////////////////////////
	r->m_sb.sb_socket = sockfd;
    f20c:	e59d3010 	ldr	r3, [sp, #16]
    f210:	e58350e0 	str	r5, [r3, #224]	; 0xe0
	if (r->m_sb.sb_socket != -1)
	{
		int flags = fcntl(r->m_sb.sb_socket, F_GETFL, 0);
    f214:	e3a01003 	mov	r1, #3
    f218:	e3a02000 	mov	r2, #0
    f21c:	e1a00005 	mov	r0, r5
    f220:	ebffd87f 	bl	5424 <fcntl@plt>
		fcntl(r->m_sb.sb_socket, F_SETFL, flags & ~O_NONBLOCK);
		
		//end
        if (r->Link.socksport)
    f224:	e59d3014 	ldr	r3, [sp, #20]
	//////////////////////////////////////////////////////////////////
	r->m_sb.sb_socket = sockfd;
	if (r->m_sb.sb_socket != -1)
	{
		int flags = fcntl(r->m_sb.sb_socket, F_GETFL, 0);
		fcntl(r->m_sb.sb_socket, F_SETFL, flags & ~O_NONBLOCK);
    f228:	e3a01004 	mov	r1, #4
		
		//end
        if (r->Link.socksport)
    f22c:	e2834f65 	add	r4, r3, #404	; 0x194
	//////////////////////////////////////////////////////////////////
	r->m_sb.sb_socket = sockfd;
	if (r->m_sb.sb_socket != -1)
	{
		int flags = fcntl(r->m_sb.sb_socket, F_GETFL, 0);
		fcntl(r->m_sb.sb_socket, F_SETFL, flags & ~O_NONBLOCK);
    f230:	e59d3010 	ldr	r3, [sp, #16]
    f234:	e3c02b02 	bic	r2, r0, #2048	; 0x800
    f238:	e59300e0 	ldr	r0, [r3, #224]	; 0xe0
    f23c:	ebffd878 	bl	5424 <fcntl@plt>
		
		//end
        if (r->Link.socksport)
    f240:	e1d430b0 	ldrh	r3, [r4]
    f244:	e3530000 	cmp	r3, #0
    f248:	0a000075 	beq	f424 <RTMP_Connect0+0x4c0>
        {
            RTMP_Log(RTMP_LOGDEBUG, "%s ... SOCKS negotiation", __FUNCTION__);
    f24c:	e59f23e4 	ldr	r2, [pc, #996]	; f638 <RTMP_Connect0+0x6d4>
    f250:	e59f13e4 	ldr	r1, [pc, #996]	; f63c <RTMP_Connect0+0x6d8>
    f254:	e08f2002 	add	r2, pc, r2
    f258:	e2422eb1 	sub	r2, r2, #2832	; 0xb10
    f25c:	e3a00004 	mov	r0, #4
    f260:	e2422004 	sub	r2, r2, #4
    f264:	e08f1001 	add	r1, pc, r1
    f268:	eb0019cf 	bl	159ac <RTMP_Log>
static int
add_addr_info(struct sockaddr_in *service, AVal *host, int port)
{
    char *hostname;
    int ret = TRUE;
    if (host->av_val[host->av_len])
    f26c:	e59d3014 	ldr	r3, [sp, #20]
static int
SocksNegotiate(RTMP *r)
{
    unsigned long addr;
    struct sockaddr_in service;
    memset(&service, 0, sizeof(struct sockaddr_in));
    f270:	e3a06000 	mov	r6, #0
static int
add_addr_info(struct sockaddr_in *service, AVal *host, int port)
{
    char *hostname;
    int ret = TRUE;
    if (host->av_val[host->av_len])
    f274:	e59350f4 	ldr	r5, [r3, #244]	; 0xf4
    f278:	e59390f8 	ldr	r9, [r3, #248]	; 0xf8
static int
SocksNegotiate(RTMP *r)
{
    unsigned long addr;
    struct sockaddr_in service;
    memset(&service, 0, sizeof(struct sockaddr_in));
    f27c:	e58d6140 	str	r6, [sp, #320]	; 0x140
    f280:	e58d6144 	str	r6, [sp, #324]	; 0x144
    f284:	e58d6148 	str	r6, [sp, #328]	; 0x148
    f288:	e58d614c 	str	r6, [sp, #332]	; 0x14c
static int
add_addr_info(struct sockaddr_in *service, AVal *host, int port)
{
    char *hostname;
    int ret = TRUE;
    if (host->av_val[host->av_len])
    f28c:	e7d53009 	ldrb	r3, [r5, r9]
{
    unsigned long addr;
    struct sockaddr_in service;
    memset(&service, 0, sizeof(struct sockaddr_in));
    
    add_addr_info(&service, &r->Link.hostname, r->Link.port);
    f290:	e1d480b2 	ldrh	r8, [r4, #2]
static int
add_addr_info(struct sockaddr_in *service, AVal *host, int port)
{
    char *hostname;
    int ret = TRUE;
    if (host->av_val[host->av_len])
    f294:	e1530006 	cmp	r3, r6
    f298:	0a000006 	beq	f2b8 <RTMP_Connect0+0x354>
    {
        hostname = malloc(host->av_len+1);
    f29c:	e2890001 	add	r0, r9, #1
    f2a0:	ebffd75d 	bl	501c <malloc@plt>
        memcpy(hostname, host->av_val, host->av_len);
    f2a4:	e1a01005 	mov	r1, r5
    f2a8:	e1a02009 	mov	r2, r9
        hostname[host->av_len] = '\0';
    f2ac:	e1a05000 	mov	r5, r0
    char *hostname;
    int ret = TRUE;
    if (host->av_val[host->av_len])
    {
        hostname = malloc(host->av_len+1);
        memcpy(hostname, host->av_val, host->av_len);
    f2b0:	ebffd7c5 	bl	51cc <memcpy@plt>
        hostname[host->av_len] = '\0';
    f2b4:	e7c06009 	strb	r6, [r0, r9]
    else
    {
        hostname = host->av_val;
    }
    
    service->sin_addr.s_addr = inet_addr(hostname);
    f2b8:	e1a00005 	mov	r0, r5
    f2bc:	ebffd879 	bl	54a8 <inet_addr@plt>
    if (service->sin_addr.s_addr == INADDR_NONE)
    f2c0:	e3700001 	cmn	r0, #1
    else
    {
        hostname = host->av_val;
    }
    
    service->sin_addr.s_addr = inet_addr(hostname);
    f2c4:	e1a04000 	mov	r4, r0
    f2c8:	e58d0144 	str	r0, [sp, #324]	; 0x144
    if (service->sin_addr.s_addr == INADDR_NONE)
    f2cc:	0a0000be 	beq	f5cc <RTMP_Connect0+0x668>
            goto finish;
        }
        service->sin_addr = *(struct in_addr *)host->h_addr;
    }
    
    service->sin_port = htons(port);
    f2d0:	e28d2d05 	add	r2, sp, #320	; 0x140
    f2d4:	e1a03428 	lsr	r3, r8, #8
    f2d8:	e1833408 	orr	r3, r3, r8, lsl #8
    f2dc:	e2822002 	add	r2, r2, #2
    f2e0:	e1c230b0 	strh	r3, [r2]
finish:
    if (hostname != host->av_val)
    f2e4:	e59d3014 	ldr	r3, [sp, #20]
    f2e8:	e59330f4 	ldr	r3, [r3, #244]	; 0xf4
    f2ec:	e1550003 	cmp	r5, r3
    f2f0:	0a000001 	beq	f2fc <RTMP_Connect0+0x398>
        free(hostname);
    f2f4:	e1a00005 	mov	r0, r5
    f2f8:	ebffd741 	bl	5004 <free@plt>
    addr = htonl(service.sin_addr.s_addr);
    
    {
        char packet[] = {
            4, 1,			/* SOCKS 4, connect */
            (r->Link.port >> 8) & 0xFF,
    f2fc:	e59d3014 	ldr	r3, [sp, #20]
    unsigned long addr;
    struct sockaddr_in service;
    memset(&service, 0, sizeof(struct sockaddr_in));
    
    add_addr_info(&service, &r->Link.hostname, r->Link.port);
    addr = htonl(service.sin_addr.s_addr);
    f300:	e0242864 	eor	r2, r4, r4, ror #16
    
    {
        char packet[] = {
            4, 1,			/* SOCKS 4, connect */
            (r->Link.port >> 8) & 0xFF,
    f304:	e2833f65 	add	r3, r3, #404	; 0x194
    unsigned long addr;
    struct sockaddr_in service;
    memset(&service, 0, sizeof(struct sockaddr_in));
    
    add_addr_info(&service, &r->Link.hostname, r->Link.port);
    addr = htonl(service.sin_addr.s_addr);
    f308:	e1a02422 	lsr	r2, r2, #8
    
    {
        char packet[] = {
            4, 1,			/* SOCKS 4, connect */
            (r->Link.port >> 8) & 0xFF,
    f30c:	e1d3c0b2 	ldrh	ip, [r3, #2]
            (char)(addr >> 24) & 0xFF, (char)(addr >> 16) & 0xFF,
            (char)(addr >> 8) & 0xFF, (char)addr & 0xFF,
            0
        };				/* NULL terminate */
        
        WriteN(r, packet, sizeof packet,0);
    f310:	e59db010 	ldr	fp, [sp, #16]
    unsigned long addr;
    struct sockaddr_in service;
    memset(&service, 0, sizeof(struct sockaddr_in));
    
    add_addr_info(&service, &r->Link.hostname, r->Link.port);
    addr = htonl(service.sin_addr.s_addr);
    f314:	e3c22cff 	bic	r2, r2, #65280	; 0xff00
    f318:	e0223464 	eor	r3, r2, r4, ror #8
    
    {
        char packet[] = {
    f31c:	e1a0a42c 	lsr	sl, ip, #8
            4, 1,			/* SOCKS 4, connect */
            (r->Link.port >> 8) & 0xFF,
            (r->Link.port) & 0xFF,
            (char)(addr >> 24) & 0xFF, (char)(addr >> 16) & 0xFF,
    f320:	e1a09c23 	lsr	r9, r3, #24
    f324:	e1a08823 	lsr	r8, r3, #16
            (char)(addr >> 8) & 0xFF, (char)addr & 0xFF,
    f328:	e1a06423 	lsr	r6, r3, #8
    
    add_addr_info(&service, &r->Link.hostname, r->Link.port);
    addr = htonl(service.sin_addr.s_addr);
    
    {
        char packet[] = {
    f32c:	e3a0e000 	mov	lr, #0
            (char)(addr >> 24) & 0xFF, (char)(addr >> 16) & 0xFF,
            (char)(addr >> 8) & 0xFF, (char)addr & 0xFF,
            0
        };				/* NULL terminate */
        
        WriteN(r, packet, sizeof packet,0);
    f330:	e1a01007 	mov	r1, r7
    f334:	e3a02009 	mov	r2, #9
    
    add_addr_info(&service, &r->Link.hostname, r->Link.port);
    addr = htonl(service.sin_addr.s_addr);
    
    {
        char packet[] = {
    f338:	e3a05004 	mov	r5, #4
    f33c:	e3a04001 	mov	r4, #1
            (char)(addr >> 24) & 0xFF, (char)(addr >> 16) & 0xFF,
            (char)(addr >> 8) & 0xFF, (char)addr & 0xFF,
            0
        };				/* NULL terminate */
        
        WriteN(r, packet, sizeof packet,0);
    f340:	e1a0000b 	mov	r0, fp
    
    add_addr_info(&service, &r->Link.hostname, r->Link.port);
    addr = htonl(service.sin_addr.s_addr);
    
    {
        char packet[] = {
    f344:	e5cdc0c3 	strb	ip, [sp, #195]	; 0xc3
    f348:	e5cd30c7 	strb	r3, [sp, #199]	; 0xc7
    f34c:	e5cde0c8 	strb	lr, [sp, #200]	; 0xc8
    f350:	e5cda0c2 	strb	sl, [sp, #194]	; 0xc2
    f354:	e5cd90c4 	strb	r9, [sp, #196]	; 0xc4
    f358:	e5cd80c5 	strb	r8, [sp, #197]	; 0xc5
    f35c:	e5cd60c6 	strb	r6, [sp, #198]	; 0xc6
    f360:	e5cd50c0 	strb	r5, [sp, #192]	; 0xc0
    f364:	e5cd40c1 	strb	r4, [sp, #193]	; 0xc1
            (char)(addr >> 24) & 0xFF, (char)(addr >> 16) & 0xFF,
            (char)(addr >> 8) & 0xFF, (char)addr & 0xFF,
            0
        };				/* NULL terminate */
        
        WriteN(r, packet, sizeof packet,0);
    f368:	ebffef7d 	bl	b164 <WriteN.isra.9>
        
        if (ReadN(r, packet, 8) != 8)
    f36c:	e1a0000b 	mov	r0, fp
    f370:	e1a01007 	mov	r1, r7
    f374:	e3a02008 	mov	r2, #8
    f378:	ebfff6cf 	bl	cebc <ReadN>
    f37c:	e3500008 	cmp	r0, #8
    f380:	1a00000d 	bne	f3bc <RTMP_Connect0+0x458>
            return FALSE;
        
        if (packet[0] == 0 && packet[1] == 90)
    f384:	e5dd30c0 	ldrb	r3, [sp, #192]	; 0xc0
    f388:	e3530000 	cmp	r3, #0
    f38c:	e5dd30c1 	ldrb	r3, [sp, #193]	; 0xc1
    f390:	1a000001 	bne	f39c <RTMP_Connect0+0x438>
    f394:	e353005a 	cmp	r3, #90	; 0x5a
    f398:	0a000021 	beq	f424 <RTMP_Connect0+0x4c0>
        {
            return TRUE;
        }
        else
        {
            RTMP_Log(RTMP_LOGERROR, "%s, SOCKS returned error code %d", __FUNCTION__, packet[1]);
    f39c:	e59f229c 	ldr	r2, [pc, #668]	; f640 <RTMP_Connect0+0x6dc>
    f3a0:	e59f129c 	ldr	r1, [pc, #668]	; f644 <RTMP_Connect0+0x6e0>
    f3a4:	e08f2002 	add	r2, pc, r2
    f3a8:	e2422c0b 	sub	r2, r2, #2816	; 0xb00
    f3ac:	e2422004 	sub	r2, r2, #4
    f3b0:	e3a00001 	mov	r0, #1
    f3b4:	e08f1001 	add	r1, pc, r1
    f3b8:	eb00197b 	bl	159ac <RTMP_Log>
        if (r->Link.socksport)
        {
            RTMP_Log(RTMP_LOGDEBUG, "%s ... SOCKS negotiation", __FUNCTION__);
            if (!SocksNegotiate(r))
            {
                RTMP_Log(RTMP_LOGERROR, "%s, SOCKS negotiation failed.", __FUNCTION__);
    f3bc:	e59f2284 	ldr	r2, [pc, #644]	; f648 <RTMP_Connect0+0x6e4>
    f3c0:	e59f1284 	ldr	r1, [pc, #644]	; f64c <RTMP_Connect0+0x6e8>
    f3c4:	e08f2002 	add	r2, pc, r2
    f3c8:	e2422eb1 	sub	r2, r2, #2832	; 0xb10
    f3cc:	e3a00001 	mov	r0, #1
    f3d0:	e2422004 	sub	r2, r2, #4
    f3d4:	e08f1001 	add	r1, pc, r1
    f3d8:	eb001973 	bl	159ac <RTMP_Log>
                
                RTMP_Close(r);
    f3dc:	e59d0010 	ldr	r0, [sp, #16]
    f3e0:	ebffef5d 	bl	b15c <RTMP_Close>
                return FALSE;
    f3e4:	e3a00000 	mov	r0, #0
	
	getsockopt(r->m_sb.sb_socket, SOL_SOCKET, SO_SNDBUF, &onb_sbuf, &sock_buf_size);
	RTMP_Log(RTMP_LOGINFO,"SEND socket buf new:%d", onb_sbuf);
	
    return TRUE;
}
    f3e8:	e28ddf71 	add	sp, sp, #452	; 0x1c4
    f3ec:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
		sprintf(hostname, "%.*s", r->Link.sockshost.av_len, r->Link.sockshost.av_val);
		sprintf(servname, "%d", r->Link.socksport);
	}
	else
	{
		sprintf(hostname, "%.*s", r->Link.hostname.av_len, r->Link.hostname.av_val);
    f3f0:	e59d3014 	ldr	r3, [sp, #20]
    f3f4:	e59f1254 	ldr	r1, [pc, #596]	; f650 <RTMP_Connect0+0x6ec>
    f3f8:	e59320f8 	ldr	r2, [r3, #248]	; 0xf8
    f3fc:	e08f1001 	add	r1, pc, r1
    f400:	e59330f4 	ldr	r3, [r3, #244]	; 0xf4
    f404:	ebffd758 	bl	516c <sprintf@plt>
		sprintf(servname, "%d", r->Link.port);
    f408:	e59f1244 	ldr	r1, [pc, #580]	; f654 <RTMP_Connect0+0x6f0>
    f40c:	e28d402c 	add	r4, sp, #44	; 0x2c
    f410:	e1d720b2 	ldrh	r2, [r7, #2]
    f414:	e1a00004 	mov	r0, r4
    f418:	e08f1001 	add	r1, pc, r1
    f41c:	ebffd752 	bl	516c <sprintf@plt>
    f420:	eafffeff 	b	f024 <RTMP_Connect0+0xc0>
    
    /* set timeout */
    {
		struct timeval tv = { 0, 100 * 1000 }; // 为了用户点击关闭时能快速退出，将TCP读数据超时时间设置很短
            
		if (setsockopt
    f424:	e59d3010 	ldr	r3, [sp, #16]
        return FALSE;
    }
    
    /* set timeout */
    {
		struct timeval tv = { 0, 100 * 1000 }; // 为了用户点击关闭时能快速退出，将TCP读数据超时时间设置很短
    f428:	e3a0e000 	mov	lr, #0
            
		if (setsockopt
    f42c:	e59300e0 	ldr	r0, [r3, #224]	; 0xe0
    f430:	e3a03008 	mov	r3, #8
    f434:	e58d3000 	str	r3, [sp]
        return FALSE;
    }
    
    /* set timeout */
    {
		struct timeval tv = { 0, 100 * 1000 }; // 为了用户点击关闭时能快速退出，将TCP读数据超时时间设置很短
    f438:	e59fc218 	ldr	ip, [pc, #536]	; f658 <RTMP_Connect0+0x6f4>
            
		if (setsockopt
    f43c:	e3a01001 	mov	r1, #1
    f440:	e3a02014 	mov	r2, #20
    f444:	e1a03007 	mov	r3, r7
        return FALSE;
    }
    
    /* set timeout */
    {
		struct timeval tv = { 0, 100 * 1000 }; // 为了用户点击关闭时能快速退出，将TCP读数据超时时间设置很短
    f448:	e58de0c0 	str	lr, [sp, #192]	; 0xc0
    f44c:	e58dc0c4 	str	ip, [sp, #196]	; 0xc4
            
		if (setsockopt
    f450:	ebffd802 	bl	5460 <setsockopt@plt>
    f454:	e3500000 	cmp	r0, #0
    f458:	1a000044 	bne	f570 <RTMP_Connect0+0x60c>
                     __FUNCTION__);
        }
		
		struct timeval tv2 = { 5, 0 }; // 发送超时5秒，应对切网络
		
		if (setsockopt
    f45c:	e59d3010 	ldr	r3, [sp, #16]
    f460:	e3a02008 	mov	r2, #8
    f464:	e28d6d05 	add	r6, sp, #320	; 0x140
    f468:	e59300e0 	ldr	r0, [r3, #224]	; 0xe0
        {
            RTMP_Log(RTMP_LOGERROR, "%s, Setting recv socket timeout to 100ms failed!",
                     __FUNCTION__);
        }
		
		struct timeval tv2 = { 5, 0 }; // 发送超时5秒，应对切网络
    f46c:	e3a0e005 	mov	lr, #5
		
		if (setsockopt
    f470:	e58d2000 	str	r2, [sp]
        {
            RTMP_Log(RTMP_LOGERROR, "%s, Setting recv socket timeout to 100ms failed!",
                     __FUNCTION__);
        }
		
		struct timeval tv2 = { 5, 0 }; // 发送超时5秒，应对切网络
    f474:	e3a0c000 	mov	ip, #0
		
		if (setsockopt
    f478:	e1a03006 	mov	r3, r6
    f47c:	e3a01001 	mov	r1, #1
    f480:	e3a02015 	mov	r2, #21
        {
            RTMP_Log(RTMP_LOGERROR, "%s, Setting recv socket timeout to 100ms failed!",
                     __FUNCTION__);
        }
		
		struct timeval tv2 = { 5, 0 }; // 发送超时5秒，应对切网络
    f484:	e58de140 	str	lr, [sp, #320]	; 0x140
    f488:	e58dc144 	str	ip, [sp, #324]	; 0x144
		
		if (setsockopt
    f48c:	ebffd7f3 	bl	5460 <setsockopt@plt>
    f490:	e3500000 	cmp	r0, #0
    f494:	1a00002c 	bne	f54c <RTMP_Connect0+0x5e8>
			RTMP_Log(RTMP_LOGERROR, "%s, Setting send socket timeout to 5s failed!",
					 __FUNCTION__);
		}
    }

	setsockopt(r->m_sb.sb_socket, IPPROTO_TCP, TCP_NODELAY, (char *) &on, sizeof(on));
    f498:	e59d8010 	ldr	r8, [sp, #16]
    f49c:	e3a05004 	mov	r5, #4
    f4a0:	e59800e0 	ldr	r0, [r8, #224]	; 0xe0
    f4a4:	e28d301c 	add	r3, sp, #28
	
	//////
	int onb_sbuf = 0;
	socklen_t sock_buf_size = sizeof(int);
	getsockopt(r->m_sb.sb_socket, SOL_SOCKET, SO_SNDBUF, &onb_sbuf, &sock_buf_size);
    f4a8:	e28d4024 	add	r4, sp, #36	; 0x24
			RTMP_Log(RTMP_LOGERROR, "%s, Setting send socket timeout to 5s failed!",
					 __FUNCTION__);
		}
    }

	setsockopt(r->m_sb.sb_socket, IPPROTO_TCP, TCP_NODELAY, (char *) &on, sizeof(on));
    f4ac:	e58d5000 	str	r5, [sp]
    f4b0:	e3a01006 	mov	r1, #6
    f4b4:	e3a02001 	mov	r2, #1
    f4b8:	ebffd7e8 	bl	5460 <setsockopt@plt>
	
	//////
	int onb_sbuf = 0;
	socklen_t sock_buf_size = sizeof(int);
	getsockopt(r->m_sb.sb_socket, SOL_SOCKET, SO_SNDBUF, &onb_sbuf, &sock_buf_size);
    f4bc:	e1a03004 	mov	r3, r4
    }

	setsockopt(r->m_sb.sb_socket, IPPROTO_TCP, TCP_NODELAY, (char *) &on, sizeof(on));
	
	//////
	int onb_sbuf = 0;
    f4c0:	e3a0c000 	mov	ip, #0
	socklen_t sock_buf_size = sizeof(int);
	getsockopt(r->m_sb.sb_socket, SOL_SOCKET, SO_SNDBUF, &onb_sbuf, &sock_buf_size);
    f4c4:	e59800e0 	ldr	r0, [r8, #224]	; 0xe0
    f4c8:	e3a01001 	mov	r1, #1
    f4cc:	e58d7000 	str	r7, [sp]
    f4d0:	e3a02007 	mov	r2, #7
    }

	setsockopt(r->m_sb.sb_socket, IPPROTO_TCP, TCP_NODELAY, (char *) &on, sizeof(on));
	
	//////
	int onb_sbuf = 0;
    f4d4:	e58dc024 	str	ip, [sp, #36]	; 0x24
	socklen_t sock_buf_size = sizeof(int);
    f4d8:	e58d50c0 	str	r5, [sp, #192]	; 0xc0
	getsockopt(r->m_sb.sb_socket, SOL_SOCKET, SO_SNDBUF, &onb_sbuf, &sock_buf_size);
    f4dc:	ebffd7f4 	bl	54b4 <getsockopt@plt>
	RTMP_Log(RTMP_LOGINFO,"SEND socket buf:%d", onb_sbuf);
    f4e0:	e59f1174 	ldr	r1, [pc, #372]	; f65c <RTMP_Connect0+0x6f8>
    f4e4:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
    f4e8:	e3a00003 	mov	r0, #3
    f4ec:	e08f1001 	add	r1, pc, r1
    f4f0:	eb00192d 	bl	159ac <RTMP_Log>
	int iSendbuf = 32000;
    f4f4:	e3a0cc7d 	mov	ip, #32000	; 0x7d00
	setsockopt(r->m_sb.sb_socket, SOL_SOCKET, SO_SNDBUF, (char *)&iSendbuf, sizeof(int));
    f4f8:	e59800e0 	ldr	r0, [r8, #224]	; 0xe0
    f4fc:	e1a03006 	mov	r3, r6
    f500:	e58d5000 	str	r5, [sp]
    f504:	e3a01001 	mov	r1, #1
    f508:	e3a02007 	mov	r2, #7
	//////
	int onb_sbuf = 0;
	socklen_t sock_buf_size = sizeof(int);
	getsockopt(r->m_sb.sb_socket, SOL_SOCKET, SO_SNDBUF, &onb_sbuf, &sock_buf_size);
	RTMP_Log(RTMP_LOGINFO,"SEND socket buf:%d", onb_sbuf);
	int iSendbuf = 32000;
    f50c:	e58dc140 	str	ip, [sp, #320]	; 0x140
	setsockopt(r->m_sb.sb_socket, SOL_SOCKET, SO_SNDBUF, (char *)&iSendbuf, sizeof(int));
    f510:	ebffd7d2 	bl	5460 <setsockopt@plt>
	
	
	getsockopt(r->m_sb.sb_socket, SOL_SOCKET, SO_SNDBUF, &onb_sbuf, &sock_buf_size);
    f514:	e59800e0 	ldr	r0, [r8, #224]	; 0xe0
    f518:	e1a03004 	mov	r3, r4
    f51c:	e58d7000 	str	r7, [sp]
    f520:	e3a01001 	mov	r1, #1
    f524:	e3a02007 	mov	r2, #7
    f528:	ebffd7e1 	bl	54b4 <getsockopt@plt>
	RTMP_Log(RTMP_LOGINFO,"SEND socket buf new:%d", onb_sbuf);
    f52c:	e59f112c 	ldr	r1, [pc, #300]	; f660 <RTMP_Connect0+0x6fc>
    f530:	e3a00003 	mov	r0, #3
    f534:	e08f1001 	add	r1, pc, r1
    f538:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
    f53c:	eb00191a 	bl	159ac <RTMP_Log>
	
    return TRUE;
    f540:	e3a00001 	mov	r0, #1
}
    f544:	e28ddf71 	add	sp, sp, #452	; 0x1c4
    f548:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
		struct timeval tv2 = { 5, 0 }; // 发送超时5秒，应对切网络
		
		if (setsockopt
			(r->m_sb.sb_socket, SOL_SOCKET, SO_SNDTIMEO, (char *)&tv2, sizeof(tv2)))
		{
			RTMP_Log(RTMP_LOGERROR, "%s, Setting send socket timeout to 5s failed!",
    f54c:	e59f2110 	ldr	r2, [pc, #272]	; f664 <RTMP_Connect0+0x700>
    f550:	e59f1110 	ldr	r1, [pc, #272]	; f668 <RTMP_Connect0+0x704>
    f554:	e08f2002 	add	r2, pc, r2
    f558:	e2422eb1 	sub	r2, r2, #2832	; 0xb10
    f55c:	e3a00001 	mov	r0, #1
    f560:	e2422004 	sub	r2, r2, #4
    f564:	e08f1001 	add	r1, pc, r1
    f568:	eb00190f 	bl	159ac <RTMP_Log>
    f56c:	eaffffc9 	b	f498 <RTMP_Connect0+0x534>
		struct timeval tv = { 0, 100 * 1000 }; // 为了用户点击关闭时能快速退出，将TCP读数据超时时间设置很短
            
		if (setsockopt
            (r->m_sb.sb_socket, SOL_SOCKET, SO_RCVTIMEO, (char *)&tv, sizeof(tv)))
        {
            RTMP_Log(RTMP_LOGERROR, "%s, Setting recv socket timeout to 100ms failed!",
    f570:	e59f20f4 	ldr	r2, [pc, #244]	; f66c <RTMP_Connect0+0x708>
    f574:	e59f10f4 	ldr	r1, [pc, #244]	; f670 <RTMP_Connect0+0x70c>
    f578:	e08f2002 	add	r2, pc, r2
    f57c:	e2422eb1 	sub	r2, r2, #2832	; 0xb10
    f580:	e3a00001 	mov	r0, #1
    f584:	e2422004 	sub	r2, r2, #4
    f588:	e08f1001 	add	r1, pc, r1
    f58c:	eb001906 	bl	159ac <RTMP_Log>
    f590:	eaffffb1 	b	f45c <RTMP_Connect0+0x4f8>
    f594:	e28d70c0 	add	r7, sp, #192	; 0xc0
    f598:	eaffff1d 	b	f214 <RTMP_Connect0+0x2b0>
								inet_ntop(aip->ai_family, &sinp->sin_addr, addrStr, sizeof(addrStr));
							}
							else if (aip->ai_family == AF_INET6)
							{
								struct sockaddr_in6 *sinp = (struct sockaddr_in6 *)aip->ai_addr;
								inet_ntop(aip->ai_family, &sinp->sin6_addr, addrStr, sizeof(addrStr));
    f59c:	e5941018 	ldr	r1, [r4, #24]
    f5a0:	e1a02006 	mov	r2, r6
    f5a4:	e2811008 	add	r1, r1, #8
    f5a8:	e3a03080 	mov	r3, #128	; 0x80
    f5ac:	ebffd7c3 	bl	54c0 <inet_ntop@plt>
    f5b0:	eaffff0e 	b	f1f0 <RTMP_Connect0+0x28c>
						{
							char addrStr[128] = { '\0' };
							if (aip->ai_family == AF_INET)
							{
								struct sockaddr_in *sinp = (struct sockaddr_in *)aip->ai_addr;
								inet_ntop(aip->ai_family, &sinp->sin_addr, addrStr, sizeof(addrStr));
    f5b4:	e5941018 	ldr	r1, [r4, #24]
    f5b8:	e1a02006 	mov	r2, r6
    f5bc:	e2811004 	add	r1, r1, #4
    f5c0:	e3a03080 	mov	r3, #128	; 0x80
    f5c4:	ebffd7bd 	bl	54c0 <inet_ntop@plt>
    f5c8:	eaffff08 	b	f1f0 <RTMP_Connect0+0x28c>
    }
    
    service->sin_addr.s_addr = inet_addr(hostname);
    if (service->sin_addr.s_addr == INADDR_NONE)
    {
        struct hostent *host = gethostbyname(hostname);
    f5cc:	e1a00005 	mov	r0, r5
    f5d0:	ebffd7bd 	bl	54cc <gethostbyname@plt>
        if (host == NULL || host->h_addr == NULL)
    f5d4:	e3500000 	cmp	r0, #0
    f5d8:	0a00000b 	beq	f60c <RTMP_Connect0+0x6a8>
    f5dc:	e5903010 	ldr	r3, [r0, #16]
    f5e0:	e5933000 	ldr	r3, [r3]
    f5e4:	e3530000 	cmp	r3, #0
    f5e8:	0a000007 	beq	f60c <RTMP_Connect0+0x6a8>
        {
            RTMP_Log(RTMP_LOGERROR, "Problem accessing the DNS. (addr: %s)", hostname);
            ret = FALSE;
            goto finish;
        }
        service->sin_addr = *(struct in_addr *)host->h_addr;
    f5ec:	e5934000 	ldr	r4, [r3]
    f5f0:	e58d4144 	str	r4, [sp, #324]	; 0x144
    f5f4:	eaffff35 	b	f2d0 <RTMP_Connect0+0x36c>
			close(sockfd);
			sockfd = -1;
		}
	}
	
	freeaddrinfo(res);
    f5f8:	ebffd795 	bl	5454 <freeaddrinfo@plt>
	
	//////////////////////////////////////////////////////////////////
	r->m_sb.sb_socket = sockfd;
    f5fc:	e59d2010 	ldr	r2, [sp, #16]
    f600:	e3e03000 	mvn	r3, #0
    f604:	e58230e0 	str	r3, [r2, #224]	; 0xe0
    f608:	eafffed7 	b	f16c <RTMP_Connect0+0x208>
    if (service->sin_addr.s_addr == INADDR_NONE)
    {
        struct hostent *host = gethostbyname(hostname);
        if (host == NULL || host->h_addr == NULL)
        {
            RTMP_Log(RTMP_LOGERROR, "Problem accessing the DNS. (addr: %s)", hostname);
    f60c:	e59f1060 	ldr	r1, [pc, #96]	; f674 <RTMP_Connect0+0x710>
    f610:	e3a00001 	mov	r0, #1
    f614:	e08f1001 	add	r1, pc, r1
    f618:	e1a02005 	mov	r2, r5
    f61c:	eb0018e2 	bl	159ac <RTMP_Log>
    f620:	eaffff2f 	b	f2e4 <RTMP_Connect0+0x380>
    f624:	0000f014 	.word	0x0000f014
    f628:	0000f660 	.word	0x0000f660
    f62c:	0000f668 	.word	0x0000f668
    f630:	00010828 	.word	0x00010828
    f634:	00010734 	.word	0x00010734
    f638:	0000f58c 	.word	0x0000f58c
    f63c:	000106e0 	.word	0x000106e0
    f640:	0000f43c 	.word	0x0000f43c
    f644:	000105d4 	.word	0x000105d4
    f648:	0000f41c 	.word	0x0000f41c
    f64c:	00010690 	.word	0x00010690
    f650:	0000ec18 	.word	0x0000ec18
    f654:	0000f264 	.word	0x0000f264
    f658:	000186a0 	.word	0x000186a0
    f65c:	0001054c 	.word	0x0001054c
    f660:	00010518 	.word	0x00010518
    f664:	0000f28c 	.word	0x0000f28c
    f668:	000104a4 	.word	0x000104a4
    f66c:	0000f268 	.word	0x0000f268
    f670:	0001044c 	.word	0x0001044c
    f674:	0001034c 	.word	0x0001034c

0000f678 <RTMP_Connect1>:
#endif
}

int
RTMP_Connect1(RTMP *r, RTMPPacket *cp)
{
    f678:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    
    if (r->Link.protocol & RTMP_FEATURE_SSL)
    f67c:	e2804901 	add	r4, r0, #16384	; 0x4000
    f680:	e5943188 	ldr	r3, [r4, #392]	; 0x188
#endif
}

int
RTMP_Connect1(RTMP *r, RTMPPacket *cp)
{
    f684:	e59f6220 	ldr	r6, [pc, #544]	; f8ac <RTMP_Connect1+0x234>
    
    if (r->Link.protocol & RTMP_FEATURE_SSL)
    f688:	e3130004 	tst	r3, #4
#endif
}

int
RTMP_Connect1(RTMP *r, RTMPPacket *cp)
{
    f68c:	e24dd008 	sub	sp, sp, #8
    f690:	e1a05000 	mov	r5, r0
    f694:	e1a07001 	mov	r7, r1
    f698:	e08f6006 	add	r6, pc, r6
    
    if (r->Link.protocol & RTMP_FEATURE_SSL)
    f69c:	1a00004f 	bne	f7e0 <RTMP_Connect1+0x168>
        RTMP_Close(r);
        return FALSE;
        
#endif
    }
    if (r->Link.protocol & RTMP_FEATURE_HTTP)
    f6a0:	e3130001 	tst	r3, #1
    f6a4:	1a00001a 	bne	f714 <RTMP_Connect1+0x9c>
            RTMP_Close(r);
            return 0;
        }
        r->m_msgCounter = 0;
    }
    RTMP_Log(RTMP_LOGDEBUG, "%s, ... connected, handshaking", __FUNCTION__);
    f6a8:	e59f4200 	ldr	r4, [pc, #512]	; f8b0 <RTMP_Connect1+0x238>
    f6ac:	e59f1200 	ldr	r1, [pc, #512]	; f8b4 <RTMP_Connect1+0x23c>
    f6b0:	e08f4004 	add	r4, pc, r4
    f6b4:	e2444eaf 	sub	r4, r4, #2800	; 0xaf0
    f6b8:	e2444004 	sub	r4, r4, #4
    f6bc:	e3a00004 	mov	r0, #4
    f6c0:	e1a02004 	mov	r2, r4
    f6c4:	e08f1001 	add	r1, pc, r1
    f6c8:	eb0018b7 	bl	159ac <RTMP_Log>
    
    if (!HandShake(r, TRUE))
    f6cc:	e1a00005 	mov	r0, r5
    f6d0:	ebfff6d8 	bl	d238 <HandShake.isra.11>
    f6d4:	e2506000 	subs	r6, r0, #0
    f6d8:	0a000036 	beq	f7b8 <RTMP_Connect1+0x140>
    {
        RTMP_Log(RTMP_LOGERROR, "%s, handshake failed.", __FUNCTION__);
        RTMP_Close(r);
        return FALSE;
    }
    RTMP_Log(RTMP_LOGDEBUG, "%s, handshaked", __FUNCTION__);
    f6dc:	e59f11d4 	ldr	r1, [pc, #468]	; f8b8 <RTMP_Connect1+0x240>
    f6e0:	e3a00004 	mov	r0, #4
    f6e4:	e08f1001 	add	r1, pc, r1
    f6e8:	e1a02004 	mov	r2, r4
    f6ec:	eb0018ae 	bl	159ac <RTMP_Log>
    
    if (!SendConnectPacket(r, cp))
    f6f0:	e1a00005 	mov	r0, r5
    f6f4:	e1a01007 	mov	r1, r7
    f6f8:	ebfff0fe 	bl	baf8 <SendConnectPacket>
    f6fc:	e2506000 	subs	r6, r0, #0
    {
        RTMP_Log(RTMP_LOGERROR, "%s, RTMP connect failed.", __FUNCTION__);
        RTMP_Close(r);
        return FALSE;
    }
    return TRUE;
    f700:	13a06001 	movne	r6, #1
        RTMP_Close(r);
        return FALSE;
    }
    RTMP_Log(RTMP_LOGDEBUG, "%s, handshaked", __FUNCTION__);
    
    if (!SendConnectPacket(r, cp))
    f704:	0a000021 	beq	f790 <RTMP_Connect1+0x118>
        RTMP_Log(RTMP_LOGERROR, "%s, RTMP connect failed.", __FUNCTION__);
        RTMP_Close(r);
        return FALSE;
    }
    return TRUE;
}
    f708:	e1a00006 	mov	r0, r6
    f70c:	e28dd008 	add	sp, sp, #8
    f710:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    if (r->Link.protocol & RTMP_FEATURE_HTTP)
    {
        r->m_msgCounter = 1;
        r->m_clientID.av_val = NULL;
        r->m_clientID.av_len = 0;
        HTTP_Post(r, RTMPT_OPEN, "", 1);
    f714:	e59f21a0 	ldr	r2, [pc, #416]	; f8bc <RTMP_Connect1+0x244>
        
#endif
    }
    if (r->Link.protocol & RTMP_FEATURE_HTTP)
    {
        r->m_msgCounter = 1;
    f718:	e3a04001 	mov	r4, #1
        r->m_clientID.av_val = NULL;
    f71c:	e3a06000 	mov	r6, #0
        r->m_clientID.av_len = 0;
        HTTP_Post(r, RTMPT_OPEN, "", 1);
    f720:	e1a03004 	mov	r3, r4
    f724:	e1a01006 	mov	r1, r6
    f728:	e08f2002 	add	r2, pc, r2
        
#endif
    }
    if (r->Link.protocol & RTMP_FEATURE_HTTP)
    {
        r->m_msgCounter = 1;
    f72c:	e5854078 	str	r4, [r5, #120]	; 0x78
        r->m_clientID.av_val = NULL;
    f730:	e5856088 	str	r6, [r5, #136]	; 0x88
        r->m_clientID.av_len = 0;
    f734:	e585608c 	str	r6, [r5, #140]	; 0x8c
        HTTP_Post(r, RTMPT_OPEN, "", 1);
    f738:	e1a00005 	mov	r0, r5
    f73c:	ebffea42 	bl	a04c <HTTP_Post>
        if (HTTP_read(r, 1) != 0)
    f740:	e1a00005 	mov	r0, r5
    f744:	e1a01004 	mov	r1, r4
    f748:	ebffe9bb 	bl	9e3c <HTTP_read>
    f74c:	e3500000 	cmp	r0, #0
            r->m_msgCounter = 0;
            RTMP_Log(RTMP_LOGDEBUG, "%s, Could not connect for handshake", __FUNCTION__);
            RTMP_Close(r);
            return 0;
        }
        r->m_msgCounter = 0;
    f750:	05850078 	streq	r0, [r5, #120]	; 0x78
    {
        r->m_msgCounter = 1;
        r->m_clientID.av_val = NULL;
        r->m_clientID.av_len = 0;
        HTTP_Post(r, RTMPT_OPEN, "", 1);
        if (HTTP_read(r, 1) != 0)
    f754:	0affffd3 	beq	f6a8 <RTMP_Connect1+0x30>
        {
            r->m_msgCounter = 0;
            RTMP_Log(RTMP_LOGDEBUG, "%s, Could not connect for handshake", __FUNCTION__);
    f758:	e59f2160 	ldr	r2, [pc, #352]	; f8c0 <RTMP_Connect1+0x248>
    f75c:	e59f1160 	ldr	r1, [pc, #352]	; f8c4 <RTMP_Connect1+0x24c>
    f760:	e08f2002 	add	r2, pc, r2
    f764:	e2422eaf 	sub	r2, r2, #2800	; 0xaf0
    f768:	e2422004 	sub	r2, r2, #4
    f76c:	e08f1001 	add	r1, pc, r1
        r->m_clientID.av_val = NULL;
        r->m_clientID.av_len = 0;
        HTTP_Post(r, RTMPT_OPEN, "", 1);
        if (HTTP_read(r, 1) != 0)
        {
            r->m_msgCounter = 0;
    f770:	e5856078 	str	r6, [r5, #120]	; 0x78
            RTMP_Log(RTMP_LOGDEBUG, "%s, Could not connect for handshake", __FUNCTION__);
    f774:	e3a00004 	mov	r0, #4
    f778:	eb00188b 	bl	159ac <RTMP_Log>
            RTMP_Close(r);
    f77c:	e1a00005 	mov	r0, r5
    f780:	ebffee75 	bl	b15c <RTMP_Close>
        RTMP_Log(RTMP_LOGERROR, "%s, RTMP connect failed.", __FUNCTION__);
        RTMP_Close(r);
        return FALSE;
    }
    return TRUE;
}
    f784:	e1a00006 	mov	r0, r6
    f788:	e28dd008 	add	sp, sp, #8
    f78c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    }
    RTMP_Log(RTMP_LOGDEBUG, "%s, handshaked", __FUNCTION__);
    
    if (!SendConnectPacket(r, cp))
    {
        RTMP_Log(RTMP_LOGERROR, "%s, RTMP connect failed.", __FUNCTION__);
    f790:	e59f1130 	ldr	r1, [pc, #304]	; f8c8 <RTMP_Connect1+0x250>
    f794:	e1a02004 	mov	r2, r4
    f798:	e08f1001 	add	r1, pc, r1
    f79c:	e3a00001 	mov	r0, #1
    f7a0:	eb001881 	bl	159ac <RTMP_Log>
        RTMP_Close(r);
    f7a4:	e1a00005 	mov	r0, r5
    f7a8:	ebffee6b 	bl	b15c <RTMP_Close>
        return FALSE;
    }
    return TRUE;
}
    f7ac:	e1a00006 	mov	r0, r6
    f7b0:	e28dd008 	add	sp, sp, #8
    f7b4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    }
    RTMP_Log(RTMP_LOGDEBUG, "%s, ... connected, handshaking", __FUNCTION__);
    
    if (!HandShake(r, TRUE))
    {
        RTMP_Log(RTMP_LOGERROR, "%s, handshake failed.", __FUNCTION__);
    f7b8:	e59f110c 	ldr	r1, [pc, #268]	; f8cc <RTMP_Connect1+0x254>
    f7bc:	e1a02004 	mov	r2, r4
    f7c0:	e08f1001 	add	r1, pc, r1
    f7c4:	e3a00001 	mov	r0, #1
    f7c8:	eb001877 	bl	159ac <RTMP_Log>
        RTMP_Close(r);
    f7cc:	e1a00005 	mov	r0, r5
    f7d0:	ebffee61 	bl	b15c <RTMP_Close>
        RTMP_Log(RTMP_LOGERROR, "%s, RTMP connect failed.", __FUNCTION__);
        RTMP_Close(r);
        return FALSE;
    }
    return TRUE;
}
    f7d4:	e1a00006 	mov	r0, r6
    f7d8:	e28dd008 	add	sp, sp, #8
    f7dc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
{
    
    if (r->Link.protocol & RTMP_FEATURE_SSL)
    {
#if defined(CRYPTO) && !defined(NO_SSL)
        TLS_client(RTMP_TLS_ctx, r->m_sb.sb_ssl);
    f7e0:	e3a00e17 	mov	r0, #368	; 0x170
    f7e4:	ebffd60c 	bl	501c <malloc@plt>
    f7e8:	e58400f0 	str	r0, [r4, #240]	; 0xf0
    f7ec:	ebffd6ca 	bl	531c <ssl_init@plt>
    f7f0:	e59400f0 	ldr	r0, [r4, #240]	; 0xf0
    f7f4:	e3a01000 	mov	r1, #0
    f7f8:	ebffd6ca 	bl	5328 <ssl_set_endpoint@plt>
    f7fc:	e59400f0 	ldr	r0, [r4, #240]	; 0xf0
    f800:	e3a01000 	mov	r1, #0
    f804:	ebffd6ca 	bl	5334 <ssl_set_authmode@plt>
    f808:	e59f30c0 	ldr	r3, [pc, #192]	; f8d0 <RTMP_Connect1+0x258>
    f80c:	e59f20c0 	ldr	r2, [pc, #192]	; f8d4 <RTMP_Connect1+0x25c>
    f810:	e7968003 	ldr	r8, [r6, r3]
    f814:	e7961002 	ldr	r1, [r6, r2]
    f818:	e59400f0 	ldr	r0, [r4, #240]	; 0xf0
    f81c:	e5982000 	ldr	r2, [r8]
    f820:	ebffd6c6 	bl	5340 <ssl_set_rng@plt>
    f824:	e59f30ac 	ldr	r3, [pc, #172]	; f8d8 <RTMP_Connect1+0x260>
    f828:	e59400f0 	ldr	r0, [r4, #240]	; 0xf0
    f82c:	e7961003 	ldr	r1, [r6, r3]
    f830:	ebffd6c5 	bl	534c <ssl_set_ciphersuites@plt>
    f834:	e5981000 	ldr	r1, [r8]
    f838:	e59400f0 	ldr	r0, [r4, #240]	; 0xf0
    f83c:	e2811a09 	add	r1, r1, #36864	; 0x9000
    f840:	e2811010 	add	r1, r1, #16
    f844:	ebffd6c3 	bl	5358 <ssl_set_session@plt>
        TLS_setfd(r->m_sb.sb_ssl, r->m_sb.sb_socket);
    f848:	e59f208c 	ldr	r2, [pc, #140]	; f8dc <RTMP_Connect1+0x264>
    f84c:	e59f308c 	ldr	r3, [pc, #140]	; f8e0 <RTMP_Connect1+0x268>
    f850:	e7961002 	ldr	r1, [r6, r2]
    f854:	e28520e0 	add	r2, r5, #224	; 0xe0
    f858:	e7963003 	ldr	r3, [r6, r3]
    f85c:	e59400f0 	ldr	r0, [r4, #240]	; 0xf0
    f860:	e58d2000 	str	r2, [sp]
    f864:	ebffd6c4 	bl	537c <ssl_set_bio@plt>
        if (TLS_connect(r->m_sb.sb_ssl) < 0)
    f868:	e59400f0 	ldr	r0, [r4, #240]	; 0xf0
    f86c:	ebffd6c5 	bl	5388 <ssl_handshake@plt>
    f870:	e3500000 	cmp	r0, #0
    f874:	a5943188 	ldrge	r3, [r4, #392]	; 0x188
    f878:	aaffff88 	bge	f6a0 <RTMP_Connect1+0x28>
        {
            RTMP_Log(RTMP_LOGERROR, "%s, TLS_Connect failed", __FUNCTION__);
    f87c:	e59f2060 	ldr	r2, [pc, #96]	; f8e4 <RTMP_Connect1+0x26c>
    f880:	e59f1060 	ldr	r1, [pc, #96]	; f8e8 <RTMP_Connect1+0x270>
    f884:	e08f2002 	add	r2, pc, r2
    f888:	e2422eaf 	sub	r2, r2, #2800	; 0xaf0
    f88c:	e3a00001 	mov	r0, #1
    f890:	e2422004 	sub	r2, r2, #4
    f894:	e08f1001 	add	r1, pc, r1
    f898:	eb001843 	bl	159ac <RTMP_Log>
            RTMP_Close(r);
    f89c:	e1a00005 	mov	r0, r5
    f8a0:	ebffee2d 	bl	b15c <RTMP_Close>
            return FALSE;
    f8a4:	e3a06000 	mov	r6, #0
    f8a8:	eaffff96 	b	f708 <RTMP_Connect1+0x90>
    f8ac:	00014720 	.word	0x00014720
    f8b0:	0000f130 	.word	0x0000f130
    f8b4:	000103e4 	.word	0x000103e4
    f8b8:	000103fc 	.word	0x000103fc
    f8bc:	0000e709 	.word	0x0000e709
    f8c0:	0000f080 	.word	0x0000f080
    f8c4:	00010318 	.word	0x00010318
    f8c8:	00010358 	.word	0x00010358
    f8cc:	00010308 	.word	0x00010308
    f8d0:	ffffffb4 	.word	0xffffffb4
    f8d4:	ffffffb0 	.word	0xffffffb0
    f8d8:	ffffffd8 	.word	0xffffffd8
    f8dc:	ffffffdc 	.word	0xffffffdc
    f8e0:	ffffffe0 	.word	0xffffffe0
    f8e4:	0000ef5c 	.word	0x0000ef5c
    f8e8:	0000f244 	.word	0x0000f244

0000f8ec <RTMP_Connect>:
    return TRUE;
}

int
RTMP_Connect(RTMP *r, RTMPPacket *cp)
{
    f8ec:	e92d4038 	push	{r3, r4, r5, lr}
    f8f0:	e1a05001 	mov	r5, r1
    f8f4:	e1a04000 	mov	r4, r0
    //LOGE("begin to connect0 \n");
    if (!RTMP_Connect0(r))
    f8f8:	ebfffd99 	bl	ef64 <RTMP_Connect0>
    f8fc:	e3500000 	cmp	r0, #0
    f900:	08bd8038 	popeq	{r3, r4, r5, pc}
        return FALSE;
    
    r->m_bSendCounter = TRUE;
    f904:	e3a03001 	mov	r3, #1
    f908:	e5c43037 	strb	r3, [r4, #55]	; 0x37
    
    //LOGE("begin to connect 1\n");
    int ret=RTMP_Connect1(r, cp);
    f90c:	e1a01005 	mov	r1, r5
    f910:	e1a00004 	mov	r0, r4
    f914:	ebffff57 	bl	f678 <RTMP_Connect1>
    printf("tcUrl:%.*s \n",r->Link.tcUrl.av_len,r->Link.tcUrl.av_val);
    f918:	e2844901 	add	r4, r4, #16384	; 0x4000
    f91c:	e5941118 	ldr	r1, [r4, #280]	; 0x118
    f920:	e5942114 	ldr	r2, [r4, #276]	; 0x114
        return FALSE;
    
    r->m_bSendCounter = TRUE;
    
    //LOGE("begin to connect 1\n");
    int ret=RTMP_Connect1(r, cp);
    f924:	e1a05000 	mov	r5, r0
    printf("tcUrl:%.*s \n",r->Link.tcUrl.av_len,r->Link.tcUrl.av_val);
    f928:	e59f000c 	ldr	r0, [pc, #12]	; f93c <RTMP_Connect+0x50>
    f92c:	e08f0000 	add	r0, pc, r0
    f930:	ebffd673 	bl	5304 <printf@plt>
    f934:	e1a00005 	mov	r0, r5
    return ret;
}
    f938:	e8bd8038 	pop	{r3, r4, r5, pc}
    f93c:	000101e0 	.word	0x000101e0

0000f940 <HandleInvoke.part.13>:
static const AVal av_NetStream_Publish_Start = AVC("NetStream.Publish.Start");
static const AVal av_NetConnection_Connect_Rejected = AVC("NetConnection.Connect.Rejected");

/* Returns 0 for OK/Failed/error, 1 for 'Stop or Complete' */
static int
HandleInvoke(RTMP *r, const char *body, unsigned int nBodySize)
    f940:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f944:	e24ddf59 	sub	sp, sp, #356	; 0x164
        RTMP_Log(RTMP_LOGWARNING, "%s, Sanity failed. no string method in invoke packet",
                 __FUNCTION__);
        return 0;
    }
    
    nRes = AMF_Decode(&obj, body, nBodySize, FALSE);
    f948:	e28d4020 	add	r4, sp, #32
static const AVal av_NetStream_Publish_Start = AVC("NetStream.Publish.Start");
static const AVal av_NetConnection_Connect_Rejected = AVC("NetConnection.Connect.Rejected");

/* Returns 0 for OK/Failed/error, 1 for 'Stop or Complete' */
static int
HandleInvoke(RTMP *r, const char *body, unsigned int nBodySize)
    f94c:	e1a05000 	mov	r5, r0
        RTMP_Log(RTMP_LOGWARNING, "%s, Sanity failed. no string method in invoke packet",
                 __FUNCTION__);
        return 0;
    }
    
    nRes = AMF_Decode(&obj, body, nBodySize, FALSE);
    f950:	e3a03000 	mov	r3, #0
    f954:	e1a00004 	mov	r0, r4
    f958:	eb001f6b 	bl	1770c <AMF_Decode>
    if (nRes < 0)
    f95c:	e3500000 	cmp	r0, #0
    f960:	ba000111 	blt	fdac <HandleInvoke.part.13+0x46c>
    {
        RTMP_Log(RTMP_LOGERROR, "%s, error decoding invoke packet", __FUNCTION__);
        return 0;
    }
    
    AMF_Dump(&obj);
    f964:	e1a00004 	mov	r0, r4
    f968:	eb001bdd 	bl	168e4 <AMF_Dump>
    AMFProp_GetString(AMF_GetProp(&obj, NULL, 0), &method);
    f96c:	e3a01000 	mov	r1, #0
    f970:	e1a02001 	mov	r2, r1
    f974:	e1a00004 	mov	r0, r4
    f978:	eb001ba4 	bl	16810 <AMF_GetProp>
    f97c:	e28d1028 	add	r1, sp, #40	; 0x28
    f980:	eb001a44 	bl	16298 <AMFProp_GetString>
    txn = AMFProp_GetNumber(AMF_GetProp(&obj, NULL, 1));
    f984:	e3a02001 	mov	r2, #1
    f988:	e3a01000 	mov	r1, #0
    f98c:	e1a00004 	mov	r0, r4
    f990:	eb001b9e 	bl	16810 <AMF_GetProp>
    f994:	eb001a35 	bl	16270 <AMFProp_GetNumber>
    RTMP_Log(RTMP_LOGINFO, "%s, server invoking <%s> \n", __FUNCTION__, method.av_val);
    f998:	e59f6fe8 	ldr	r6, [pc, #4072]	; 10988 <HandleInvoke.part.13+0x1048>
    f99c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
    f9a0:	e08f6006 	add	r6, pc, r6
    f9a4:	e2466eae 	sub	r6, r6, #2784	; 0xae0
    f9a8:	e2466004 	sub	r6, r6, #4
    f9ac:	e1a02006 	mov	r2, r6
        return 0;
    }
    
    AMF_Dump(&obj);
    AMFProp_GetString(AMF_GetProp(&obj, NULL, 0), &method);
    txn = AMFProp_GetNumber(AMF_GetProp(&obj, NULL, 1));
    f9b0:	e1a09001 	mov	r9, r1
    RTMP_Log(RTMP_LOGINFO, "%s, server invoking <%s> \n", __FUNCTION__, method.av_val);
    f9b4:	e59f1fd0 	ldr	r1, [pc, #4048]	; 1098c <HandleInvoke.part.13+0x104c>
        return 0;
    }
    
    AMF_Dump(&obj);
    AMFProp_GetString(AMF_GetProp(&obj, NULL, 0), &method);
    txn = AMFProp_GetNumber(AMF_GetProp(&obj, NULL, 1));
    f9b8:	e1a08000 	mov	r8, r0
    RTMP_Log(RTMP_LOGINFO, "%s, server invoking <%s> \n", __FUNCTION__, method.av_val);
    f9bc:	e08f1001 	add	r1, pc, r1
    f9c0:	e3a00003 	mov	r0, #3
    f9c4:	eb0017f8 	bl	159ac <RTMP_Log>
    
    if (AVMATCH(&method, &av__result))
    f9c8:	e59d702c 	ldr	r7, [sp, #44]	; 0x2c
    f9cc:	e3570007 	cmp	r7, #7
    f9d0:	0a000034 	beq	faa8 <HandleInvoke.part.13+0x168>
        {
            r->m_bPlaying = TRUE;
        }
        free(methodInvoked.av_val);
    }
    else if (AVMATCH(&method, &av_onBWDone))
    f9d4:	e3570008 	cmp	r7, #8
    f9d8:	0a00005d 	beq	fb54 <HandleInvoke.part.13+0x214>
        {
            //printf("send check bw \n");
            SendCheckBW(r);
        }
    }
    else if (AVMATCH(&method, &av_onFCSubscribe))
    f9dc:	e357000d 	cmp	r7, #13
    f9e0:	0a000055 	beq	fb3c <HandleInvoke.part.13+0x1fc>
    {
        /* SendOnFCSubscribe(); */
    }
    else if (AVMATCH(&method, &av_onFCUnsubscribe))
    f9e4:	e357000f 	cmp	r7, #15
    f9e8:	0a0000fa 	beq	fdd8 <HandleInvoke.part.13+0x498>
    {
        RTMP_Close(r);
        ret = 1;
    }
    else if (AVMATCH(&method, &av_ping))
    f9ec:	e3570004 	cmp	r7, #4
    f9f0:	0a000103 	beq	fe04 <HandleInvoke.part.13+0x4c4>
    {
        SendPong(r, txn);
    }
    else if (AVMATCH(&method, &av__onbwcheck))
    f9f4:	e357000a 	cmp	r7, #10
    f9f8:	0a00012c 	beq	feb0 <HandleInvoke.part.13+0x570>
    {
        
        SendCheckBWResult(r, txn);
    }
    else if (AVMATCH(&method, &av__onbwdone))
    f9fc:	e3570009 	cmp	r7, #9
    fa00:	0a00015f 	beq	ff84 <HandleInvoke.part.13+0x644>
            {
                AV_erase(r->m_methodCalls, &r->m_numCalls, i, TRUE);
                break;
            }
    }
    else if (AVMATCH(&method, &av__error))
    fa04:	e3570006 	cmp	r7, #6
    fa08:	0a0000a3 	beq	fc9c <HandleInvoke.part.13+0x35c>
        free(methodInvoked.av_val);
#else
        RTMP_Log(RTMP_LOGERROR, "rtmp server sent error");
#endif
    }
    else if (AVMATCH(&method, &av_close))
    fa0c:	e3570005 	cmp	r7, #5
    fa10:	0a0000d7 	beq	fd74 <HandleInvoke.part.13+0x434>
                RTMP_SendPause(r, FALSE, r->m_pauseStamp);
                r->m_pausing = 3;
            }
        }
    }
    else if (AVMATCH(&method, &av_playlist_ready))
    fa14:	e357000e 	cmp	r7, #14
    fa18:	1a000047 	bne	fb3c <HandleInvoke.part.13+0x1fc>
    fa1c:	e59f1f6c 	ldr	r1, [pc, #3948]	; 10990 <HandleInvoke.part.13+0x1050>
    fa20:	e1a02007 	mov	r2, r7
    fa24:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
    fa28:	e08f1001 	add	r1, pc, r1
    fa2c:	ebffd5e9 	bl	51d8 <memcmp@plt>
    fa30:	e3500000 	cmp	r0, #0
    fa34:	1a000040 	bne	fb3c <HandleInvoke.part.13+0x1fc>
    {
        int i;
        for (i = 0; i < r->m_numCalls; i++)
    fa38:	e595b03c 	ldr	fp, [r5, #60]	; 0x3c
    fa3c:	e35b0000 	cmp	fp, #0
    fa40:	da000408 	ble	10a68 <HandleInvoke.part.13+0x1128>
    fa44:	e595a040 	ldr	sl, [r5, #64]	; 0x40
        {
            if (AVMATCH(&r->m_methodCalls[i].name, &av_set_playlist))
    fa48:	e59f9f44 	ldr	r9, [pc, #3908]	; 10994 <HandleInvoke.part.13+0x1054>
        }
    }
    else if (AVMATCH(&method, &av_playlist_ready))
    {
        int i;
        for (i = 0; i < r->m_numCalls; i++)
    fa4c:	e1a07000 	mov	r7, r0
        {
            if (AVMATCH(&r->m_methodCalls[i].name, &av_set_playlist))
    fa50:	e08f9009 	add	r9, pc, r9
    fa54:	e1a0600a 	mov	r6, sl
    fa58:	ea000003 	b	fa6c <HandleInvoke.part.13+0x12c>
        }
    }
    else if (AVMATCH(&method, &av_playlist_ready))
    {
        int i;
        for (i = 0; i < r->m_numCalls; i++)
    fa5c:	e2877001 	add	r7, r7, #1
    fa60:	e157000b 	cmp	r7, fp
    fa64:	e286600c 	add	r6, r6, #12
    fa68:	0a000033 	beq	fb3c <HandleInvoke.part.13+0x1fc>
        {
            if (AVMATCH(&r->m_methodCalls[i].name, &av_set_playlist))
    fa6c:	e5962004 	ldr	r2, [r6, #4]
    fa70:	e352000c 	cmp	r2, #12
    fa74:	1afffff8 	bne	fa5c <HandleInvoke.part.13+0x11c>
    fa78:	e5960000 	ldr	r0, [r6]
    fa7c:	e1a01009 	mov	r1, r9
    fa80:	ebffd5d4 	bl	51d8 <memcmp@plt>
    fa84:	e3500000 	cmp	r0, #0
    fa88:	1afffff3 	bne	fa5c <HandleInvoke.part.13+0x11c>
    fa8c:	e1a08000 	mov	r8, r0
            {
                AV_erase(r->m_methodCalls, &r->m_numCalls, i, TRUE);
    fa90:	e285103c 	add	r1, r5, #60	; 0x3c
    fa94:	e1a0000a 	mov	r0, sl
    fa98:	e1a02007 	mov	r2, r7
    fa9c:	e3a03001 	mov	r3, #1
    faa0:	ebffd768 	bl	5848 <AV_erase>
    faa4:	ea000025 	b	fb40 <HandleInvoke.part.13+0x200>
    AMF_Dump(&obj);
    AMFProp_GetString(AMF_GetProp(&obj, NULL, 0), &method);
    txn = AMFProp_GetNumber(AMF_GetProp(&obj, NULL, 1));
    RTMP_Log(RTMP_LOGINFO, "%s, server invoking <%s> \n", __FUNCTION__, method.av_val);
    
    if (AVMATCH(&method, &av__result))
    faa8:	e59f1ee8 	ldr	r1, [pc, #3816]	; 10998 <HandleInvoke.part.13+0x1058>
    faac:	e1a02007 	mov	r2, r7
    fab0:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
    fab4:	e08f1001 	add	r1, pc, r1
    fab8:	ebffd5c6 	bl	51d8 <memcmp@plt>
    fabc:	e2507000 	subs	r7, r0, #0
    fac0:	1a00001d 	bne	fb3c <HandleInvoke.part.13+0x1fc>
    {
        AVal methodInvoked = {0};
        int i;
        
        for (i=0; i<r->m_numCalls; i++) {
    fac4:	e595b03c 	ldr	fp, [r5, #60]	; 0x3c
    fac8:	e35b0000 	cmp	fp, #0
    facc:	da000011 	ble	fb18 <HandleInvoke.part.13+0x1d8>
            if (r->m_methodCalls[i].num == (int)txn) {
    fad0:	e1a00008 	mov	r0, r8
    fad4:	e1a01009 	mov	r1, r9
    fad8:	eb003259 	bl	1c444 <__aeabi_d2iz>
    fadc:	e595a040 	ldr	sl, [r5, #64]	; 0x40
    fae0:	e59a3008 	ldr	r3, [sl, #8]
    fae4:	e1530000 	cmp	r3, r0
    fae8:	11a02007 	movne	r2, r7
    faec:	128a600c 	addne	r6, sl, #12
    faf0:	1a000003 	bne	fb04 <HandleInvoke.part.13+0x1c4>
    faf4:	ea000167 	b	10098 <HandleInvoke.part.13+0x758>
    faf8:	e5163004 	ldr	r3, [r6, #-4]
    fafc:	e1530000 	cmp	r3, r0
    fb00:	0a000166 	beq	100a0 <HandleInvoke.part.13+0x760>
    if (AVMATCH(&method, &av__result))
    {
        AVal methodInvoked = {0};
        int i;
        
        for (i=0; i<r->m_numCalls; i++) {
    fb04:	e2822001 	add	r2, r2, #1
    fb08:	e152000b 	cmp	r2, fp
            if (r->m_methodCalls[i].num == (int)txn) {
    fb0c:	e1a0c006 	mov	ip, r6
    fb10:	e286600c 	add	r6, r6, #12
    if (AVMATCH(&method, &av__result))
    {
        AVal methodInvoked = {0};
        int i;
        
        for (i=0; i<r->m_numCalls; i++) {
    fb14:	1afffff7 	bne	faf8 <HandleInvoke.part.13+0x1b8>
                AV_erase(r->m_methodCalls, &r->m_numCalls, i, FALSE);
                break;
            }
        }
        if (!methodInvoked.av_val) {
            RTMP_Log(RTMP_LOGDEBUG, "%s, received result id %f without matching request",
    fb18:	e59f2e7c 	ldr	r2, [pc, #3708]	; 1099c <HandleInvoke.part.13+0x105c>
    fb1c:	e59f1e7c 	ldr	r1, [pc, #3708]	; 109a0 <HandleInvoke.part.13+0x1060>
    fb20:	e08f2002 	add	r2, pc, r2
    fb24:	e2422eae 	sub	r2, r2, #2784	; 0xae0
    fb28:	e1cd80f0 	strd	r8, [sp]
    fb2c:	e2422004 	sub	r2, r2, #4
    fb30:	e3a00004 	mov	r0, #4
    fb34:	e08f1001 	add	r1, pc, r1
    fb38:	eb00179b 	bl	159ac <RTMP_Log>
HandleInvoke(RTMP *r, const char *body, unsigned int nBodySize)
{
    AMFObject obj;
    AVal method;
    double txn;
    int ret = 0, nRes;
    fb3c:	e3a08000 	mov	r8, #0
    else
    {
        
    }
leave:
    AMF_Reset(&obj);
    fb40:	e1a00004 	mov	r0, r4
    fb44:	eb001c20 	bl	16bcc <AMF_Reset>
    return ret;
    fb48:	e1a00008 	mov	r0, r8
}
    fb4c:	e28ddf59 	add	sp, sp, #356	; 0x164
    fb50:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        {
            r->m_bPlaying = TRUE;
        }
        free(methodInvoked.av_val);
    }
    else if (AVMATCH(&method, &av_onBWDone))
    fb54:	e59d9028 	ldr	r9, [sp, #40]	; 0x28
    fb58:	e59f1e44 	ldr	r1, [pc, #3652]	; 109a4 <HandleInvoke.part.13+0x1064>
    fb5c:	e1a00009 	mov	r0, r9
    fb60:	e08f1001 	add	r1, pc, r1
    fb64:	e1a02007 	mov	r2, r7
    fb68:	ebffd59a 	bl	51d8 <memcmp@plt>
    fb6c:	e3500000 	cmp	r0, #0
    fb70:	0a000126 	beq	10010 <HandleInvoke.part.13+0x6d0>
    else if (AVMATCH(&method, &av_close))
    {
        RTMP_Log(RTMP_LOGINFO, "rtmp server requested close");
        RTMP_Close(r);
    }
    else if (AVMATCH(&method, &av_onStatus))
    fb74:	e59f1e2c 	ldr	r1, [pc, #3628]	; 109a8 <HandleInvoke.part.13+0x1068>
    fb78:	e1a00009 	mov	r0, r9
    fb7c:	e08f1001 	add	r1, pc, r1
    fb80:	e1a02007 	mov	r2, r7
    fb84:	ebffd593 	bl	51d8 <memcmp@plt>
    fb88:	e2501000 	subs	r1, r0, #0
    fb8c:	1affffea 	bne	fb3c <HandleInvoke.part.13+0x1fc>
    {
        AMFObject obj2;
        AVal code, level;
        AMFProp_GetObject(AMF_GetProp(&obj, NULL, 3), &obj2);
        AMFProp_GetString(AMF_GetProp(&obj2, &av_code, -1), &code);
    fb90:	e59f8e14 	ldr	r8, [pc, #3604]	; 109ac <HandleInvoke.part.13+0x106c>
    }
    else if (AVMATCH(&method, &av_onStatus))
    {
        AMFObject obj2;
        AVal code, level;
        AMFProp_GetObject(AMF_GetProp(&obj, NULL, 3), &obj2);
    fb94:	e3a02003 	mov	r2, #3
    fb98:	e28d7038 	add	r7, sp, #56	; 0x38
    fb9c:	e1a00004 	mov	r0, r4
    fba0:	eb001b1a 	bl	16810 <AMF_GetProp>
        AMFProp_GetString(AMF_GetProp(&obj2, &av_code, -1), &code);
    fba4:	e08f8008 	add	r8, pc, r8
    }
    else if (AVMATCH(&method, &av_onStatus))
    {
        AMFObject obj2;
        AVal code, level;
        AMFProp_GetObject(AMF_GetProp(&obj, NULL, 3), &obj2);
    fba8:	e1a01007 	mov	r1, r7
    fbac:	eb0019be 	bl	162ac <AMFProp_GetObject>
        AMFProp_GetString(AMF_GetProp(&obj2, &av_code, -1), &code);
    fbb0:	e3e02000 	mvn	r2, #0
    fbb4:	e2881e36 	add	r1, r8, #864	; 0x360
    fbb8:	e1a00007 	mov	r0, r7
    fbbc:	eb001b13 	bl	16810 <AMF_GetProp>
    fbc0:	e28d1040 	add	r1, sp, #64	; 0x40
    fbc4:	eb0019b3 	bl	16298 <AMFProp_GetString>
        AMFProp_GetString(AMF_GetProp(&obj2, &av_level, -1), &level);
    fbc8:	e3e02000 	mvn	r2, #0
    fbcc:	e2881fda 	add	r1, r8, #872	; 0x368
    fbd0:	e1a00007 	mov	r0, r7
    fbd4:	eb001b0d 	bl	16810 <AMF_GetProp>
    fbd8:	e28d1060 	add	r1, sp, #96	; 0x60
    fbdc:	eb0019ad 	bl	16298 <AMFProp_GetString>
        
        RTMP_Log(RTMP_LOGINFO, "%s, onStatus: %s", __FUNCTION__, code.av_val);
    fbe0:	e59f1dc8 	ldr	r1, [pc, #3528]	; 109b0 <HandleInvoke.part.13+0x1070>
    fbe4:	e1a02006 	mov	r2, r6
    fbe8:	e3a00003 	mov	r0, #3
    fbec:	e08f1001 	add	r1, pc, r1
    fbf0:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
    fbf4:	eb00176c 	bl	159ac <RTMP_Log>
        if (AVMATCH(&code, &av_NetStream_Failed)
    fbf8:	e59d6044 	ldr	r6, [sp, #68]	; 0x44
    fbfc:	e3560010 	cmp	r6, #16
    fc00:	0a0001f6 	beq	103e0 <HandleInvoke.part.13+0xaa0>
            || AVMATCH(&code, &av_NetStream_Publish_BadName)
    fc04:	e3560019 	cmp	r6, #25
    fc08:	0a000206 	beq	10428 <HandleInvoke.part.13+0xae8>
            || AVMATCH(&code, &av_NetStream_Play_Failed)
    fc0c:	e3560015 	cmp	r6, #21
    fc10:	0a00020c 	beq	10448 <HandleInvoke.part.13+0xb08>
            || AVMATCH(&code, &av_NetStream_Play_StreamNotFound)
    fc14:	e356001d 	cmp	r6, #29
    fc18:	0a0002ee 	beq	107d8 <HandleInvoke.part.13+0xe98>
            || AVMATCH(&code, &av_NetConnection_Connect_InvalidApp))
    fc1c:	e3560020 	cmp	r6, #32
    fc20:	0a0002f4 	beq	107f8 <HandleInvoke.part.13+0xeb8>
            r->m_stream_id = -1;
            RTMP_Close(r);
            RTMP_Log(RTMP_LOGDEBUG, "Closing connection: %s", code.av_val);
        }
        
        else if (AVMATCH(&code, &av_NetStream_Play_Start)
    fc24:	e3560014 	cmp	r6, #20
    fc28:	0a0002fa 	beq	10818 <HandleInvoke.part.13+0xed8>
                 || AVMATCH(&code, &av_NetStream_Play_PublishNotify))
    fc2c:	e356001c 	cmp	r6, #28
    fc30:	0a000317 	beq	10894 <HandleInvoke.part.13+0xf54>
                    break;
                }
            }
        }
        
        else if (AVMATCH(&code, &av_NetStream_Publish_Start))
    fc34:	e3560017 	cmp	r6, #23
    fc38:	0a00031d 	beq	108b4 <HandleInvoke.part.13+0xf74>
            }
        }
        
        /* Return 1 if this is a Play.Complete or Play.Stop */
        else if (AVMATCH(&code, &av_NetStream_Play_Complete)
                 || AVMATCH(&code, &av_NetStream_Play_Stop)
    fc3c:	e3560013 	cmp	r6, #19
    fc40:	0a00038a 	beq	10a70 <HandleInvoke.part.13+0x1130>
                 || AVMATCH(&code, &av_NetStream_Play_UnpublishNotify))
    fc44:	e356001e 	cmp	r6, #30
    fc48:	0a000393 	beq	10a9c <HandleInvoke.part.13+0x115c>
        else if (AVMATCH(&code, &av_NetStream_Seek_Notify))
        {
            r->m_read.flags &= ~RTMP_READ_SEEKING;
        }
        
        else if (AVMATCH(&code, &av_NetStream_Pause_Notify))
    fc4c:	e3560016 	cmp	r6, #22
    fc50:	1affffb9 	bne	fb3c <HandleInvoke.part.13+0x1fc>
    fc54:	e59f1d58 	ldr	r1, [pc, #3416]	; 109b4 <HandleInvoke.part.13+0x1074>
    fc58:	e1a02006 	mov	r2, r6
    fc5c:	e59d0040 	ldr	r0, [sp, #64]	; 0x40
    fc60:	e08f1001 	add	r1, pc, r1
    fc64:	ebffd55b 	bl	51d8 <memcmp@plt>
    fc68:	e2508000 	subs	r8, r0, #0
    fc6c:	1affffb2 	bne	fb3c <HandleInvoke.part.13+0x1fc>
        {
            if (r->m_pausing == 1 || r->m_pausing == 2)
    fc70:	e5953028 	ldr	r3, [r5, #40]	; 0x28
    fc74:	e2433001 	sub	r3, r3, #1
    fc78:	e3530001 	cmp	r3, #1
    fc7c:	8affffae 	bhi	fb3c <HandleInvoke.part.13+0x1fc>
            {
                RTMP_SendPause(r, FALSE, r->m_pauseStamp);
    fc80:	e1a00005 	mov	r0, r5
    fc84:	e1a01008 	mov	r1, r8
    fc88:	e5952024 	ldr	r2, [r5, #36]	; 0x24
    fc8c:	ebfff32f 	bl	c950 <RTMP_SendPause>
                r->m_pausing = 3;
    fc90:	e3a03003 	mov	r3, #3
    fc94:	e5853028 	str	r3, [r5, #40]	; 0x28
    fc98:	eaffffa8 	b	fb40 <HandleInvoke.part.13+0x200>
            {
                AV_erase(r->m_methodCalls, &r->m_numCalls, i, TRUE);
                break;
            }
    }
    else if (AVMATCH(&method, &av__error))
    fc9c:	e59f1d14 	ldr	r1, [pc, #3348]	; 109b8 <HandleInvoke.part.13+0x1078>
    fca0:	e1a02007 	mov	r2, r7
    fca4:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
    fca8:	e08f1001 	add	r1, pc, r1
    fcac:	ebffd549 	bl	51d8 <memcmp@plt>
    fcb0:	e3500000 	cmp	r0, #0
    fcb4:	1affffa0 	bne	fb3c <HandleInvoke.part.13+0x1fc>
    {
#ifdef CRYPTO
        AVal methodInvoked = {0};
        int i;
        
        if (r->Link.protocol & RTMP_FEATURE_WRITE)
    fcb8:	e2853901 	add	r3, r5, #16384	; 0x4000
    fcbc:	e5933188 	ldr	r3, [r3, #392]	; 0x188
    fcc0:	e2137010 	ands	r7, r3, #16
    fcc4:	0a00017e 	beq	102c4 <HandleInvoke.part.13+0x984>
        {
            for (i=0; i<r->m_numCalls; i++)
    fcc8:	e595a03c 	ldr	sl, [r5, #60]	; 0x3c
    fccc:	e35a0000 	cmp	sl, #0
    fcd0:	da00001c 	ble	fd48 <HandleInvoke.part.13+0x408>
            {
                if (r->m_methodCalls[i].num == txn)
    fcd4:	e5953040 	ldr	r3, [r5, #64]	; 0x40
    fcd8:	e58d3008 	str	r3, [sp, #8]
    fcdc:	e5930008 	ldr	r0, [r3, #8]
    fce0:	eb003039 	bl	1bdcc <__aeabi_i2d>
    fce4:	e1a02000 	mov	r2, r0
    fce8:	e1a03001 	mov	r3, r1
    fcec:	e1a00008 	mov	r0, r8
    fcf0:	e1a01009 	mov	r1, r9
    fcf4:	eb0031b9 	bl	1c3e0 <__aeabi_dcmpeq>
    fcf8:	e3500000 	cmp	r0, #0
    fcfc:	1a000155 	bne	10258 <HandleInvoke.part.13+0x918>
    fd00:	e59d3008 	ldr	r3, [sp, #8]
    fd04:	e1a06000 	mov	r6, r0
    fd08:	e283700c 	add	r7, r3, #12
    fd0c:	ea000009 	b	fd38 <HandleInvoke.part.13+0x3f8>
    fd10:	e59b0008 	ldr	r0, [fp, #8]
    fd14:	eb00302c 	bl	1bdcc <__aeabi_i2d>
    fd18:	e287700c 	add	r7, r7, #12
    fd1c:	e1a02000 	mov	r2, r0
    fd20:	e1a03001 	mov	r3, r1
    fd24:	e1a00008 	mov	r0, r8
    fd28:	e1a01009 	mov	r1, r9
    fd2c:	eb0031ab 	bl	1c3e0 <__aeabi_dcmpeq>
    fd30:	e3500000 	cmp	r0, #0
    fd34:	1a000149 	bne	10260 <HandleInvoke.part.13+0x920>
        AVal methodInvoked = {0};
        int i;
        
        if (r->Link.protocol & RTMP_FEATURE_WRITE)
        {
            for (i=0; i<r->m_numCalls; i++)
    fd38:	e2866001 	add	r6, r6, #1
    fd3c:	e156000a 	cmp	r6, sl
            {
                if (r->m_methodCalls[i].num == txn)
    fd40:	e1a0b007 	mov	fp, r7
        AVal methodInvoked = {0};
        int i;
        
        if (r->Link.protocol & RTMP_FEATURE_WRITE)
        {
            for (i=0; i<r->m_numCalls; i++)
    fd44:	1afffff1 	bne	fd10 <HandleInvoke.part.13+0x3d0>
                    break;
                }
            }
            if (!methodInvoked.av_val)
            {
                RTMP_Log(RTMP_LOGDEBUG, "%s, received result id %f without matching request",
    fd48:	e59f2c6c 	ldr	r2, [pc, #3180]	; 109bc <HandleInvoke.part.13+0x107c>
    fd4c:	e59f1c6c 	ldr	r1, [pc, #3180]	; 109c0 <HandleInvoke.part.13+0x1080>
    fd50:	e08f2002 	add	r2, pc, r2
    fd54:	e2422eae 	sub	r2, r2, #2784	; 0xae0
    fd58:	e1cd80f0 	strd	r8, [sp]
    fd5c:	e2422004 	sub	r2, r2, #4
    fd60:	e3a00004 	mov	r0, #4
    fd64:	e08f1001 	add	r1, pc, r1
    fd68:	eb00170f 	bl	159ac <RTMP_Log>
HandleInvoke(RTMP *r, const char *body, unsigned int nBodySize)
{
    AMFObject obj;
    AVal method;
    double txn;
    int ret = 0, nRes;
    fd6c:	e3a08000 	mov	r8, #0
    fd70:	eaffff72 	b	fb40 <HandleInvoke.part.13+0x200>
        free(methodInvoked.av_val);
#else
        RTMP_Log(RTMP_LOGERROR, "rtmp server sent error");
#endif
    }
    else if (AVMATCH(&method, &av_close))
    fd74:	e59f1c48 	ldr	r1, [pc, #3144]	; 109c4 <HandleInvoke.part.13+0x1084>
    fd78:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
    fd7c:	e08f1001 	add	r1, pc, r1
    fd80:	e3a02005 	mov	r2, #5
    fd84:	ebffd513 	bl	51d8 <memcmp@plt>
    fd88:	e2508000 	subs	r8, r0, #0
    fd8c:	1affff6a 	bne	fb3c <HandleInvoke.part.13+0x1fc>
    {
        RTMP_Log(RTMP_LOGINFO, "rtmp server requested close");
    fd90:	e59f1c30 	ldr	r1, [pc, #3120]	; 109c8 <HandleInvoke.part.13+0x1088>
    fd94:	e3a00003 	mov	r0, #3
    fd98:	e08f1001 	add	r1, pc, r1
    fd9c:	eb001702 	bl	159ac <RTMP_Log>
        RTMP_Close(r);
    fda0:	e1a00005 	mov	r0, r5
    fda4:	ebffecec 	bl	b15c <RTMP_Close>
    fda8:	eaffff64 	b	fb40 <HandleInvoke.part.13+0x200>
    }
    
    nRes = AMF_Decode(&obj, body, nBodySize, FALSE);
    if (nRes < 0)
    {
        RTMP_Log(RTMP_LOGERROR, "%s, error decoding invoke packet", __FUNCTION__);
    fdac:	e59f2c18 	ldr	r2, [pc, #3096]	; 109cc <HandleInvoke.part.13+0x108c>
    fdb0:	e59f1c18 	ldr	r1, [pc, #3096]	; 109d0 <HandleInvoke.part.13+0x1090>
    fdb4:	e08f2002 	add	r2, pc, r2
    fdb8:	e2422eae 	sub	r2, r2, #2784	; 0xae0
    fdbc:	e3a00001 	mov	r0, #1
    fdc0:	e2422004 	sub	r2, r2, #4
    fdc4:	e08f1001 	add	r1, pc, r1
    fdc8:	eb0016f7 	bl	159ac <RTMP_Log>
        return 0;
    fdcc:	e3a00000 	mov	r0, #0
        
    }
leave:
    AMF_Reset(&obj);
    return ret;
}
    fdd0:	e28ddf59 	add	sp, sp, #356	; 0x164
    fdd4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    }
    else if (AVMATCH(&method, &av_onFCSubscribe))
    {
        /* SendOnFCSubscribe(); */
    }
    else if (AVMATCH(&method, &av_onFCUnsubscribe))
    fdd8:	e59f1bf4 	ldr	r1, [pc, #3060]	; 109d4 <HandleInvoke.part.13+0x1094>
    fddc:	e1a02007 	mov	r2, r7
    fde0:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
    fde4:	e08f1001 	add	r1, pc, r1
    fde8:	ebffd4fa 	bl	51d8 <memcmp@plt>
    fdec:	e3500000 	cmp	r0, #0
    fdf0:	1affff51 	bne	fb3c <HandleInvoke.part.13+0x1fc>
        /* Return 1 if this is a Play.Complete or Play.Stop */
        else if (AVMATCH(&code, &av_NetStream_Play_Complete)
                 || AVMATCH(&code, &av_NetStream_Play_Stop)
                 || AVMATCH(&code, &av_NetStream_Play_UnpublishNotify))
        {
            RTMP_Close(r);
    fdf4:	e1a00005 	mov	r0, r5
    fdf8:	ebffecd7 	bl	b15c <RTMP_Close>
            ret = 1;
    fdfc:	e3a08001 	mov	r8, #1
    fe00:	eaffff4e 	b	fb40 <HandleInvoke.part.13+0x200>
    else if (AVMATCH(&method, &av_onFCUnsubscribe))
    {
        RTMP_Close(r);
        ret = 1;
    }
    else if (AVMATCH(&method, &av_ping))
    fe04:	e59f1bcc 	ldr	r1, [pc, #3020]	; 109d8 <HandleInvoke.part.13+0x1098>
    fe08:	e1a02007 	mov	r2, r7
    fe0c:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
    fe10:	e08f1001 	add	r1, pc, r1
    fe14:	ebffd4ef 	bl	51d8 <memcmp@plt>
    fe18:	e2506000 	subs	r6, r0, #0
    fe1c:	1affff46 	bne	fb3c <HandleInvoke.part.13+0x1fc>
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0x16 * r->m_nBWCheckCounter;	/* temp inc value. till we figure it out. */
    fe20:	e5953008 	ldr	r3, [r5, #8]
    fe24:	e3a0c016 	mov	ip, #22
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_pong);
    fe28:	e59f2bac 	ldr	r2, [pc, #2988]	; 109dc <HandleInvoke.part.13+0x109c>
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0x16 * r->m_nBWCheckCounter;	/* temp inc value. till we figure it out. */
    fe2c:	e00c0c93 	mul	ip, r3, ip
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_pong);
    fe30:	e08f2002 	add	r2, pc, r2
    fe34:	e28d3072 	add	r3, sp, #114	; 0x72
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    fe38:	e3a0e014 	mov	lr, #20
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_pong);
    fe3c:	e2822e35 	add	r2, r2, #848	; 0x350
    fe40:	e1a00003 	mov	r0, r3
    fe44:	e28d1e16 	add	r1, sp, #352	; 0x160
{
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    fe48:	e3a0a003 	mov	sl, #3
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    fe4c:	e3a07001 	mov	r7, #1
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0x16 * r->m_nBWCheckCounter;	/* temp inc value. till we figure it out. */
    fe50:	e58dc048 	str	ip, [sp, #72]	; 0x48
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    fe54:	e58d305c 	str	r3, [sp, #92]	; 0x5c
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    fe58:	e5cde041 	strb	lr, [sp, #65]	; 0x41
    packet.m_nTimeStamp = 0x16 * r->m_nBWCheckCounter;	/* temp inc value. till we figure it out. */
    packet.m_nInfoField2 = 0;
    fe5c:	e58d604c 	str	r6, [sp, #76]	; 0x4c
    packet.m_hasAbsTimestamp = 0;
    fe60:	e5cd6042 	strb	r6, [sp, #66]	; 0x42
{
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    fe64:	e58da044 	str	sl, [sp, #68]	; 0x44
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    fe68:	e5cd7040 	strb	r7, [sp, #64]	; 0x40
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_pong);
    fe6c:	eb00185d 	bl	15fe8 <AMF_EncodeString>
    enc = AMF_EncodeNumber(enc, pend, txn);
    fe70:	e1a02008 	mov	r2, r8
    fe74:	e28d1e16 	add	r1, sp, #352	; 0x160
    fe78:	e1a03009 	mov	r3, r9
    fe7c:	eb001880 	bl	16084 <AMF_EncodeNumber>
HandleInvoke(RTMP *r, const char *body, unsigned int nBodySize)
{
    AMFObject obj;
    AVal method;
    double txn;
    int ret = 0, nRes;
    fe80:	e1a08006 	mov	r8, r6
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_pong);
    enc = AMF_EncodeNumber(enc, pend, txn);
    *enc++ = AMF_NULL;
    fe84:	e3a0c005 	mov	ip, #5
    
    packet.m_nBodySize = enc - packet.m_body;
    
    return RTMP_SendPacket(r, &packet, FALSE);
    fe88:	e28d1040 	add	r1, sp, #64	; 0x40
    fe8c:	e1a02006 	mov	r2, r6
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_pong);
    enc = AMF_EncodeNumber(enc, pend, txn);
    *enc++ = AMF_NULL;
    fe90:	e1a03000 	mov	r3, r0
    fe94:	e4c3c001 	strb	ip, [r3], #1
    
    packet.m_nBodySize = enc - packet.m_body;
    fe98:	e59dc05c 	ldr	ip, [sp, #92]	; 0x5c
    
    return RTMP_SendPacket(r, &packet, FALSE);
    fe9c:	e1a00005 	mov	r0, r5
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av_pong);
    enc = AMF_EncodeNumber(enc, pend, txn);
    *enc++ = AMF_NULL;
    
    packet.m_nBodySize = enc - packet.m_body;
    fea0:	e06c3003 	rsb	r3, ip, r3
    fea4:	e58d3050 	str	r3, [sp, #80]	; 0x50
    
    return RTMP_SendPacket(r, &packet, FALSE);
    fea8:	ebffed53 	bl	b3fc <RTMP_SendPacket>
    feac:	eaffff23 	b	fb40 <HandleInvoke.part.13+0x200>
    }
    else if (AVMATCH(&method, &av_ping))
    {
        SendPong(r, txn);
    }
    else if (AVMATCH(&method, &av__onbwcheck))
    feb0:	e59f1b28 	ldr	r1, [pc, #2856]	; 109e0 <HandleInvoke.part.13+0x10a0>
    feb4:	e1a02007 	mov	r2, r7
    feb8:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
    febc:	e08f1001 	add	r1, pc, r1
    fec0:	ebffd4c4 	bl	51d8 <memcmp@plt>
    fec4:	e2507000 	subs	r7, r0, #0
    fec8:	1affff1b 	bne	fb3c <HandleInvoke.part.13+0x1fc>
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0x16 * r->m_nBWCheckCounter;	/* temp inc value. till we figure it out. */
    fecc:	e5953008 	ldr	r3, [r5, #8]
    fed0:	e3a0c016 	mov	ip, #22
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av__result);
    fed4:	e59f2b08 	ldr	r2, [pc, #2824]	; 109e4 <HandleInvoke.part.13+0x10a4>
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0x16 * r->m_nBWCheckCounter;	/* temp inc value. till we figure it out. */
    fed8:	e00c0c93 	mul	ip, r3, ip
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av__result);
    fedc:	e08f2002 	add	r2, pc, r2
    fee0:	e28d3072 	add	r3, sp, #114	; 0x72
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    fee4:	e3a0e014 	mov	lr, #20
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av__result);
    fee8:	e28d1e16 	add	r1, sp, #352	; 0x160
    feec:	e2822fd6 	add	r2, r2, #856	; 0x358
    fef0:	e1a00003 	mov	r0, r3
{
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    fef4:	e3a0a003 	mov	sl, #3
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    fef8:	e3a06001 	mov	r6, #1
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0x16 * r->m_nBWCheckCounter;	/* temp inc value. till we figure it out. */
    fefc:	e58dc048 	str	ip, [sp, #72]	; 0x48
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    ff00:	e5cde041 	strb	lr, [sp, #65]	; 0x41
    packet.m_nTimeStamp = 0x16 * r->m_nBWCheckCounter;	/* temp inc value. till we figure it out. */
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    ff04:	e58d305c 	str	r3, [sp, #92]	; 0x5c
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_MEDIUM;
    ff08:	e5cd6040 	strb	r6, [sp, #64]	; 0x40
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0x16 * r->m_nBWCheckCounter;	/* temp inc value. till we figure it out. */
    packet.m_nInfoField2 = 0;
    ff0c:	e58d704c 	str	r7, [sp, #76]	; 0x4c
    packet.m_hasAbsTimestamp = 0;
    ff10:	e5cd7042 	strb	r7, [sp, #66]	; 0x42
{
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    ff14:	e58da044 	str	sl, [sp, #68]	; 0x44
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av__result);
    ff18:	eb001832 	bl	15fe8 <AMF_EncodeString>
    enc = AMF_EncodeNumber(enc, pend, txn);
    ff1c:	e28d1e16 	add	r1, sp, #352	; 0x160
    ff20:	e1a02008 	mov	r2, r8
    ff24:	e1a03009 	mov	r3, r9
    ff28:	eb001855 	bl	16084 <AMF_EncodeNumber>
    *enc++ = AMF_NULL;
    ff2c:	e3a02005 	mov	r2, #5
HandleInvoke(RTMP *r, const char *body, unsigned int nBodySize)
{
    AMFObject obj;
    AVal method;
    double txn;
    int ret = 0, nRes;
    ff30:	e1a08007 	mov	r8, r7
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av__result);
    enc = AMF_EncodeNumber(enc, pend, txn);
    *enc++ = AMF_NULL;
    ff34:	e5c02000 	strb	r2, [r0]
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av__result);
    enc = AMF_EncodeNumber(enc, pend, txn);
    ff38:	e1a03000 	mov	r3, r0
    *enc++ = AMF_NULL;
    enc = AMF_EncodeNumber(enc, pend, (double)r->m_nBWCheckCounter++);
    ff3c:	e5950008 	ldr	r0, [r5, #8]
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av__result);
    enc = AMF_EncodeNumber(enc, pend, txn);
    *enc++ = AMF_NULL;
    ff40:	e0836006 	add	r6, r3, r6
    enc = AMF_EncodeNumber(enc, pend, (double)r->m_nBWCheckCounter++);
    ff44:	e2803001 	add	r3, r0, #1
    ff48:	e5853008 	str	r3, [r5, #8]
    ff4c:	eb002f9e 	bl	1bdcc <__aeabi_i2d>
    ff50:	e1a02000 	mov	r2, r0
    ff54:	e1a03001 	mov	r3, r1
    ff58:	e1a00006 	mov	r0, r6
    ff5c:	e28d1e16 	add	r1, sp, #352	; 0x160
    ff60:	eb001847 	bl	16084 <AMF_EncodeNumber>
    
    packet.m_nBodySize = enc - packet.m_body;
    ff64:	e59d305c 	ldr	r3, [sp, #92]	; 0x5c
    
    return RTMP_SendPacket(r, &packet, FALSE);
    ff68:	e28d1040 	add	r1, sp, #64	; 0x40
    ff6c:	e1a02007 	mov	r2, r7
    enc = AMF_EncodeString(enc, pend, &av__result);
    enc = AMF_EncodeNumber(enc, pend, txn);
    *enc++ = AMF_NULL;
    enc = AMF_EncodeNumber(enc, pend, (double)r->m_nBWCheckCounter++);
    
    packet.m_nBodySize = enc - packet.m_body;
    ff70:	e0633000 	rsb	r3, r3, r0
    
    return RTMP_SendPacket(r, &packet, FALSE);
    ff74:	e1a00005 	mov	r0, r5
    enc = AMF_EncodeString(enc, pend, &av__result);
    enc = AMF_EncodeNumber(enc, pend, txn);
    *enc++ = AMF_NULL;
    enc = AMF_EncodeNumber(enc, pend, (double)r->m_nBWCheckCounter++);
    
    packet.m_nBodySize = enc - packet.m_body;
    ff78:	e58d3050 	str	r3, [sp, #80]	; 0x50
    
    return RTMP_SendPacket(r, &packet, FALSE);
    ff7c:	ebffed1e 	bl	b3fc <RTMP_SendPacket>
    ff80:	eafffeee 	b	fb40 <HandleInvoke.part.13+0x200>
    else if (AVMATCH(&method, &av__onbwcheck))
    {
        
        SendCheckBWResult(r, txn);
    }
    else if (AVMATCH(&method, &av__onbwdone))
    ff84:	e59f1a5c 	ldr	r1, [pc, #2652]	; 109e8 <HandleInvoke.part.13+0x10a8>
    ff88:	e1a02007 	mov	r2, r7
    ff8c:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
    ff90:	e08f1001 	add	r1, pc, r1
    ff94:	ebffd48f 	bl	51d8 <memcmp@plt>
    ff98:	e3500000 	cmp	r0, #0
    ff9c:	1afffee6 	bne	fb3c <HandleInvoke.part.13+0x1fc>
    {
        int i;
        for (i = 0; i < r->m_numCalls; i++)
    ffa0:	e595903c 	ldr	r9, [r5, #60]	; 0x3c
    ffa4:	e3590000 	cmp	r9, #0
    ffa8:	dafffee3 	ble	fb3c <HandleInvoke.part.13+0x1fc>
    ffac:	e595b040 	ldr	fp, [r5, #64]	; 0x40
            if (AVMATCH(&r->m_methodCalls[i].name, &av__checkbw))
    ffb0:	e59faa34 	ldr	sl, [pc, #2612]	; 109ec <HandleInvoke.part.13+0x10ac>
    ffb4:	e1a0600b 	mov	r6, fp
    ffb8:	e08fa00a 	add	sl, pc, sl
        SendCheckBWResult(r, txn);
    }
    else if (AVMATCH(&method, &av__onbwdone))
    {
        int i;
        for (i = 0; i < r->m_numCalls; i++)
    ffbc:	e3a07000 	mov	r7, #0
    ffc0:	ea000003 	b	ffd4 <HandleInvoke.part.13+0x694>
    ffc4:	e2877001 	add	r7, r7, #1
    ffc8:	e1570009 	cmp	r7, r9
    ffcc:	e286600c 	add	r6, r6, #12
    ffd0:	0afffed9 	beq	fb3c <HandleInvoke.part.13+0x1fc>
            if (AVMATCH(&r->m_methodCalls[i].name, &av__checkbw))
    ffd4:	e5962004 	ldr	r2, [r6, #4]
    ffd8:	e3520008 	cmp	r2, #8
    ffdc:	1afffff8 	bne	ffc4 <HandleInvoke.part.13+0x684>
    ffe0:	e5960000 	ldr	r0, [r6]
    ffe4:	e1a0100a 	mov	r1, sl
    ffe8:	ebffd47a 	bl	51d8 <memcmp@plt>
    ffec:	e3500000 	cmp	r0, #0
    fff0:	1afffff3 	bne	ffc4 <HandleInvoke.part.13+0x684>
    fff4:	e1a08000 	mov	r8, r0
            r->m_bPlaying = TRUE;
            for (i = 0; i < r->m_numCalls; i++)
            {
                if (AVMATCH(&r->m_methodCalls[i].name, &av_play))
                {
                    AV_erase(r->m_methodCalls, &r->m_numCalls, i, TRUE);
    fff8:	e285103c 	add	r1, r5, #60	; 0x3c
    fffc:	e1a0000b 	mov	r0, fp
   10000:	e1a02007 	mov	r2, r7
   10004:	e3a03001 	mov	r3, #1
   10008:	ebffd60e 	bl	5848 <AV_erase>
   1000c:	eafffecb 	b	fb40 <HandleInvoke.part.13+0x200>
        }
        free(methodInvoked.av_val);
    }
    else if (AVMATCH(&method, &av_onBWDone))
    {
        if (!r->m_nBWCheckCounter)
   10010:	e5956008 	ldr	r6, [r5, #8]
   10014:	e3560000 	cmp	r6, #0
   10018:	1afffec7 	bne	fb3c <HandleInvoke.part.13+0x1fc>
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av__checkbw);
   1001c:	e59f29cc 	ldr	r2, [pc, #2508]	; 109f0 <HandleInvoke.part.13+0x10b0>
   10020:	e28d3072 	add	r3, sp, #114	; 0x72
   10024:	e08f2002 	add	r2, pc, r2
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
   10028:	e3a0c014 	mov	ip, #20
{
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
   1002c:	e3a0e003 	mov	lr, #3
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av__checkbw);
   10030:	e2822fd2 	add	r2, r2, #840	; 0x348
   10034:	e1a00003 	mov	r0, r3
   10038:	e28d1e16 	add	r1, sp, #352	; 0x160
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
   1003c:	e5cdc041 	strb	ip, [sp, #65]	; 0x41
    packet.m_nTimeStamp = 0;	/* RTMP_GetTime(); */
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
   10040:	e58d305c 	str	r3, [sp, #92]	; 0x5c
{
    RTMPPacket packet;
    char pbuf[256], *pend = pbuf + sizeof(pbuf);
    char *enc;
    
    packet.m_nChannel = 0x03;	/* control channel (invoke) */
   10044:	e58de044 	str	lr, [sp, #68]	; 0x44
    packet.m_headerType = RTMP_PACKET_SIZE_LARGE;
   10048:	e5cd6040 	strb	r6, [sp, #64]	; 0x40
    packet.m_packetType = RTMP_PACKET_TYPE_INVOKE;
    packet.m_nTimeStamp = 0;	/* RTMP_GetTime(); */
   1004c:	e58d6048 	str	r6, [sp, #72]	; 0x48
    packet.m_nInfoField2 = 0;
   10050:	e58d604c 	str	r6, [sp, #76]	; 0x4c
    packet.m_hasAbsTimestamp = 0;
   10054:	e5cd6042 	strb	r6, [sp, #66]	; 0x42
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av__checkbw);
   10058:	eb0017e2 	bl	15fe8 <AMF_EncodeString>
HandleInvoke(RTMP *r, const char *body, unsigned int nBodySize)
{
    AMFObject obj;
    AVal method;
    double txn;
    int ret = 0, nRes;
   1005c:	e1a08006 	mov	r8, r6
    packet.m_nInfoField2 = 0;
    packet.m_hasAbsTimestamp = 0;
    packet.m_body = pbuf + RTMP_MAX_HEADER_SIZE;
    
    enc = packet.m_body;
    enc = AMF_EncodeString(enc, pend, &av__checkbw);
   10060:	e1a07000 	mov	r7, r0
    enc = AMF_EncodeNumber(enc, pend, ++r->m_numInvokes);
   10064:	e5950038 	ldr	r0, [r5, #56]	; 0x38
   10068:	e2800001 	add	r0, r0, #1
   1006c:	e5850038 	str	r0, [r5, #56]	; 0x38
   10070:	eb002f55 	bl	1bdcc <__aeabi_i2d>
   10074:	e1a02000 	mov	r2, r0
   10078:	e1a03001 	mov	r3, r1
   1007c:	e1a00007 	mov	r0, r7
   10080:	e28d1e16 	add	r1, sp, #352	; 0x160
   10084:	eb0017fe 	bl	16084 <AMF_EncodeNumber>
    *enc++ = AMF_NULL;
   10088:	e3a0c005 	mov	ip, #5
    
    packet.m_nBodySize = enc - packet.m_body;
    
    /* triggers _onbwcheck and eventually results in _onbwdone */
    return RTMP_SendPacket(r, &packet, FALSE);
   1008c:	e28d1040 	add	r1, sp, #64	; 0x40
   10090:	e1a02006 	mov	r2, r6
   10094:	eaffff7d 	b	fe90 <HandleInvoke.part.13+0x550>
    {
        AVal methodInvoked = {0};
        int i;
        
        for (i=0; i<r->m_numCalls; i++) {
            if (r->m_methodCalls[i].num == (int)txn) {
   10098:	e1a02007 	mov	r2, r7
   1009c:	e1a0c00a 	mov	ip, sl
                methodInvoked = r->m_methodCalls[i].name;
   100a0:	e59c6000 	ldr	r6, [ip]
                AV_erase(r->m_methodCalls, &r->m_numCalls, i, FALSE);
   100a4:	e1a0000a 	mov	r0, sl
   100a8:	e285103c 	add	r1, r5, #60	; 0x3c
   100ac:	e3a03000 	mov	r3, #0
        AVal methodInvoked = {0};
        int i;
        
        for (i=0; i<r->m_numCalls; i++) {
            if (r->m_methodCalls[i].num == (int)txn) {
                methodInvoked = r->m_methodCalls[i].name;
   100b0:	e59c7004 	ldr	r7, [ip, #4]
                AV_erase(r->m_methodCalls, &r->m_numCalls, i, FALSE);
   100b4:	ebffd5e3 	bl	5848 <AV_erase>
                break;
            }
        }
        if (!methodInvoked.av_val) {
   100b8:	e3560000 	cmp	r6, #0
   100bc:	0afffe95 	beq	fb18 <HandleInvoke.part.13+0x1d8>
            RTMP_Log(RTMP_LOGDEBUG, "%s, received result id %f without matching request",
                     __FUNCTION__, txn);
            goto leave;
        }
        
        RTMP_Log(RTMP_LOGINFO, "%s, received result for method call <%s>", __FUNCTION__,
   100c0:	e59f292c 	ldr	r2, [pc, #2348]	; 109f4 <HandleInvoke.part.13+0x10b4>
   100c4:	e59f192c 	ldr	r1, [pc, #2348]	; 109f8 <HandleInvoke.part.13+0x10b8>
   100c8:	e08f2002 	add	r2, pc, r2
   100cc:	e2422eae 	sub	r2, r2, #2784	; 0xae0
   100d0:	e3a00003 	mov	r0, #3
   100d4:	e2422004 	sub	r2, r2, #4
   100d8:	e08f1001 	add	r1, pc, r1
   100dc:	e1a03006 	mov	r3, r6
   100e0:	eb001631 	bl	159ac <RTMP_Log>
                 methodInvoked.av_val);
        
        if (AVMATCH(&methodInvoked, &av_connect))
   100e4:	e3570007 	cmp	r7, #7
   100e8:	0a000023 	beq	1017c <HandleInvoke.part.13+0x83c>
                    SendFCSubscribe(r, &r->Link.subscribepath);
                else if (r->Link.lFlags & RTMP_LF_LIVE)
                    SendFCSubscribe(r, &r->Link.playpath);
            }
        }
        else if (AVMATCH(&methodInvoked, &av_createStream))
   100ec:	e357000c 	cmp	r7, #12
   100f0:	0a000005 	beq	1010c <HandleInvoke.part.13+0x7cc>
                SendPlay(r);
                //RTMP_Log(RTMP_LOGINFO,"send play bufferms :%d\n",r->m_nBufferMS);
                RTMP_SendCtrl(r, 3, r->m_stream_id, r->m_nBufferMS);
            }
        }
        else if (AVMATCH(&methodInvoked, &av_play) ||
   100f4:	e3570004 	cmp	r7, #4
   100f8:	0a000044 	beq	10210 <HandleInvoke.part.13+0x8d0>
                 AVMATCH(&methodInvoked, &av_publish))
        {
            r->m_bPlaying = TRUE;
        }
        free(methodInvoked.av_val);
   100fc:	e1a00006 	mov	r0, r6
   10100:	ebffd3bf 	bl	5004 <free@plt>
HandleInvoke(RTMP *r, const char *body, unsigned int nBodySize)
{
    AMFObject obj;
    AVal method;
    double txn;
    int ret = 0, nRes;
   10104:	e3a08000 	mov	r8, #0
   10108:	eafffe8c 	b	fb40 <HandleInvoke.part.13+0x200>
                    SendFCSubscribe(r, &r->Link.subscribepath);
                else if (r->Link.lFlags & RTMP_LF_LIVE)
                    SendFCSubscribe(r, &r->Link.playpath);
            }
        }
        else if (AVMATCH(&methodInvoked, &av_createStream))
   1010c:	e59f18e8 	ldr	r1, [pc, #2280]	; 109fc <HandleInvoke.part.13+0x10bc>
   10110:	e1a02007 	mov	r2, r7
   10114:	e08f1001 	add	r1, pc, r1
   10118:	e1a00006 	mov	r0, r6
   1011c:	ebffd42d 	bl	51d8 <memcmp@plt>
   10120:	e2501000 	subs	r1, r0, #0
   10124:	1afffff4 	bne	100fc <HandleInvoke.part.13+0x7bc>
        {
            r->m_stream_id = (int)AMFProp_GetNumber(AMF_GetProp(&obj, NULL, 3));
   10128:	e3a02003 	mov	r2, #3
   1012c:	e1a00004 	mov	r0, r4
   10130:	eb0019b6 	bl	16810 <AMF_GetProp>
   10134:	eb00184d 	bl	16270 <AMFProp_GetNumber>
   10138:	eb0030c1 	bl	1c444 <__aeabi_d2iz>
            
            if (r->Link.protocol & RTMP_FEATURE_WRITE)
   1013c:	e2853901 	add	r3, r5, #16384	; 0x4000
   10140:	e5932188 	ldr	r2, [r3, #392]	; 0x188
   10144:	e3120010 	tst	r2, #16
                    SendFCSubscribe(r, &r->Link.playpath);
            }
        }
        else if (AVMATCH(&methodInvoked, &av_createStream))
        {
            r->m_stream_id = (int)AMFProp_GetNumber(AMF_GetProp(&obj, NULL, 3));
   10148:	e5850018 	str	r0, [r5, #24]
            
            if (r->Link.protocol & RTMP_FEATURE_WRITE)
   1014c:	1a000202 	bne	1095c <HandleInvoke.part.13+0x101c>
            {
                SendPublish(r);
            }
            else
            {
                if (r->Link.lFlags & RTMP_LF_PLST)
   10150:	e5933180 	ldr	r3, [r3, #384]	; 0x180
   10154:	e3130008 	tst	r3, #8
   10158:	1a00024c 	bne	10a90 <HandleInvoke.part.13+0x1150>
                    SendPlaylist(r);
                //printf("send play \n");
                SendPlay(r);
   1015c:	e1a00005 	mov	r0, r5
   10160:	ebfff121 	bl	c5ec <SendPlay>
                //RTMP_Log(RTMP_LOGINFO,"send play bufferms :%d\n",r->m_nBufferMS);
                RTMP_SendCtrl(r, 3, r->m_stream_id, r->m_nBufferMS);
   10164:	e1a00005 	mov	r0, r5
   10168:	e3a01003 	mov	r1, #3
   1016c:	e5952018 	ldr	r2, [r5, #24]
   10170:	e5953014 	ldr	r3, [r5, #20]
   10174:	ebfff2d4 	bl	cccc <RTMP_SendCtrl>
   10178:	eaffffdf 	b	100fc <HandleInvoke.part.13+0x7bc>
        }
        
        RTMP_Log(RTMP_LOGINFO, "%s, received result for method call <%s>", __FUNCTION__,
                 methodInvoked.av_val);
        
        if (AVMATCH(&methodInvoked, &av_connect))
   1017c:	e59f187c 	ldr	r1, [pc, #2172]	; 10a00 <HandleInvoke.part.13+0x10c0>
   10180:	e1a00006 	mov	r0, r6
   10184:	e08f1001 	add	r1, pc, r1
   10188:	e1a02007 	mov	r2, r7
   1018c:	ebffd411 	bl	51d8 <memcmp@plt>
   10190:	e2508000 	subs	r8, r0, #0
   10194:	1a000027 	bne	10238 <HandleInvoke.part.13+0x8f8>
        {
            if (r->Link.token.av_len)
   10198:	e2857901 	add	r7, r5, #16384	; 0x4000
   1019c:	e5973158 	ldr	r3, [r7, #344]	; 0x158
   101a0:	e3530000 	cmp	r3, #0
   101a4:	1a0000bb 	bne	10498 <HandleInvoke.part.13+0xb58>
                {
                    DecodeTEA(&r->Link.token, &p.p_vu.p_aval);
                    SendSecureTokenResponse(r, &p.p_vu.p_aval);
                }
            }
            if (r->Link.protocol & RTMP_FEATURE_WRITE)
   101a8:	e5973188 	ldr	r3, [r7, #392]	; 0x188
            {
                SendReleaseStream(r);
   101ac:	e1a00005 	mov	r0, r5
                {
                    DecodeTEA(&r->Link.token, &p.p_vu.p_aval);
                    SendSecureTokenResponse(r, &p.p_vu.p_aval);
                }
            }
            if (r->Link.protocol & RTMP_FEATURE_WRITE)
   101b0:	e2138010 	ands	r8, r3, #16
   101b4:	0a000082 	beq	103c4 <HandleInvoke.part.13+0xa84>
            {
                SendReleaseStream(r);
   101b8:	ebffefb6 	bl	c098 <SendReleaseStream>
                SendFCPublish(r);
   101bc:	e1a00005 	mov	r0, r5
   101c0:	ebffefe7 	bl	c164 <SendFCPublish>
            else
            {
                RTMP_SendServerBW(r);
                RTMP_SendCtrl(r, 3, 0, 300);
            }
            RTMP_SendCreateStream(r);
   101c4:	e1a00005 	mov	r0, r5
   101c8:	ebfff1b4 	bl	c8a0 <RTMP_SendCreateStream>
            
            if (!(r->Link.protocol & RTMP_FEATURE_WRITE))
   101cc:	e5973188 	ldr	r3, [r7, #392]	; 0x188
   101d0:	e3130010 	tst	r3, #16
   101d4:	1affffc8 	bne	100fc <HandleInvoke.part.13+0x7bc>
            {
                /* Authenticate on Justin.tv legacy servers before sending FCSubscribe */
                if (r->Link.usherToken.av_len)
   101d8:	e5973150 	ldr	r3, [r7, #336]	; 0x150
   101dc:	e3530000 	cmp	r3, #0
   101e0:	1a0001d3 	bne	10934 <HandleInvoke.part.13+0xff4>
                    SendUsherToken(r, &r->Link.usherToken);
                /* Send the FCSubscribe if live stream or if subscribepath is set */
                if (r->Link.subscribepath.av_len)
   101e4:	e5973148 	ldr	r3, [r7, #328]	; 0x148
   101e8:	e3530000 	cmp	r3, #0
   101ec:	1a0001d5 	bne	10948 <HandleInvoke.part.13+0x1008>
                    SendFCSubscribe(r, &r->Link.subscribepath);
                else if (r->Link.lFlags & RTMP_LF_LIVE)
   101f0:	e5973180 	ldr	r3, [r7, #384]	; 0x180
   101f4:	e3130002 	tst	r3, #2
   101f8:	0affffbf 	beq	100fc <HandleInvoke.part.13+0x7bc>
                    SendFCSubscribe(r, &r->Link.playpath);
   101fc:	e2851c41 	add	r1, r5, #16640	; 0x4100
   10200:	e281100c 	add	r1, r1, #12
   10204:	e1a00005 	mov	r0, r5
   10208:	ebfff043 	bl	c31c <SendFCSubscribe>
   1020c:	eaffffba 	b	100fc <HandleInvoke.part.13+0x7bc>
                SendPlay(r);
                //RTMP_Log(RTMP_LOGINFO,"send play bufferms :%d\n",r->m_nBufferMS);
                RTMP_SendCtrl(r, 3, r->m_stream_id, r->m_nBufferMS);
            }
        }
        else if (AVMATCH(&methodInvoked, &av_play) ||
   10210:	e59f17ec 	ldr	r1, [pc, #2028]	; 10a04 <HandleInvoke.part.13+0x10c4>
   10214:	e1a02007 	mov	r2, r7
   10218:	e1a00006 	mov	r0, r6
   1021c:	e08f1001 	add	r1, pc, r1
   10220:	ebffd3ec 	bl	51d8 <memcmp@plt>
   10224:	e3500000 	cmp	r0, #0
   10228:	1affffb3 	bne	100fc <HandleInvoke.part.13+0x7bc>
                 AVMATCH(&methodInvoked, &av_publish))
        {
            r->m_bPlaying = TRUE;
   1022c:	e3a03001 	mov	r3, #1
   10230:	e5c53035 	strb	r3, [r5, #53]	; 0x35
   10234:	eaffffb0 	b	100fc <HandleInvoke.part.13+0x7bc>
                //RTMP_Log(RTMP_LOGINFO,"send play bufferms :%d\n",r->m_nBufferMS);
                RTMP_SendCtrl(r, 3, r->m_stream_id, r->m_nBufferMS);
            }
        }
        else if (AVMATCH(&methodInvoked, &av_play) ||
                 AVMATCH(&methodInvoked, &av_publish))
   10238:	e59f17c8 	ldr	r1, [pc, #1992]	; 10a08 <HandleInvoke.part.13+0x10c8>
   1023c:	e1a02007 	mov	r2, r7
   10240:	e1a00006 	mov	r0, r6
   10244:	e08f1001 	add	r1, pc, r1
   10248:	ebffd3e2 	bl	51d8 <memcmp@plt>
   1024c:	e3500000 	cmp	r0, #0
   10250:	1affffa9 	bne	100fc <HandleInvoke.part.13+0x7bc>
   10254:	eafffff4 	b	1022c <HandleInvoke.part.13+0x8ec>
        
        if (r->Link.protocol & RTMP_FEATURE_WRITE)
        {
            for (i=0; i<r->m_numCalls; i++)
            {
                if (r->m_methodCalls[i].num == txn)
   10258:	e59db008 	ldr	fp, [sp, #8]
   1025c:	e3a06000 	mov	r6, #0
                {
                    methodInvoked = r->m_methodCalls[i].name;
   10260:	e59b7000 	ldr	r7, [fp]
                    AV_erase(r->m_methodCalls, &r->m_numCalls, i, FALSE);
   10264:	e59d0008 	ldr	r0, [sp, #8]
   10268:	e1a02006 	mov	r2, r6
   1026c:	e285103c 	add	r1, r5, #60	; 0x3c
   10270:	e3a03000 	mov	r3, #0
        {
            for (i=0; i<r->m_numCalls; i++)
            {
                if (r->m_methodCalls[i].num == txn)
                {
                    methodInvoked = r->m_methodCalls[i].name;
   10274:	e59ba004 	ldr	sl, [fp, #4]
                    AV_erase(r->m_methodCalls, &r->m_numCalls, i, FALSE);
   10278:	ebffd572 	bl	5848 <AV_erase>
                    break;
                }
            }
            if (!methodInvoked.av_val)
   1027c:	e3570000 	cmp	r7, #0
   10280:	0afffeb0 	beq	fd48 <HandleInvoke.part.13+0x408>
                RTMP_Log(RTMP_LOGDEBUG, "%s, received result id %f without matching request",
                         __FUNCTION__, txn);
                goto leave;
            }
            
            RTMP_Log(RTMP_LOGDEBUG, "%s, received error for method call <%s>", __FUNCTION__,
   10284:	e59f6780 	ldr	r6, [pc, #1920]	; 10a0c <HandleInvoke.part.13+0x10cc>
   10288:	e59f1780 	ldr	r1, [pc, #1920]	; 10a10 <HandleInvoke.part.13+0x10d0>
   1028c:	e08f6006 	add	r6, pc, r6
   10290:	e2466eae 	sub	r6, r6, #2784	; 0xae0
   10294:	e2466004 	sub	r6, r6, #4
   10298:	e3a00004 	mov	r0, #4
   1029c:	e1a02006 	mov	r2, r6
   102a0:	e08f1001 	add	r1, pc, r1
   102a4:	e1a03007 	mov	r3, r7
   102a8:	eb0015bf 	bl	159ac <RTMP_Log>
                     methodInvoked.av_val);
            
            if (AVMATCH(&methodInvoked, &av_connect))
   102ac:	e35a0007 	cmp	sl, #7
   102b0:	0a000008 	beq	102d8 <HandleInvoke.part.13+0x998>
        }
        else
        {
            RTMP_Log(RTMP_LOGERROR, "rtmp server sent error");
        }
        free(methodInvoked.av_val);
   102b4:	e1a00007 	mov	r0, r7
   102b8:	ebffd351 	bl	5004 <free@plt>
HandleInvoke(RTMP *r, const char *body, unsigned int nBodySize)
{
    AMFObject obj;
    AVal method;
    double txn;
    int ret = 0, nRes;
   102bc:	e3a08000 	mov	r8, #0
   102c0:	eafffe1e 	b	fb40 <HandleInvoke.part.13+0x200>
                }
            }
        }
        else
        {
            RTMP_Log(RTMP_LOGERROR, "rtmp server sent error");
   102c4:	e59f1748 	ldr	r1, [pc, #1864]	; 10a14 <HandleInvoke.part.13+0x10d4>
   102c8:	e3a00001 	mov	r0, #1
   102cc:	e08f1001 	add	r1, pc, r1
   102d0:	eb0015b5 	bl	159ac <RTMP_Log>
   102d4:	eafffff6 	b	102b4 <HandleInvoke.part.13+0x974>
            }
            
            RTMP_Log(RTMP_LOGDEBUG, "%s, received error for method call <%s>", __FUNCTION__,
                     methodInvoked.av_val);
            
            if (AVMATCH(&methodInvoked, &av_connect))
   102d8:	e59f1738 	ldr	r1, [pc, #1848]	; 10a18 <HandleInvoke.part.13+0x10d8>
   102dc:	e1a0200a 	mov	r2, sl
   102e0:	e1a00007 	mov	r0, r7
   102e4:	e08f1001 	add	r1, pc, r1
   102e8:	ebffd3ba 	bl	51d8 <memcmp@plt>
   102ec:	e2508000 	subs	r8, r0, #0
   102f0:	1affffef 	bne	102b4 <HandleInvoke.part.13+0x974>
            {
                AMFObject obj2;
                AVal code, level, description;
                AMFProp_GetObject(AMF_GetProp(&obj, NULL, 3), &obj2);
                AMFProp_GetString(AMF_GetProp(&obj2, &av_code, -1), &code);
   102f4:	e59fa720 	ldr	sl, [pc, #1824]	; 10a1c <HandleInvoke.part.13+0x10dc>
            
            if (AVMATCH(&methodInvoked, &av_connect))
            {
                AMFObject obj2;
                AVal code, level, description;
                AMFProp_GetObject(AMF_GetProp(&obj, NULL, 3), &obj2);
   102f8:	e28d9030 	add	r9, sp, #48	; 0x30
   102fc:	e3a02003 	mov	r2, #3
   10300:	e1a01008 	mov	r1, r8
   10304:	e1a00004 	mov	r0, r4
   10308:	eb001940 	bl	16810 <AMF_GetProp>
                AMFProp_GetString(AMF_GetProp(&obj2, &av_code, -1), &code);
   1030c:	e08fa00a 	add	sl, pc, sl
            
            if (AVMATCH(&methodInvoked, &av_connect))
            {
                AMFObject obj2;
                AVal code, level, description;
                AMFProp_GetObject(AMF_GetProp(&obj, NULL, 3), &obj2);
   10310:	e1a01009 	mov	r1, r9
   10314:	eb0017e4 	bl	162ac <AMFProp_GetObject>
                AMFProp_GetString(AMF_GetProp(&obj2, &av_code, -1), &code);
   10318:	e3e02000 	mvn	r2, #0
   1031c:	e28a1e36 	add	r1, sl, #864	; 0x360
   10320:	e1a00009 	mov	r0, r9
   10324:	eb001939 	bl	16810 <AMF_GetProp>
   10328:	e28d1038 	add	r1, sp, #56	; 0x38
   1032c:	eb0017d9 	bl	16298 <AMFProp_GetString>
                AMFProp_GetString(AMF_GetProp(&obj2, &av_level, -1), &level);
   10330:	e3e02000 	mvn	r2, #0
   10334:	e28a1fda 	add	r1, sl, #872	; 0x368
   10338:	e1a00009 	mov	r0, r9
   1033c:	eb001933 	bl	16810 <AMF_GetProp>
   10340:	e28d1040 	add	r1, sp, #64	; 0x40
   10344:	eb0017d3 	bl	16298 <AMFProp_GetString>
                AMFProp_GetString(AMF_GetProp(&obj2, &av_description, -1), &description);
   10348:	e3e02000 	mvn	r2, #0
   1034c:	e28a1e37 	add	r1, sl, #880	; 0x370
   10350:	e1a00009 	mov	r0, r9
   10354:	eb00192d 	bl	16810 <AMF_GetProp>
   10358:	e28d1060 	add	r1, sp, #96	; 0x60
   1035c:	eb0017cd 	bl	16298 <AMFProp_GetString>
                RTMP_Log(RTMP_LOGDEBUG, "%s, error description: %s", __FUNCTION__, description.av_val);
   10360:	e59f16b8 	ldr	r1, [pc, #1720]	; 10a20 <HandleInvoke.part.13+0x10e0>
   10364:	e1a02006 	mov	r2, r6
   10368:	e3a00004 	mov	r0, #4
   1036c:	e08f1001 	add	r1, pc, r1
   10370:	e59d3060 	ldr	r3, [sp, #96]	; 0x60
   10374:	eb00158c 	bl	159ac <RTMP_Log>
                /* if PublisherAuth returns 1, then reconnect */
                if (PublisherAuth(r, &description) == 1)
   10378:	e59d1060 	ldr	r1, [sp, #96]	; 0x60
   1037c:	e1a00005 	mov	r0, r5
   10380:	ebffd87a 	bl	6570 <PublisherAuth.isra.7>
   10384:	e3500001 	cmp	r0, #1
   10388:	e1a01000 	mov	r1, r0
   1038c:	1affffc8 	bne	102b4 <HandleInvoke.part.13+0x974>
                {
                    CloseInternal(r, 1);
   10390:	e1a00005 	mov	r0, r5
   10394:	ebffea9f 	bl	ae18 <CloseInternal>
                    if (!RTMP_Connect(r, NULL) || !RTMP_ConnectStream(r, 0))
   10398:	e1a00005 	mov	r0, r5
   1039c:	e1a01008 	mov	r1, r8
   103a0:	ebfffd51 	bl	f8ec <RTMP_Connect>
   103a4:	e3500000 	cmp	r0, #0
   103a8:	0afffde3 	beq	fb3c <HandleInvoke.part.13+0x1fc>
   103ac:	e1a00005 	mov	r0, r5
   103b0:	e1a01008 	mov	r1, r8
   103b4:	eb000403 	bl	113c8 <RTMP_ConnectStream>
   103b8:	e3500000 	cmp	r0, #0
   103bc:	1affffbc 	bne	102b4 <HandleInvoke.part.13+0x974>
   103c0:	eafffddd 	b	fb3c <HandleInvoke.part.13+0x1fc>
                SendReleaseStream(r);
                SendFCPublish(r);
            }
            else
            {
                RTMP_SendServerBW(r);
   103c4:	ebfff209 	bl	cbf0 <RTMP_SendServerBW>
                RTMP_SendCtrl(r, 3, 0, 300);
   103c8:	e1a00005 	mov	r0, r5
   103cc:	e1a02008 	mov	r2, r8
   103d0:	e3a01003 	mov	r1, #3
   103d4:	e3a03f4b 	mov	r3, #300	; 0x12c
   103d8:	ebfff23b 	bl	cccc <RTMP_SendCtrl>
   103dc:	eaffff78 	b	101c4 <HandleInvoke.part.13+0x884>
        AMFProp_GetObject(AMF_GetProp(&obj, NULL, 3), &obj2);
        AMFProp_GetString(AMF_GetProp(&obj2, &av_code, -1), &code);
        AMFProp_GetString(AMF_GetProp(&obj2, &av_level, -1), &level);
        
        RTMP_Log(RTMP_LOGINFO, "%s, onStatus: %s", __FUNCTION__, code.av_val);
        if (AVMATCH(&code, &av_NetStream_Failed)
   103e0:	e59f163c 	ldr	r1, [pc, #1596]	; 10a24 <HandleInvoke.part.13+0x10e4>
   103e4:	e1a02006 	mov	r2, r6
   103e8:	e59d0040 	ldr	r0, [sp, #64]	; 0x40
   103ec:	e08f1001 	add	r1, pc, r1
   103f0:	ebffd378 	bl	51d8 <memcmp@plt>
   103f4:	e3500000 	cmp	r0, #0
   103f8:	1afffdcf 	bne	fb3c <HandleInvoke.part.13+0x1fc>
            || AVMATCH(&code, &av_NetStream_Publish_BadName)
            || AVMATCH(&code, &av_NetStream_Play_Failed)
            || AVMATCH(&code, &av_NetStream_Play_StreamNotFound)
            || AVMATCH(&code, &av_NetConnection_Connect_InvalidApp))
        {
            r->m_stream_id = -1;
   103fc:	e3e03000 	mvn	r3, #0
   10400:	e5853018 	str	r3, [r5, #24]
            RTMP_Close(r);
   10404:	e1a00005 	mov	r0, r5
   10408:	ebffeb53 	bl	b15c <RTMP_Close>
            RTMP_Log(RTMP_LOGDEBUG, "Closing connection: %s", code.av_val);
   1040c:	e59f1614 	ldr	r1, [pc, #1556]	; 10a28 <HandleInvoke.part.13+0x10e8>
   10410:	e3a00004 	mov	r0, #4
   10414:	e08f1001 	add	r1, pc, r1
   10418:	e59d2040 	ldr	r2, [sp, #64]	; 0x40
   1041c:	eb001562 	bl	159ac <RTMP_Log>
HandleInvoke(RTMP *r, const char *body, unsigned int nBodySize)
{
    AMFObject obj;
    AVal method;
    double txn;
    int ret = 0, nRes;
   10420:	e3a08000 	mov	r8, #0
   10424:	eafffdc5 	b	fb40 <HandleInvoke.part.13+0x200>
        AMFProp_GetString(AMF_GetProp(&obj2, &av_code, -1), &code);
        AMFProp_GetString(AMF_GetProp(&obj2, &av_level, -1), &level);
        
        RTMP_Log(RTMP_LOGINFO, "%s, onStatus: %s", __FUNCTION__, code.av_val);
        if (AVMATCH(&code, &av_NetStream_Failed)
            || AVMATCH(&code, &av_NetStream_Publish_BadName)
   10428:	e59f15fc 	ldr	r1, [pc, #1532]	; 10a2c <HandleInvoke.part.13+0x10ec>
   1042c:	e1a02006 	mov	r2, r6
   10430:	e59d0040 	ldr	r0, [sp, #64]	; 0x40
   10434:	e08f1001 	add	r1, pc, r1
   10438:	ebffd366 	bl	51d8 <memcmp@plt>
   1043c:	e3500000 	cmp	r0, #0
   10440:	0affffed 	beq	103fc <HandleInvoke.part.13+0xabc>
   10444:	eafffdbc 	b	fb3c <HandleInvoke.part.13+0x1fc>
            || AVMATCH(&code, &av_NetStream_Play_Failed)
   10448:	e59d7040 	ldr	r7, [sp, #64]	; 0x40
   1044c:	e59f15dc 	ldr	r1, [pc, #1500]	; 10a30 <HandleInvoke.part.13+0x10f0>
   10450:	e1a00007 	mov	r0, r7
   10454:	e08f1001 	add	r1, pc, r1
   10458:	e1a02006 	mov	r2, r6
   1045c:	ebffd35d 	bl	51d8 <memcmp@plt>
   10460:	e3500000 	cmp	r0, #0
   10464:	0affffe4 	beq	103fc <HandleInvoke.part.13+0xabc>
        {
            RTMP_Close(r);
            ret = 1;
        }
        
        else if (AVMATCH(&code, &av_NetStream_Seek_Notify))
   10468:	e59f15c4 	ldr	r1, [pc, #1476]	; 10a34 <HandleInvoke.part.13+0x10f4>
   1046c:	e1a00007 	mov	r0, r7
   10470:	e1a02006 	mov	r2, r6
   10474:	e08f1001 	add	r1, pc, r1
   10478:	ebffd356 	bl	51d8 <memcmp@plt>
   1047c:	e3500000 	cmp	r0, #0
   10480:	1afffdad 	bne	fb3c <HandleInvoke.part.13+0x1fc>
        {
            r->m_read.flags &= ~RTMP_READ_SEEKING;
   10484:	e5d530a1 	ldrb	r3, [r5, #161]	; 0xa1
HandleInvoke(RTMP *r, const char *body, unsigned int nBodySize)
{
    AMFObject obj;
    AVal method;
    double txn;
    int ret = 0, nRes;
   10488:	e3a08000 	mov	r8, #0
            ret = 1;
        }
        
        else if (AVMATCH(&code, &av_NetStream_Seek_Notify))
        {
            r->m_read.flags &= ~RTMP_READ_SEEKING;
   1048c:	e3c33020 	bic	r3, r3, #32
   10490:	e5c530a1 	strb	r3, [r5, #161]	; 0xa1
   10494:	eafffda9 	b	fb40 <HandleInvoke.part.13+0x200>
        if (AVMATCH(&methodInvoked, &av_connect))
        {
            if (r->Link.token.av_len)
            {
                AMFObjectProperty p;
                if (RTMP_FindFirstMatchingProperty(&obj, &av_secureToken, &p))
   10498:	e59f1598 	ldr	r1, [pc, #1432]	; 10a38 <HandleInvoke.part.13+0x10f8>
   1049c:	e1a00004 	mov	r0, r4
   104a0:	e08f1001 	add	r1, pc, r1
   104a4:	e2811d0d 	add	r1, r1, #832	; 0x340
   104a8:	e28d2060 	add	r2, sp, #96	; 0x60
   104ac:	ebffe574 	bl	9a84 <RTMP_FindFirstMatchingProperty>
   104b0:	e3500000 	cmp	r0, #0
   104b4:	0affff3b 	beq	101a8 <HandleInvoke.part.13+0x868>
    /* prep key: pack 1st 16 chars into 4 LittleEndian ints */
    ptr = (unsigned char *)key->av_val;
    u = 0;
    n = 0;
    v = k;
    p = key->av_len > 16 ? 16 : key->av_len;
   104b8:	e597c158 	ldr	ip, [r7, #344]	; 0x158
#define HEX2BIN(a)	(((a)&0x40)?((a)&0xf)+9:((a)&0xf))

static void
DecodeTEA(AVal *key, AVal *text)
{
    uint32_t *v, k[4] = { 0 }, u;
   104bc:	e58d8040 	str	r8, [sp, #64]	; 0x40
    /* prep key: pack 1st 16 chars into 4 LittleEndian ints */
    ptr = (unsigned char *)key->av_val;
    u = 0;
    n = 0;
    v = k;
    p = key->av_len > 16 ? 16 : key->av_len;
   104c0:	e35c0010 	cmp	ip, #16
   104c4:	a3a0c010 	movge	ip, #16
    for (i = 0; i < p; i++)
   104c8:	e35c0000 	cmp	ip, #0
#define HEX2BIN(a)	(((a)&0x40)?((a)&0xf)+9:((a)&0xf))

static void
DecodeTEA(AVal *key, AVal *text)
{
    uint32_t *v, k[4] = { 0 }, u;
   104cc:	e58d8044 	str	r8, [sp, #68]	; 0x44
   104d0:	e58d8048 	str	r8, [sp, #72]	; 0x48
   104d4:	e58d804c 	str	r8, [sp, #76]	; 0x4c
    int32_t p, q;
    int i, n;
    unsigned char *ptr, *out;
    
    /* prep key: pack 1st 16 chars into 4 LittleEndian ints */
    ptr = (unsigned char *)key->av_val;
   104d8:	e5971154 	ldr	r1, [r7, #340]	; 0x154
    u = 0;
    n = 0;
    v = k;
    p = key->av_len > 16 ? 16 : key->av_len;
    for (i = 0; i < p; i++)
   104dc:	da00000f 	ble	10520 <HandleInvoke.part.13+0xbe0>
   104e0:	e1a03008 	mov	r3, r8
   104e4:	e081c00c 	add	ip, r1, ip
   104e8:	e28de040 	add	lr, sp, #64	; 0x40
    {
        u |= ptr[i] << (n * 8);
   104ec:	e4d10001 	ldrb	r0, [r1], #1
   104f0:	e1a02188 	lsl	r2, r8, #3
   104f4:	e1833210 	orr	r3, r3, r0, lsl r2
        if (n == 3)
   104f8:	e3580003 	cmp	r8, #3
        {
            *v++ = u;
   104fc:	058e3000 	streq	r3, [lr]
            u = 0;
            n = 0;
   10500:	03a03000 	moveq	r3, #0
    n = 0;
    v = k;
    p = key->av_len > 16 ? 16 : key->av_len;
    for (i = 0; i < p; i++)
    {
        u |= ptr[i] << (n * 8);
   10504:	e2888001 	add	r8, r8, #1
        if (n == 3)
        {
            *v++ = u;
   10508:	028ee004 	addeq	lr, lr, #4
            u = 0;
   1050c:	01a08003 	moveq	r8, r3
    ptr = (unsigned char *)key->av_val;
    u = 0;
    n = 0;
    v = k;
    p = key->av_len > 16 ? 16 : key->av_len;
    for (i = 0; i < p; i++)
   10510:	e151000c 	cmp	r1, ip
   10514:	1afffff4 	bne	104ec <HandleInvoke.part.13+0xbac>
        {
            n++;
        }
    }
    /* any trailing chars */
    if (u)
   10518:	e3530000 	cmp	r3, #0
        *v = u;
   1051c:	158e3000 	strne	r3, [lr]
    
    /* prep text: hex2bin, multiples of 4 */
    n = (text->av_len + 7) / 8;
   10520:	e59d3074 	ldr	r3, [sp, #116]	; 0x74
   10524:	e58d3014 	str	r3, [sp, #20]
   10528:	e293a007 	adds	sl, r3, #7
   1052c:	4283a00e 	addmi	sl, r3, #14
   10530:	e1a031ca 	asr	r3, sl, #3
    out = malloc(n * 8);
   10534:	e1a00183 	lsl	r0, r3, #3
    /* any trailing chars */
    if (u)
        *v = u;
    
    /* prep text: hex2bin, multiples of 4 */
    n = (text->av_len + 7) / 8;
   10538:	e1a08003 	mov	r8, r3
   1053c:	e58d300c 	str	r3, [sp, #12]
    out = malloc(n * 8);
   10540:	ebffd2b5 	bl	501c <malloc@plt>
    ptr = (unsigned char *)text->av_val;
   10544:	e59d3070 	ldr	r3, [sp, #112]	; 0x70
    v = (uint32_t *) out;
    for (i = 0; i < n; i++)
   10548:	e3580000 	cmp	r8, #0
        *v = u;
    
    /* prep text: hex2bin, multiples of 4 */
    n = (text->av_len + 7) / 8;
    out = malloc(n * 8);
    ptr = (unsigned char *)text->av_val;
   1054c:	e58d3010 	str	r3, [sp, #16]
    if (u)
        *v = u;
    
    /* prep text: hex2bin, multiples of 4 */
    n = (text->av_len + 7) / 8;
    out = malloc(n * 8);
   10550:	e58d0008 	str	r0, [sp, #8]
    ptr = (unsigned char *)text->av_val;
    v = (uint32_t *) out;
    for (i = 0; i < n; i++)
   10554:	da000044 	ble	1066c <HandleInvoke.part.13+0xd2c>
   10558:	e59d3010 	ldr	r3, [sp, #16]
   1055c:	e59d200c 	ldr	r2, [sp, #12]
   10560:	e2839008 	add	r9, r3, #8
   10564:	e59d3008 	ldr	r3, [sp, #8]
   10568:	e083b102 	add	fp, r3, r2, lsl #2
    if (u)
        *v = u;
    
    /* prep text: hex2bin, multiples of 4 */
    n = (text->av_len + 7) / 8;
    out = malloc(n * 8);
   1056c:	e1a0a003 	mov	sl, r3
    ptr = (unsigned char *)text->av_val;
    v = (uint32_t *) out;
    for (i = 0; i < n; i++)
    {
        u = (HEX2BIN(ptr[0]) << 4) + HEX2BIN(ptr[1]);
   10570:	e5591008 	ldrb	r1, [r9, #-8]
   10574:	e559c007 	ldrb	ip, [r9, #-7]
   10578:	e201e00f 	and	lr, r1, #15
   1057c:	e1a03201 	lsl	r3, r1, #4
        u |= ((HEX2BIN(ptr[2]) << 4) + HEX2BIN(ptr[3])) << 8;
   10580:	e5592006 	ldrb	r2, [r9, #-6]
   10584:	e3110040 	tst	r1, #64	; 0x40
    out = malloc(n * 8);
    ptr = (unsigned char *)text->av_val;
    v = (uint32_t *) out;
    for (i = 0; i < n; i++)
    {
        u = (HEX2BIN(ptr[0]) << 4) + HEX2BIN(ptr[1]);
   10588:	e20330ff 	and	r3, r3, #255	; 0xff
   1058c:	e20c100f 	and	r1, ip, #15
   10590:	e28ee009 	add	lr, lr, #9
        u |= ((HEX2BIN(ptr[2]) << 4) + HEX2BIN(ptr[3])) << 8;
   10594:	e5590005 	ldrb	r0, [r9, #-5]
   10598:	01a0e003 	moveq	lr, r3
   1059c:	11a0e20e 	lslne	lr, lr, #4
   105a0:	e31c0040 	tst	ip, #64	; 0x40
    out = malloc(n * 8);
    ptr = (unsigned char *)text->av_val;
    v = (uint32_t *) out;
    for (i = 0; i < n; i++)
    {
        u = (HEX2BIN(ptr[0]) << 4) + HEX2BIN(ptr[1]);
   105a4:	e2813009 	add	r3, r1, #9
   105a8:	11a01003 	movne	r1, r3
        u |= ((HEX2BIN(ptr[2]) << 4) + HEX2BIN(ptr[3])) << 8;
   105ac:	e202800f 	and	r8, r2, #15
   105b0:	e1a03202 	lsl	r3, r2, #4
   105b4:	e200c00f 	and	ip, r0, #15
   105b8:	e3120040 	tst	r2, #64	; 0x40
   105bc:	e20330ff 	and	r3, r3, #255	; 0xff
        u |= ((HEX2BIN(ptr[4]) << 4) + HEX2BIN(ptr[5])) << 16;
   105c0:	e5592004 	ldrb	r2, [r9, #-4]
    ptr = (unsigned char *)text->av_val;
    v = (uint32_t *) out;
    for (i = 0; i < n; i++)
    {
        u = (HEX2BIN(ptr[0]) << 4) + HEX2BIN(ptr[1]);
        u |= ((HEX2BIN(ptr[2]) << 4) + HEX2BIN(ptr[3])) << 8;
   105c4:	e2888009 	add	r8, r8, #9
   105c8:	01a08003 	moveq	r8, r3
   105cc:	11a08208 	lslne	r8, r8, #4
   105d0:	e3100040 	tst	r0, #64	; 0x40
   105d4:	e28c3009 	add	r3, ip, #9
        u |= ((HEX2BIN(ptr[4]) << 4) + HEX2BIN(ptr[5])) << 16;
   105d8:	e5590003 	ldrb	r0, [r9, #-3]
   105dc:	11a0c003 	movne	ip, r3
   105e0:	e3120040 	tst	r2, #64	; 0x40
   105e4:	e202300f 	and	r3, r2, #15
   105e8:	e1a02202 	lsl	r2, r2, #4
   105ec:	e20220ff 	and	r2, r2, #255	; 0xff
   105f0:	e2833009 	add	r3, r3, #9
   105f4:	01a03002 	moveq	r3, r2
   105f8:	11a03203 	lslne	r3, r3, #4
   105fc:	e3100040 	tst	r0, #64	; 0x40
   10600:	e200000f 	and	r0, r0, #15
        u |= ((HEX2BIN(ptr[6]) << 4) + HEX2BIN(ptr[7])) << 24;
   10604:	e5592002 	ldrb	r2, [r9, #-2]
    ptr = (unsigned char *)text->av_val;
    v = (uint32_t *) out;
    for (i = 0; i < n; i++)
    {
        u = (HEX2BIN(ptr[0]) << 4) + HEX2BIN(ptr[1]);
        u |= ((HEX2BIN(ptr[2]) << 4) + HEX2BIN(ptr[3])) << 8;
   10608:	e088c00c 	add	ip, r8, ip
        u |= ((HEX2BIN(ptr[4]) << 4) + HEX2BIN(ptr[5])) << 16;
   1060c:	e2808009 	add	r8, r0, #9
   10610:	11a00008 	movne	r0, r8
   10614:	e0833000 	add	r3, r3, r0
   10618:	e3120040 	tst	r2, #64	; 0x40
        u |= ((HEX2BIN(ptr[6]) << 4) + HEX2BIN(ptr[7])) << 24;
   1061c:	e5590001 	ldrb	r0, [r9, #-1]
   10620:	e202800f 	and	r8, r2, #15
   10624:	e1a02202 	lsl	r2, r2, #4
   10628:	e2888009 	add	r8, r8, #9
   1062c:	e20220ff 	and	r2, r2, #255	; 0xff
   10630:	11a02208 	lslne	r2, r8, #4
   10634:	e3100040 	tst	r0, #64	; 0x40
   10638:	e200000f 	and	r0, r0, #15
    out = malloc(n * 8);
    ptr = (unsigned char *)text->av_val;
    v = (uint32_t *) out;
    for (i = 0; i < n; i++)
    {
        u = (HEX2BIN(ptr[0]) << 4) + HEX2BIN(ptr[1]);
   1063c:	e08ee001 	add	lr, lr, r1
        u |= ((HEX2BIN(ptr[2]) << 4) + HEX2BIN(ptr[3])) << 8;
        u |= ((HEX2BIN(ptr[4]) << 4) + HEX2BIN(ptr[5])) << 16;
   10640:	e1a03803 	lsl	r3, r3, #16
        u |= ((HEX2BIN(ptr[6]) << 4) + HEX2BIN(ptr[7])) << 24;
   10644:	e2801009 	add	r1, r0, #9
   10648:	11a00001 	movne	r0, r1
   1064c:	e183340c 	orr	r3, r3, ip, lsl #8
    v = (uint32_t *) out;
    for (i = 0; i < n; i++)
    {
        u = (HEX2BIN(ptr[0]) << 4) + HEX2BIN(ptr[1]);
        u |= ((HEX2BIN(ptr[2]) << 4) + HEX2BIN(ptr[3])) << 8;
        u |= ((HEX2BIN(ptr[4]) << 4) + HEX2BIN(ptr[5])) << 16;
   10650:	e183100e 	orr	r1, r3, lr
        u |= ((HEX2BIN(ptr[6]) << 4) + HEX2BIN(ptr[7])) << 24;
   10654:	e0823000 	add	r3, r2, r0
   10658:	e1813c03 	orr	r3, r1, r3, lsl #24
        *v++ = u;
   1065c:	e48a3004 	str	r3, [sl], #4
    /* prep text: hex2bin, multiples of 4 */
    n = (text->av_len + 7) / 8;
    out = malloc(n * 8);
    ptr = (unsigned char *)text->av_val;
    v = (uint32_t *) out;
    for (i = 0; i < n; i++)
   10660:	e15a000b 	cmp	sl, fp
   10664:	e2899008 	add	r9, r9, #8
   10668:	1affffc0 	bne	10570 <HandleInvoke.part.13+0xc30>
    
    /* http://www.movable-type.co.uk/scripts/tea-block.html */
#define MX (((z>>5)^(y<<2)) + ((y>>3)^(z<<4))) ^ ((sum^y) + (k[(p&3)^e]^z));
    z = v[n - 1];
    y = v[0];
    q = 6 + 52 / n;
   1066c:	e3a00034 	mov	r0, #52	; 0x34
   10670:	e59d100c 	ldr	r1, [sp, #12]
   10674:	eb002cde 	bl	1b9f4 <__aeabi_idiv>
    sum = q * DELTA;
   10678:	e59f93bc 	ldr	r9, [pc, #956]	; 10a3c <HandleInvoke.part.13+0x10fc>
    v = (uint32_t *) out;
    
    /* http://www.movable-type.co.uk/scripts/tea-block.html */
#define MX (((z>>5)^(y<<2)) + ((y>>3)^(z<<4))) ^ ((sum^y) + (k[(p&3)^e]^z));
    z = v[n - 1];
    y = v[0];
   1067c:	e59d3008 	ldr	r3, [sp, #8]
   10680:	e593c000 	ldr	ip, [r3]
   10684:	e1a0300c 	mov	r3, ip
    q = 6 + 52 / n;
   10688:	e2800006 	add	r0, r0, #6
    sum = q * DELTA;
    while (sum != 0)
   1068c:	e0190990 	muls	r9, r0, r9
   10690:	0a000041 	beq	1079c <HandleInvoke.part.13+0xe5c>
   10694:	e59d200c 	ldr	r2, [sp, #12]
   10698:	e58d401c 	str	r4, [sp, #28]
   1069c:	e242a107 	sub	sl, r2, #-1073741823	; 0xc0000001
   106a0:	e242b001 	sub	fp, r2, #1
   106a4:	e59d2008 	ldr	r2, [sp, #8]
   106a8:	e58d600c 	str	r6, [sp, #12]
   106ac:	e082110a 	add	r1, r2, sl, lsl #2
   106b0:	e082010b 	add	r0, r2, fp, lsl #2
   106b4:	e1a08002 	mov	r8, r2
   106b8:	e1a0a001 	mov	sl, r1
   106bc:	e1a04000 	mov	r4, r0
   106c0:	e58d5018 	str	r5, [sp, #24]
    {
        e = sum >> 2 & 3;
        for (p = n - 1; p > 0; p--)
   106c4:	e35b0000 	cmp	fp, #0
    y = v[0];
    q = 6 + 52 / n;
    sum = q * DELTA;
    while (sum != 0)
    {
        e = sum >> 2 & 3;
   106c8:	e1a06129 	lsr	r6, r9, #2
        for (p = n - 1; p > 0; p--)
   106cc:	da0000fa 	ble	10abc <HandleInvoke.part.13+0x117c>
   106d0:	e1a05004 	mov	r5, r4
   106d4:	e1a0e00b 	mov	lr, fp
            z = v[p - 1], y = v[p] -= MX;
   106d8:	e02e2006 	eor	r2, lr, r6
   106dc:	e28d1e16 	add	r1, sp, #352	; 0x160
   106e0:	e2022003 	and	r2, r2, #3
   106e4:	e0812102 	add	r2, r1, r2, lsl #2
   106e8:	e5150004 	ldr	r0, [r5, #-4]
   106ec:	e5121120 	ldr	r1, [r2, #-288]	; 0xfffffee0
   106f0:	e023c009 	eor	ip, r3, r9
   106f4:	e1a021a3 	lsr	r2, r3, #3
   106f8:	e1a03103 	lsl	r3, r3, #2
   106fc:	e02332a0 	eor	r3, r3, r0, lsr #5
   10700:	e0211000 	eor	r1, r1, r0
   10704:	e0222200 	eor	r2, r2, r0, lsl #4
   10708:	e0822003 	add	r2, r2, r3
   1070c:	e081100c 	add	r1, r1, ip
   10710:	e5953000 	ldr	r3, [r5]
   10714:	e0211002 	eor	r1, r1, r2
   10718:	e0613003 	rsb	r3, r1, r3
    q = 6 + 52 / n;
    sum = q * DELTA;
    while (sum != 0)
    {
        e = sum >> 2 & 3;
        for (p = n - 1; p > 0; p--)
   1071c:	e25ee001 	subs	lr, lr, #1
            z = v[p - 1], y = v[p] -= MX;
   10720:	e4053004 	str	r3, [r5], #-4
    q = 6 + 52 / n;
    sum = q * DELTA;
    while (sum != 0)
    {
        e = sum >> 2 & 3;
        for (p = n - 1; p > 0; p--)
   10724:	1affffeb 	bne	106d8 <HandleInvoke.part.13+0xd98>
   10728:	e598c000 	ldr	ip, [r8]
   1072c:	e3a02000 	mov	r2, #0
            z = v[p - 1], y = v[p] -= MX;
        z = v[n - 1];
        y = v[0] -= MX;
   10730:	e0222006 	eor	r2, r2, r6
   10734:	e28d1e16 	add	r1, sp, #352	; 0x160
   10738:	e2022003 	and	r2, r2, #3
   1073c:	e0812102 	add	r2, r1, r2, lsl #2
   10740:	e5120120 	ldr	r0, [r2, #-288]	; 0xfffffee0
    while (sum != 0)
    {
        e = sum >> 2 & 3;
        for (p = n - 1; p > 0; p--)
            z = v[p - 1], y = v[p] -= MX;
        z = v[n - 1];
   10744:	e59a1000 	ldr	r1, [sl]
        y = v[0] -= MX;
   10748:	e023e009 	eor	lr, r3, r9
   1074c:	e1a02201 	lsl	r2, r1, #4
   10750:	e0200001 	eor	r0, r0, r1
        sum -= DELTA;
   10754:	e2899461 	add	r9, r9, #1627389952	; 0x61000000
    {
        e = sum >> 2 & 3;
        for (p = n - 1; p > 0; p--)
            z = v[p - 1], y = v[p] -= MX;
        z = v[n - 1];
        y = v[0] -= MX;
   10758:	e1a012a1 	lsr	r1, r1, #5
   1075c:	e02221a3 	eor	r2, r2, r3, lsr #3
   10760:	e0211103 	eor	r1, r1, r3, lsl #2
        sum -= DELTA;
   10764:	e2899732 	add	r9, r9, #13107200	; 0xc80000
    {
        e = sum >> 2 & 3;
        for (p = n - 1; p > 0; p--)
            z = v[p - 1], y = v[p] -= MX;
        z = v[n - 1];
        y = v[0] -= MX;
   10768:	e080300e 	add	r3, r0, lr
        sum -= DELTA;
   1076c:	e2899c86 	add	r9, r9, #34304	; 0x8600
    {
        e = sum >> 2 & 3;
        for (p = n - 1; p > 0; p--)
            z = v[p - 1], y = v[p] -= MX;
        z = v[n - 1];
        y = v[0] -= MX;
   10770:	e0822001 	add	r2, r2, r1
        sum -= DELTA;
   10774:	e2899047 	add	r9, r9, #71	; 0x47
    {
        e = sum >> 2 & 3;
        for (p = n - 1; p > 0; p--)
            z = v[p - 1], y = v[p] -= MX;
        z = v[n - 1];
        y = v[0] -= MX;
   10778:	e0233002 	eor	r3, r3, r2
   1077c:	e063300c 	rsb	r3, r3, ip
#define MX (((z>>5)^(y<<2)) + ((y>>3)^(z<<4))) ^ ((sum^y) + (k[(p&3)^e]^z));
    z = v[n - 1];
    y = v[0];
    q = 6 + 52 / n;
    sum = q * DELTA;
    while (sum != 0)
   10780:	e3590000 	cmp	r9, #0
    {
        e = sum >> 2 & 3;
        for (p = n - 1; p > 0; p--)
            z = v[p - 1], y = v[p] -= MX;
        z = v[n - 1];
        y = v[0] -= MX;
   10784:	e5883000 	str	r3, [r8]
   10788:	e1a0c003 	mov	ip, r3
#define MX (((z>>5)^(y<<2)) + ((y>>3)^(z<<4))) ^ ((sum^y) + (k[(p&3)^e]^z));
    z = v[n - 1];
    y = v[0];
    q = 6 + 52 / n;
    sum = q * DELTA;
    while (sum != 0)
   1078c:	1affffcc 	bne	106c4 <HandleInvoke.part.13+0xd84>
   10790:	e59d600c 	ldr	r6, [sp, #12]
   10794:	e59d5018 	ldr	r5, [sp, #24]
   10798:	e59d401c 	ldr	r4, [sp, #28]
        z = v[n - 1];
        y = v[0] -= MX;
        sum -= DELTA;
    }
    
    text->av_len /= 2;
   1079c:	e59d3014 	ldr	r3, [sp, #20]
    memcpy(text->av_val, out, text->av_len);
   107a0:	e59d8008 	ldr	r8, [sp, #8]
        z = v[n - 1];
        y = v[0] -= MX;
        sum -= DELTA;
    }
    
    text->av_len /= 2;
   107a4:	e0839fa3 	add	r9, r3, r3, lsr #31
   107a8:	e1a090c9 	asr	r9, r9, #1
    memcpy(text->av_val, out, text->av_len);
   107ac:	e1a01008 	mov	r1, r8
   107b0:	e1a02009 	mov	r2, r9
   107b4:	e59d0010 	ldr	r0, [sp, #16]
        z = v[n - 1];
        y = v[0] -= MX;
        sum -= DELTA;
    }
    
    text->av_len /= 2;
   107b8:	e58d9074 	str	r9, [sp, #116]	; 0x74
    memcpy(text->av_val, out, text->av_len);
   107bc:	ebffd282 	bl	51cc <memcpy@plt>
    free(out);
   107c0:	e1a00008 	mov	r0, r8
   107c4:	ebffd20e 	bl	5004 <free@plt>
            {
                AMFObjectProperty p;
                if (RTMP_FindFirstMatchingProperty(&obj, &av_secureToken, &p))
                {
                    DecodeTEA(&r->Link.token, &p.p_vu.p_aval);
                    SendSecureTokenResponse(r, &p.p_vu.p_aval);
   107c8:	e1a00005 	mov	r0, r5
   107cc:	e28d1070 	add	r1, sp, #112	; 0x70
   107d0:	ebffee01 	bl	bfdc <SendSecureTokenResponse>
   107d4:	eafffe73 	b	101a8 <HandleInvoke.part.13+0x868>
        
        RTMP_Log(RTMP_LOGINFO, "%s, onStatus: %s", __FUNCTION__, code.av_val);
        if (AVMATCH(&code, &av_NetStream_Failed)
            || AVMATCH(&code, &av_NetStream_Publish_BadName)
            || AVMATCH(&code, &av_NetStream_Play_Failed)
            || AVMATCH(&code, &av_NetStream_Play_StreamNotFound)
   107d8:	e59f1260 	ldr	r1, [pc, #608]	; 10a40 <HandleInvoke.part.13+0x1100>
   107dc:	e1a02006 	mov	r2, r6
   107e0:	e59d0040 	ldr	r0, [sp, #64]	; 0x40
   107e4:	e08f1001 	add	r1, pc, r1
   107e8:	ebffd27a 	bl	51d8 <memcmp@plt>
   107ec:	e3500000 	cmp	r0, #0
   107f0:	0affff01 	beq	103fc <HandleInvoke.part.13+0xabc>
   107f4:	eafffcd0 	b	fb3c <HandleInvoke.part.13+0x1fc>
            || AVMATCH(&code, &av_NetConnection_Connect_InvalidApp))
   107f8:	e59f1244 	ldr	r1, [pc, #580]	; 10a44 <HandleInvoke.part.13+0x1104>
   107fc:	e59d0040 	ldr	r0, [sp, #64]	; 0x40
   10800:	e08f1001 	add	r1, pc, r1
   10804:	e3a02020 	mov	r2, #32
   10808:	ebffd272 	bl	51d8 <memcmp@plt>
   1080c:	e3500000 	cmp	r0, #0
   10810:	1afffcc9 	bne	fb3c <HandleInvoke.part.13+0x1fc>
   10814:	eafffef8 	b	103fc <HandleInvoke.part.13+0xabc>
            r->m_stream_id = -1;
            RTMP_Close(r);
            RTMP_Log(RTMP_LOGDEBUG, "Closing connection: %s", code.av_val);
        }
        
        else if (AVMATCH(&code, &av_NetStream_Play_Start)
   10818:	e59f1228 	ldr	r1, [pc, #552]	; 10a48 <HandleInvoke.part.13+0x1108>
   1081c:	e1a02006 	mov	r2, r6
   10820:	e59d0040 	ldr	r0, [sp, #64]	; 0x40
   10824:	e08f1001 	add	r1, pc, r1
   10828:	ebffd26a 	bl	51d8 <memcmp@plt>
   1082c:	e3500000 	cmp	r0, #0
   10830:	1afffcc1 	bne	fb3c <HandleInvoke.part.13+0x1fc>
                 || AVMATCH(&code, &av_NetStream_Play_PublishNotify))
        {
            int i;
            r->m_bPlaying = TRUE;
            for (i = 0; i < r->m_numCalls; i++)
   10834:	e595903c 	ldr	r9, [r5, #60]	; 0x3c
        
        else if (AVMATCH(&code, &av_NetStream_Play_Start)
                 || AVMATCH(&code, &av_NetStream_Play_PublishNotify))
        {
            int i;
            r->m_bPlaying = TRUE;
   10838:	e3a03001 	mov	r3, #1
            for (i = 0; i < r->m_numCalls; i++)
   1083c:	e3590000 	cmp	r9, #0
        
        else if (AVMATCH(&code, &av_NetStream_Play_Start)
                 || AVMATCH(&code, &av_NetStream_Play_PublishNotify))
        {
            int i;
            r->m_bPlaying = TRUE;
   10840:	e5c53035 	strb	r3, [r5, #53]	; 0x35
            for (i = 0; i < r->m_numCalls; i++)
   10844:	dafffcbc 	ble	fb3c <HandleInvoke.part.13+0x1fc>
   10848:	e595b040 	ldr	fp, [r5, #64]	; 0x40
            {
                if (AVMATCH(&r->m_methodCalls[i].name, &av_play))
   1084c:	e59fa1f8 	ldr	sl, [pc, #504]	; 10a4c <HandleInvoke.part.13+0x110c>
   10850:	e1a0600b 	mov	r6, fp
   10854:	e08fa00a 	add	sl, pc, sl
        else if (AVMATCH(&code, &av_NetStream_Play_Start)
                 || AVMATCH(&code, &av_NetStream_Play_PublishNotify))
        {
            int i;
            r->m_bPlaying = TRUE;
            for (i = 0; i < r->m_numCalls; i++)
   10858:	e3a07000 	mov	r7, #0
   1085c:	ea000003 	b	10870 <HandleInvoke.part.13+0xf30>
   10860:	e2877001 	add	r7, r7, #1
   10864:	e1570009 	cmp	r7, r9
   10868:	e286600c 	add	r6, r6, #12
   1086c:	0afffcb2 	beq	fb3c <HandleInvoke.part.13+0x1fc>
            {
                if (AVMATCH(&r->m_methodCalls[i].name, &av_play))
   10870:	e5962004 	ldr	r2, [r6, #4]
   10874:	e3520004 	cmp	r2, #4
   10878:	1afffff8 	bne	10860 <HandleInvoke.part.13+0xf20>
   1087c:	e5960000 	ldr	r0, [r6]
   10880:	e1a0100a 	mov	r1, sl
   10884:	ebffd253 	bl	51d8 <memcmp@plt>
   10888:	e3500000 	cmp	r0, #0
   1088c:	1afffff3 	bne	10860 <HandleInvoke.part.13+0xf20>
   10890:	eafffdd7 	b	fff4 <HandleInvoke.part.13+0x6b4>
            RTMP_Close(r);
            RTMP_Log(RTMP_LOGDEBUG, "Closing connection: %s", code.av_val);
        }
        
        else if (AVMATCH(&code, &av_NetStream_Play_Start)
                 || AVMATCH(&code, &av_NetStream_Play_PublishNotify))
   10894:	e59f11b4 	ldr	r1, [pc, #436]	; 10a50 <HandleInvoke.part.13+0x1110>
   10898:	e1a02006 	mov	r2, r6
   1089c:	e59d0040 	ldr	r0, [sp, #64]	; 0x40
   108a0:	e08f1001 	add	r1, pc, r1
   108a4:	ebffd24b 	bl	51d8 <memcmp@plt>
   108a8:	e3500000 	cmp	r0, #0
   108ac:	1afffca2 	bne	fb3c <HandleInvoke.part.13+0x1fc>
   108b0:	eaffffdf 	b	10834 <HandleInvoke.part.13+0xef4>
                    break;
                }
            }
        }
        
        else if (AVMATCH(&code, &av_NetStream_Publish_Start))
   108b4:	e59d7040 	ldr	r7, [sp, #64]	; 0x40
   108b8:	e59f1194 	ldr	r1, [pc, #404]	; 10a54 <HandleInvoke.part.13+0x1114>
   108bc:	e1a00007 	mov	r0, r7
   108c0:	e08f1001 	add	r1, pc, r1
   108c4:	e1a02006 	mov	r2, r6
   108c8:	ebffd242 	bl	51d8 <memcmp@plt>
   108cc:	e3500000 	cmp	r0, #0
   108d0:	1a000024 	bne	10968 <HandleInvoke.part.13+0x1028>
        {
            int i;
            r->m_bPlaying = TRUE;
            for (i = 0; i < r->m_numCalls; i++)
   108d4:	e595b03c 	ldr	fp, [r5, #60]	; 0x3c
        }
        
        else if (AVMATCH(&code, &av_NetStream_Publish_Start))
        {
            int i;
            r->m_bPlaying = TRUE;
   108d8:	e3a03001 	mov	r3, #1
            for (i = 0; i < r->m_numCalls; i++)
   108dc:	e35b0000 	cmp	fp, #0
        }
        
        else if (AVMATCH(&code, &av_NetStream_Publish_Start))
        {
            int i;
            r->m_bPlaying = TRUE;
   108e0:	e5c53035 	strb	r3, [r5, #53]	; 0x35
            for (i = 0; i < r->m_numCalls; i++)
   108e4:	dafffc94 	ble	fb3c <HandleInvoke.part.13+0x1fc>
   108e8:	e595a040 	ldr	sl, [r5, #64]	; 0x40
            {
                if (AVMATCH(&r->m_methodCalls[i].name, &av_publish))
   108ec:	e59f9164 	ldr	r9, [pc, #356]	; 10a58 <HandleInvoke.part.13+0x1118>
        
        else if (AVMATCH(&code, &av_NetStream_Publish_Start))
        {
            int i;
            r->m_bPlaying = TRUE;
            for (i = 0; i < r->m_numCalls; i++)
   108f0:	e1a07000 	mov	r7, r0
            {
                if (AVMATCH(&r->m_methodCalls[i].name, &av_publish))
   108f4:	e08f9009 	add	r9, pc, r9
   108f8:	e1a0600a 	mov	r6, sl
   108fc:	ea000003 	b	10910 <HandleInvoke.part.13+0xfd0>
        
        else if (AVMATCH(&code, &av_NetStream_Publish_Start))
        {
            int i;
            r->m_bPlaying = TRUE;
            for (i = 0; i < r->m_numCalls; i++)
   10900:	e2877001 	add	r7, r7, #1
   10904:	e157000b 	cmp	r7, fp
   10908:	e286600c 	add	r6, r6, #12
   1090c:	0afffc8a 	beq	fb3c <HandleInvoke.part.13+0x1fc>
            {
                if (AVMATCH(&r->m_methodCalls[i].name, &av_publish))
   10910:	e5962004 	ldr	r2, [r6, #4]
   10914:	e3520007 	cmp	r2, #7
   10918:	1afffff8 	bne	10900 <HandleInvoke.part.13+0xfc0>
   1091c:	e5960000 	ldr	r0, [r6]
   10920:	e1a01009 	mov	r1, r9
   10924:	ebffd22b 	bl	51d8 <memcmp@plt>
   10928:	e3500000 	cmp	r0, #0
   1092c:	1afffff3 	bne	10900 <HandleInvoke.part.13+0xfc0>
   10930:	eafffc55 	b	fa8c <HandleInvoke.part.13+0x14c>
            
            if (!(r->Link.protocol & RTMP_FEATURE_WRITE))
            {
                /* Authenticate on Justin.tv legacy servers before sending FCSubscribe */
                if (r->Link.usherToken.av_len)
                    SendUsherToken(r, &r->Link.usherToken);
   10934:	e2851c41 	add	r1, r5, #16640	; 0x4100
   10938:	e281104c 	add	r1, r1, #76	; 0x4c
   1093c:	e1a00005 	mov	r0, r5
   10940:	ebffee3a 	bl	c230 <SendUsherToken>
   10944:	eafffe26 	b	101e4 <HandleInvoke.part.13+0x8a4>
                /* Send the FCSubscribe if live stream or if subscribepath is set */
                if (r->Link.subscribepath.av_len)
                    SendFCSubscribe(r, &r->Link.subscribepath);
   10948:	e2851c41 	add	r1, r5, #16640	; 0x4100
   1094c:	e2811044 	add	r1, r1, #68	; 0x44
   10950:	e1a00005 	mov	r0, r5
   10954:	ebffee70 	bl	c31c <SendFCSubscribe>
   10958:	eafffde7 	b	100fc <HandleInvoke.part.13+0x7bc>
        {
            r->m_stream_id = (int)AMFProp_GetNumber(AMF_GetProp(&obj, NULL, 3));
            
            if (r->Link.protocol & RTMP_FEATURE_WRITE)
            {
                SendPublish(r);
   1095c:	e1a00005 	mov	r0, r5
   10960:	ebffeea6 	bl	c400 <SendPublish>
   10964:	eafffde4 	b	100fc <HandleInvoke.part.13+0x7bc>
                }
            }
        }
        
        /* Return 1 if this is a Play.Complete or Play.Stop */
        else if (AVMATCH(&code, &av_NetStream_Play_Complete)
   10968:	e59f10ec 	ldr	r1, [pc, #236]	; 10a5c <HandleInvoke.part.13+0x111c>
   1096c:	e1a00007 	mov	r0, r7
   10970:	e1a02006 	mov	r2, r6
   10974:	e08f1001 	add	r1, pc, r1
   10978:	ebffd216 	bl	51d8 <memcmp@plt>
   1097c:	e3500000 	cmp	r0, #0
   10980:	0afffd1b 	beq	fdf4 <HandleInvoke.part.13+0x4b4>
   10984:	eafffc6c 	b	fb3c <HandleInvoke.part.13+0x1fc>
   10988:	0000ee40 	.word	0x0000ee40
   1098c:	00010184 	.word	0x00010184
   10990:	0001041c 	.word	0x0001041c
   10994:	00010404 	.word	0x00010404
   10998:	000100a8 	.word	0x000100a8
   1099c:	0000ecc0 	.word	0x0000ecc0
   109a0:	00010030 	.word	0x00010030
   109a4:	00010084 	.word	0x00010084
   109a8:	00010138 	.word	0x00010138
   109ac:	00013ca4 	.word	0x00013ca4
   109b0:	000100d4 	.word	0x000100d4
   109b4:	000101cc 	.word	0x000101cc
   109b8:	0000ff84 	.word	0x0000ff84
   109bc:	0000ea90 	.word	0x0000ea90
   109c0:	0000fe00 	.word	0x0000fe00
   109c4:	0000ff14 	.word	0x0000ff14
   109c8:	0000ff00 	.word	0x0000ff00
   109cc:	0000ea2c 	.word	0x0000ea2c
   109d0:	0000fd58 	.word	0x0000fd58
   109d4:	0000fe0c 	.word	0x0000fe0c
   109d8:	0000fdf0 	.word	0x0000fdf0
   109dc:	00013a18 	.word	0x00013a18
   109e0:	0000fd4c 	.word	0x0000fd4c
   109e4:	0001396c 	.word	0x0001396c
   109e8:	0000fc84 	.word	0x0000fc84
   109ec:	0000fc68 	.word	0x0000fc68
   109f0:	00013824 	.word	0x00013824
   109f4:	0000e718 	.word	0x0000e718
   109f8:	0000fac0 	.word	0x0000fac0
   109fc:	0000fab8 	.word	0x0000fab8
   10a00:	0000fa40 	.word	0x0000fa40
   10a04:	0000f9c0 	.word	0x0000f9c0
   10a08:	0000e290 	.word	0x0000e290
   10a0c:	0000e554 	.word	0x0000e554
   10a10:	0000f994 	.word	0x0000f994
   10a14:	0000f9ac 	.word	0x0000f9ac
   10a18:	0000f8e0 	.word	0x0000f8e0
   10a1c:	0001353c 	.word	0x0001353c
   10a20:	0000f8f0 	.word	0x0000f8f0
   10a24:	0000f8e8 	.word	0x0000f8e8
   10a28:	0000f94c 	.word	0x0000f94c
   10a2c:	0000f8b4 	.word	0x0000f8b4
   10a30:	0000f8b0 	.word	0x0000f8b0
   10a34:	0000f9a0 	.word	0x0000f9a0
   10a38:	000133a8 	.word	0x000133a8
   10a3c:	9e3779b9 	.word	0x9e3779b9
   10a40:	0000f538 	.word	0x0000f538
   10a44:	0000f53c 	.word	0x0000f53c
   10a48:	0000f554 	.word	0x0000f554
   10a4c:	0000f388 	.word	0x0000f388
   10a50:	0000f4f0 	.word	0x0000f4f0
   10a54:	0000f4f0 	.word	0x0000f4f0
   10a58:	0000dbe0 	.word	0x0000dbe0
   10a5c:	0000f454 	.word	0x0000f454
   10a60:	0000f364 	.word	0x0000f364
   10a64:	0000f34c 	.word	0x0000f34c
HandleInvoke(RTMP *r, const char *body, unsigned int nBodySize)
{
    AMFObject obj;
    AVal method;
    double txn;
    int ret = 0, nRes;
   10a68:	e1a08000 	mov	r8, r0
   10a6c:	eafffc33 	b	fb40 <HandleInvoke.part.13+0x200>
            }
        }
        
        /* Return 1 if this is a Play.Complete or Play.Stop */
        else if (AVMATCH(&code, &av_NetStream_Play_Complete)
                 || AVMATCH(&code, &av_NetStream_Play_Stop)
   10a70:	e51f1018 	ldr	r1, [pc, #-24]	; 10a60 <HandleInvoke.part.13+0x1120>
   10a74:	e1a02006 	mov	r2, r6
   10a78:	e59d0040 	ldr	r0, [sp, #64]	; 0x40
   10a7c:	e08f1001 	add	r1, pc, r1
   10a80:	ebffd1d4 	bl	51d8 <memcmp@plt>
   10a84:	e3500000 	cmp	r0, #0
   10a88:	0afffcd9 	beq	fdf4 <HandleInvoke.part.13+0x4b4>
   10a8c:	eafffc2a 	b	fb3c <HandleInvoke.part.13+0x1fc>
                SendPublish(r);
            }
            else
            {
                if (r->Link.lFlags & RTMP_LF_PLST)
                    SendPlaylist(r);
   10a90:	e1a00005 	mov	r0, r5
   10a94:	ebffee96 	bl	c4f4 <SendPlaylist>
   10a98:	eafffdaf 	b	1015c <HandleInvoke.part.13+0x81c>
        }
        
        /* Return 1 if this is a Play.Complete or Play.Stop */
        else if (AVMATCH(&code, &av_NetStream_Play_Complete)
                 || AVMATCH(&code, &av_NetStream_Play_Stop)
                 || AVMATCH(&code, &av_NetStream_Play_UnpublishNotify))
   10a9c:	e51f1040 	ldr	r1, [pc, #-64]	; 10a64 <HandleInvoke.part.13+0x1124>
   10aa0:	e1a02006 	mov	r2, r6
   10aa4:	e59d0040 	ldr	r0, [sp, #64]	; 0x40
   10aa8:	e08f1001 	add	r1, pc, r1
   10aac:	ebffd1c9 	bl	51d8 <memcmp@plt>
   10ab0:	e3500000 	cmp	r0, #0
   10ab4:	1afffc20 	bne	fb3c <HandleInvoke.part.13+0x1fc>
   10ab8:	eafffccd 	b	fdf4 <HandleInvoke.part.13+0x4b4>
    q = 6 + 52 / n;
    sum = q * DELTA;
    while (sum != 0)
    {
        e = sum >> 2 & 3;
        for (p = n - 1; p > 0; p--)
   10abc:	e1a0200b 	mov	r2, fp
   10ac0:	eaffff1a 	b	10730 <HandleInvoke.part.13+0xdf0>

00010ac4 <RTMP_ClientPacket>:
    return bHasMediaPacket;
}

int
RTMP_ClientPacket(RTMP *r, RTMPPacket *packet)
{
   10ac4:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
    //LOGE(" ===== RTMP_ClientPacket()   packet type:%d \n",packet->m_packetType);
    int bHasMediaPacket = 0;
    switch (packet->m_packetType)
   10ac8:	e5d13001 	ldrb	r3, [r1, #1]
    return bHasMediaPacket;
}

int
RTMP_ClientPacket(RTMP *r, RTMPPacket *packet)
{
   10acc:	e24dd00c 	sub	sp, sp, #12
    //LOGE(" ===== RTMP_ClientPacket()   packet type:%d \n",packet->m_packetType);
    int bHasMediaPacket = 0;
    switch (packet->m_packetType)
   10ad0:	e2432001 	sub	r2, r3, #1
    return bHasMediaPacket;
}

int
RTMP_ClientPacket(RTMP *r, RTMPPacket *packet)
{
   10ad4:	e1a04001 	mov	r4, r1
   10ad8:	e1a07000 	mov	r7, r0
    //LOGE(" ===== RTMP_ClientPacket()   packet type:%d \n",packet->m_packetType);
    int bHasMediaPacket = 0;
    switch (packet->m_packetType)
   10adc:	e3520015 	cmp	r2, #21
   10ae0:	908ff102 	addls	pc, pc, r2, lsl #2
   10ae4:	ea000104 	b	10efc <RTMP_ClientPacket+0x438>
   10ae8:	ea00007c 	b	10ce0 <RTMP_ClientPacket+0x21c>
   10aec:	ea000102 	b	10efc <RTMP_ClientPacket+0x438>
   10af0:	ea00007f 	b	10cf4 <RTMP_ClientPacket+0x230>
   10af4:	ea000088 	b	10d1c <RTMP_ClientPacket+0x258>
   10af8:	ea0000be 	b	10df8 <RTMP_ClientPacket+0x334>
   10afc:	ea0000cb 	b	10e30 <RTMP_ClientPacket+0x36c>
   10b00:	ea0000fd 	b	10efc <RTMP_ClientPacket+0x438>
   10b04:	ea00000d 	b	10b40 <RTMP_ClientPacket+0x7c>
   10b08:	ea00000c 	b	10b40 <RTMP_ClientPacket+0x7c>
   10b0c:	ea0000fa 	b	10efc <RTMP_ClientPacket+0x438>
   10b10:	ea0000f9 	b	10efc <RTMP_ClientPacket+0x438>
   10b14:	ea0000f8 	b	10efc <RTMP_ClientPacket+0x438>
   10b18:	ea0000f7 	b	10efc <RTMP_ClientPacket+0x438>
   10b1c:	ea0000f6 	b	10efc <RTMP_ClientPacket+0x438>
   10b20:	ea000012 	b	10b70 <RTMP_ClientPacket+0xac>
   10b24:	ea000044 	b	10c3c <RTMP_ClientPacket+0x178>
   10b28:	ea00001b 	b	10b9c <RTMP_ClientPacket+0xd8>
   10b2c:	ea000032 	b	10bfc <RTMP_ClientPacket+0x138>
   10b30:	ea00004c 	b	10c68 <RTMP_ClientPacket+0x1a4>
   10b34:	ea000055 	b	10c90 <RTMP_ClientPacket+0x1cc>
   10b38:	ea0000ef 	b	10efc <RTMP_ClientPacket+0x438>
   10b3c:	ea0000d0 	b	10e84 <RTMP_ClientPacket+0x3c0>
        case RTMP_PACKET_TYPE_VIDEO:
            /* video data */
            /*RTMP_Log(RTMP_LOGDEBUG, "%s, received: video %lu bytes", __FUNCTION__, packet.m_nBodySize); */
            HandleVideo(r, packet);
            bHasMediaPacket = 1;
            if (!r->m_mediaChannel)
   10b40:	e590301c 	ldr	r3, [r0, #28]
   10b44:	e3530000 	cmp	r3, #0
                r->m_mediaChannel = packet->m_nChannel;
   10b48:	05913004 	ldreq	r3, [r1, #4]
   10b4c:	0580301c 	streq	r3, [r0, #28]
            if (!r->m_pausing)
   10b50:	e5903028 	ldr	r3, [r0, #40]	; 0x28
   10b54:	e3530000 	cmp	r3, #0
   10b58:	1a0000f8 	bne	10f40 <RTMP_ClientPacket+0x47c>
                r->m_mediaStamp = packet->m_nTimeStamp;
   10b5c:	e5913008 	ldr	r3, [r1, #8]
   10b60:	e5803020 	str	r3, [r0, #32]
            
        case RTMP_PACKET_TYPE_VIDEO:
            /* video data */
            /*RTMP_Log(RTMP_LOGDEBUG, "%s, received: video %lu bytes", __FUNCTION__, packet.m_nBodySize); */
            HandleVideo(r, packet);
            bHasMediaPacket = 1;
   10b64:	e3a00001 	mov	r0, #1
            RTMP_LogHex(RTMP_LOGDEBUG, packet->m_body, packet->m_nBodySize);
#endif
    }
    
    return bHasMediaPacket;
}
   10b68:	e28dd00c 	add	sp, sp, #12
   10b6c:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
                r->m_mediaStamp = packet->m_nTimeStamp;
            break;
            
        case RTMP_PACKET_TYPE_FLEX_STREAM_SEND:
            /* flex stream send */
            RTMP_Log(RTMP_LOGDEBUG,
   10b70:	e59f2784 	ldr	r2, [pc, #1924]	; 112fc <RTMP_ClientPacket+0x838>
   10b74:	e5913010 	ldr	r3, [r1, #16]
   10b78:	e08f2002 	add	r2, pc, r2
   10b7c:	e59f177c 	ldr	r1, [pc, #1916]	; 11300 <RTMP_ClientPacket+0x83c>
   10b80:	e2422eab 	sub	r2, r2, #2736	; 0xab0
   10b84:	e3a00004 	mov	r0, #4
   10b88:	e242200c 	sub	r2, r2, #12
   10b8c:	e08f1001 	add	r1, pc, r1
   10b90:	eb001385 	bl	159ac <RTMP_Log>

int
RTMP_ClientPacket(RTMP *r, RTMPPacket *packet)
{
    //LOGE(" ===== RTMP_ClientPacket()   packet type:%d \n",packet->m_packetType);
    int bHasMediaPacket = 0;
   10b94:	e3a00000 	mov	r0, #0
        case RTMP_PACKET_TYPE_FLEX_STREAM_SEND:
            /* flex stream send */
            RTMP_Log(RTMP_LOGDEBUG,
                     "%s, flex stream send, size %u bytes, not supported, ignoring",
                     __FUNCTION__, packet->m_nBodySize);
            break;
   10b98:	eafffff2 	b	10b68 <RTMP_ClientPacket+0xa4>
            break;
            
        case RTMP_PACKET_TYPE_FLEX_MESSAGE:
            /* flex message */
        {
            RTMP_Log(RTMP_LOGDEBUG,
   10b9c:	e59f2760 	ldr	r2, [pc, #1888]	; 11304 <RTMP_ClientPacket+0x840>
   10ba0:	e59f1760 	ldr	r1, [pc, #1888]	; 11308 <RTMP_ClientPacket+0x844>
   10ba4:	e08f2002 	add	r2, pc, r2
   10ba8:	e2422eab 	sub	r2, r2, #2736	; 0xab0
   10bac:	e242200c 	sub	r2, r2, #12
   10bb0:	e08f1001 	add	r1, pc, r1
   10bb4:	e5943010 	ldr	r3, [r4, #16]
   10bb8:	e3a00004 	mov	r0, #4
   10bbc:	eb00137a 	bl	159ac <RTMP_Log>
                     "%s, flex message, size %u bytes, not fully supported",
                     __FUNCTION__, packet->m_nBodySize);
            /*RTMP_LogHex(packet.m_body, packet.m_nBodySize); */
            
            if (HandleInvoke(r, packet->m_body + 1, packet->m_nBodySize - 1) == 1)
   10bc0:	e594101c 	ldr	r1, [r4, #28]
   10bc4:	e5942010 	ldr	r2, [r4, #16]
{
    AMFObject obj;
    AVal method;
    double txn;
    int ret = 0, nRes;
    if (body[0] != 0x02)		/* make sure it is a string method name we start with */
   10bc8:	e5d13001 	ldrb	r3, [r1, #1]
   10bcc:	e3530002 	cmp	r3, #2
   10bd0:	0a000133 	beq	110a4 <RTMP_ClientPacket+0x5e0>
    {
        RTMP_Log(RTMP_LOGWARNING, "%s, Sanity failed. no string method in invoke packet",
   10bd4:	e59f2730 	ldr	r2, [pc, #1840]	; 1130c <RTMP_ClientPacket+0x848>
   10bd8:	e59f1730 	ldr	r1, [pc, #1840]	; 11310 <RTMP_ClientPacket+0x84c>
   10bdc:	e08f2002 	add	r2, pc, r2
   10be0:	e2422eae 	sub	r2, r2, #2784	; 0xae0
   10be4:	e3a00002 	mov	r0, #2
   10be8:	e2422004 	sub	r2, r2, #4
   10bec:	e08f1001 	add	r1, pc, r1
   10bf0:	eb00136d 	bl	159ac <RTMP_Log>

int
RTMP_ClientPacket(RTMP *r, RTMPPacket *packet)
{
    //LOGE(" ===== RTMP_ClientPacket()   packet type:%d \n",packet->m_packetType);
    int bHasMediaPacket = 0;
   10bf4:	e3a00000 	mov	r0, #0
   10bf8:	eaffffda 	b	10b68 <RTMP_ClientPacket+0xa4>
                bHasMediaPacket = 2;
            break;
        }
        case RTMP_PACKET_TYPE_INFO:
            /* metadata (notify) */
            RTMP_Log(RTMP_LOGDEBUG, "%s, received: notify %u bytes", __FUNCTION__,
   10bfc:	e59f2710 	ldr	r2, [pc, #1808]	; 11314 <RTMP_ClientPacket+0x850>
   10c00:	e59f1710 	ldr	r1, [pc, #1808]	; 11318 <RTMP_ClientPacket+0x854>
   10c04:	e08f2002 	add	r2, pc, r2
   10c08:	e2422eab 	sub	r2, r2, #2736	; 0xab0
   10c0c:	e3a00004 	mov	r0, #4
   10c10:	e242200c 	sub	r2, r2, #12
   10c14:	e08f1001 	add	r1, pc, r1
   10c18:	e5943010 	ldr	r3, [r4, #16]
   10c1c:	eb001362 	bl	159ac <RTMP_Log>
                     packet->m_nBodySize);
            if (HandleMetadata(r, packet->m_body, packet->m_nBodySize))
   10c20:	e1a00007 	mov	r0, r7
   10c24:	e594101c 	ldr	r1, [r4, #28]
   10c28:	e5942010 	ldr	r2, [r4, #16]
   10c2c:	ebffe3f4 	bl	9c04 <HandleMetadata>
   10c30:	e2900000 	adds	r0, r0, #0
   10c34:	13a00001 	movne	r0, #1
   10c38:	eaffffca 	b	10b68 <RTMP_ClientPacket+0xa4>
                     __FUNCTION__, packet->m_nBodySize);
            break;
            
        case RTMP_PACKET_TYPE_FLEX_SHARED_OBJECT:
            /* flex shared object */
            RTMP_Log(RTMP_LOGDEBUG,
   10c3c:	e59f26d8 	ldr	r2, [pc, #1752]	; 1131c <RTMP_ClientPacket+0x858>
   10c40:	e5913010 	ldr	r3, [r1, #16]
   10c44:	e08f2002 	add	r2, pc, r2
   10c48:	e59f16d0 	ldr	r1, [pc, #1744]	; 11320 <RTMP_ClientPacket+0x85c>
   10c4c:	e2422eab 	sub	r2, r2, #2736	; 0xab0
   10c50:	e3a00004 	mov	r0, #4
   10c54:	e242200c 	sub	r2, r2, #12
   10c58:	e08f1001 	add	r1, pc, r1
   10c5c:	eb001352 	bl	159ac <RTMP_Log>

int
RTMP_ClientPacket(RTMP *r, RTMPPacket *packet)
{
    //LOGE(" ===== RTMP_ClientPacket()   packet type:%d \n",packet->m_packetType);
    int bHasMediaPacket = 0;
   10c60:	e3a00000 	mov	r0, #0
        case RTMP_PACKET_TYPE_FLEX_SHARED_OBJECT:
            /* flex shared object */
            RTMP_Log(RTMP_LOGDEBUG,
                     "%s, flex shared object, size %u bytes, not supported, ignoring",
                     __FUNCTION__, packet->m_nBodySize);
            break;
   10c64:	eaffffbf 	b	10b68 <RTMP_ClientPacket+0xa4>
            if (HandleMetadata(r, packet->m_body, packet->m_nBodySize))
                bHasMediaPacket = 1;
            break;
            
        case RTMP_PACKET_TYPE_SHARED_OBJECT:
            RTMP_Log(RTMP_LOGDEBUG, "%s, shared object, not supported, ignoring",
   10c68:	e59f26b4 	ldr	r2, [pc, #1716]	; 11324 <RTMP_ClientPacket+0x860>
   10c6c:	e59f16b4 	ldr	r1, [pc, #1716]	; 11328 <RTMP_ClientPacket+0x864>
   10c70:	e08f2002 	add	r2, pc, r2
   10c74:	e2422eab 	sub	r2, r2, #2736	; 0xab0
   10c78:	e3a00004 	mov	r0, #4
   10c7c:	e242200c 	sub	r2, r2, #12
   10c80:	e08f1001 	add	r1, pc, r1
   10c84:	eb001348 	bl	159ac <RTMP_Log>

int
RTMP_ClientPacket(RTMP *r, RTMPPacket *packet)
{
    //LOGE(" ===== RTMP_ClientPacket()   packet type:%d \n",packet->m_packetType);
    int bHasMediaPacket = 0;
   10c88:	e3a00000 	mov	r0, #0
            break;
            
        case RTMP_PACKET_TYPE_SHARED_OBJECT:
            RTMP_Log(RTMP_LOGDEBUG, "%s, shared object, not supported, ignoring",
                     __FUNCTION__);
            break;
   10c8c:	eaffffb5 	b	10b68 <RTMP_ClientPacket+0xa4>
            
        case RTMP_PACKET_TYPE_INVOKE:
            /* invoke */
            RTMP_Log(RTMP_LOGDEBUG, "%s, received: invoke %u bytes", __FUNCTION__,
   10c90:	e59f2694 	ldr	r2, [pc, #1684]	; 1132c <RTMP_ClientPacket+0x868>
   10c94:	e59f1694 	ldr	r1, [pc, #1684]	; 11330 <RTMP_ClientPacket+0x86c>
   10c98:	e08f2002 	add	r2, pc, r2
   10c9c:	e2422eab 	sub	r2, r2, #2736	; 0xab0
   10ca0:	e242200c 	sub	r2, r2, #12
   10ca4:	e08f1001 	add	r1, pc, r1
   10ca8:	e5943010 	ldr	r3, [r4, #16]
   10cac:	e3a00004 	mov	r0, #4
   10cb0:	eb00133d 	bl	159ac <RTMP_Log>
                     packet->m_nBodySize);
            /*RTMP_LogHex(packet.m_body, packet.m_nBodySize); */
            
            if (HandleInvoke(r, packet->m_body, packet->m_nBodySize) == 1)
   10cb4:	e594101c 	ldr	r1, [r4, #28]
   10cb8:	e5942010 	ldr	r2, [r4, #16]
{
    AMFObject obj;
    AVal method;
    double txn;
    int ret = 0, nRes;
    if (body[0] != 0x02)		/* make sure it is a string method name we start with */
   10cbc:	e5d13000 	ldrb	r3, [r1]
   10cc0:	e3530002 	cmp	r3, #2
   10cc4:	1affffc2 	bne	10bd4 <RTMP_ClientPacket+0x110>
   10cc8:	e1a00007 	mov	r0, r7
   10ccc:	ebfffb1b 	bl	f940 <HandleInvoke.part.13>
            /* invoke */
            RTMP_Log(RTMP_LOGDEBUG, "%s, received: invoke %u bytes", __FUNCTION__,
                     packet->m_nBodySize);
            /*RTMP_LogHex(packet.m_body, packet.m_nBodySize); */
            
            if (HandleInvoke(r, packet->m_body, packet->m_nBodySize) == 1)
   10cd0:	e3500001 	cmp	r0, #1
   10cd4:	1a000004 	bne	10cec <RTMP_ClientPacket+0x228>
                     "%s, flex message, size %u bytes, not fully supported",
                     __FUNCTION__, packet->m_nBodySize);
            /*RTMP_LogHex(packet.m_body, packet.m_nBodySize); */
            
            if (HandleInvoke(r, packet->m_body + 1, packet->m_nBodySize - 1) == 1)
                bHasMediaPacket = 2;
   10cd8:	e3a00002 	mov	r0, #2
   10cdc:	eaffffa1 	b	10b68 <RTMP_ClientPacket+0xa4>
}

static void
HandleChangeChunkSize(RTMP *r, const RTMPPacket *packet)
{
    if (packet->m_nBodySize >= 4)
   10ce0:	e5913010 	ldr	r3, [r1, #16]
   10ce4:	e3530003 	cmp	r3, #3
   10ce8:	8a0000df 	bhi	1106c <RTMP_ClientPacket+0x5a8>

int
RTMP_ClientPacket(RTMP *r, RTMPPacket *packet)
{
    //LOGE(" ===== RTMP_ClientPacket()   packet type:%d \n",packet->m_packetType);
    int bHasMediaPacket = 0;
   10cec:	e3a00000 	mov	r0, #0
   10cf0:	eaffff9c 	b	10b68 <RTMP_ClientPacket+0xa4>
            HandleChangeChunkSize(r, packet);
            break;
            
        case RTMP_PACKET_TYPE_BYTES_READ_REPORT:
            /* bytes read report */
            RTMP_Log(RTMP_LOGDEBUG, "%s, received: bytes read report", __FUNCTION__);
   10cf4:	e59f2638 	ldr	r2, [pc, #1592]	; 11334 <RTMP_ClientPacket+0x870>
   10cf8:	e59f1638 	ldr	r1, [pc, #1592]	; 11338 <RTMP_ClientPacket+0x874>
   10cfc:	e08f2002 	add	r2, pc, r2
   10d00:	e2422eab 	sub	r2, r2, #2736	; 0xab0
   10d04:	e3a00004 	mov	r0, #4
   10d08:	e242200c 	sub	r2, r2, #12
   10d0c:	e08f1001 	add	r1, pc, r1
   10d10:	eb001325 	bl	159ac <RTMP_Log>

int
RTMP_ClientPacket(RTMP *r, RTMPPacket *packet)
{
    //LOGE(" ===== RTMP_ClientPacket()   packet type:%d \n",packet->m_packetType);
    int bHasMediaPacket = 0;
   10d14:	e3a00000 	mov	r0, #0
            break;
            
        case RTMP_PACKET_TYPE_BYTES_READ_REPORT:
            /* bytes read report */
            RTMP_Log(RTMP_LOGDEBUG, "%s, received: bytes read report", __FUNCTION__);
            break;
   10d18:	eaffff92 	b	10b68 <RTMP_ClientPacket+0xa4>
static void
HandleCtrl(RTMP *r, const RTMPPacket *packet)
{
    short nType = -1;
    unsigned int tmp;
    if (packet->m_body && packet->m_nBodySize >= 2)
   10d1c:	e591001c 	ldr	r0, [r1, #28]
   10d20:	e5913010 	ldr	r3, [r1, #16]
   10d24:	e3500000 	cmp	r0, #0
   10d28:	0a0000b4 	beq	11000 <RTMP_ClientPacket+0x53c>
   10d2c:	e3530001 	cmp	r3, #1
   10d30:	9a0000b2 	bls	11000 <RTMP_ClientPacket+0x53c>
        nType = AMF_DecodeInt16(packet->m_body);
   10d34:	eb00144a 	bl	15e64 <AMF_DecodeInt16>
    RTMP_Log(RTMP_LOGDEBUG, "%s, received ctrl. type: %d, len: %d", __FUNCTION__, nType,
   10d38:	e59f25fc 	ldr	r2, [pc, #1532]	; 1133c <RTMP_ClientPacket+0x878>
   10d3c:	e5941010 	ldr	r1, [r4, #16]
   10d40:	e58d1000 	str	r1, [sp]
   10d44:	e08f2002 	add	r2, pc, r2
   10d48:	e59f15f0 	ldr	r1, [pc, #1520]	; 11340 <RTMP_ClientPacket+0x87c>
   10d4c:	e2422eaa 	sub	r2, r2, #2720	; 0xaa0
   10d50:	e2422008 	sub	r2, r2, #8
   10d54:	e08f1001 	add	r1, pc, r1
   10d58:	e1a06800 	lsl	r6, r0, #16
   10d5c:	e1a03846 	asr	r3, r6, #16
HandleCtrl(RTMP *r, const RTMPPacket *packet)
{
    short nType = -1;
    unsigned int tmp;
    if (packet->m_body && packet->m_nBodySize >= 2)
        nType = AMF_DecodeInt16(packet->m_body);
   10d60:	e1a05000 	mov	r5, r0
    RTMP_Log(RTMP_LOGDEBUG, "%s, received ctrl. type: %d, len: %d", __FUNCTION__, nType,
   10d64:	e3a00004 	mov	r0, #4
   10d68:	eb00130f 	bl	159ac <RTMP_Log>
             packet->m_nBodySize);
    /*RTMP_LogHex(packet.m_body, packet.m_nBodySize); */
    
    if (packet->m_nBodySize >= 6)
   10d6c:	e5943010 	ldr	r3, [r4, #16]
   10d70:	e3530005 	cmp	r3, #5
   10d74:	8a00007d 	bhi	10f70 <RTMP_ClientPacket+0x4ac>
                break;
        }
        
    }
    
    if (nType == 0x1A)
   10d78:	e356081a 	cmp	r6, #1703936	; 0x1a0000
   10d7c:	1affffda 	bne	10cec <RTMP_ClientPacket+0x228>
    {
        RTMP_Log(RTMP_LOGDEBUG, "%s, SWFVerification ping received: ", __FUNCTION__);
   10d80:	e59f55bc 	ldr	r5, [pc, #1468]	; 11344 <RTMP_ClientPacket+0x880>
   10d84:	e59f15bc 	ldr	r1, [pc, #1468]	; 11348 <RTMP_ClientPacket+0x884>
   10d88:	e08f5005 	add	r5, pc, r5
   10d8c:	e2455eaa 	sub	r5, r5, #2720	; 0xaa0
   10d90:	e2455008 	sub	r5, r5, #8
   10d94:	e3a00004 	mov	r0, #4
   10d98:	e1a02005 	mov	r2, r5
   10d9c:	e08f1001 	add	r1, pc, r1
   10da0:	eb001301 	bl	159ac <RTMP_Log>
        if (packet->m_nBodySize > 2 && packet->m_body[2] > 0x01)
   10da4:	e5943010 	ldr	r3, [r4, #16]
   10da8:	e3530002 	cmp	r3, #2
   10dac:	9a000003 	bls	10dc0 <RTMP_ClientPacket+0x2fc>
   10db0:	e594301c 	ldr	r3, [r4, #28]
   10db4:	e5d33002 	ldrb	r3, [r3, #2]
   10db8:	e3530001 	cmp	r3, #1
   10dbc:	8a00013e 	bhi	112bc <RTMP_ClientPacket+0x7f8>
        }
#ifdef CRYPTO
        /*RTMP_LogHex(packet.m_body, packet.m_nBodySize); */
        
        /* respond with HMAC SHA256 of decompressed SWF, key is the 30byte player key, also the last 30 bytes of the server handshake are applied */
        else if (r->Link.SWFSize)
   10dc0:	e2873901 	add	r3, r7, #16384	; 0x4000
   10dc4:	e59341a4 	ldr	r4, [r3, #420]	; 0x1a4
   10dc8:	e3540000 	cmp	r4, #0
   10dcc:	1a000133 	bne	112a0 <RTMP_ClientPacket+0x7dc>
        {
            RTMP_SendCtrl(r, 0x1B, 0, 0);
        }
        else
        {
            RTMP_Log(RTMP_LOGERROR,
   10dd0:	e59f2574 	ldr	r2, [pc, #1396]	; 1134c <RTMP_ClientPacket+0x888>
   10dd4:	e59f1574 	ldr	r1, [pc, #1396]	; 11350 <RTMP_ClientPacket+0x88c>
   10dd8:	e08f2002 	add	r2, pc, r2
   10ddc:	e2422eaa 	sub	r2, r2, #2720	; 0xaa0
   10de0:	e3a00001 	mov	r0, #1
   10de4:	e2422008 	sub	r2, r2, #8
   10de8:	e08f1001 	add	r1, pc, r1
   10dec:	eb0012ee 	bl	159ac <RTMP_Log>

int
RTMP_ClientPacket(RTMP *r, RTMPPacket *packet)
{
    //LOGE(" ===== RTMP_ClientPacket()   packet type:%d \n",packet->m_packetType);
    int bHasMediaPacket = 0;
   10df0:	e1a00004 	mov	r0, r4
   10df4:	eaffff5b 	b	10b68 <RTMP_ClientPacket+0xa4>
}

static void
HandleServerBW(RTMP *r, const RTMPPacket *packet)
{
    r->m_nServerBW = AMF_DecodeInt32(packet->m_body);
   10df8:	e591001c 	ldr	r0, [r1, #28]
   10dfc:	eb001423 	bl	15e90 <AMF_DecodeInt32>
    RTMP_Log(RTMP_LOGDEBUG, "%s: server BW = %d", __FUNCTION__, r->m_nServerBW);
   10e00:	e59f254c 	ldr	r2, [pc, #1356]	; 11354 <RTMP_ClientPacket+0x890>
   10e04:	e59f154c 	ldr	r1, [pc, #1356]	; 11358 <RTMP_ClientPacket+0x894>
   10e08:	e08f2002 	add	r2, pc, r2
   10e0c:	e2422ea9 	sub	r2, r2, #2704	; 0xa90
   10e10:	e242200c 	sub	r2, r2, #12
   10e14:	e08f1001 	add	r1, pc, r1
}

static void
HandleServerBW(RTMP *r, const RTMPPacket *packet)
{
    r->m_nServerBW = AMF_DecodeInt32(packet->m_body);
   10e18:	e1a03000 	mov	r3, r0
   10e1c:	e587002c 	str	r0, [r7, #44]	; 0x2c
    RTMP_Log(RTMP_LOGDEBUG, "%s: server BW = %d", __FUNCTION__, r->m_nServerBW);
   10e20:	e3a00004 	mov	r0, #4
   10e24:	eb0012e0 	bl	159ac <RTMP_Log>

int
RTMP_ClientPacket(RTMP *r, RTMPPacket *packet)
{
    //LOGE(" ===== RTMP_ClientPacket()   packet type:%d \n",packet->m_packetType);
    int bHasMediaPacket = 0;
   10e28:	e3a00000 	mov	r0, #0
   10e2c:	eaffff4d 	b	10b68 <RTMP_ClientPacket+0xa4>
}

static void
HandleClientBW(RTMP *r, const RTMPPacket *packet)
{
    r->m_nClientBW = AMF_DecodeInt32(packet->m_body);
   10e30:	e591001c 	ldr	r0, [r1, #28]
   10e34:	eb001415 	bl	15e90 <AMF_DecodeInt32>
   10e38:	e5870030 	str	r0, [r7, #48]	; 0x30
    if (packet->m_nBodySize > 4)
   10e3c:	e5942010 	ldr	r2, [r4, #16]
}

static void
HandleClientBW(RTMP *r, const RTMPPacket *packet)
{
    r->m_nClientBW = AMF_DecodeInt32(packet->m_body);
   10e40:	e1a03000 	mov	r3, r0
    if (packet->m_nBodySize > 4)
   10e44:	e3520004 	cmp	r2, #4
        r->m_nClientBW2 = packet->m_body[4];
   10e48:	8594201c 	ldrhi	r2, [r4, #28]

static void
HandleClientBW(RTMP *r, const RTMPPacket *packet)
{
    r->m_nClientBW = AMF_DecodeInt32(packet->m_body);
    if (packet->m_nBodySize > 4)
   10e4c:	93a010ff 	movls	r1, #255	; 0xff
        r->m_nClientBW2 = packet->m_body[4];
   10e50:	85d21004 	ldrbhi	r1, [r2, #4]
    else
        r->m_nClientBW2 = -1;
    RTMP_Log(RTMP_LOGDEBUG, "%s: client BW = %d %d", __FUNCTION__, r->m_nClientBW,
   10e54:	e59f2500 	ldr	r2, [pc, #1280]	; 1135c <RTMP_ClientPacket+0x898>
   10e58:	e5c71034 	strb	r1, [r7, #52]	; 0x34
   10e5c:	e08f2002 	add	r2, pc, r2
   10e60:	e58d1000 	str	r1, [sp]
   10e64:	e59f14f4 	ldr	r1, [pc, #1268]	; 11360 <RTMP_ClientPacket+0x89c>
   10e68:	e2422d2a 	sub	r2, r2, #2688	; 0xa80
   10e6c:	e3a00004 	mov	r0, #4
   10e70:	e242200c 	sub	r2, r2, #12
   10e74:	e08f1001 	add	r1, pc, r1
   10e78:	eb0012cb 	bl	159ac <RTMP_Log>

int
RTMP_ClientPacket(RTMP *r, RTMPPacket *packet)
{
    //LOGE(" ===== RTMP_ClientPacket()   packet type:%d \n",packet->m_packetType);
    int bHasMediaPacket = 0;
   10e7c:	e3a00000 	mov	r0, #0
   10e80:	eaffff38 	b	10b68 <RTMP_ClientPacket+0xa4>
            
        case RTMP_PACKET_TYPE_FLASH_VIDEO:
        {
            /* go through FLV packets and handle metadata packets */
            unsigned int pos = 0;
            uint32_t nTimeStamp = packet->m_nTimeStamp;
   10e84:	e5918008 	ldr	r8, [r1, #8]
   10e88:	e5913010 	ldr	r3, [r1, #16]
            break;
            
        case RTMP_PACKET_TYPE_FLASH_VIDEO:
        {
            /* go through FLV packets and handle metadata packets */
            unsigned int pos = 0;
   10e8c:	e3a05000 	mov	r5, #0
            uint32_t nTimeStamp = packet->m_nTimeStamp;
            
            while (pos + 11 < packet->m_nBodySize)
   10e90:	ea000002 	b	10ea0 <RTMP_ClientPacket+0x3dc>
                }
                if (packet->m_body[pos] == 0x12)
                {
                    HandleMetadata(r, packet->m_body + pos + 11, dataSize);
                }
                else if (packet->m_body[pos] == 8 || packet->m_body[pos] == 9)
   10e94:	e3520001 	cmp	r2, #1
   10e98:	9a00002b 	bls	10f4c <RTMP_ClientPacket+0x488>
{
    r->m_nClientBW = AMF_DecodeInt32(packet->m_body);
    if (packet->m_nBodySize > 4)
        r->m_nClientBW2 = packet->m_body[4];
    else
        r->m_nClientBW2 = -1;
   10e9c:	e1a05006 	mov	r5, r6
        {
            /* go through FLV packets and handle metadata packets */
            unsigned int pos = 0;
            uint32_t nTimeStamp = packet->m_nTimeStamp;
            
            while (pos + 11 < packet->m_nBodySize)
   10ea0:	e285900b 	add	r9, r5, #11
   10ea4:	e1590003 	cmp	r9, r3
            {
                uint32_t dataSize = AMF_DecodeInt24(packet->m_body + pos + 1);	/* size without header (11) and prevTagSize (4) */
   10ea8:	e2852001 	add	r2, r5, #1
        {
            /* go through FLV packets and handle metadata packets */
            unsigned int pos = 0;
            uint32_t nTimeStamp = packet->m_nTimeStamp;
            
            while (pos + 11 < packet->m_nBodySize)
   10eac:	2a000020 	bcs	10f34 <RTMP_ClientPacket+0x470>
            {
                uint32_t dataSize = AMF_DecodeInt24(packet->m_body + pos + 1);	/* size without header (11) and prevTagSize (4) */
   10eb0:	e594001c 	ldr	r0, [r4, #28]
   10eb4:	e0800002 	add	r0, r0, r2
   10eb8:	eb0013ed 	bl	15e74 <AMF_DecodeInt24>
                
                if (pos + 11 + dataSize + 4 > packet->m_nBodySize)
   10ebc:	e5943010 	ldr	r3, [r4, #16]
   10ec0:	e280600f 	add	r6, r0, #15
   10ec4:	e0866005 	add	r6, r6, r5
   10ec8:	e1560003 	cmp	r6, r3
   10ecc:	8a000014 	bhi	10f24 <RTMP_ClientPacket+0x460>
                {
                    RTMP_Log(RTMP_LOGWARNING, "Stream corrupt?!");
                    break;
                }
                if (packet->m_body[pos] == 0x12)
   10ed0:	e594101c 	ldr	r1, [r4, #28]
   10ed4:	e7d1c005 	ldrb	ip, [r1, r5]
   10ed8:	e35c0012 	cmp	ip, #18
                {
                    HandleMetadata(r, packet->m_body + pos + 11, dataSize);
                }
                else if (packet->m_body[pos] == 8 || packet->m_body[pos] == 9)
   10edc:	e24c2008 	sub	r2, ip, #8
                if (pos + 11 + dataSize + 4 > packet->m_nBodySize)
                {
                    RTMP_Log(RTMP_LOGWARNING, "Stream corrupt?!");
                    break;
                }
                if (packet->m_body[pos] == 0x12)
   10ee0:	1affffeb 	bne	10e94 <RTMP_ClientPacket+0x3d0>
                {
                    HandleMetadata(r, packet->m_body + pos + 11, dataSize);
   10ee4:	e1a02000 	mov	r2, r0
   10ee8:	e0811009 	add	r1, r1, r9
   10eec:	e1a00007 	mov	r0, r7
   10ef0:	ebffe343 	bl	9c04 <HandleMetadata>
   10ef4:	e5943010 	ldr	r3, [r4, #16]
   10ef8:	eaffffe7 	b	10e9c <RTMP_ClientPacket+0x3d8>
            /*RTMP_Log(RTMP_LOGDEBUG, "%s, received: FLV tag(s) %lu bytes", __FUNCTION__, packet.m_nBodySize); */
            bHasMediaPacket = 1;
            break;
        }
        default:
            RTMP_Log(RTMP_LOGDEBUG, "%s, unknown packet type received: 0x%02x", __FUNCTION__,
   10efc:	e59f2460 	ldr	r2, [pc, #1120]	; 11364 <RTMP_ClientPacket+0x8a0>
   10f00:	e59f1460 	ldr	r1, [pc, #1120]	; 11368 <RTMP_ClientPacket+0x8a4>
   10f04:	e08f2002 	add	r2, pc, r2
   10f08:	e2422eab 	sub	r2, r2, #2736	; 0xab0
   10f0c:	e3a00004 	mov	r0, #4
   10f10:	e242200c 	sub	r2, r2, #12
   10f14:	e08f1001 	add	r1, pc, r1
   10f18:	eb0012a3 	bl	159ac <RTMP_Log>

int
RTMP_ClientPacket(RTMP *r, RTMPPacket *packet)
{
    //LOGE(" ===== RTMP_ClientPacket()   packet type:%d \n",packet->m_packetType);
    int bHasMediaPacket = 0;
   10f1c:	e3a00000 	mov	r0, #0
   10f20:	eaffff10 	b	10b68 <RTMP_ClientPacket+0xa4>
            {
                uint32_t dataSize = AMF_DecodeInt24(packet->m_body + pos + 1);	/* size without header (11) and prevTagSize (4) */
                
                if (pos + 11 + dataSize + 4 > packet->m_nBodySize)
                {
                    RTMP_Log(RTMP_LOGWARNING, "Stream corrupt?!");
   10f24:	e59f1440 	ldr	r1, [pc, #1088]	; 1136c <RTMP_ClientPacket+0x8a8>
   10f28:	e3a00002 	mov	r0, #2
   10f2c:	e08f1001 	add	r1, pc, r1
   10f30:	eb00129d 	bl	159ac <RTMP_Log>
                    nTimeStamp = AMF_DecodeInt24(packet->m_body + pos + 4);
                    nTimeStamp |= (packet->m_body[pos + 7] << 24);
                }
                pos += (11 + dataSize + 4);
            }
            if (!r->m_pausing)
   10f34:	e5973028 	ldr	r3, [r7, #40]	; 0x28
   10f38:	e3530000 	cmp	r3, #0
                r->m_mediaStamp = nTimeStamp;
   10f3c:	05878020 	streq	r8, [r7, #32]
            
            /* FLV tag(s) */
            /*RTMP_Log(RTMP_LOGDEBUG, "%s, received: FLV tag(s) %lu bytes", __FUNCTION__, packet.m_nBodySize); */
            bHasMediaPacket = 1;
   10f40:	e3a00001 	mov	r0, #1
            RTMP_LogHex(RTMP_LOGDEBUG, packet->m_body, packet->m_nBodySize);
#endif
    }
    
    return bHasMediaPacket;
}
   10f44:	e28dd00c 	add	sp, sp, #12
   10f48:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
                {
                    HandleMetadata(r, packet->m_body + pos + 11, dataSize);
                }
                else if (packet->m_body[pos] == 8 || packet->m_body[pos] == 9)
                {
                    nTimeStamp = AMF_DecodeInt24(packet->m_body + pos + 4);
   10f4c:	e2850004 	add	r0, r5, #4
   10f50:	e0810000 	add	r0, r1, r0
   10f54:	eb0013c6 	bl	15e74 <AMF_DecodeInt24>
                    nTimeStamp |= (packet->m_body[pos + 7] << 24);
   10f58:	e594201c 	ldr	r2, [r4, #28]
   10f5c:	e5943010 	ldr	r3, [r4, #16]
   10f60:	e0825005 	add	r5, r2, r5
   10f64:	e5d58007 	ldrb	r8, [r5, #7]
   10f68:	e1808c08 	orr	r8, r0, r8, lsl #24
   10f6c:	eaffffca 	b	10e9c <RTMP_ClientPacket+0x3d8>
             packet->m_nBodySize);
    /*RTMP_LogHex(packet.m_body, packet.m_nBodySize); */
    
    if (packet->m_nBodySize >= 6)
    {
        switch (nType)
   10f70:	e3550020 	cmp	r5, #32
   10f74:	908ff105 	addls	pc, pc, r5, lsl #2
   10f78:	ea00002e 	b	11038 <RTMP_ClientPacket+0x574>
   10f7c:	ea00009c 	b	111f4 <RTMP_ClientPacket+0x730>
   10f80:	ea0000a8 	b	11228 <RTMP_ClientPacket+0x764>
   10f84:	ea00008d 	b	111c0 <RTMP_ClientPacket+0x6fc>
   10f88:	ea00002a 	b	11038 <RTMP_ClientPacket+0x574>
   10f8c:	ea0000b6 	b	1126c <RTMP_ClientPacket+0x7a8>
   10f90:	ea000028 	b	11038 <RTMP_ClientPacket+0x574>
   10f94:	ea000076 	b	11174 <RTMP_ClientPacket+0x6b0>
   10f98:	ea000026 	b	11038 <RTMP_ClientPacket+0x574>
   10f9c:	ea000025 	b	11038 <RTMP_ClientPacket+0x574>
   10fa0:	ea000024 	b	11038 <RTMP_ClientPacket+0x574>
   10fa4:	ea000023 	b	11038 <RTMP_ClientPacket+0x574>
   10fa8:	ea000022 	b	11038 <RTMP_ClientPacket+0x574>
   10fac:	ea000021 	b	11038 <RTMP_ClientPacket+0x574>
   10fb0:	ea000020 	b	11038 <RTMP_ClientPacket+0x574>
   10fb4:	ea00001f 	b	11038 <RTMP_ClientPacket+0x574>
   10fb8:	ea00001e 	b	11038 <RTMP_ClientPacket+0x574>
   10fbc:	ea00001d 	b	11038 <RTMP_ClientPacket+0x574>
   10fc0:	ea00001c 	b	11038 <RTMP_ClientPacket+0x574>
   10fc4:	ea00001b 	b	11038 <RTMP_ClientPacket+0x574>
   10fc8:	ea00001a 	b	11038 <RTMP_ClientPacket+0x574>
   10fcc:	ea000019 	b	11038 <RTMP_ClientPacket+0x574>
   10fd0:	ea000018 	b	11038 <RTMP_ClientPacket+0x574>
   10fd4:	ea000017 	b	11038 <RTMP_ClientPacket+0x574>
   10fd8:	ea000016 	b	11038 <RTMP_ClientPacket+0x574>
   10fdc:	ea000015 	b	11038 <RTMP_ClientPacket+0x574>
   10fe0:	ea000014 	b	11038 <RTMP_ClientPacket+0x574>
   10fe4:	ea000013 	b	11038 <RTMP_ClientPacket+0x574>
   10fe8:	ea000012 	b	11038 <RTMP_ClientPacket+0x574>
   10fec:	ea000011 	b	11038 <RTMP_ClientPacket+0x574>
   10ff0:	ea000010 	b	11038 <RTMP_ClientPacket+0x574>
   10ff4:	ea00000f 	b	11038 <RTMP_ClientPacket+0x574>
   10ff8:	ea00003d 	b	110f4 <RTMP_ClientPacket+0x630>
   10ffc:	ea00002f 	b	110c0 <RTMP_ClientPacket+0x5fc>
{
    short nType = -1;
    unsigned int tmp;
    if (packet->m_body && packet->m_nBodySize >= 2)
        nType = AMF_DecodeInt16(packet->m_body);
    RTMP_Log(RTMP_LOGDEBUG, "%s, received ctrl. type: %d, len: %d", __FUNCTION__, nType,
   11000:	e59f2368 	ldr	r2, [pc, #872]	; 11370 <RTMP_ClientPacket+0x8ac>
   11004:	e59f1368 	ldr	r1, [pc, #872]	; 11374 <RTMP_ClientPacket+0x8b0>
   11008:	e08f2002 	add	r2, pc, r2
   1100c:	e2422eaa 	sub	r2, r2, #2720	; 0xaa0
   11010:	e58d3000 	str	r3, [sp]
   11014:	e2422008 	sub	r2, r2, #8
   11018:	e3e03000 	mvn	r3, #0
   1101c:	e3a00004 	mov	r0, #4
   11020:	e08f1001 	add	r1, pc, r1
   11024:	eb001260 	bl	159ac <RTMP_Log>
             packet->m_nBodySize);
    /*RTMP_LogHex(packet.m_body, packet.m_nBodySize); */
    
    if (packet->m_nBodySize >= 6)
   11028:	e5943010 	ldr	r3, [r4, #16]
   1102c:	e3530005 	cmp	r3, #5
   11030:	9affff2d 	bls	10cec <RTMP_ClientPacket+0x228>
   11034:	e59f633c 	ldr	r6, [pc, #828]	; 11378 <RTMP_ClientPacket+0x8b4>
                tmp = AMF_DecodeInt32(packet->m_body + 2);
                RTMP_Log(RTMP_LOGDEBUG, "%s, Stream BufferReady %d", __FUNCTION__, tmp);
                break;
                
            default:
                tmp = AMF_DecodeInt32(packet->m_body + 2);
   11038:	e594001c 	ldr	r0, [r4, #28]
   1103c:	e2800002 	add	r0, r0, #2
   11040:	eb001392 	bl	15e90 <AMF_DecodeInt32>
                RTMP_Log(RTMP_LOGDEBUG, "%s, Stream xx %d", __FUNCTION__, tmp);
   11044:	e59f2330 	ldr	r2, [pc, #816]	; 1137c <RTMP_ClientPacket+0x8b8>
   11048:	e59f1330 	ldr	r1, [pc, #816]	; 11380 <RTMP_ClientPacket+0x8bc>
   1104c:	e08f2002 	add	r2, pc, r2
   11050:	e2422eaa 	sub	r2, r2, #2720	; 0xaa0
   11054:	e2422008 	sub	r2, r2, #8
   11058:	e08f1001 	add	r1, pc, r1
                tmp = AMF_DecodeInt32(packet->m_body + 2);
                RTMP_Log(RTMP_LOGDEBUG, "%s, Stream BufferReady %d", __FUNCTION__, tmp);
                break;
                
            default:
                tmp = AMF_DecodeInt32(packet->m_body + 2);
   1105c:	e1a03000 	mov	r3, r0
                RTMP_Log(RTMP_LOGDEBUG, "%s, Stream xx %d", __FUNCTION__, tmp);
   11060:	e3a00004 	mov	r0, #4
   11064:	eb001250 	bl	159ac <RTMP_Log>
   11068:	eaffff42 	b	10d78 <RTMP_ClientPacket+0x2b4>
static void
HandleChangeChunkSize(RTMP *r, const RTMPPacket *packet)
{
    if (packet->m_nBodySize >= 4)
    {
        r->m_inChunkSize = AMF_DecodeInt32(packet->m_body);
   1106c:	e591001c 	ldr	r0, [r1, #28]
   11070:	eb001386 	bl	15e90 <AMF_DecodeInt32>
        RTMP_Log(RTMP_LOGDEBUG, "%s, received: chunk size change to %d", __FUNCTION__,
   11074:	e59f2308 	ldr	r2, [pc, #776]	; 11384 <RTMP_ClientPacket+0x8c0>
   11078:	e59f1308 	ldr	r1, [pc, #776]	; 11388 <RTMP_ClientPacket+0x8c4>
   1107c:	e08f2002 	add	r2, pc, r2
   11080:	e2422ead 	sub	r2, r2, #2768	; 0xad0
   11084:	e2422004 	sub	r2, r2, #4
   11088:	e08f1001 	add	r1, pc, r1
static void
HandleChangeChunkSize(RTMP *r, const RTMPPacket *packet)
{
    if (packet->m_nBodySize >= 4)
    {
        r->m_inChunkSize = AMF_DecodeInt32(packet->m_body);
   1108c:	e1a03000 	mov	r3, r0
   11090:	e5870000 	str	r0, [r7]
        RTMP_Log(RTMP_LOGDEBUG, "%s, received: chunk size change to %d", __FUNCTION__,
   11094:	e3a00004 	mov	r0, #4
   11098:	eb001243 	bl	159ac <RTMP_Log>

int
RTMP_ClientPacket(RTMP *r, RTMPPacket *packet)
{
    //LOGE(" ===== RTMP_ClientPacket()   packet type:%d \n",packet->m_packetType);
    int bHasMediaPacket = 0;
   1109c:	e3a00000 	mov	r0, #0
   110a0:	eafffeb0 	b	10b68 <RTMP_ClientPacket+0xa4>
   110a4:	e1a00007 	mov	r0, r7
   110a8:	e2811001 	add	r1, r1, #1
   110ac:	e2422001 	sub	r2, r2, #1
   110b0:	ebfffa22 	bl	f940 <HandleInvoke.part.13>
            RTMP_Log(RTMP_LOGDEBUG,
                     "%s, flex message, size %u bytes, not fully supported",
                     __FUNCTION__, packet->m_nBodySize);
            /*RTMP_LogHex(packet.m_body, packet.m_nBodySize); */
            
            if (HandleInvoke(r, packet->m_body + 1, packet->m_nBodySize - 1) == 1)
   110b4:	e3500001 	cmp	r0, #1
   110b8:	0affff06 	beq	10cd8 <RTMP_ClientPacket+0x214>
   110bc:	eaffff0a 	b	10cec <RTMP_ClientPacket+0x228>
                    r->m_pausing = 3;
                }
                break;
                
            case 32:
                tmp = AMF_DecodeInt32(packet->m_body + 2);
   110c0:	e594001c 	ldr	r0, [r4, #28]
   110c4:	e2800002 	add	r0, r0, #2
   110c8:	eb001370 	bl	15e90 <AMF_DecodeInt32>
                RTMP_Log(RTMP_LOGDEBUG, "%s, Stream BufferReady %d", __FUNCTION__, tmp);
   110cc:	e59f22b8 	ldr	r2, [pc, #696]	; 1138c <RTMP_ClientPacket+0x8c8>
   110d0:	e59f12b8 	ldr	r1, [pc, #696]	; 11390 <RTMP_ClientPacket+0x8cc>
   110d4:	e08f2002 	add	r2, pc, r2
   110d8:	e2422eaa 	sub	r2, r2, #2720	; 0xaa0
   110dc:	e2422008 	sub	r2, r2, #8
   110e0:	e08f1001 	add	r1, pc, r1
                    r->m_pausing = 3;
                }
                break;
                
            case 32:
                tmp = AMF_DecodeInt32(packet->m_body + 2);
   110e4:	e1a03000 	mov	r3, r0
                RTMP_Log(RTMP_LOGDEBUG, "%s, Stream BufferReady %d", __FUNCTION__, tmp);
   110e8:	e3a00004 	mov	r0, #4
   110ec:	eb00122e 	bl	159ac <RTMP_Log>
   110f0:	eafffefd 	b	10cec <RTMP_ClientPacket+0x228>
                 * for live streams since they obviously can only be sent in
                 * realtime. And it's all moot if the network speed is actually
                 * slower than the media bitrate.
                 */
            case 31:
                tmp = AMF_DecodeInt32(packet->m_body + 2);
   110f4:	e594001c 	ldr	r0, [r4, #28]
   110f8:	e2800002 	add	r0, r0, #2
   110fc:	eb001363 	bl	15e90 <AMF_DecodeInt32>
                RTMP_Log(RTMP_LOGDEBUG, "%s, Stream BufferEmpty %d", __FUNCTION__, tmp);
   11100:	e59f228c 	ldr	r2, [pc, #652]	; 11394 <RTMP_ClientPacket+0x8d0>
   11104:	e59f128c 	ldr	r1, [pc, #652]	; 11398 <RTMP_ClientPacket+0x8d4>
   11108:	e08f2002 	add	r2, pc, r2
   1110c:	e2422eaa 	sub	r2, r2, #2720	; 0xaa0
   11110:	e2422008 	sub	r2, r2, #8
   11114:	e08f1001 	add	r1, pc, r1
                 * for live streams since they obviously can only be sent in
                 * realtime. And it's all moot if the network speed is actually
                 * slower than the media bitrate.
                 */
            case 31:
                tmp = AMF_DecodeInt32(packet->m_body + 2);
   11118:	e1a03000 	mov	r3, r0
                RTMP_Log(RTMP_LOGDEBUG, "%s, Stream BufferEmpty %d", __FUNCTION__, tmp);
   1111c:	e3a00004 	mov	r0, #4
   11120:	eb001221 	bl	159ac <RTMP_Log>
                if (!(r->Link.lFlags & RTMP_LF_BUFX))
   11124:	e2873901 	add	r3, r7, #16384	; 0x4000
   11128:	e5933180 	ldr	r3, [r3, #384]	; 0x180
   1112c:	e3130010 	tst	r3, #16
   11130:	0afffeed 	beq	10cec <RTMP_ClientPacket+0x228>
                    break;
                if (!r->m_pausing)
   11134:	e5973028 	ldr	r3, [r7, #40]	; 0x28
   11138:	e3530000 	cmp	r3, #0
   1113c:	1a000065 	bne	112d8 <RTMP_ClientPacket+0x814>
                {
                    r->m_pauseStamp = r->m_mediaChannel < r->m_channelsAllocatedIn ?
   11140:	e597201c 	ldr	r2, [r7, #28]
   11144:	e5971044 	ldr	r1, [r7, #68]	; 0x44
                    r->m_channelTimestamp[r->m_mediaChannel] : 0;
                    RTMP_SendPause(r, TRUE, r->m_pauseStamp);
   11148:	e1a00007 	mov	r0, r7
                RTMP_Log(RTMP_LOGDEBUG, "%s, Stream BufferEmpty %d", __FUNCTION__, tmp);
                if (!(r->Link.lFlags & RTMP_LF_BUFX))
                    break;
                if (!r->m_pausing)
                {
                    r->m_pauseStamp = r->m_mediaChannel < r->m_channelsAllocatedIn ?
   1114c:	e1520001 	cmp	r2, r1
                    r->m_channelTimestamp[r->m_mediaChannel] : 0;
   11150:	b5973054 	ldrlt	r3, [r7, #84]	; 0x54
                RTMP_Log(RTMP_LOGDEBUG, "%s, Stream BufferEmpty %d", __FUNCTION__, tmp);
                if (!(r->Link.lFlags & RTMP_LF_BUFX))
                    break;
                if (!r->m_pausing)
                {
                    r->m_pauseStamp = r->m_mediaChannel < r->m_channelsAllocatedIn ?
   11154:	a1a02003 	movge	r2, r3
   11158:	b7932102 	ldrlt	r2, [r3, r2, lsl #2]
   1115c:	e5872024 	str	r2, [r7, #36]	; 0x24
                    r->m_channelTimestamp[r->m_mediaChannel] : 0;
                    RTMP_SendPause(r, TRUE, r->m_pauseStamp);
   11160:	e3a01001 	mov	r1, #1
   11164:	ebffedf9 	bl	c950 <RTMP_SendPause>
                    r->m_pausing = 1;
   11168:	e3a03001 	mov	r3, #1
   1116c:	e5873028 	str	r3, [r7, #40]	; 0x28
   11170:	eafffedd 	b	10cec <RTMP_ClientPacket+0x228>
                tmp = AMF_DecodeInt32(packet->m_body + 2);
                RTMP_Log(RTMP_LOGDEBUG, "%s, Stream IsRecorded %d", __FUNCTION__, tmp);
                break;
                
            case 6:		/* server ping. reply with pong. */
                tmp = AMF_DecodeInt32(packet->m_body + 2);
   11174:	e594001c 	ldr	r0, [r4, #28]
   11178:	e2800002 	add	r0, r0, #2
   1117c:	eb001343 	bl	15e90 <AMF_DecodeInt32>
                RTMP_Log(RTMP_LOGDEBUG, "%s, Ping %d", __FUNCTION__, tmp);
   11180:	e59f2214 	ldr	r2, [pc, #532]	; 1139c <RTMP_ClientPacket+0x8d8>
   11184:	e59f1214 	ldr	r1, [pc, #532]	; 113a0 <RTMP_ClientPacket+0x8dc>
   11188:	e08f2002 	add	r2, pc, r2
   1118c:	e2422eaa 	sub	r2, r2, #2720	; 0xaa0
   11190:	e2422008 	sub	r2, r2, #8
   11194:	e08f1001 	add	r1, pc, r1
                tmp = AMF_DecodeInt32(packet->m_body + 2);
                RTMP_Log(RTMP_LOGDEBUG, "%s, Stream IsRecorded %d", __FUNCTION__, tmp);
                break;
                
            case 6:		/* server ping. reply with pong. */
                tmp = AMF_DecodeInt32(packet->m_body + 2);
   11198:	e1a04000 	mov	r4, r0
                RTMP_Log(RTMP_LOGDEBUG, "%s, Ping %d", __FUNCTION__, tmp);
   1119c:	e1a03000 	mov	r3, r0
   111a0:	e3a00004 	mov	r0, #4
   111a4:	eb001200 	bl	159ac <RTMP_Log>
                RTMP_SendCtrl(r, 0x07, tmp, 0);
   111a8:	e1a00007 	mov	r0, r7
   111ac:	e1a02004 	mov	r2, r4
   111b0:	e3a01007 	mov	r1, #7
   111b4:	e3a03000 	mov	r3, #0
   111b8:	ebffeec3 	bl	cccc <RTMP_SendCtrl>
   111bc:	eafffeca 	b	10cec <RTMP_ClientPacket+0x228>
                if (r->m_pausing == 1)
                    r->m_pausing = 2;
                break;
                
            case 2:
                tmp = AMF_DecodeInt32(packet->m_body + 2);
   111c0:	e594001c 	ldr	r0, [r4, #28]
   111c4:	e2800002 	add	r0, r0, #2
   111c8:	eb001330 	bl	15e90 <AMF_DecodeInt32>
                RTMP_Log(RTMP_LOGDEBUG, "%s, Stream Dry %d", __FUNCTION__, tmp);
   111cc:	e59f21d0 	ldr	r2, [pc, #464]	; 113a4 <RTMP_ClientPacket+0x8e0>
   111d0:	e59f11d0 	ldr	r1, [pc, #464]	; 113a8 <RTMP_ClientPacket+0x8e4>
   111d4:	e08f2002 	add	r2, pc, r2
   111d8:	e2422eaa 	sub	r2, r2, #2720	; 0xaa0
   111dc:	e2422008 	sub	r2, r2, #8
   111e0:	e08f1001 	add	r1, pc, r1
                if (r->m_pausing == 1)
                    r->m_pausing = 2;
                break;
                
            case 2:
                tmp = AMF_DecodeInt32(packet->m_body + 2);
   111e4:	e1a03000 	mov	r3, r0
                RTMP_Log(RTMP_LOGDEBUG, "%s, Stream Dry %d", __FUNCTION__, tmp);
   111e8:	e3a00004 	mov	r0, #4
   111ec:	eb0011ee 	bl	159ac <RTMP_Log>
   111f0:	eafffebd 	b	10cec <RTMP_ClientPacket+0x228>
    if (packet->m_nBodySize >= 6)
    {
        switch (nType)
        {
            case 0:
                tmp = AMF_DecodeInt32(packet->m_body + 2);
   111f4:	e594001c 	ldr	r0, [r4, #28]
   111f8:	e2800002 	add	r0, r0, #2
   111fc:	eb001323 	bl	15e90 <AMF_DecodeInt32>
                RTMP_Log(RTMP_LOGDEBUG, "%s, Stream Begin %d", __FUNCTION__, tmp);
   11200:	e59f21a4 	ldr	r2, [pc, #420]	; 113ac <RTMP_ClientPacket+0x8e8>
   11204:	e59f11a4 	ldr	r1, [pc, #420]	; 113b0 <RTMP_ClientPacket+0x8ec>
   11208:	e08f2002 	add	r2, pc, r2
   1120c:	e2422eaa 	sub	r2, r2, #2720	; 0xaa0
   11210:	e2422008 	sub	r2, r2, #8
   11214:	e08f1001 	add	r1, pc, r1
    if (packet->m_nBodySize >= 6)
    {
        switch (nType)
        {
            case 0:
                tmp = AMF_DecodeInt32(packet->m_body + 2);
   11218:	e1a03000 	mov	r3, r0
                RTMP_Log(RTMP_LOGDEBUG, "%s, Stream Begin %d", __FUNCTION__, tmp);
   1121c:	e3a00004 	mov	r0, #4
   11220:	eb0011e1 	bl	159ac <RTMP_Log>
   11224:	eafffeb0 	b	10cec <RTMP_ClientPacket+0x228>
                break;
                
            case 1:
                tmp = AMF_DecodeInt32(packet->m_body + 2);
   11228:	e594001c 	ldr	r0, [r4, #28]
   1122c:	e2800002 	add	r0, r0, #2
   11230:	eb001316 	bl	15e90 <AMF_DecodeInt32>
                RTMP_Log(RTMP_LOGDEBUG, "%s, Stream EOF %d", __FUNCTION__, tmp);
   11234:	e59f2178 	ldr	r2, [pc, #376]	; 113b4 <RTMP_ClientPacket+0x8f0>
   11238:	e59f1178 	ldr	r1, [pc, #376]	; 113b8 <RTMP_ClientPacket+0x8f4>
   1123c:	e08f2002 	add	r2, pc, r2
   11240:	e2422eaa 	sub	r2, r2, #2720	; 0xaa0
   11244:	e2422008 	sub	r2, r2, #8
   11248:	e08f1001 	add	r1, pc, r1
                tmp = AMF_DecodeInt32(packet->m_body + 2);
                RTMP_Log(RTMP_LOGDEBUG, "%s, Stream Begin %d", __FUNCTION__, tmp);
                break;
                
            case 1:
                tmp = AMF_DecodeInt32(packet->m_body + 2);
   1124c:	e1a03000 	mov	r3, r0
                RTMP_Log(RTMP_LOGDEBUG, "%s, Stream EOF %d", __FUNCTION__, tmp);
   11250:	e3a00004 	mov	r0, #4
   11254:	eb0011d4 	bl	159ac <RTMP_Log>
                if (r->m_pausing == 1)
   11258:	e5973028 	ldr	r3, [r7, #40]	; 0x28
   1125c:	e3530001 	cmp	r3, #1
                    r->m_pausing = 2;
   11260:	03a03002 	moveq	r3, #2
   11264:	05873028 	streq	r3, [r7, #40]	; 0x28
   11268:	eafffe9f 	b	10cec <RTMP_ClientPacket+0x228>
                tmp = AMF_DecodeInt32(packet->m_body + 2);
                RTMP_Log(RTMP_LOGDEBUG, "%s, Stream Dry %d", __FUNCTION__, tmp);
                break;
                
            case 4:
                tmp = AMF_DecodeInt32(packet->m_body + 2);
   1126c:	e594001c 	ldr	r0, [r4, #28]
   11270:	e2800002 	add	r0, r0, #2
   11274:	eb001305 	bl	15e90 <AMF_DecodeInt32>
                RTMP_Log(RTMP_LOGDEBUG, "%s, Stream IsRecorded %d", __FUNCTION__, tmp);
   11278:	e59f213c 	ldr	r2, [pc, #316]	; 113bc <RTMP_ClientPacket+0x8f8>
   1127c:	e59f113c 	ldr	r1, [pc, #316]	; 113c0 <RTMP_ClientPacket+0x8fc>
   11280:	e08f2002 	add	r2, pc, r2
   11284:	e2422eaa 	sub	r2, r2, #2720	; 0xaa0
   11288:	e2422008 	sub	r2, r2, #8
   1128c:	e08f1001 	add	r1, pc, r1
                tmp = AMF_DecodeInt32(packet->m_body + 2);
                RTMP_Log(RTMP_LOGDEBUG, "%s, Stream Dry %d", __FUNCTION__, tmp);
                break;
                
            case 4:
                tmp = AMF_DecodeInt32(packet->m_body + 2);
   11290:	e1a03000 	mov	r3, r0
                RTMP_Log(RTMP_LOGDEBUG, "%s, Stream IsRecorded %d", __FUNCTION__, tmp);
   11294:	e3a00004 	mov	r0, #4
   11298:	eb0011c3 	bl	159ac <RTMP_Log>
   1129c:	eafffe92 	b	10cec <RTMP_ClientPacket+0x228>
        /*RTMP_LogHex(packet.m_body, packet.m_nBodySize); */
        
        /* respond with HMAC SHA256 of decompressed SWF, key is the 30byte player key, also the last 30 bytes of the server handshake are applied */
        else if (r->Link.SWFSize)
        {
            RTMP_SendCtrl(r, 0x1B, 0, 0);
   112a0:	e3a02000 	mov	r2, #0
   112a4:	e1a00007 	mov	r0, r7
   112a8:	e1a03002 	mov	r3, r2
   112ac:	e3a0101b 	mov	r1, #27
   112b0:	ebffee85 	bl	cccc <RTMP_SendCtrl>

int
RTMP_ClientPacket(RTMP *r, RTMPPacket *packet)
{
    //LOGE(" ===== RTMP_ClientPacket()   packet type:%d \n",packet->m_packetType);
    int bHasMediaPacket = 0;
   112b4:	e3a00000 	mov	r0, #0
   112b8:	eafffe2a 	b	10b68 <RTMP_ClientPacket+0xa4>
    if (nType == 0x1A)
    {
        RTMP_Log(RTMP_LOGDEBUG, "%s, SWFVerification ping received: ", __FUNCTION__);
        if (packet->m_nBodySize > 2 && packet->m_body[2] > 0x01)
        {
            RTMP_Log(RTMP_LOGERROR,
   112bc:	e59f1100 	ldr	r1, [pc, #256]	; 113c4 <RTMP_ClientPacket+0x900>
   112c0:	e3a00001 	mov	r0, #1
   112c4:	e1a02005 	mov	r2, r5
   112c8:	e08f1001 	add	r1, pc, r1
   112cc:	eb0011b6 	bl	159ac <RTMP_Log>

int
RTMP_ClientPacket(RTMP *r, RTMPPacket *packet)
{
    //LOGE(" ===== RTMP_ClientPacket()   packet type:%d \n",packet->m_packetType);
    int bHasMediaPacket = 0;
   112d0:	e3a00000 	mov	r0, #0
   112d4:	eafffe23 	b	10b68 <RTMP_ClientPacket+0xa4>
                    r->m_pauseStamp = r->m_mediaChannel < r->m_channelsAllocatedIn ?
                    r->m_channelTimestamp[r->m_mediaChannel] : 0;
                    RTMP_SendPause(r, TRUE, r->m_pauseStamp);
                    r->m_pausing = 1;
                }
                else if (r->m_pausing == 2)
   112d8:	e3530002 	cmp	r3, #2
   112dc:	1afffe82 	bne	10cec <RTMP_ClientPacket+0x228>
                {
                    RTMP_SendPause(r, FALSE, r->m_pauseStamp);
   112e0:	e1a00007 	mov	r0, r7
   112e4:	e3a01000 	mov	r1, #0
   112e8:	e5972024 	ldr	r2, [r7, #36]	; 0x24
   112ec:	ebffed97 	bl	c950 <RTMP_SendPause>
                    r->m_pausing = 3;
   112f0:	e3a03003 	mov	r3, #3
   112f4:	e5873028 	str	r3, [r7, #40]	; 0x28
   112f8:	eafffe7b 	b	10cec <RTMP_ClientPacket+0x228>
   112fc:	0000dc68 	.word	0x0000dc68
   11300:	0000f4c4 	.word	0x0000f4c4
   11304:	0000dc3c 	.word	0x0000dc3c
   11308:	0000f520 	.word	0x0000f520
   1130c:	0000dc04 	.word	0x0000dc04
   11310:	0000f51c 	.word	0x0000f51c
   11314:	0000dbdc 	.word	0x0000dbdc
   11318:	0000f52c 	.word	0x0000f52c
   1131c:	0000db9c 	.word	0x0000db9c
   11320:	0000f438 	.word	0x0000f438
   11324:	0000db70 	.word	0x0000db70
   11328:	0000f4e0 	.word	0x0000f4e0
   1132c:	0000db48 	.word	0x0000db48
   11330:	0000f4e8 	.word	0x0000f4e8
   11334:	0000dae4 	.word	0x0000dae4
   11338:	0000f180 	.word	0x0000f180
   1133c:	0000da9c 	.word	0x0000da9c
   11340:	0000f158 	.word	0x0000f158
   11344:	0000da58 	.word	0x0000da58
   11348:	0000f1e8 	.word	0x0000f1e8
   1134c:	0000da08 	.word	0x0000da08
   11350:	0000f208 	.word	0x0000f208
   11354:	0000d9d8 	.word	0x0000d9d8
   11358:	0000f210 	.word	0x0000f210
   1135c:	0000d984 	.word	0x0000d984
   11360:	0000f1c4 	.word	0x0000f1c4
   11364:	0000d8dc 	.word	0x0000d8dc
   11368:	0000f2ac 	.word	0x0000f2ac
   1136c:	0000f280 	.word	0x0000f280
   11370:	0000d7d8 	.word	0x0000d7d8
   11374:	0000ee8c 	.word	0x0000ee8c
   11378:	ffff0000 	.word	0xffff0000
   1137c:	0000d794 	.word	0x0000d794
   11380:	0000ef18 	.word	0x0000ef18
   11384:	0000d764 	.word	0x0000d764
   11388:	0000eddc 	.word	0x0000eddc
   1138c:	0000d70c 	.word	0x0000d70c
   11390:	0000ee74 	.word	0x0000ee74
   11394:	0000d6d8 	.word	0x0000d6d8
   11398:	0000ee24 	.word	0x0000ee24
   1139c:	0000d658 	.word	0x0000d658
   113a0:	0000ed98 	.word	0x0000ed98
   113a4:	0000d60c 	.word	0x0000d60c
   113a8:	0000ed1c 	.word	0x0000ed1c
   113ac:	0000d5d8 	.word	0x0000d5d8
   113b0:	0000ecc0 	.word	0x0000ecc0
   113b4:	0000d5a4 	.word	0x0000d5a4
   113b8:	0000eca0 	.word	0x0000eca0
   113bc:	0000d560 	.word	0x0000d560
   113c0:	0000ec84 	.word	0x0000ec84
   113c4:	0000ece0 	.word	0x0000ece0

000113c8 <RTMP_ConnectStream>:
    }
}

int
RTMP_ConnectStream(RTMP *r, int seekTime)
{
   113c8:	e92d4070 	push	{r4, r5, r6, lr}
    RTMPPacket packet = { 0 };
   113cc:	e3a03000 	mov	r3, #0
    }
}

int
RTMP_ConnectStream(RTMP *r, int seekTime)
{
   113d0:	e24dd020 	sub	sp, sp, #32
    RTMPPacket packet = { 0 };
    
    /* seekTime was already set by SetupStream / SetupURL.
     * This is only needed by ReconnectStream.
     */
    if (seekTime > 0)
   113d4:	e3510000 	cmp	r1, #0
                continue;
            if ((packet.m_packetType == RTMP_PACKET_TYPE_AUDIO) ||
                (packet.m_packetType == RTMP_PACKET_TYPE_VIDEO) ||
                (packet.m_packetType == RTMP_PACKET_TYPE_INFO))
            {
                RTMP_Log(RTMP_LOGWARNING, "Received FLV packet before play()! Ignoring.");
   113d8:	e59f60f4 	ldr	r6, [pc, #244]	; 114d4 <RTMP_ConnectStream+0x10c>
}

int
RTMP_ConnectStream(RTMP *r, int seekTime)
{
    RTMPPacket packet = { 0 };
   113dc:	e58d3000 	str	r3, [sp]
   113e0:	e58d3004 	str	r3, [sp, #4]
   113e4:	e58d3008 	str	r3, [sp, #8]
   113e8:	e58d300c 	str	r3, [sp, #12]
   113ec:	e58d3010 	str	r3, [sp, #16]
   113f0:	e58d3014 	str	r3, [sp, #20]
   113f4:	e58d3018 	str	r3, [sp, #24]
   113f8:	e58d301c 	str	r3, [sp, #28]
    
    /* seekTime was already set by SetupStream / SetupURL.
     * This is only needed by ReconnectStream.
     */
    if (seekTime > 0)
        r->Link.seekTime = seekTime;
   113fc:	c2803901 	addgt	r3, r0, #16384	; 0x4000
   11400:	c5831178 	strgt	r1, [r3, #376]	; 0x178
    }
}

int
RTMP_ConnectStream(RTMP *r, int seekTime)
{
   11404:	e1a04000 	mov	r4, r0
     * This is only needed by ReconnectStream.
     */
    if (seekTime > 0)
        r->Link.seekTime = seekTime;
    
    r->m_mediaChannel = 0;
   11408:	e3a03000 	mov	r3, #0
    
    while (!r->m_bPlaying && RTMP_IsConnected(r) && RTMP_ReadPacket(r, &packet))
   1140c:	e1a0500d 	mov	r5, sp
                continue;
            if ((packet.m_packetType == RTMP_PACKET_TYPE_AUDIO) ||
                (packet.m_packetType == RTMP_PACKET_TYPE_VIDEO) ||
                (packet.m_packetType == RTMP_PACKET_TYPE_INFO))
            {
                RTMP_Log(RTMP_LOGWARNING, "Received FLV packet before play()! Ignoring.");
   11410:	e08f6006 	add	r6, pc, r6
     * This is only needed by ReconnectStream.
     */
    if (seekTime > 0)
        r->Link.seekTime = seekTime;
    
    r->m_mediaChannel = 0;
   11414:	e580301c 	str	r3, [r0, #28]
    
    while (!r->m_bPlaying && RTMP_IsConnected(r) && RTMP_ReadPacket(r, &packet))
   11418:	e5d43035 	ldrb	r3, [r4, #53]	; 0x35
   1141c:	e1a00004 	mov	r0, r4
   11420:	e3530000 	cmp	r3, #0
   11424:	1a00001f 	bne	114a8 <RTMP_ConnectStream+0xe0>
   11428:	ebffdd77 	bl	8a0c <RTMP_IsConnected>
   1142c:	e1a01005 	mov	r1, r5
   11430:	e3500000 	cmp	r0, #0
   11434:	e1a00004 	mov	r0, r4
   11438:	0a000021 	beq	114c4 <RTMP_ConnectStream+0xfc>
   1143c:	ebfff28c 	bl	de74 <RTMP_ReadPacket>
   11440:	e3500000 	cmp	r0, #0
   11444:	0a00001e 	beq	114c4 <RTMP_ConnectStream+0xfc>
    {
        if (RTMPPacket_IsReady(&packet))
   11448:	e59d2010 	ldr	r2, [sp, #16]
   1144c:	e59d1014 	ldr	r1, [sp, #20]
        {
            if (!packet.m_nBodySize)
   11450:	e16f3f12 	clz	r3, r2
   11454:	e1a032a3 	lsr	r3, r3, #5
   11458:	e1510002 	cmp	r1, r2
   1145c:	13833001 	orrne	r3, r3, #1
   11460:	e3530000 	cmp	r3, #0
   11464:	1affffeb 	bne	11418 <RTMP_ConnectStream+0x50>
                continue;
            if ((packet.m_packetType == RTMP_PACKET_TYPE_AUDIO) ||
   11468:	e5dd3001 	ldrb	r3, [sp, #1]
                RTMP_Log(RTMP_LOGWARNING, "Received FLV packet before play()! Ignoring.");
                RTMPPacket_Free(&packet);
                continue;
            }
            
            RTMP_ClientPacket(r, &packet);
   1146c:	e1a00004 	mov	r0, r4
        if (RTMPPacket_IsReady(&packet))
        {
            if (!packet.m_nBodySize)
                continue;
            if ((packet.m_packetType == RTMP_PACKET_TYPE_AUDIO) ||
                (packet.m_packetType == RTMP_PACKET_TYPE_VIDEO) ||
   11470:	e2432008 	sub	r2, r3, #8
    {
        if (RTMPPacket_IsReady(&packet))
        {
            if (!packet.m_nBodySize)
                continue;
            if ((packet.m_packetType == RTMP_PACKET_TYPE_AUDIO) ||
   11474:	e3530012 	cmp	r3, #18
   11478:	13520001 	cmpne	r2, #1
                RTMP_Log(RTMP_LOGWARNING, "Received FLV packet before play()! Ignoring.");
                RTMPPacket_Free(&packet);
                continue;
            }
            
            RTMP_ClientPacket(r, &packet);
   1147c:	e1a01005 	mov	r1, r5
    {
        if (RTMPPacket_IsReady(&packet))
        {
            if (!packet.m_nBodySize)
                continue;
            if ((packet.m_packetType == RTMP_PACKET_TYPE_AUDIO) ||
   11480:	8a00000b 	bhi	114b4 <RTMP_ConnectStream+0xec>
                (packet.m_packetType == RTMP_PACKET_TYPE_VIDEO) ||
                (packet.m_packetType == RTMP_PACKET_TYPE_INFO))
            {
                RTMP_Log(RTMP_LOGWARNING, "Received FLV packet before play()! Ignoring.");
   11484:	e3a00002 	mov	r0, #2
   11488:	e1a01006 	mov	r1, r6
   1148c:	eb001146 	bl	159ac <RTMP_Log>
                RTMPPacket_Free(&packet);
   11490:	e1a00005 	mov	r0, r5
   11494:	ebffdcb1 	bl	8760 <RTMPPacket_Free>
    if (seekTime > 0)
        r->Link.seekTime = seekTime;
    
    r->m_mediaChannel = 0;
    
    while (!r->m_bPlaying && RTMP_IsConnected(r) && RTMP_ReadPacket(r, &packet))
   11498:	e5d43035 	ldrb	r3, [r4, #53]	; 0x35
   1149c:	e1a00004 	mov	r0, r4
   114a0:	e3530000 	cmp	r3, #0
   114a4:	0affffdf 	beq	11428 <RTMP_ConnectStream+0x60>
            RTMPPacket_Free(&packet);
        }
    }
    
    return r->m_bPlaying;
}
   114a8:	e1a00003 	mov	r0, r3
   114ac:	e28dd020 	add	sp, sp, #32
   114b0:	e8bd8070 	pop	{r4, r5, r6, pc}
                RTMP_Log(RTMP_LOGWARNING, "Received FLV packet before play()! Ignoring.");
                RTMPPacket_Free(&packet);
                continue;
            }
            
            RTMP_ClientPacket(r, &packet);
   114b4:	ebfffd82 	bl	10ac4 <RTMP_ClientPacket>
            RTMPPacket_Free(&packet);
   114b8:	e1a00005 	mov	r0, r5
   114bc:	ebffdca7 	bl	8760 <RTMPPacket_Free>
   114c0:	eaffffd4 	b	11418 <RTMP_ConnectStream+0x50>
   114c4:	e5d43035 	ldrb	r3, [r4, #53]	; 0x35
        }
    }
    
    return r->m_bPlaying;
}
   114c8:	e1a00003 	mov	r0, r3
   114cc:	e28dd020 	add	sp, sp, #32
   114d0:	e8bd8070 	pop	{r4, r5, r6, pc}
   114d4:	0000eddc 	.word	0x0000eddc

000114d8 <RTMP_ReconnectStream>:

int
RTMP_ReconnectStream(RTMP *r, int seekTime)
{
   114d8:	e92d4038 	push	{r3, r4, r5, lr}
   114dc:	e1a04000 	mov	r4, r0
   114e0:	e1a05001 	mov	r5, r1
    RTMP_DeleteStream(r);
   114e4:	ebffeaac 	bl	bf9c <RTMP_DeleteStream>
    
    RTMP_SendCreateStream(r);
   114e8:	e1a00004 	mov	r0, r4
   114ec:	ebffeceb 	bl	c8a0 <RTMP_SendCreateStream>
    
    return RTMP_ConnectStream(r, seekTime);
   114f0:	e1a00004 	mov	r0, r4
   114f4:	e1a01005 	mov	r1, r5
}
   114f8:	e8bd4038 	pop	{r3, r4, r5, lr}
{
    RTMP_DeleteStream(r);
    
    RTMP_SendCreateStream(r);
    
    return RTMP_ConnectStream(r, seekTime);
   114fc:	eaffffb1 	b	113c8 <RTMP_ConnectStream>

00011500 <RTMP_GetNextMediaPacket>:
    r->m_stream_id = -1;
}

int
RTMP_GetNextMediaPacket(RTMP *r, RTMPPacket *packet)
{
   11500:	e92d4038 	push	{r3, r4, r5, lr}
   11504:	e1a05000 	mov	r5, r0
   11508:	e1a04001 	mov	r4, r1
    int bHasMediaPacket = 0;
    
    while (!bHasMediaPacket && RTMP_IsConnected(r) && RTMP_ReadPacket(r, packet))
   1150c:	e1a00005 	mov	r0, r5
   11510:	ebffdd3d 	bl	8a0c <RTMP_IsConnected>
   11514:	e1a01004 	mov	r1, r4
   11518:	e3500000 	cmp	r0, #0
   1151c:	e1a00005 	mov	r0, r5
   11520:	0a000011 	beq	1156c <RTMP_GetNextMediaPacket+0x6c>
   11524:	ebfff252 	bl	de74 <RTMP_ReadPacket>
   11528:	e3500000 	cmp	r0, #0
   1152c:	0a00000e 	beq	1156c <RTMP_GetNextMediaPacket+0x6c>
    {
        
        if (!RTMPPacket_IsReady(packet))
   11530:	e5942014 	ldr	r2, [r4, #20]
   11534:	e5943010 	ldr	r3, [r4, #16]
   11538:	e1520003 	cmp	r2, r3
   1153c:	1afffff2 	bne	1150c <RTMP_GetNextMediaPacket+0xc>
        {
            continue;
        }
        
        bHasMediaPacket = RTMP_ClientPacket(r, packet);
   11540:	e1a00005 	mov	r0, r5
   11544:	e1a01004 	mov	r1, r4
   11548:	ebfffd5d 	bl	10ac4 <RTMP_ClientPacket>
        
        if (!bHasMediaPacket)
   1154c:	e3500000 	cmp	r0, #0
   11550:	0a000015 	beq	115ac <RTMP_GetNextMediaPacket+0xac>
        {
            RTMPPacket_Free(packet);
        }
        else if (r->m_pausing == 3)
   11554:	e5953028 	ldr	r3, [r5, #40]	; 0x28
   11558:	e3530003 	cmp	r3, #3
   1155c:	0a000015 	beq	115b8 <RTMP_GetNextMediaPacket+0xb8>
            r->m_pausing = 0;
        }
    }
    
    if (bHasMediaPacket)
        r->m_bPlaying = TRUE;
   11560:	e3a03001 	mov	r3, #1
   11564:	e5c53035 	strb	r3, [r5, #53]	; 0x35
    else if (r->m_sb.sb_timedout && !r->m_pausing)
        r->m_pauseStamp = r->m_mediaChannel < r->m_channelsAllocatedIn ?
        r->m_channelTimestamp[r->m_mediaChannel] : 0;
    
    return bHasMediaPacket;
}
   11568:	e8bd8038 	pop	{r3, r4, r5, pc}
        }
    }
    
    if (bHasMediaPacket)
        r->m_bPlaying = TRUE;
    else if (r->m_sb.sb_timedout && !r->m_pausing)
   1156c:	e2853901 	add	r3, r5, #16384	; 0x4000
   11570:	e59300ec 	ldr	r0, [r3, #236]	; 0xec
   11574:	e3500000 	cmp	r0, #0
   11578:	0a00000a 	beq	115a8 <RTMP_GetNextMediaPacket+0xa8>
   1157c:	e5953028 	ldr	r3, [r5, #40]	; 0x28
   11580:	e3530000 	cmp	r3, #0
   11584:	1a000012 	bne	115d4 <RTMP_GetNextMediaPacket+0xd4>
        r->m_pauseStamp = r->m_mediaChannel < r->m_channelsAllocatedIn ?
   11588:	e595201c 	ldr	r2, [r5, #28]
   1158c:	e5951044 	ldr	r1, [r5, #68]	; 0x44
   11590:	e3a00000 	mov	r0, #0
   11594:	e1520001 	cmp	r2, r1
        r->m_channelTimestamp[r->m_mediaChannel] : 0;
   11598:	b5953054 	ldrlt	r3, [r5, #84]	; 0x54
    }
    
    if (bHasMediaPacket)
        r->m_bPlaying = TRUE;
    else if (r->m_sb.sb_timedout && !r->m_pausing)
        r->m_pauseStamp = r->m_mediaChannel < r->m_channelsAllocatedIn ?
   1159c:	b7933102 	ldrlt	r3, [r3, r2, lsl #2]
   115a0:	e5853024 	str	r3, [r5, #36]	; 0x24
   115a4:	e8bd8038 	pop	{r3, r4, r5, pc}
   115a8:	e8bd8038 	pop	{r3, r4, r5, pc}
        
        bHasMediaPacket = RTMP_ClientPacket(r, packet);
        
        if (!bHasMediaPacket)
        {
            RTMPPacket_Free(packet);
   115ac:	e1a00004 	mov	r0, r4
   115b0:	ebffdc6a 	bl	8760 <RTMPPacket_Free>
   115b4:	eaffffd4 	b	1150c <RTMP_GetNextMediaPacket+0xc>
        }
        else if (r->m_pausing == 3)
        {
            if (packet->m_nTimeStamp <= r->m_mediaStamp)
   115b8:	e5942008 	ldr	r2, [r4, #8]
   115bc:	e5953020 	ldr	r3, [r5, #32]
   115c0:	e1520003 	cmp	r2, r3
   115c4:	9afffff8 	bls	115ac <RTMP_GetNextMediaPacket+0xac>
                         r->m_mediaStamp);
#endif
                RTMPPacket_Free(packet);
                continue;
            }
            r->m_pausing = 0;
   115c8:	e3a03000 	mov	r3, #0
   115cc:	e5853028 	str	r3, [r5, #40]	; 0x28
   115d0:	eaffffe2 	b	11560 <RTMP_GetNextMediaPacket+0x60>
   115d4:	e3a00000 	mov	r0, #0
   115d8:	e8bd8038 	pop	{r3, r4, r5, pc}

000115dc <Read_1_Packet>:
 * Returns -3 if Play.Close/Stop, -2 if fatal error, -1 if no more media
 * packets, 0 if ignorable error, >0 if there is a media packet
 */
static int
Read_1_Packet(RTMP *r, char *buf, unsigned int buflen)
{
   115dc:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   115e0:	e24dd064 	sub	sp, sp, #100	; 0x64
    unsigned int size;
    char *ptr, *pend;
    uint32_t nTimeStamp = 0;
    unsigned int len;
    
    rtnGetNextMediaPacket = RTMP_GetNextMediaPacket(r, &packet);
   115e4:	e28d8040 	add	r8, sp, #64	; 0x40
static int
Read_1_Packet(RTMP *r, char *buf, unsigned int buflen)
{
    uint32_t prevTagSize = 0;
    int rtnGetNextMediaPacket = 0, ret = RTMP_READ_EOF;
    RTMPPacket packet = { 0 };
   115e8:	e3a07000 	mov	r7, #0
 * Returns -3 if Play.Close/Stop, -2 if fatal error, -1 if no more media
 * packets, 0 if ignorable error, >0 if there is a media packet
 */
static int
Read_1_Packet(RTMP *r, char *buf, unsigned int buflen)
{
   115ec:	e58d1008 	str	r1, [sp, #8]
    unsigned int size;
    char *ptr, *pend;
    uint32_t nTimeStamp = 0;
    unsigned int len;
    
    rtnGetNextMediaPacket = RTMP_GetNextMediaPacket(r, &packet);
   115f0:	e1a01008 	mov	r1, r8
 * Returns -3 if Play.Close/Stop, -2 if fatal error, -1 if no more media
 * packets, 0 if ignorable error, >0 if there is a media packet
 */
static int
Read_1_Packet(RTMP *r, char *buf, unsigned int buflen)
{
   115f4:	e58d2004 	str	r2, [sp, #4]
    uint32_t prevTagSize = 0;
    int rtnGetNextMediaPacket = 0, ret = RTMP_READ_EOF;
    RTMPPacket packet = { 0 };
   115f8:	e58d7040 	str	r7, [sp, #64]	; 0x40
   115fc:	e58d7044 	str	r7, [sp, #68]	; 0x44
   11600:	e58d7048 	str	r7, [sp, #72]	; 0x48
   11604:	e58d704c 	str	r7, [sp, #76]	; 0x4c
   11608:	e58d7050 	str	r7, [sp, #80]	; 0x50
   1160c:	e58d7054 	str	r7, [sp, #84]	; 0x54
   11610:	e58d7058 	str	r7, [sp, #88]	; 0x58
   11614:	e58d705c 	str	r7, [sp, #92]	; 0x5c
 * Returns -3 if Play.Close/Stop, -2 if fatal error, -1 if no more media
 * packets, 0 if ignorable error, >0 if there is a media packet
 */
static int
Read_1_Packet(RTMP *r, char *buf, unsigned int buflen)
{
   11618:	e1a04000 	mov	r4, r0
    unsigned int size;
    char *ptr, *pend;
    uint32_t nTimeStamp = 0;
    unsigned int len;
    
    rtnGetNextMediaPacket = RTMP_GetNextMediaPacket(r, &packet);
   1161c:	ebffffb7 	bl	11500 <RTMP_GetNextMediaPacket>
    while (rtnGetNextMediaPacket)
   11620:	e3500000 	cmp	r0, #0
   11624:	0a000170 	beq	11bec <Read_1_Packet+0x610>
        unsigned int nPacketLen = packet.m_nBodySize;
        
        /* Return RTMP_READ_COMPLETE if this was completed nicely with
         * invoke message Play.Stop or Play.Complete
         */
        if (rtnGetNextMediaPacket == 2)
   11628:	e3500002 	cmp	r0, #2
    rtnGetNextMediaPacket = RTMP_GetNextMediaPacket(r, &packet);
    while (rtnGetNextMediaPacket)
    {
        
//        RTMP_Log(RTMP_LOGINFO,"librtmp packet type:%d  %d",packet.m_packetType,packet.m_nTimeStamp);
        char *packetBody = packet.m_body;
   1162c:	e59d505c 	ldr	r5, [sp, #92]	; 0x5c
        unsigned int nPacketLen = packet.m_nBodySize;
   11630:	e59d6050 	ldr	r6, [sp, #80]	; 0x50
        
        /* Return RTMP_READ_COMPLETE if this was completed nicely with
         * invoke message Play.Stop or Play.Complete
         */
        if (rtnGetNextMediaPacket == 2)
   11634:	0a0001a2 	beq	11cc4 <Read_1_Packet+0x6e8>
                     "Assuming stream is complete");
            ret = RTMP_READ_COMPLETE;
            break;
        }
        
        r->m_read.dataType |= (((packet.m_packetType == RTMP_PACKET_TYPE_AUDIO) << 2) |
   11638:	e5ddb041 	ldrb	fp, [sp, #65]	; 0x41
   1163c:	e5d430a0 	ldrb	r3, [r4, #160]	; 0xa0
   11640:	e35b0008 	cmp	fp, #8
   11644:	0a000076 	beq	11824 <Read_1_Packet+0x248>
                               (packet.m_packetType == RTMP_PACKET_TYPE_VIDEO));
   11648:	e24b2009 	sub	r2, fp, #9
   1164c:	e16f2f12 	clz	r2, r2
   11650:	e1a022a2 	lsr	r2, r2, #5
                     "Assuming stream is complete");
            ret = RTMP_READ_COMPLETE;
            break;
        }
        
        r->m_read.dataType |= (((packet.m_packetType == RTMP_PACKET_TYPE_AUDIO) << 2) |
   11654:	e1823003 	orr	r3, r2, r3
                               (packet.m_packetType == RTMP_PACKET_TYPE_VIDEO));
        
        if (packet.m_packetType == RTMP_PACKET_TYPE_VIDEO && nPacketLen <= 5)
   11658:	e3520000 	cmp	r2, #0
                     "Assuming stream is complete");
            ret = RTMP_READ_COMPLETE;
            break;
        }
        
        r->m_read.dataType |= (((packet.m_packetType == RTMP_PACKET_TYPE_AUDIO) << 2) |
   1165c:	e5c430a0 	strb	r3, [r4, #160]	; 0xa0
                               (packet.m_packetType == RTMP_PACKET_TYPE_VIDEO));
        
        if (packet.m_packetType == RTMP_PACKET_TYPE_VIDEO && nPacketLen <= 5)
   11660:	1a00001f 	bne	116e4 <Read_1_Packet+0x108>
                     nPacketLen);
            ret = RTMP_READ_IGNORE;
            break;
        }
        
        if (r->m_read.flags & RTMP_READ_SEEKING)
   11664:	e5d470a1 	ldrb	r7, [r4, #161]	; 0xa1
   11668:	e3170020 	tst	r7, #32
   1166c:	0a000005 	beq	11688 <Read_1_Packet+0xac>
                         "Stream does not start with requested frame, ignoring data... ");
                r->m_read.nIgnoredFrameCounter++;
                if (r->m_read.nIgnoredFrameCounter > MAX_IGNORED_FRAMES)
                    ret = RTMP_READ_ERROR;	/* fatal error, couldn't continue stream */
                else
                    ret = RTMP_READ_IGNORE;
   11670:	e3a07000 	mov	r7, #0
        ret = size;
        break;
    }
    
    if (rtnGetNextMediaPacket)
        RTMPPacket_Free(&packet);
   11674:	e1a00008 	mov	r0, r8
   11678:	ebffdc38 	bl	8760 <RTMPPacket_Free>
        memcpy(buf, r->m_read.buf, len);
        r->m_read.bufpos = r->m_read.buf + len;
        r->m_read.buflen = ret - len;
    }
    return ret;
}
   1167c:	e1a00007 	mov	r0, r7
   11680:	e28dd064 	add	sp, sp, #100	; 0x64
   11684:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
             packet.m_hasAbsTimestamp);
        if (packet.m_packetType == RTMP_PACKET_TYPE_VIDEO)
            LOGE("frametype: %02X", (*packetBody & 0xf0));
#endif
        
        if (r->m_read.flags & RTMP_READ_RESUME)
   11688:	e3170002 	tst	r7, #2
   1168c:	0a000024 	beq	11724 <Read_1_Packet+0x148>
        {
            /* check the header if we get one */
            if (packet.m_nTimeStamp == 0)
   11690:	e59da048 	ldr	sl, [sp, #72]	; 0x48
   11694:	e35a0000 	cmp	sl, #0
   11698:	0a00007c 	beq	11890 <Read_1_Packet+0x2b4>
                    }
                }
            }
            
            if (packet.m_nTimeStamp > 0
                && (r->m_read.flags & (RTMP_READ_GOTKF|RTMP_READ_GOTFLVK)))
   1169c:	e3170018 	tst	r7, #24
                 * We assume that if we found one keyframe somewhere and were
                 * already beyond TS > 0 we have written data to the output
                 * which means we can accept all forthcoming data including the
                 * change between 08/09 <-> FLV packets
                 */
                r->m_read.flags |= (RTMP_READ_GOTKF|RTMP_READ_GOTFLVK);
   116a0:	13877018 	orrne	r7, r7, #24
   116a4:	15c470a1 	strbne	r7, [r4, #161]	; 0xa1
            }
            
            /* skip till we find our keyframe
             * (seeking might put us somewhere before it)
             */
            if (!(r->m_read.flags & RTMP_READ_GOTKF) &&
   116a8:	e3170008 	tst	r7, #8
   116ac:	1a000066 	bne	1184c <Read_1_Packet+0x270>
   116b0:	e35b0016 	cmp	fp, #22
   116b4:	0a0000e3 	beq	11a48 <Read_1_Packet+0x46c>
                packet.m_packetType != RTMP_PACKET_TYPE_FLASH_VIDEO)
            {
                RTMP_Log(RTMP_LOGWARNING,
   116b8:	e59f1728 	ldr	r1, [pc, #1832]	; 11de8 <Read_1_Packet+0x80c>
   116bc:	e3a00002 	mov	r0, #2
   116c0:	e08f1001 	add	r1, pc, r1
   116c4:	eb0010b8 	bl	159ac <RTMP_Log>
                         "Stream does not start with requested frame, ignoring data... ");
                r->m_read.nIgnoredFrameCounter++;
   116c8:	e59430b8 	ldr	r3, [r4, #184]	; 0xb8
   116cc:	e2833001 	add	r3, r3, #1
                if (r->m_read.nIgnoredFrameCounter > MAX_IGNORED_FRAMES)
   116d0:	e3530032 	cmp	r3, #50	; 0x32
            if (!(r->m_read.flags & RTMP_READ_GOTKF) &&
                packet.m_packetType != RTMP_PACKET_TYPE_FLASH_VIDEO)
            {
                RTMP_Log(RTMP_LOGWARNING,
                         "Stream does not start with requested frame, ignoring data... ");
                r->m_read.nIgnoredFrameCounter++;
   116d4:	e58430b8 	str	r3, [r4, #184]	; 0xb8
                if (r->m_read.nIgnoredFrameCounter > MAX_IGNORED_FRAMES)
   116d8:	9affffe4 	bls	11670 <Read_1_Packet+0x94>
             * prevTagSize (we need extra 4 bytes to append it) */
            r->m_read.buf = malloc(size + 4);
            if (r->m_read.buf == 0)
            {
                RTMP_Log(RTMP_LOGERROR, "Couldn't allocate memory!");
                ret = RTMP_READ_ERROR;		/* fatal error */
   116dc:	e3e07001 	mvn	r7, #1
                break;
   116e0:	eaffffe3 	b	11674 <Read_1_Packet+0x98>
        }
        
        r->m_read.dataType |= (((packet.m_packetType == RTMP_PACKET_TYPE_AUDIO) << 2) |
                               (packet.m_packetType == RTMP_PACKET_TYPE_VIDEO));
        
        if (packet.m_packetType == RTMP_PACKET_TYPE_VIDEO && nPacketLen <= 5)
   116e4:	e3560005 	cmp	r6, #5
   116e8:	8affffdd 	bhi	11664 <Read_1_Packet+0x88>
        {
            RTMP_Log(RTMP_LOGDEBUG, "ignoring too small video packet: size: %d",
   116ec:	e59f16f8 	ldr	r1, [pc, #1784]	; 11dec <Read_1_Packet+0x810>
   116f0:	e1a02006 	mov	r2, r6
   116f4:	e3a00004 	mov	r0, #4
   116f8:	e08f1001 	add	r1, pc, r1
   116fc:	eb0010aa 	bl	159ac <RTMP_Log>
                     nPacketLen);
            ret = RTMP_READ_IGNORE;
            break;
   11700:	eaffffdb 	b	11674 <Read_1_Packet+0x98>
             * keyframes; we've got these so don't mess around with multiple
             * copies sent by the server to us! (if the keyframe is found at a
             * later position there is only one copy and it will be ignored by
             * the preceding if clause)
             */
            if (!(r->m_read.flags & RTMP_READ_NO_IGNORE) &&
   11704:	e2179004 	ands	r9, r7, #4
   11708:	1a000005 	bne	11724 <Read_1_Packet+0x148>
   1170c:	e35b0016 	cmp	fp, #22
   11710:	0a000099 	beq	1197c <Read_1_Packet+0x3a0>
                packet.m_packetType != RTMP_PACKET_TYPE_FLASH_VIDEO)
            {
                /* exclude type RTMP_PACKET_TYPE_FLASH_VIDEO since it can
                 * contain several FLV packets
                 */
                if (packet.m_nTimeStamp == 0)
   11714:	e35a0000 	cmp	sl, #0
   11718:	0affffd4 	beq	11670 <Read_1_Packet+0x94>
                    break;
                }
                else
                {
                    /* stop ignoring packets */
                    r->m_read.flags |= RTMP_READ_NO_IGNORE;
   1171c:	e3877004 	orr	r7, r7, #4
   11720:	e5c470a1 	strb	r7, [r4, #161]	; 0xa1
        
        /* calculate packet size and allocate slop buffer if necessary */
        size = nPacketLen +
        ((packet.m_packetType == RTMP_PACKET_TYPE_AUDIO
          || packet.m_packetType == RTMP_PACKET_TYPE_VIDEO
          || packet.m_packetType == RTMP_PACKET_TYPE_INFO) ? 11 : 0) +
   11724:	e24b9008 	sub	r9, fp, #8
                }
            }
        }
        
        /* calculate packet size and allocate slop buffer if necessary */
        size = nPacketLen +
   11728:	e35b0012 	cmp	fp, #18
   1172c:	13590001 	cmpne	r9, #1
   11730:	93a09001 	movls	r9, #1
   11734:	83a09000 	movhi	r9, #0
   11738:	93a0100b 	movls	r1, #11
   1173c:	8a000050 	bhi	11884 <Read_1_Packet+0x2a8>
        ((packet.m_packetType == RTMP_PACKET_TYPE_AUDIO
          || packet.m_packetType == RTMP_PACKET_TYPE_VIDEO
          || packet.m_packetType == RTMP_PACKET_TYPE_INFO) ? 11 : 0) +
   11740:	e35b0016 	cmp	fp, #22
                }
            }
        }
        
        /* calculate packet size and allocate slop buffer if necessary */
        size = nPacketLen +
   11744:	e0863001 	add	r3, r6, r1
        ((packet.m_packetType == RTMP_PACKET_TYPE_AUDIO
          || packet.m_packetType == RTMP_PACKET_TYPE_VIDEO
          || packet.m_packetType == RTMP_PACKET_TYPE_INFO) ? 11 : 0) +
   11748:	13a01004 	movne	r1, #4
   1174c:	03a01000 	moveq	r1, #0
                }
            }
        }
        
        /* calculate packet size and allocate slop buffer if necessary */
        size = nPacketLen +
   11750:	e0833001 	add	r3, r3, r1
        ((packet.m_packetType == RTMP_PACKET_TYPE_AUDIO
          || packet.m_packetType == RTMP_PACKET_TYPE_VIDEO
          || packet.m_packetType == RTMP_PACKET_TYPE_INFO) ? 11 : 0) +
        (packet.m_packetType != RTMP_PACKET_TYPE_FLASH_VIDEO ? 4 : 0);
        
        if (size + 4 > buflen)
   11754:	e283a004 	add	sl, r3, #4
                }
            }
        }
        
        /* calculate packet size and allocate slop buffer if necessary */
        size = nPacketLen +
   11758:	e58d300c 	str	r3, [sp, #12]
        ((packet.m_packetType == RTMP_PACKET_TYPE_AUDIO
          || packet.m_packetType == RTMP_PACKET_TYPE_VIDEO
          || packet.m_packetType == RTMP_PACKET_TYPE_INFO) ? 11 : 0) +
        (packet.m_packetType != RTMP_PACKET_TYPE_FLASH_VIDEO ? 4 : 0);
        
        if (size + 4 > buflen)
   1175c:	e59d3004 	ldr	r3, [sp, #4]
   11760:	e15a0003 	cmp	sl, r3
   11764:	8a00005e 	bhi	118e4 <Read_1_Packet+0x308>
            recopy = TRUE;
            ptr = r->m_read.buf;
        }
        else
        {
            ptr = buf;
   11768:	e59d7008 	ldr	r7, [sp, #8]
Read_1_Packet(RTMP *r, char *buf, unsigned int buflen)
{
    uint32_t prevTagSize = 0;
    int rtnGetNextMediaPacket = 0, ret = RTMP_READ_EOF;
    RTMPPacket packet = { 0 };
    int recopy = FALSE;
   1176c:	e3a03000 	mov	r3, #0
   11770:	e58d3020 	str	r3, [sp, #32]
        }
        else
        {
            ptr = buf;
        }
        pend = ptr + size + 4;
   11774:	e087300a 	add	r3, r7, sl
        
        /* use to return timestamp of last processed packet */
        
        /* audio (0x08), video (0x09) or metadata (0x12) packets :
         * construct 11 byte header then add rtmp packet's data */
        if (packet.m_packetType == RTMP_PACKET_TYPE_AUDIO
   11778:	e3590000 	cmp	r9, #0
        }
        else
        {
            ptr = buf;
        }
        pend = ptr + size + 4;
   1177c:	e58d3010 	str	r3, [sp, #16]
    int rtnGetNextMediaPacket = 0, ret = RTMP_READ_EOF;
    RTMPPacket packet = { 0 };
    int recopy = FALSE;
    unsigned int size;
    char *ptr, *pend;
    uint32_t nTimeStamp = 0;
   11780:	01a0a009 	moveq	sl, r9
        
        /* use to return timestamp of last processed packet */
        
        /* audio (0x08), video (0x09) or metadata (0x12) packets :
         * construct 11 byte header then add rtmp packet's data */
        if (packet.m_packetType == RTMP_PACKET_TYPE_AUDIO
   11784:	1a000063 	bne	11918 <Read_1_Packet+0x33c>
            
            /* stream id */
            ptr = AMF_EncodeInt24(ptr, pend, 0);
        }
        
        memcpy(ptr, packetBody, nPacketLen);
   11788:	e1a00007 	mov	r0, r7
   1178c:	e1a01005 	mov	r1, r5
   11790:	e1a02006 	mov	r2, r6
   11794:	ebffce8c 	bl	51cc <memcpy@plt>
        len = nPacketLen;
        
        /* correct tagSize and obtain timestamp if we have an FLV stream */
        if (packet.m_packetType == RTMP_PACKET_TYPE_FLASH_VIDEO)
   11798:	e5dd3041 	ldrb	r3, [sp, #65]	; 0x41
   1179c:	e3530016 	cmp	r3, #22
                }
                
                pos += prevTagSize + 4;	/*(11+dataSize+4); */
            }
        }
        ptr += len;
   117a0:	10870006 	addne	r0, r7, r6
        
        memcpy(ptr, packetBody, nPacketLen);
        len = nPacketLen;
        
        /* correct tagSize and obtain timestamp if we have an FLV stream */
        if (packet.m_packetType == RTMP_PACKET_TYPE_FLASH_VIDEO)
   117a4:	0a0000b3 	beq	11a78 <Read_1_Packet+0x49c>
        ptr += len;
        
        if (packet.m_packetType != RTMP_PACKET_TYPE_FLASH_VIDEO)
        {
            /* FLV tag packets contain their own prevTagSize */
            AMF_EncodeInt32(ptr, pend, prevTagSize);
   117a8:	e59d1010 	ldr	r1, [sp, #16]
   117ac:	e1a02009 	mov	r2, r9
   117b0:	eb0011fd 	bl	15fac <AMF_EncodeInt32>
        /* In non-live this nTimeStamp can contain an absolute TS.
         * Update ext timestamp with this absolute offset in non-live mode
         * otherwise report the relative one
         */
        /* RTMP_Log(RTMP_LOGDEBUG, "type: %02X, size: %d, pktTS: %dms, TS: %dms, bLiveStream: %d", packet.m_packetType, nPacketLen, packet.m_nTimeStamp, nTimeStamp, r->Link.lFlags & RTMP_LF_LIVE); */
        r->m_read.timestamp = (r->Link.lFlags & RTMP_LF_LIVE) ? packet.m_nTimeStamp : nTimeStamp;
   117b4:	e2843901 	add	r3, r4, #16384	; 0x4000
   117b8:	e5933180 	ldr	r3, [r3, #384]	; 0x180
        ret = size;
        break;
    }
    
    if (rtnGetNextMediaPacket)
        RTMPPacket_Free(&packet);
   117bc:	e1a00008 	mov	r0, r8
        /* In non-live this nTimeStamp can contain an absolute TS.
         * Update ext timestamp with this absolute offset in non-live mode
         * otherwise report the relative one
         */
        /* RTMP_Log(RTMP_LOGDEBUG, "type: %02X, size: %d, pktTS: %dms, TS: %dms, bLiveStream: %d", packet.m_packetType, nPacketLen, packet.m_nTimeStamp, nTimeStamp, r->Link.lFlags & RTMP_LF_LIVE); */
        r->m_read.timestamp = (r->Link.lFlags & RTMP_LF_LIVE) ? packet.m_nTimeStamp : nTimeStamp;
   117c0:	e3130002 	tst	r3, #2
   117c4:	159d1048 	ldrne	r1, [sp, #72]	; 0x48
   117c8:	01a0100a 	moveq	r1, sl
   117cc:	e584109c 	str	r1, [r4, #156]	; 0x9c
        ret = size;
        break;
    }
    
    if (rtnGetNextMediaPacket)
        RTMPPacket_Free(&packet);
   117d0:	ebffdbe2 	bl	8760 <RTMPPacket_Free>
    
    if (recopy)
   117d4:	e59d3020 	ldr	r3, [sp, #32]
         * otherwise report the relative one
         */
        /* RTMP_Log(RTMP_LOGDEBUG, "type: %02X, size: %d, pktTS: %dms, TS: %dms, bLiveStream: %d", packet.m_packetType, nPacketLen, packet.m_nTimeStamp, nTimeStamp, r->Link.lFlags & RTMP_LF_LIVE); */
        r->m_read.timestamp = (r->Link.lFlags & RTMP_LF_LIVE) ? packet.m_nTimeStamp : nTimeStamp;
        
        ret = size;
   117d8:	e59d700c 	ldr	r7, [sp, #12]
    }
    
    if (rtnGetNextMediaPacket)
        RTMPPacket_Free(&packet);
    
    if (recopy)
   117dc:	e3530000 	cmp	r3, #0
   117e0:	0affffa5 	beq	1167c <Read_1_Packet+0xa0>
    {
        len = ret > buflen ? buflen : ret;
   117e4:	e59d3004 	ldr	r3, [sp, #4]
        memcpy(buf, r->m_read.buf, len);
   117e8:	e59d0008 	ldr	r0, [sp, #8]
    if (rtnGetNextMediaPacket)
        RTMPPacket_Free(&packet);
    
    if (recopy)
    {
        len = ret > buflen ? buflen : ret;
   117ec:	e1570003 	cmp	r7, r3
   117f0:	21a05003 	movcs	r5, r3
   117f4:	31a05007 	movcc	r5, r7
        memcpy(buf, r->m_read.buf, len);
   117f8:	e1a02005 	mov	r2, r5
   117fc:	e5941090 	ldr	r1, [r4, #144]	; 0x90
   11800:	ebffce71 	bl	51cc <memcpy@plt>
        r->m_read.bufpos = r->m_read.buf + len;
   11804:	e5943090 	ldr	r3, [r4, #144]	; 0x90
        r->m_read.buflen = ret - len;
   11808:	e0652007 	rsb	r2, r5, r7
    
    if (recopy)
    {
        len = ret > buflen ? buflen : ret;
        memcpy(buf, r->m_read.buf, len);
        r->m_read.bufpos = r->m_read.buf + len;
   1180c:	e0833005 	add	r3, r3, r5
        r->m_read.buflen = ret - len;
    }
    return ret;
}
   11810:	e1a00007 	mov	r0, r7
    
    if (recopy)
    {
        len = ret > buflen ? buflen : ret;
        memcpy(buf, r->m_read.buf, len);
        r->m_read.bufpos = r->m_read.buf + len;
   11814:	e5843094 	str	r3, [r4, #148]	; 0x94
        r->m_read.buflen = ret - len;
   11818:	e5842098 	str	r2, [r4, #152]	; 0x98
    }
    return ret;
}
   1181c:	e28dd064 	add	sp, sp, #100	; 0x64
   11820:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
                     "Assuming stream is complete");
            ret = RTMP_READ_COMPLETE;
            break;
        }
        
        r->m_read.dataType |= (((packet.m_packetType == RTMP_PACKET_TYPE_AUDIO) << 2) |
   11824:	e3833004 	orr	r3, r3, #4
            RTMP_Log(RTMP_LOGDEBUG, "ignoring too small video packet: size: %d",
                     nPacketLen);
            ret = RTMP_READ_IGNORE;
            break;
        }
        if (packet.m_packetType == RTMP_PACKET_TYPE_AUDIO && nPacketLen <= 1)
   11828:	e3560001 	cmp	r6, #1
                     "Assuming stream is complete");
            ret = RTMP_READ_COMPLETE;
            break;
        }
        
        r->m_read.dataType |= (((packet.m_packetType == RTMP_PACKET_TYPE_AUDIO) << 2) |
   1182c:	e5c430a0 	strb	r3, [r4, #160]	; 0xa0
            RTMP_Log(RTMP_LOGDEBUG, "ignoring too small video packet: size: %d",
                     nPacketLen);
            ret = RTMP_READ_IGNORE;
            break;
        }
        if (packet.m_packetType == RTMP_PACKET_TYPE_AUDIO && nPacketLen <= 1)
   11830:	8affff8b 	bhi	11664 <Read_1_Packet+0x88>
        {
            RTMP_Log(RTMP_LOGDEBUG, "ignoring too small audio packet: size: %d",
   11834:	e59f15b4 	ldr	r1, [pc, #1460]	; 11df0 <Read_1_Packet+0x814>
   11838:	e1a02006 	mov	r2, r6
   1183c:	e3a00004 	mov	r0, #4
   11840:	e08f1001 	add	r1, pc, r1
   11844:	eb001058 	bl	159ac <RTMP_Log>
                     nPacketLen);
            ret = RTMP_READ_IGNORE;
            break;
   11848:	eaffff89 	b	11674 <Read_1_Packet+0x98>
                else
                    ret = RTMP_READ_IGNORE;
                break;
            }
            /* ok, do the same for FLV streams */
            if (!(r->m_read.flags & RTMP_READ_GOTFLVK) &&
   1184c:	e3170010 	tst	r7, #16
   11850:	1affffab 	bne	11704 <Read_1_Packet+0x128>
   11854:	e35b0016 	cmp	fp, #22
   11858:	0a00007c 	beq	11a50 <Read_1_Packet+0x474>
             * keyframes; we've got these so don't mess around with multiple
             * copies sent by the server to us! (if the keyframe is found at a
             * later position there is only one copy and it will be ignored by
             * the preceding if clause)
             */
            if (!(r->m_read.flags & RTMP_READ_NO_IGNORE) &&
   1185c:	e3170004 	tst	r7, #4
   11860:	0affffab 	beq	11714 <Read_1_Packet+0x138>
        
        /* calculate packet size and allocate slop buffer if necessary */
        size = nPacketLen +
        ((packet.m_packetType == RTMP_PACKET_TYPE_AUDIO
          || packet.m_packetType == RTMP_PACKET_TYPE_VIDEO
          || packet.m_packetType == RTMP_PACKET_TYPE_INFO) ? 11 : 0) +
   11864:	e24b9008 	sub	r9, fp, #8
                }
            }
        }
        
        /* calculate packet size and allocate slop buffer if necessary */
        size = nPacketLen +
   11868:	e35b0012 	cmp	fp, #18
   1186c:	13590001 	cmpne	r9, #1
   11870:	93a09001 	movls	r9, #1
   11874:	83a09000 	movhi	r9, #0
   11878:	9286300b 	addls	r3, r6, #11
        ((packet.m_packetType == RTMP_PACKET_TYPE_AUDIO
          || packet.m_packetType == RTMP_PACKET_TYPE_VIDEO
          || packet.m_packetType == RTMP_PACKET_TYPE_INFO) ? 11 : 0) +
   1187c:	93a01004 	movls	r1, #4
                }
            }
        }
        
        /* calculate packet size and allocate slop buffer if necessary */
        size = nPacketLen +
   11880:	9affffb2 	bls	11750 <Read_1_Packet+0x174>
        ((packet.m_packetType == RTMP_PACKET_TYPE_AUDIO
          || packet.m_packetType == RTMP_PACKET_TYPE_VIDEO
          || packet.m_packetType == RTMP_PACKET_TYPE_INFO) ? 11 : 0) +
   11884:	e3a09000 	mov	r9, #0
                }
            }
        }
        
        /* calculate packet size and allocate slop buffer if necessary */
        size = nPacketLen +
   11888:	e1a01009 	mov	r1, r9
   1188c:	eaffffab 	b	11740 <Read_1_Packet+0x164>
        if (r->m_read.flags & RTMP_READ_RESUME)
        {
            /* check the header if we get one */
            if (packet.m_nTimeStamp == 0)
            {
                if (r->m_read.nMetaHeaderSize > 0
   11890:	e59430b0 	ldr	r3, [r4, #176]	; 0xb0
                    && packet.m_packetType == RTMP_PACKET_TYPE_INFO)
   11894:	e2933000 	adds	r3, r3, #0
   11898:	13a03001 	movne	r3, #1
   1189c:	e35b0012 	cmp	fp, #18
   118a0:	13a03000 	movne	r3, #0
   118a4:	e3530000 	cmp	r3, #0
   118a8:	1a0000ec 	bne	11c60 <Read_1_Packet+0x684>
                }
                
                /* check first keyframe to make sure we got the right position
                 * in the stream! (the first non ignored frame)
                 */
                if (r->m_read.nInitialFrameSize > 0)
   118ac:	e594a0b4 	ldr	sl, [r4, #180]	; 0xb4
   118b0:	e35a0000 	cmp	sl, #0
   118b4:	0affff7b 	beq	116a8 <Read_1_Packet+0xcc>
                {
                    /* video or audio data */
                    if (packet.m_packetType == r->m_read.initialFrameType
   118b8:	e5d430a3 	ldrb	r3, [r4, #163]	; 0xa3
                        && r->m_read.nInitialFrameSize == nPacketLen)
   118bc:	e153000b 	cmp	r3, fp
   118c0:	0156000a 	cmpeq	r6, sl
   118c4:	0a00002f 	beq	11988 <Read_1_Packet+0x3ac>
                    /* hande FLV streams, even though the server resends the
                     * keyframe as an extra video packet it is also included
                     * in the first FLV stream chunk and we have to compare
                     * it and filter it out !!
                     */
                    if (packet.m_packetType == RTMP_PACKET_TYPE_FLASH_VIDEO)
   118c8:	e35b0016 	cmp	fp, #22
   118cc:	0a00003b 	beq	119c0 <Read_1_Packet+0x3e4>
   118d0:	e5d470a1 	ldrb	r7, [r4, #161]	; 0xa1
                        }
                    }
                }
            }
            
            if (packet.m_nTimeStamp > 0
   118d4:	e59da048 	ldr	sl, [sp, #72]	; 0x48
   118d8:	e35a0000 	cmp	sl, #0
   118dc:	0affff71 	beq	116a8 <Read_1_Packet+0xcc>
   118e0:	eaffff6d 	b	1169c <Read_1_Packet+0xc0>
        
        if (size + 4 > buflen)
        {
            /* the extra 4 is for the case of an FLV stream without a last
             * prevTagSize (we need extra 4 bytes to append it) */
            r->m_read.buf = malloc(size + 4);
   118e4:	e1a0000a 	mov	r0, sl
   118e8:	ebffcdcb 	bl	501c <malloc@plt>
            if (r->m_read.buf == 0)
   118ec:	e3500000 	cmp	r0, #0
            {
                RTMP_Log(RTMP_LOGERROR, "Couldn't allocate memory!");
                ret = RTMP_READ_ERROR;		/* fatal error */
                break;
            }
            recopy = TRUE;
   118f0:	13a03001 	movne	r3, #1
        
        if (size + 4 > buflen)
        {
            /* the extra 4 is for the case of an FLV stream without a last
             * prevTagSize (we need extra 4 bytes to append it) */
            r->m_read.buf = malloc(size + 4);
   118f4:	e1a07000 	mov	r7, r0
   118f8:	e5840090 	str	r0, [r4, #144]	; 0x90
            {
                RTMP_Log(RTMP_LOGERROR, "Couldn't allocate memory!");
                ret = RTMP_READ_ERROR;		/* fatal error */
                break;
            }
            recopy = TRUE;
   118fc:	158d3020 	strne	r3, [sp, #32]
        if (size + 4 > buflen)
        {
            /* the extra 4 is for the case of an FLV stream without a last
             * prevTagSize (we need extra 4 bytes to append it) */
            r->m_read.buf = malloc(size + 4);
            if (r->m_read.buf == 0)
   11900:	1affff9b 	bne	11774 <Read_1_Packet+0x198>
            {
                RTMP_Log(RTMP_LOGERROR, "Couldn't allocate memory!");
   11904:	e59f14e8 	ldr	r1, [pc, #1256]	; 11df4 <Read_1_Packet+0x818>
   11908:	e3a00001 	mov	r0, #1
   1190c:	e08f1001 	add	r1, pc, r1
   11910:	eb001025 	bl	159ac <RTMP_Log>
   11914:	eaffff70 	b	116dc <Read_1_Packet+0x100>
         * construct 11 byte header then add rtmp packet's data */
        if (packet.m_packetType == RTMP_PACKET_TYPE_AUDIO
            || packet.m_packetType == RTMP_PACKET_TYPE_VIDEO
            || packet.m_packetType == RTMP_PACKET_TYPE_INFO)
        {
            nTimeStamp = r->m_read.nResumeTS + packet.m_nTimeStamp;
   11918:	e59430a4 	ldr	r3, [r4, #164]	; 0xa4
   1191c:	e59d1048 	ldr	r1, [sp, #72]	; 0x48
            prevTagSize = 11 + nPacketLen;
            
            *ptr = packet.m_packetType;
            ptr++;
            ptr = AMF_EncodeInt24(ptr, pend, nPacketLen);
   11920:	e59d9010 	ldr	r9, [sp, #16]
         * construct 11 byte header then add rtmp packet's data */
        if (packet.m_packetType == RTMP_PACKET_TYPE_AUDIO
            || packet.m_packetType == RTMP_PACKET_TYPE_VIDEO
            || packet.m_packetType == RTMP_PACKET_TYPE_INFO)
        {
            nTimeStamp = r->m_read.nResumeTS + packet.m_nTimeStamp;
   11924:	e0813003 	add	r3, r1, r3
            prevTagSize = 11 + nPacketLen;
            
            *ptr = packet.m_packetType;
   11928:	e1a00007 	mov	r0, r7
            ptr++;
            ptr = AMF_EncodeInt24(ptr, pend, nPacketLen);
   1192c:	e1a01009 	mov	r1, r9
         * construct 11 byte header then add rtmp packet's data */
        if (packet.m_packetType == RTMP_PACKET_TYPE_AUDIO
            || packet.m_packetType == RTMP_PACKET_TYPE_VIDEO
            || packet.m_packetType == RTMP_PACKET_TYPE_INFO)
        {
            nTimeStamp = r->m_read.nResumeTS + packet.m_nTimeStamp;
   11930:	e1a07003 	mov	r7, r3
            prevTagSize = 11 + nPacketLen;
            
            *ptr = packet.m_packetType;
            ptr++;
            ptr = AMF_EncodeInt24(ptr, pend, nPacketLen);
   11934:	e1a02006 	mov	r2, r6
            || packet.m_packetType == RTMP_PACKET_TYPE_INFO)
        {
            nTimeStamp = r->m_read.nResumeTS + packet.m_nTimeStamp;
            prevTagSize = 11 + nPacketLen;
            
            *ptr = packet.m_packetType;
   11938:	e4c0b001 	strb	fp, [r0], #1
         * construct 11 byte header then add rtmp packet's data */
        if (packet.m_packetType == RTMP_PACKET_TYPE_AUDIO
            || packet.m_packetType == RTMP_PACKET_TYPE_VIDEO
            || packet.m_packetType == RTMP_PACKET_TYPE_INFO)
        {
            nTimeStamp = r->m_read.nResumeTS + packet.m_nTimeStamp;
   1193c:	e1a0a003 	mov	sl, r3
            prevTagSize = 11 + nPacketLen;
            
            *ptr = packet.m_packetType;
            ptr++;
            ptr = AMF_EncodeInt24(ptr, pend, nPacketLen);
   11940:	eb00118f 	bl	15f84 <AMF_EncodeInt24>
            ptr = AMF_EncodeInt24(ptr, pend, nTimeStamp);
   11944:	e1a01009 	mov	r1, r9
   11948:	e1a02007 	mov	r2, r7
   1194c:	eb00118c 	bl	15f84 <AMF_EncodeInt24>
            *ptr = (char)((nTimeStamp & 0xFF000000) >> 24);
   11950:	e1a03c27 	lsr	r3, r7, #24
            ptr++;
            
            /* stream id */
            ptr = AMF_EncodeInt24(ptr, pend, 0);
   11954:	e1a01009 	mov	r1, r9
   11958:	e3a02000 	mov	r2, #0
        if (packet.m_packetType == RTMP_PACKET_TYPE_AUDIO
            || packet.m_packetType == RTMP_PACKET_TYPE_VIDEO
            || packet.m_packetType == RTMP_PACKET_TYPE_INFO)
        {
            nTimeStamp = r->m_read.nResumeTS + packet.m_nTimeStamp;
            prevTagSize = 11 + nPacketLen;
   1195c:	e286900b 	add	r9, r6, #11
            
            *ptr = packet.m_packetType;
            ptr++;
            ptr = AMF_EncodeInt24(ptr, pend, nPacketLen);
            ptr = AMF_EncodeInt24(ptr, pend, nTimeStamp);
            *ptr = (char)((nTimeStamp & 0xFF000000) >> 24);
   11960:	e4c03001 	strb	r3, [r0], #1
            ptr++;
            
            /* stream id */
            ptr = AMF_EncodeInt24(ptr, pend, 0);
   11964:	eb001186 	bl	15f84 <AMF_EncodeInt24>
   11968:	e1a07000 	mov	r7, r0
   1196c:	eaffff85 	b	11788 <Read_1_Packet+0x1ac>
             * keyframes; we've got these so don't mess around with multiple
             * copies sent by the server to us! (if the keyframe is found at a
             * later position there is only one copy and it will be ignored by
             * the preceding if clause)
             */
            if (!(r->m_read.flags & RTMP_READ_NO_IGNORE) &&
   11970:	e2171004 	ands	r1, r7, #4
   11974:	1affffc2 	bne	11884 <Read_1_Packet+0x2a8>
        
        /* calculate packet size and allocate slop buffer if necessary */
        size = nPacketLen +
        ((packet.m_packetType == RTMP_PACKET_TYPE_AUDIO
          || packet.m_packetType == RTMP_PACKET_TYPE_VIDEO
          || packet.m_packetType == RTMP_PACKET_TYPE_INFO) ? 11 : 0) +
   11978:	e1a09001 	mov	r9, r1
   1197c:	e1a01009 	mov	r1, r9
                }
            }
        }
        
        /* calculate packet size and allocate slop buffer if necessary */
        size = nPacketLen +
   11980:	e1a03006 	mov	r3, r6
   11984:	eaffff71 	b	11750 <Read_1_Packet+0x174>
                        /* we don't compare the sizes since the packet can
                         * contain several FLV packets, just make sure the
                         * first frame is our keyframe (which we are going
                         * to rewrite)
                         */
                        if (memcmp
   11988:	e1a0200a 	mov	r2, sl
   1198c:	e59400ac 	ldr	r0, [r4, #172]	; 0xac
   11990:	e1a01005 	mov	r1, r5
   11994:	ebffce0f 	bl	51d8 <memcmp@plt>
   11998:	e2507000 	subs	r7, r0, #0
   1199c:	1affffc9 	bne	118c8 <Read_1_Packet+0x2ec>
                            (r->m_read.initialFrame, packetBody,
                             r->m_read.nInitialFrameSize) == 0)
                        {
                            RTMP_Log(RTMP_LOGDEBUG, "Checked keyframe successfully!");
   119a0:	e59f1450 	ldr	r1, [pc, #1104]	; 11df8 <Read_1_Packet+0x81c>
   119a4:	e3a00004 	mov	r0, #4
   119a8:	e08f1001 	add	r1, pc, r1
   119ac:	eb000ffe 	bl	159ac <RTMP_Log>
                            r->m_read.flags |= RTMP_READ_GOTKF;
   119b0:	e5d430a1 	ldrb	r3, [r4, #161]	; 0xa1
   119b4:	e3833008 	orr	r3, r3, #8
   119b8:	e5c430a1 	strb	r3, [r4, #161]	; 0xa1
                            /* ignore it! (what about audio data after it? it is
                             * handled by ignoring all 0ms frames, see below)
                             */
                            ret = RTMP_READ_IGNORE;
                            break;
   119bc:	eaffff2c 	b	11674 <Read_1_Packet+0x98>
                         * correct TS being nResumeTS
                         */
                        unsigned int pos = 0;
                        uint32_t ts = 0;
                        
                        while (pos + 11 < nPacketLen)
   119c0:	e356000b 	cmp	r6, #11
   119c4:	9a0000f9 	bls	11db0 <Read_1_Packet+0x7d4>
   119c8:	e3a0b00b 	mov	fp, #11
   119cc:	e3a07000 	mov	r7, #0
   119d0:	ea000003 	b	119e4 <Read_1_Packet+0x408>
   119d4:	e282b01a 	add	fp, r2, #26
   119d8:	e156000b 	cmp	r6, fp
                                     * further packets, wait for seek
                                     */
                                    goto stopKeyframeSearch;
                                }
                            }
                            pos += (11 + dataSize + 4);
   119dc:	e282700f 	add	r7, r2, #15
                         * correct TS being nResumeTS
                         */
                        unsigned int pos = 0;
                        uint32_t ts = 0;
                        
                        while (pos + 11 < nPacketLen)
   119e0:	9a000095 	bls	11c3c <Read_1_Packet+0x660>
                        {
                            /* size without header (11) and prevTagSize (4) */
                            uint32_t dataSize =
                            AMF_DecodeInt24(packetBody + pos + 1);
   119e4:	e2870001 	add	r0, r7, #1
                        uint32_t ts = 0;
                        
                        while (pos + 11 < nPacketLen)
                        {
                            /* size without header (11) and prevTagSize (4) */
                            uint32_t dataSize =
   119e8:	e0850000 	add	r0, r5, r0
   119ec:	eb001120 	bl	15e74 <AMF_DecodeInt24>
   119f0:	e1a09000 	mov	r9, r0
                            AMF_DecodeInt24(packetBody + pos + 1);
                            ts = AMF_DecodeInt24(packetBody + pos + 4);
   119f4:	e2870004 	add	r0, r7, #4
   119f8:	e0850000 	add	r0, r5, r0
   119fc:	eb00111c 	bl	15e74 <AMF_DecodeInt24>
                            ts |= (packetBody[pos + 7] << 24);
   11a00:	e0853007 	add	r3, r5, r7
                                     packetBody[pos], dataSize, ts);
#endif
                            /* ok, is it a keyframe?:
                             * well doesn't work for audio!
                             */
                            if (packetBody[pos /*6928, test 0 */ ] ==
   11a04:	e7d5c007 	ldrb	ip, [r5, r7]
   11a08:	e5d410a3 	ldrb	r1, [r4, #163]	; 0xa3
                        {
                            /* size without header (11) and prevTagSize (4) */
                            uint32_t dataSize =
                            AMF_DecodeInt24(packetBody + pos + 1);
                            ts = AMF_DecodeInt24(packetBody + pos + 4);
                            ts |= (packetBody[pos + 7] << 24);
   11a0c:	e5d33007 	ldrb	r3, [r3, #7]
                                     packetBody[pos], dataSize, ts);
#endif
                            /* ok, is it a keyframe?:
                             * well doesn't work for audio!
                             */
                            if (packetBody[pos /*6928, test 0 */ ] ==
   11a10:	e15c0001 	cmp	ip, r1
                                     * further packets, wait for seek
                                     */
                                    goto stopKeyframeSearch;
                                }
                            }
                            pos += (11 + dataSize + 4);
   11a14:	e0892007 	add	r2, r9, r7
                        {
                            /* size without header (11) and prevTagSize (4) */
                            uint32_t dataSize =
                            AMF_DecodeInt24(packetBody + pos + 1);
                            ts = AMF_DecodeInt24(packetBody + pos + 4);
                            ts |= (packetBody[pos + 7] << 24);
   11a18:	e1800c03 	orr	r0, r0, r3, lsl #24
                                     packetBody[pos], dataSize, ts);
#endif
                            /* ok, is it a keyframe?:
                             * well doesn't work for audio!
                             */
                            if (packetBody[pos /*6928, test 0 */ ] ==
   11a1c:	1affffec 	bne	119d4 <Read_1_Packet+0x3f8>
                                r->m_read.initialFrameType
                                /* && (packetBody[11]&0xf0) == 0x10 */ )
                            {
                                if (ts == r->m_read.nResumeTS)
   11a20:	e59410a4 	ldr	r1, [r4, #164]	; 0xa4
   11a24:	e1510000 	cmp	r1, r0
   11a28:	0a0000b1 	beq	11cf4 <Read_1_Packet+0x718>
                                    nPacketLen -= (pos + 11 + dataSize + 4);
                                    
                                    goto stopKeyframeSearch;
                                    
                                }
                                else if (r->m_read.nResumeTS < ts)
   11a2c:	e1500001 	cmp	r0, r1
   11a30:	9affffe7 	bls	119d4 <Read_1_Packet+0x3f8>
                                     "timestamps are smaller than the keyframe "
                                     "timestamp; probably the resume seek failed?");
                        }
                    stopKeyframeSearch:
                        ;
                        if (!(r->m_read.flags & RTMP_READ_GOTFLVK))
   11a34:	e5d470a1 	ldrb	r7, [r4, #161]	; 0xa1
   11a38:	e2172010 	ands	r2, r7, #16
   11a3c:	0a0000a6 	beq	11cdc <Read_1_Packet+0x700>
   11a40:	e5ddb041 	ldrb	fp, [sp, #65]	; 0x41
   11a44:	eaffffa2 	b	118d4 <Read_1_Packet+0x2f8>
                else
                    ret = RTMP_READ_IGNORE;
                break;
            }
            /* ok, do the same for FLV streams */
            if (!(r->m_read.flags & RTMP_READ_GOTFLVK) &&
   11a48:	e3170010 	tst	r7, #16
   11a4c:	1affffc7 	bne	11970 <Read_1_Packet+0x394>
                packet.m_packetType == RTMP_PACKET_TYPE_FLASH_VIDEO)
            {
                RTMP_Log(RTMP_LOGWARNING,
   11a50:	e59f13a4 	ldr	r1, [pc, #932]	; 11dfc <Read_1_Packet+0x820>
   11a54:	e3a00002 	mov	r0, #2
   11a58:	e08f1001 	add	r1, pc, r1
   11a5c:	eb000fd2 	bl	159ac <RTMP_Log>
                         "Stream does not start with requested FLV frame, ignoring data... ");
                r->m_read.nIgnoredFlvFrameCounter++;
   11a60:	e59430bc 	ldr	r3, [r4, #188]	; 0xbc
   11a64:	e2833001 	add	r3, r3, #1
                if (r->m_read.nIgnoredFlvFrameCounter > MAX_IGNORED_FRAMES)
   11a68:	e3530032 	cmp	r3, #50	; 0x32
            if (!(r->m_read.flags & RTMP_READ_GOTFLVK) &&
                packet.m_packetType == RTMP_PACKET_TYPE_FLASH_VIDEO)
            {
                RTMP_Log(RTMP_LOGWARNING,
                         "Stream does not start with requested FLV frame, ignoring data... ");
                r->m_read.nIgnoredFlvFrameCounter++;
   11a6c:	e58430bc 	str	r3, [r4, #188]	; 0xbc
                if (r->m_read.nIgnoredFlvFrameCounter > MAX_IGNORED_FRAMES)
   11a70:	9afffefe 	bls	11670 <Read_1_Packet+0x94>
   11a74:	eaffff18 	b	116dc <Read_1_Packet+0x100>
        {
            unsigned int pos = 0;
            int delta;
            
            /* grab first timestamp and see if it needs fixing */
            nTimeStamp = AMF_DecodeInt24(packetBody + 4);
   11a78:	e2850004 	add	r0, r5, #4
   11a7c:	eb0010fc 	bl	15e74 <AMF_DecodeInt24>
            nTimeStamp |= (packetBody[7] << 24);
   11a80:	e5d51007 	ldrb	r1, [r5, #7]
   11a84:	e594b0a4 	ldr	fp, [r4, #164]	; 0xa4
   11a88:	e59d3048 	ldr	r3, [sp, #72]	; 0x48
            delta = packet.m_nTimeStamp - nTimeStamp + r->m_read.nResumeTS;
            
            while (pos + 11 < nPacketLen)
   11a8c:	e356000b 	cmp	r6, #11
   11a90:	e08b3003 	add	r3, fp, r3
            unsigned int pos = 0;
            int delta;
            
            /* grab first timestamp and see if it needs fixing */
            nTimeStamp = AMF_DecodeInt24(packetBody + 4);
            nTimeStamp |= (packetBody[7] << 24);
   11a94:	e1802c01 	orr	r2, r0, r1, lsl #24
            delta = packet.m_nTimeStamp - nTimeStamp + r->m_read.nResumeTS;
   11a98:	e0623003 	rsb	r3, r2, r3
            unsigned int pos = 0;
            int delta;
            
            /* grab first timestamp and see if it needs fixing */
            nTimeStamp = AMF_DecodeInt24(packetBody + 4);
            nTimeStamp |= (packetBody[7] << 24);
   11a9c:	e1a0a002 	mov	sl, r2
            delta = packet.m_nTimeStamp - nTimeStamp + r->m_read.nResumeTS;
   11aa0:	e58d301c 	str	r3, [sp, #28]
            
            while (pos + 11 < nPacketLen)
   11aa4:	9a0000ad 	bls	11d60 <Read_1_Packet+0x784>
                                 "Wrong data size (%u), stream corrupted, aborting!",
                                 dataSize);
                        ret = RTMP_READ_ERROR;
                        break;
                    }
                    RTMP_Log(RTMP_LOGWARNING, "No tagSize found, appending!");
   11aa8:	e59f3350 	ldr	r3, [pc, #848]	; 11e00 <Read_1_Packet+0x824>
            /* grab first timestamp and see if it needs fixing */
            nTimeStamp = AMF_DecodeInt24(packetBody + 4);
            nTimeStamp |= (packetBody[7] << 24);
            delta = packet.m_nTimeStamp - nTimeStamp + r->m_read.nResumeTS;
            
            while (pos + 11 < nPacketLen)
   11aac:	e58d6018 	str	r6, [sp, #24]
                                 "Wrong data size (%u), stream corrupted, aborting!",
                                 dataSize);
                        ret = RTMP_READ_ERROR;
                        break;
                    }
                    RTMP_Log(RTMP_LOGWARNING, "No tagSize found, appending!");
   11ab0:	e08f3003 	add	r3, pc, r3
   11ab4:	e58d3024 	str	r3, [sp, #36]	; 0x24
            /* grab first timestamp and see if it needs fixing */
            nTimeStamp = AMF_DecodeInt24(packetBody + 4);
            nTimeStamp |= (packetBody[7] << 24);
            delta = packet.m_nTimeStamp - nTimeStamp + r->m_read.nResumeTS;
            
            while (pos + 11 < nPacketLen)
   11ab8:	e3a0a000 	mov	sl, #0
   11abc:	e58d7014 	str	r7, [sp, #20]
   11ac0:	e58d802c 	str	r8, [sp, #44]	; 0x2c
   11ac4:	ea000023 	b	11b58 <Read_1_Packet+0x57c>
                    AMF_EncodeInt24(ptr+pos+4, pend, nTimeStamp);
                    ptr[pos+7] = nTimeStamp>>24;
                }
                
                /* set data type */
                r->m_read.dataType |= (((*(packetBody + pos) == 0x08) << 2) |
   11ac8:	e7d5300a 	ldrb	r3, [r5, sl]
   11acc:	e5d4c0a0 	ldrb	ip, [r4, #160]	; 0xa0
                                       (*(packetBody + pos) == 0x09));
                
                if (pos + 11 + dataSize + 4 > nPacketLen)
   11ad0:	e088200a 	add	r2, r8, sl
   11ad4:	e3530009 	cmp	r3, #9
   11ad8:	038cc001 	orreq	ip, ip, #1
                    AMF_EncodeInt24(ptr+pos+4, pend, nTimeStamp);
                    ptr[pos+7] = nTimeStamp>>24;
                }
                
                /* set data type */
                r->m_read.dataType |= (((*(packetBody + pos) == 0x08) << 2) |
   11adc:	e3530008 	cmp	r3, #8
   11ae0:	03a03004 	moveq	r3, #4
   11ae4:	13a03000 	movne	r3, #0
                                       (*(packetBody + pos) == 0x09));
                
                if (pos + 11 + dataSize + 4 > nPacketLen)
   11ae8:	e282e00f 	add	lr, r2, #15
                    AMF_EncodeInt24(ptr+pos+4, pend, nTimeStamp);
                    ptr[pos+7] = nTimeStamp>>24;
                }
                
                /* set data type */
                r->m_read.dataType |= (((*(packetBody + pos) == 0x08) << 2) |
   11aec:	e18c3003 	orr	r3, ip, r3
                                       (*(packetBody + pos) == 0x09));
                
                if (pos + 11 + dataSize + 4 > nPacketLen)
   11af0:	e15e0006 	cmp	lr, r6
                {
                    if (pos + 11 + dataSize > nPacketLen)
   11af4:	e282b00b 	add	fp, r2, #11
                                 "Wrong data size (%u), stream corrupted, aborting!",
                                 dataSize);
                        ret = RTMP_READ_ERROR;
                        break;
                    }
                    RTMP_Log(RTMP_LOGWARNING, "No tagSize found, appending!");
   11af8:	e3a00002 	mov	r0, #2
   11afc:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
                    AMF_EncodeInt24(ptr+pos+4, pend, nTimeStamp);
                    ptr[pos+7] = nTimeStamp>>24;
                }
                
                /* set data type */
                r->m_read.dataType |= (((*(packetBody + pos) == 0x08) << 2) |
   11b00:	e5c430a0 	strb	r3, [r4, #160]	; 0xa0
                                       (*(packetBody + pos) == 0x09));
                
                if (pos + 11 + dataSize + 4 > nPacketLen)
   11b04:	9a00002c 	bls	11bbc <Read_1_Packet+0x5e0>
                {
                    if (pos + 11 + dataSize > nPacketLen)
   11b08:	e15b0006 	cmp	fp, r6
   11b0c:	8a000041 	bhi	11c18 <Read_1_Packet+0x63c>
                                 "Wrong data size (%u), stream corrupted, aborting!",
                                 dataSize);
                        ret = RTMP_READ_ERROR;
                        break;
                    }
                    RTMP_Log(RTMP_LOGWARNING, "No tagSize found, appending!");
   11b10:	eb000fa5 	bl	159ac <RTMP_Log>
                    
                    /* we have to append a last tagSize! */
                    prevTagSize = dataSize + 11;
                    AMF_EncodeInt32(ptr + pos + 11 + dataSize, pend,
   11b14:	e59d3014 	ldr	r3, [sp, #20]
                        break;
                    }
                    RTMP_Log(RTMP_LOGWARNING, "No tagSize found, appending!");
                    
                    /* we have to append a last tagSize! */
                    prevTagSize = dataSize + 11;
   11b18:	e288900b 	add	r9, r8, #11
                    AMF_EncodeInt32(ptr + pos + 11 + dataSize, pend,
   11b1c:	e083000b 	add	r0, r3, fp
                                    prevTagSize);
                    size += 4;
   11b20:	e59d300c 	ldr	r3, [sp, #12]
                    }
                    RTMP_Log(RTMP_LOGWARNING, "No tagSize found, appending!");
                    
                    /* we have to append a last tagSize! */
                    prevTagSize = dataSize + 11;
                    AMF_EncodeInt32(ptr + pos + 11 + dataSize, pend,
   11b24:	e1a02009 	mov	r2, r9
                                    prevTagSize);
                    size += 4;
   11b28:	e2833004 	add	r3, r3, #4
   11b2c:	e58d300c 	str	r3, [sp, #12]
                    len += 4;
   11b30:	e59d3018 	ldr	r3, [sp, #24]
                    }
                    RTMP_Log(RTMP_LOGWARNING, "No tagSize found, appending!");
                    
                    /* we have to append a last tagSize! */
                    prevTagSize = dataSize + 11;
                    AMF_EncodeInt32(ptr + pos + 11 + dataSize, pend,
   11b34:	e59d1010 	ldr	r1, [sp, #16]
                                    prevTagSize);
                    size += 4;
                    len += 4;
   11b38:	e2833004 	add	r3, r3, #4
   11b3c:	e58d3018 	str	r3, [sp, #24]
                    }
                    RTMP_Log(RTMP_LOGWARNING, "No tagSize found, appending!");
                    
                    /* we have to append a last tagSize! */
                    prevTagSize = dataSize + 11;
                    AMF_EncodeInt32(ptr + pos + 11 + dataSize, pend,
   11b40:	eb001119 	bl	15fac <AMF_EncodeInt32>
   11b44:	e2893004 	add	r3, r9, #4
                        AMF_EncodeInt32(ptr + pos + 11 + dataSize, pend,
                                        prevTagSize);
                    }
                }
                
                pos += prevTagSize + 4;	/*(11+dataSize+4); */
   11b48:	e08aa003 	add	sl, sl, r3
            /* grab first timestamp and see if it needs fixing */
            nTimeStamp = AMF_DecodeInt24(packetBody + 4);
            nTimeStamp |= (packetBody[7] << 24);
            delta = packet.m_nTimeStamp - nTimeStamp + r->m_read.nResumeTS;
            
            while (pos + 11 < nPacketLen)
   11b4c:	e28a300b 	add	r3, sl, #11
   11b50:	e1530006 	cmp	r3, r6
   11b54:	2a000026 	bcs	11bf4 <Read_1_Packet+0x618>
            {
                /* size without header (11) and without prevTagSize (4) */
                uint32_t dataSize = AMF_DecodeInt24(packetBody + pos + 1);
   11b58:	e28a0001 	add	r0, sl, #1
   11b5c:	e0850000 	add	r0, r5, r0
   11b60:	eb0010c3 	bl	15e74 <AMF_DecodeInt24>
                nTimeStamp = AMF_DecodeInt24(packetBody + pos + 4);
   11b64:	e28ab004 	add	fp, sl, #4
            delta = packet.m_nTimeStamp - nTimeStamp + r->m_read.nResumeTS;
            
            while (pos + 11 < nPacketLen)
            {
                /* size without header (11) and without prevTagSize (4) */
                uint32_t dataSize = AMF_DecodeInt24(packetBody + pos + 1);
   11b68:	e1a08000 	mov	r8, r0
                nTimeStamp = AMF_DecodeInt24(packetBody + pos + 4);
   11b6c:	e085000b 	add	r0, r5, fp
   11b70:	eb0010bf 	bl	15e74 <AMF_DecodeInt24>
                nTimeStamp |= (packetBody[pos + 7] << 24);
   11b74:	e28a3007 	add	r3, sl, #7
                
                if (delta)
   11b78:	e59d201c 	ldr	r2, [sp, #28]
            while (pos + 11 < nPacketLen)
            {
                /* size without header (11) and without prevTagSize (4) */
                uint32_t dataSize = AMF_DecodeInt24(packetBody + pos + 1);
                nTimeStamp = AMF_DecodeInt24(packetBody + pos + 4);
                nTimeStamp |= (packetBody[pos + 7] << 24);
   11b7c:	e7d57003 	ldrb	r7, [r5, r3]
                
                if (delta)
   11b80:	e3520000 	cmp	r2, #0
            while (pos + 11 < nPacketLen)
            {
                /* size without header (11) and without prevTagSize (4) */
                uint32_t dataSize = AMF_DecodeInt24(packetBody + pos + 1);
                nTimeStamp = AMF_DecodeInt24(packetBody + pos + 4);
                nTimeStamp |= (packetBody[pos + 7] << 24);
   11b84:	e1807c07 	orr	r7, r0, r7, lsl #24
                
                if (delta)
   11b88:	0affffce 	beq	11ac8 <Read_1_Packet+0x4ec>
   11b8c:	e58d3028 	str	r3, [sp, #40]	; 0x28
                {
                    nTimeStamp += delta;
                    AMF_EncodeInt24(ptr+pos+4, pend, nTimeStamp);
   11b90:	e59d3014 	ldr	r3, [sp, #20]
                nTimeStamp = AMF_DecodeInt24(packetBody + pos + 4);
                nTimeStamp |= (packetBody[pos + 7] << 24);
                
                if (delta)
                {
                    nTimeStamp += delta;
   11b94:	e0877002 	add	r7, r7, r2
                    AMF_EncodeInt24(ptr+pos+4, pend, nTimeStamp);
   11b98:	e083000b 	add	r0, r3, fp
   11b9c:	e1a02007 	mov	r2, r7
   11ba0:	e59d1010 	ldr	r1, [sp, #16]
   11ba4:	eb0010f6 	bl	15f84 <AMF_EncodeInt24>
                    ptr[pos+7] = nTimeStamp>>24;
   11ba8:	e59d1014 	ldr	r1, [sp, #20]
   11bac:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
   11bb0:	e1a02c27 	lsr	r2, r7, #24
   11bb4:	e7c12003 	strb	r2, [r1, r3]
   11bb8:	eaffffc2 	b	11ac8 <Read_1_Packet+0x4ec>
                    len += 4;
                }
                else
                {
                    prevTagSize =
                    AMF_DecodeInt32(packetBody + pos + 11 + dataSize);
   11bbc:	e282b00b 	add	fp, r2, #11
                    size += 4;
                    len += 4;
                }
                else
                {
                    prevTagSize =
   11bc0:	e085000b 	add	r0, r5, fp
   11bc4:	eb0010b1 	bl	15e90 <AMF_DecodeInt32>
                             "FLV Packet: type %02X, dataSize: %lu, tagSize: %lu, timeStamp: %lu ms",
                             (unsigned char)packetBody[pos], dataSize, prevTagSize,
                             nTimeStamp);
#endif
                    
                    if (prevTagSize != (dataSize + 11))
   11bc8:	e288900b 	add	r9, r8, #11
                                 "Tag and data size are not consitent, writing tag size according to dataSize+11: %d",
                                 dataSize + 11);
#endif
                        
                        prevTagSize = dataSize + 11;
                        AMF_EncodeInt32(ptr + pos + 11 + dataSize, pend,
   11bcc:	e59d3014 	ldr	r3, [sp, #20]
   11bd0:	e59d1010 	ldr	r1, [sp, #16]
   11bd4:	e1a02009 	mov	r2, r9
                             "FLV Packet: type %02X, dataSize: %lu, tagSize: %lu, timeStamp: %lu ms",
                             (unsigned char)packetBody[pos], dataSize, prevTagSize,
                             nTimeStamp);
#endif
                    
                    if (prevTagSize != (dataSize + 11))
   11bd8:	e1590000 	cmp	r9, r0
                                 "Tag and data size are not consitent, writing tag size according to dataSize+11: %d",
                                 dataSize + 11);
#endif
                        
                        prevTagSize = dataSize + 11;
                        AMF_EncodeInt32(ptr + pos + 11 + dataSize, pend,
   11bdc:	e083000b 	add	r0, r3, fp
                             "FLV Packet: type %02X, dataSize: %lu, tagSize: %lu, timeStamp: %lu ms",
                             (unsigned char)packetBody[pos], dataSize, prevTagSize,
                             nTimeStamp);
#endif
                    
                    if (prevTagSize != (dataSize + 11))
   11be0:	0affffd7 	beq	11b44 <Read_1_Packet+0x568>
                                 "Tag and data size are not consitent, writing tag size according to dataSize+11: %d",
                                 dataSize + 11);
#endif
                        
                        prevTagSize = dataSize + 11;
                        AMF_EncodeInt32(ptr + pos + 11 + dataSize, pend,
   11be4:	eb0010f0 	bl	15fac <AMF_EncodeInt32>
   11be8:	eaffffd5 	b	11b44 <Read_1_Packet+0x568>
 */
static int
Read_1_Packet(RTMP *r, char *buf, unsigned int buflen)
{
    uint32_t prevTagSize = 0;
    int rtnGetNextMediaPacket = 0, ret = RTMP_READ_EOF;
   11bec:	e3e07000 	mvn	r7, #0
   11bf0:	eafffea1 	b	1167c <Read_1_Packet+0xa0>
   11bf4:	e1a0a007 	mov	sl, r7
   11bf8:	e59d802c 	ldr	r8, [sp, #44]	; 0x2c
   11bfc:	e59d7014 	ldr	r7, [sp, #20]
                pos += prevTagSize + 4;	/*(11+dataSize+4); */
            }
        }
        ptr += len;
        
        if (packet.m_packetType != RTMP_PACKET_TYPE_FLASH_VIDEO)
   11c00:	e5dd3041 	ldrb	r3, [sp, #65]	; 0x41
   11c04:	e3530016 	cmp	r3, #22
   11c08:	0afffee9 	beq	117b4 <Read_1_Packet+0x1d8>
                }
                
                pos += prevTagSize + 4;	/*(11+dataSize+4); */
            }
        }
        ptr += len;
   11c0c:	e59d3018 	ldr	r3, [sp, #24]
   11c10:	e0870003 	add	r0, r7, r3
   11c14:	eafffee3 	b	117a8 <Read_1_Packet+0x1cc>
                
                if (pos + 11 + dataSize + 4 > nPacketLen)
                {
                    if (pos + 11 + dataSize > nPacketLen)
                    {
                        RTMP_Log(RTMP_LOGERROR,
   11c18:	e59f11e4 	ldr	r1, [pc, #484]	; 11e04 <Read_1_Packet+0x828>
   11c1c:	e1a02008 	mov	r2, r8
   11c20:	e3a00001 	mov	r0, #1
   11c24:	e08f1001 	add	r1, pc, r1
   11c28:	e1a0a007 	mov	sl, r7
   11c2c:	e59d802c 	ldr	r8, [sp, #44]	; 0x2c
   11c30:	e59d7014 	ldr	r7, [sp, #20]
   11c34:	eb000f5c 	bl	159ac <RTMP_Log>
                                 "Wrong data size (%u), stream corrupted, aborting!",
                                 dataSize);
                        ret = RTMP_READ_ERROR;
                        break;
   11c38:	eafffff0 	b	11c00 <Read_1_Packet+0x624>
   11c3c:	e1a0a000 	mov	sl, r0
                                    goto stopKeyframeSearch;
                                }
                            }
                            pos += (11 + dataSize + 4);
                        }
                        if (ts < r->m_read.nResumeTS)
   11c40:	e59430a4 	ldr	r3, [r4, #164]	; 0xa4
   11c44:	e15a0003 	cmp	sl, r3
   11c48:	2affff79 	bcs	11a34 <Read_1_Packet+0x458>
                        {
                            RTMP_Log(RTMP_LOGERROR,
   11c4c:	e59f11b4 	ldr	r1, [pc, #436]	; 11e08 <Read_1_Packet+0x82c>
   11c50:	e3a00001 	mov	r0, #1
   11c54:	e08f1001 	add	r1, pc, r1
   11c58:	eb000f53 	bl	159ac <RTMP_Log>
   11c5c:	eaffff74 	b	11a34 <Read_1_Packet+0x458>
            {
                if (r->m_read.nMetaHeaderSize > 0
                    && packet.m_packetType == RTMP_PACKET_TYPE_INFO)
                {
                    AMFObject metaObj;
                    int nRes =
   11c60:	e28d7030 	add	r7, sp, #48	; 0x30
   11c64:	e1a00007 	mov	r0, r7
   11c68:	e1a01005 	mov	r1, r5
   11c6c:	e1a02006 	mov	r2, r6
   11c70:	e1a0300a 	mov	r3, sl
   11c74:	eb0016a4 	bl	1770c <AMF_Decode>
                    AMF_Decode(&metaObj, packetBody, nPacketLen, FALSE);
                    if (nRes >= 0)
   11c78:	e3500000 	cmp	r0, #0
   11c7c:	ba00000a 	blt	11cac <Read_1_Packet+0x6d0>
                    {
                        AVal metastring;
                        AMFProp_GetString(AMF_GetProp(&metaObj, NULL, 0),
   11c80:	e1a0200a 	mov	r2, sl
   11c84:	e1a0100a 	mov	r1, sl
   11c88:	e1a00007 	mov	r0, r7
   11c8c:	eb0012df 	bl	16810 <AMF_GetProp>
   11c90:	e28d1038 	add	r1, sp, #56	; 0x38
   11c94:	eb00117f 	bl	16298 <AMFProp_GetString>
                                          &metastring);
                        
                        if (AVMATCH(&metastring, &av_onMetaData))
   11c98:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
   11c9c:	e352000a 	cmp	r2, #10
   11ca0:	0a000035 	beq	11d7c <Read_1_Packet+0x7a0>
                                  r->m_read.nMetaHeaderSize) != 0))
                            {
                                ret = RTMP_READ_ERROR;
                            }
                        }
                        AMF_Reset(&metaObj);
   11ca4:	e1a00007 	mov	r0, r7
   11ca8:	eb0013c7 	bl	16bcc <AMF_Reset>
                }
                
                /* check first keyframe to make sure we got the right position
                 * in the stream! (the first non ignored frame)
                 */
                if (r->m_read.nInitialFrameSize > 0)
   11cac:	e594a0b4 	ldr	sl, [r4, #180]	; 0xb4
   11cb0:	e35a0000 	cmp	sl, #0
   11cb4:	15ddb041 	ldrbne	fp, [sp, #65]	; 0x41
   11cb8:	1afffefe 	bne	118b8 <Read_1_Packet+0x2dc>
   11cbc:	e5d470a1 	ldrb	r7, [r4, #161]	; 0xa1
   11cc0:	eaffff5e 	b	11a40 <Read_1_Packet+0x464>
        /* Return RTMP_READ_COMPLETE if this was completed nicely with
         * invoke message Play.Stop or Play.Complete
         */
        if (rtnGetNextMediaPacket == 2)
        {
            RTMP_Log(RTMP_LOGDEBUG,
   11cc4:	e59f1140 	ldr	r1, [pc, #320]	; 11e0c <Read_1_Packet+0x830>
   11cc8:	e3a00004 	mov	r0, #4
   11ccc:	e08f1001 	add	r1, pc, r1
   11cd0:	eb000f35 	bl	159ac <RTMP_Log>
                     "Got Play.Complete or Play.Stop from server. "
                     "Assuming stream is complete");
            ret = RTMP_READ_COMPLETE;
   11cd4:	e3e07002 	mvn	r7, #2
            break;
   11cd8:	eafffe65 	b	11674 <Read_1_Packet+0x98>
                        }
                    stopKeyframeSearch:
                        ;
                        if (!(r->m_read.flags & RTMP_READ_GOTFLVK))
                        {
                            RTMP_Log(RTMP_LOGERROR,
   11cdc:	e59f112c 	ldr	r1, [pc, #300]	; 11e10 <Read_1_Packet+0x834>
   11ce0:	e3a00001 	mov	r0, #1
   11ce4:	e08f1001 	add	r1, pc, r1
                                     "Couldn't find the seeked keyframe in this chunk!");
                            ret = RTMP_READ_IGNORE;
   11ce8:	e1a07002 	mov	r7, r2
                        }
                    stopKeyframeSearch:
                        ;
                        if (!(r->m_read.flags & RTMP_READ_GOTFLVK))
                        {
                            RTMP_Log(RTMP_LOGERROR,
   11cec:	eb000f2e 	bl	159ac <RTMP_Log>
                                     "Couldn't find the seeked keyframe in this chunk!");
                            ret = RTMP_READ_IGNORE;
                            break;
   11cf0:	eafffe5f 	b	11674 <Read_1_Packet+0x98>
                                r->m_read.initialFrameType
                                /* && (packetBody[11]&0xf0) == 0x10 */ )
                            {
                                if (ts == r->m_read.nResumeTS)
                                {
                                    RTMP_Log(RTMP_LOGDEBUG,
   11cf4:	e59f1118 	ldr	r1, [pc, #280]	; 11e14 <Read_1_Packet+0x838>
   11cf8:	e1a0a000 	mov	sl, r0
   11cfc:	e08f1001 	add	r1, pc, r1
   11d00:	e3a00004 	mov	r0, #4
   11d04:	eb000f28 	bl	159ac <RTMP_Log>
                                             "Found keyframe with resume-keyframe timestamp!");
                                    if (r->m_read.nInitialFrameSize != dataSize
   11d08:	e59430b4 	ldr	r3, [r4, #180]	; 0xb4
   11d0c:	e1530009 	cmp	r3, r9
   11d10:	1a000014 	bne	11d68 <Read_1_Packet+0x78c>
                                        || memcmp(r->m_read.initialFrame,
   11d14:	e1a02003 	mov	r2, r3
   11d18:	e085100b 	add	r1, r5, fp
   11d1c:	e59400ac 	ldr	r0, [r4, #172]	; 0xac
   11d20:	e58d300c 	str	r3, [sp, #12]
   11d24:	ebffcd2b 	bl	51d8 <memcmp@plt>
   11d28:	e59d300c 	ldr	r3, [sp, #12]
   11d2c:	e3500000 	cmp	r0, #0
   11d30:	1a00000c 	bne	11d68 <Read_1_Packet+0x78c>
                                        RTMP_Log(RTMP_LOGERROR,
                                                 "FLV Stream: Keyframe doesn't match!");
                                        ret = RTMP_READ_ERROR;
                                        break;
                                    }
                                    r->m_read.flags |= RTMP_READ_GOTFLVK;
   11d34:	e5d420a1 	ldrb	r2, [r4, #161]	; 0xa1
                                    
                                    /* skip this packet?
                                     * check whether skippable:
                                     */
                                    if (pos + 11 + dataSize + 4 > nPacketLen)
   11d38:	e0873003 	add	r3, r7, r3
   11d3c:	e283100f 	add	r1, r3, #15
                                        RTMP_Log(RTMP_LOGERROR,
                                                 "FLV Stream: Keyframe doesn't match!");
                                        ret = RTMP_READ_ERROR;
                                        break;
                                    }
                                    r->m_read.flags |= RTMP_READ_GOTFLVK;
   11d40:	e3822010 	orr	r2, r2, #16
                                    
                                    /* skip this packet?
                                     * check whether skippable:
                                     */
                                    if (pos + 11 + dataSize + 4 > nPacketLen)
   11d44:	e1560001 	cmp	r6, r1
                                        RTMP_Log(RTMP_LOGERROR,
                                                 "FLV Stream: Keyframe doesn't match!");
                                        ret = RTMP_READ_ERROR;
                                        break;
                                    }
                                    r->m_read.flags |= RTMP_READ_GOTFLVK;
   11d48:	e5c420a1 	strb	r2, [r4, #161]	; 0xa1
                                    
                                    /* skip this packet?
                                     * check whether skippable:
                                     */
                                    if (pos + 11 + dataSize + 4 > nPacketLen)
   11d4c:	3a000019 	bcc	11db8 <Read_1_Packet+0x7dc>
   11d50:	e246600f 	sub	r6, r6, #15
                                                 "Non skipable packet since it doesn't end with chunk, stream corrupt!");
                                        ret = RTMP_READ_ERROR;
                                        break;
                                    }
                                    packetBody += (pos + 11 + dataSize + 4);
                                    nPacketLen -= (pos + 11 + dataSize + 4);
   11d54:	e0636006 	rsb	r6, r3, r6
                                        RTMP_Log(RTMP_LOGWARNING,
                                                 "Non skipable packet since it doesn't end with chunk, stream corrupt!");
                                        ret = RTMP_READ_ERROR;
                                        break;
                                    }
                                    packetBody += (pos + 11 + dataSize + 4);
   11d58:	e0855001 	add	r5, r5, r1
                                    nPacketLen -= (pos + 11 + dataSize + 4);
                                    
                                    goto stopKeyframeSearch;
   11d5c:	eaffff34 	b	11a34 <Read_1_Packet+0x458>
            /* grab first timestamp and see if it needs fixing */
            nTimeStamp = AMF_DecodeInt24(packetBody + 4);
            nTimeStamp |= (packetBody[7] << 24);
            delta = packet.m_nTimeStamp - nTimeStamp + r->m_read.nResumeTS;
            
            while (pos + 11 < nPacketLen)
   11d60:	e58d6018 	str	r6, [sp, #24]
   11d64:	eaffffa5 	b	11c00 <Read_1_Packet+0x624>
                                        || memcmp(r->m_read.initialFrame,
                                                  packetBody + pos + 11,
                                                  r->m_read.
                                                  nInitialFrameSize) != 0)
                                    {
                                        RTMP_Log(RTMP_LOGERROR,
   11d68:	e59f10a8 	ldr	r1, [pc, #168]	; 11e18 <Read_1_Packet+0x83c>
   11d6c:	e3a00001 	mov	r0, #1
   11d70:	e08f1001 	add	r1, pc, r1
   11d74:	eb000f0c 	bl	159ac <RTMP_Log>
                                                 "FLV Stream: Keyframe doesn't match!");
                                        ret = RTMP_READ_ERROR;
                                        break;
   11d78:	eaffffb0 	b	11c40 <Read_1_Packet+0x664>
                    {
                        AVal metastring;
                        AMFProp_GetString(AMF_GetProp(&metaObj, NULL, 0),
                                          &metastring);
                        
                        if (AVMATCH(&metastring, &av_onMetaData))
   11d7c:	e59f1098 	ldr	r1, [pc, #152]	; 11e1c <Read_1_Packet+0x840>
   11d80:	e59d0038 	ldr	r0, [sp, #56]	; 0x38
   11d84:	e08f1001 	add	r1, pc, r1
   11d88:	ebffcd12 	bl	51d8 <memcmp@plt>
   11d8c:	e3500000 	cmp	r0, #0
   11d90:	1affffc3 	bne	11ca4 <Read_1_Packet+0x6c8>
                        {
                            /* compare */
                            if ((r->m_read.nMetaHeaderSize != nPacketLen) ||
   11d94:	e59430b0 	ldr	r3, [r4, #176]	; 0xb0
   11d98:	e1530006 	cmp	r3, r6
   11d9c:	0a00000a 	beq	11dcc <Read_1_Packet+0x7f0>
                                  r->m_read.nMetaHeaderSize) != 0))
                            {
                                ret = RTMP_READ_ERROR;
                            }
                        }
                        AMF_Reset(&metaObj);
   11da0:	e1a00007 	mov	r0, r7
   11da4:	eb001388 	bl	16bcc <AMF_Reset>
   11da8:	e3e07001 	mvn	r7, #1
   11dac:	eafffe30 	b	11674 <Read_1_Packet+0x98>
                         * correct TS being nResumeTS
                         */
                        unsigned int pos = 0;
                        uint32_t ts = 0;
                        
                        while (pos + 11 < nPacketLen)
   11db0:	e3a0a000 	mov	sl, #0
   11db4:	eaffffa1 	b	11c40 <Read_1_Packet+0x664>
                                    /* skip this packet?
                                     * check whether skippable:
                                     */
                                    if (pos + 11 + dataSize + 4 > nPacketLen)
                                    {
                                        RTMP_Log(RTMP_LOGWARNING,
   11db8:	e59f1060 	ldr	r1, [pc, #96]	; 11e20 <Read_1_Packet+0x844>
   11dbc:	e3a00002 	mov	r0, #2
   11dc0:	e08f1001 	add	r1, pc, r1
   11dc4:	eb000ef8 	bl	159ac <RTMP_Log>
                                                 "Non skipable packet since it doesn't end with chunk, stream corrupt!");
                                        ret = RTMP_READ_ERROR;
                                        break;
   11dc8:	eaffff9c 	b	11c40 <Read_1_Packet+0x664>
                        
                        if (AVMATCH(&metastring, &av_onMetaData))
                        {
                            /* compare */
                            if ((r->m_read.nMetaHeaderSize != nPacketLen) ||
                                (memcmp
   11dcc:	e59400a8 	ldr	r0, [r4, #168]	; 0xa8
   11dd0:	e1a01005 	mov	r1, r5
   11dd4:	e1a02006 	mov	r2, r6
   11dd8:	ebffccfe 	bl	51d8 <memcmp@plt>
                                          &metastring);
                        
                        if (AVMATCH(&metastring, &av_onMetaData))
                        {
                            /* compare */
                            if ((r->m_read.nMetaHeaderSize != nPacketLen) ||
   11ddc:	e3500000 	cmp	r0, #0
   11de0:	1affffee 	bne	11da0 <Read_1_Packet+0x7c4>
   11de4:	eaffffae 	b	11ca4 <Read_1_Packet+0x6c8>
   11de8:	0000ed70 	.word	0x0000ed70
   11dec:	0000eb6c 	.word	0x0000eb6c
   11df0:	0000ea50 	.word	0x0000ea50
   11df4:	0000eba8 	.word	0x0000eba8
   11df8:	0000e914 	.word	0x0000e914
   11dfc:	0000ea18 	.word	0x0000ea18
   11e00:	0000ea54 	.word	0x0000ea54
   11e04:	0000e8ac 	.word	0x0000e8ac
   11e08:	0000e724 	.word	0x0000e724
   11e0c:	0000e550 	.word	0x0000e550
   11e10:	0000e718 	.word	0x0000e718
   11e14:	0000e5e0 	.word	0x0000e5e0
   11e18:	0000e59c 	.word	0x0000e59c
   11e1c:	0000cd90 	.word	0x0000cd90
   11e20:	0000e570 	.word	0x0000e570

00011e24 <RTMP_SendPacket_reconnect>:
    return TRUE;
}

int RTMP_SendPacket_reconnect(RTMPMetadata *pMetadata, BufferConfig *pConfig, RTMPPacket *packet,RTMPAccess *pAccess,void (*ChangeState)(int))
{
    if(!pConfig || !pConfig->pRTMP)
   11e24:	e3510000 	cmp	r1, #0
   11e28:	0a0000d9 	beq	12194 <RTMP_SendPacket_reconnect+0x370>
    memcpy(r->m_vecChannelsOut[packet->m_nChannel], packet, sizeof(RTMPPacket));
    return TRUE;
}

int RTMP_SendPacket_reconnect(RTMPMetadata *pMetadata, BufferConfig *pConfig, RTMPPacket *packet,RTMPAccess *pAccess,void (*ChangeState)(int))
{
   11e2c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if(!pConfig || !pConfig->pRTMP)
   11e30:	e5914000 	ldr	r4, [r1]
    memcpy(r->m_vecChannelsOut[packet->m_nChannel], packet, sizeof(RTMPPacket));
    return TRUE;
}

int RTMP_SendPacket_reconnect(RTMPMetadata *pMetadata, BufferConfig *pConfig, RTMPPacket *packet,RTMPAccess *pAccess,void (*ChangeState)(int))
{
   11e34:	e24ddf8d 	sub	sp, sp, #564	; 0x234
    if(!pConfig || !pConfig->pRTMP)
   11e38:	e3540000 	cmp	r4, #0
   11e3c:	0a00007d 	beq	12038 <RTMP_SendPacket_reconnect+0x214>
   11e40:	e58d2014 	str	r2, [sp, #20]
   11e44:	e58d0018 	str	r0, [sp, #24]
   11e48:	e1a0a001 	mov	sl, r1
        return 0;
	
    RTMP *r = pConfig->pRTMP;
    
    int ret = FALSE;
    ret = RTMP_SendPacket(r, packet, 0);
   11e4c:	e1a00004 	mov	r0, r4
   11e50:	e1a01002 	mov	r1, r2
   11e54:	e3a02000 	mov	r2, #0
   11e58:	e1a08003 	mov	r8, r3
   11e5c:	ebffe566 	bl	b3fc <RTMP_SendPacket>

    // add the time cost
    if (ret == TRUE) {
   11e60:	e3500001 	cmp	r0, #1
        return 0;
	
    RTMP *r = pConfig->pRTMP;
    
    int ret = FALSE;
    ret = RTMP_SendPacket(r, packet, 0);
   11e64:	e58d0010 	str	r0, [sp, #16]

    // add the time cost
    if (ret == TRUE) {
   11e68:	0a0000cb 	beq	1219c <RTMP_SendPacket_reconnect+0x378>
    }

    
    if (ret != TRUE)
    {
        ChangeState(reconnect_begin);
   11e6c:	e59d3258 	ldr	r3, [sp, #600]	; 0x258
   11e70:	e3a00006 	mov	r0, #6
   11e74:	e12fff33 	blx	r3
        pConfig->bKeyFramePutted = FALSE;
        RTMP_Log(RTMP_LOGINFO," push : change state to : reconnect begin \n");
   11e78:	e59f140c 	ldr	r1, [pc, #1036]	; 1228c <RTMP_SendPacket_reconnect+0x468>

    
    if (ret != TRUE)
    {
        ChangeState(reconnect_begin);
        pConfig->bKeyFramePutted = FALSE;
   11e7c:	e3a07000 	mov	r7, #0
        RTMP_Log(RTMP_LOGINFO," push : change state to : reconnect begin \n");
   11e80:	e3a00003 	mov	r0, #3
   11e84:	e08f1001 	add	r1, pc, r1

    
    if (ret != TRUE)
    {
        ChangeState(reconnect_begin);
        pConfig->bKeyFramePutted = FALSE;
   11e88:	e58a7038 	str	r7, [sl, #56]	; 0x38
        RTMP_Log(RTMP_LOGINFO," push : change state to : reconnect begin \n");
   11e8c:	eb000ec6 	bl	159ac <RTMP_Log>
        int try_time = pConfig->iWaitTime/1000;
   11e90:	e59ab014 	ldr	fp, [sl, #20]
   11e94:	e59f33f4 	ldr	r3, [pc, #1012]	; 12290 <RTMP_SendPacket_reconnect+0x46c>
        RTMP_Log(RTMP_LOGINFO," push : send fail,so connect,%d   %d \n",r->m_sb.sb_socket,try_time);
   11e98:	e59f13f4 	ldr	r1, [pc, #1012]	; 12294 <RTMP_SendPacket_reconnect+0x470>
    if (ret != TRUE)
    {
        ChangeState(reconnect_begin);
        pConfig->bKeyFramePutted = FALSE;
        RTMP_Log(RTMP_LOGINFO," push : change state to : reconnect begin \n");
        int try_time = pConfig->iWaitTime/1000;
   11e9c:	e08b2b93 	umull	r2, fp, r3, fp
        RTMP_Log(RTMP_LOGINFO," push : send fail,so connect,%d   %d \n",r->m_sb.sb_socket,try_time);
   11ea0:	e3a00003 	mov	r0, #3
    if (ret != TRUE)
    {
        ChangeState(reconnect_begin);
        pConfig->bKeyFramePutted = FALSE;
        RTMP_Log(RTMP_LOGINFO," push : change state to : reconnect begin \n");
        int try_time = pConfig->iWaitTime/1000;
   11ea4:	e1a0332b 	lsr	r3, fp, #6
   11ea8:	e1a05003 	mov	r5, r3
        RTMP_Log(RTMP_LOGINFO," push : send fail,so connect,%d   %d \n",r->m_sb.sb_socket,try_time);
   11eac:	e08f1001 	add	r1, pc, r1
   11eb0:	e59420e0 	ldr	r2, [r4, #224]	; 0xe0
    if (ret != TRUE)
    {
        ChangeState(reconnect_begin);
        pConfig->bKeyFramePutted = FALSE;
        RTMP_Log(RTMP_LOGINFO," push : change state to : reconnect begin \n");
        int try_time = pConfig->iWaitTime/1000;
   11eb4:	e58d3000 	str	r3, [sp]
        RTMP_Log(RTMP_LOGINFO," push : send fail,so connect,%d   %d \n",r->m_sb.sb_socket,try_time);
   11eb8:	eb000ebb 	bl	159ac <RTMP_Log>
        int fail_num = 0;
        for(fail_num = 0; fail_num < try_time; fail_num++)
   11ebc:	e1550007 	cmp	r5, r7
   11ec0:	0a00007d 	beq	120bc <RTMP_SendPacket_reconnect+0x298>
            
            pthread_mutex_unlock(&pConfig->lock);
            if(state_rtmp != send_status)
                break;

            if (strstr(pAccess->src_url, "rtmp://gb.push.live.kankan.com") != NULL)
   11ec4:	e59f33cc 	ldr	r3, [pc, #972]	; 12298 <RTMP_SendPacket_reconnect+0x474>
   11ec8:	e28a9024 	add	r9, sl, #36	; 0x24
   11ecc:	e08f3003 	add	r3, pc, r3
   11ed0:	e58d3004 	str	r3, [sp, #4]
            else
            {
                memcpy(rtmp_url,pAccess->src_url,strlen(pAccess->src_url));
            }
			
			RTMP_Log(RTMP_LOGINFO, "push: real rtmp url:%s",rtmp_url);
   11ed4:	e59f33c0 	ldr	r3, [pc, #960]	; 1229c <RTMP_SendPacket_reconnect+0x478>
   11ed8:	e28d603c 	add	r6, sp, #60	; 0x3c
   11edc:	e08f3003 	add	r3, pc, r3
   11ee0:	e58d3008 	str	r3, [sp, #8]
				RTMP_Log(RTMP_LOGINFO, "*** setup url fail");
				continue;
			}
            
            RTMP_EnableWrite(r);
            RTMP_Log(RTMP_LOGINFO, "push: reconnect tcurl:%s  %d", r->Link.tcUrl.av_val, r->Link.tcUrl.av_len);
   11ee4:	e59f33b4 	ldr	r3, [pc, #948]	; 122a0 <RTMP_SendPacket_reconnect+0x47c>
   11ee8:	e08f3003 	add	r3, pc, r3
   11eec:	e58d300c 	str	r3, [sp, #12]
            //send sh end
            //send data
            ret = RTMP_SendPacket(r,packet,0);
            if(!ret)
            {
                RTMP_Log(RTMP_LOGINFO, "push: send reconnect packet fail");
   11ef0:	e59f33ac 	ldr	r3, [pc, #940]	; 122a4 <RTMP_SendPacket_reconnect+0x480>
   11ef4:	e08f3003 	add	r3, pc, r3
   11ef8:	e58d3024 	str	r3, [sp, #36]	; 0x24
            }
			
            ret = RTMP_Send_Sequence(r,pConfig->pAudioBuffer,packet->m_nTimeStamp);
            if(!ret)
            {
                RTMP_Log(RTMP_LOGINFO, "push: send reconnect audio sh fail");
   11efc:	e59f33a4 	ldr	r3, [pc, #932]	; 122a8 <RTMP_SendPacket_reconnect+0x484>
   11f00:	e08f3003 	add	r3, pc, r3
   11f04:	e58d3020 	str	r3, [sp, #32]
			
            //send sh begin
            ret = RTMP_Send_Sequence(r,pConfig->pVideoBuffer,packet->m_nTimeStamp);
            if(!ret)
            {
                RTMP_Log(RTMP_LOGINFO, "push: send reconnect video sh fail");
   11f08:	e59f339c 	ldr	r3, [pc, #924]	; 122ac <RTMP_SendPacket_reconnect+0x488>
   11f0c:	e08f3003 	add	r3, pc, r3
   11f10:	e58d301c 	str	r3, [sp, #28]
   11f14:	ea000008 	b	11f3c <RTMP_SendPacket_reconnect+0x118>
            {
                memcpy(&r->access,pAccess,sizeof(RTMPAccess));
                
                if(!RTMP_Request_Access(r,pAccess->src_url,rtmp_url))
                {
                    RTMP_Log(RTMP_LOGINFO, "push : request push access fail, %s",rtmp_url);
   11f18:	e59f1390 	ldr	r1, [pc, #912]	; 122b0 <RTMP_SendPacket_reconnect+0x48c>
   11f1c:	e3a00003 	mov	r0, #3
   11f20:	e08f1001 	add	r1, pc, r1
   11f24:	e1a02006 	mov	r2, r6
   11f28:	eb000e9f 	bl	159ac <RTMP_Log>
        pConfig->bKeyFramePutted = FALSE;
        RTMP_Log(RTMP_LOGINFO," push : change state to : reconnect begin \n");
        int try_time = pConfig->iWaitTime/1000;
        RTMP_Log(RTMP_LOGINFO," push : send fail,so connect,%d   %d \n",r->m_sb.sb_socket,try_time);
        int fail_num = 0;
        for(fail_num = 0; fail_num < try_time; fail_num++)
   11f2c:	e59d3000 	ldr	r3, [sp]
   11f30:	e2877001 	add	r7, r7, #1
   11f34:	e1530007 	cmp	r3, r7
   11f38:	0a000039 	beq	12024 <RTMP_SendPacket_reconnect+0x200>
        {
           
            CloseInternal(r, 0);
   11f3c:	e3a01000 	mov	r1, #0
   11f40:	e1a00004 	mov	r0, r4
   11f44:	ebffe3b3 	bl	ae18 <CloseInternal>
            RTMP_Init(r);
   11f48:	e1a00004 	mov	r0, r4
   11f4c:	ebffda6e 	bl	890c <RTMP_Init>
                
            if(!r)
                break;
			
            char rtmp_url[500] = {'\0'};
   11f50:	e3a01000 	mov	r1, #0
   11f54:	e3a02f7d 	mov	r2, #500	; 0x1f4
   11f58:	e1a00006 	mov	r0, r6
   11f5c:	ebffcc5b 	bl	50d0 <memset@plt>
            sleep(1);
   11f60:	e3a00001 	mov	r0, #1
   11f64:	ebffcd49 	bl	5490 <sleep@plt>
            
            pthread_mutex_lock(&pConfig->lock);
   11f68:	e1a00009 	mov	r0, r9
   11f6c:	ebffccba 	bl	525c <pthread_mutex_lock@plt>
            
            int state_rtmp = pConfig->state;
   11f70:	e59a500c 	ldr	r5, [sl, #12]
            
            pthread_mutex_unlock(&pConfig->lock);
   11f74:	e1a00009 	mov	r0, r9
   11f78:	ebffccba 	bl	5268 <pthread_mutex_unlock@plt>
            if(state_rtmp != send_status)
   11f7c:	e3550002 	cmp	r5, #2
   11f80:	1a00004e 	bne	120c0 <RTMP_SendPacket_reconnect+0x29c>
                break;

            if (strstr(pAccess->src_url, "rtmp://gb.push.live.kankan.com") != NULL)
   11f84:	e2885e79 	add	r5, r8, #1936	; 0x790
   11f88:	e2855008 	add	r5, r5, #8
   11f8c:	e1a00005 	mov	r0, r5
   11f90:	e59d1004 	ldr	r1, [sp, #4]
   11f94:	ebffcc77 	bl	5178 <strstr@plt>
   11f98:	e3500000 	cmp	r0, #0
   11f9c:	0a00003f 	beq	120a0 <RTMP_SendPacket_reconnect+0x27c>
            {
                memcpy(&r->access,pAccess,sizeof(RTMPAccess));
   11fa0:	e2843c42 	add	r3, r4, #16896	; 0x4200
   11fa4:	e283b008 	add	fp, r3, #8
   11fa8:	e1a01008 	mov	r1, r8
   11fac:	e59f2300 	ldr	r2, [pc, #768]	; 122b4 <RTMP_SendPacket_reconnect+0x490>
   11fb0:	e1a0000b 	mov	r0, fp
   11fb4:	ebffcc84 	bl	51cc <memcpy@plt>
                
                if(!RTMP_Request_Access(r,pAccess->src_url,rtmp_url))
   11fb8:	e1a00004 	mov	r0, r4
   11fbc:	e1a01005 	mov	r1, r5
   11fc0:	e1a02006 	mov	r2, r6
   11fc4:	ebffe345 	bl	ace0 <RTMP_Request_Access>
   11fc8:	e3500000 	cmp	r0, #0
   11fcc:	0affffd1 	beq	11f18 <RTMP_SendPacket_reconnect+0xf4>
                {
                    RTMP_Log(RTMP_LOGINFO, "push : request push access fail, %s",rtmp_url);
                    continue;
                }
                memcpy(pAccess,&r->access,sizeof(RTMPAccess));
   11fd0:	e1a0100b 	mov	r1, fp
   11fd4:	e1a00008 	mov	r0, r8
   11fd8:	e59f22d4 	ldr	r2, [pc, #724]	; 122b4 <RTMP_SendPacket_reconnect+0x490>
   11fdc:	ebffcc7a 	bl	51cc <memcpy@plt>
            else
            {
                memcpy(rtmp_url,pAccess->src_url,strlen(pAccess->src_url));
            }
			
			RTMP_Log(RTMP_LOGINFO, "push: real rtmp url:%s",rtmp_url);
   11fe0:	e3a00003 	mov	r0, #3
   11fe4:	e59d1008 	ldr	r1, [sp, #8]
   11fe8:	e1a02006 	mov	r2, r6
   11fec:	eb000e6e 	bl	159ac <RTMP_Log>
			if (RTMP_SetupURL(r,rtmp_url) == FALSE)
   11ff0:	e1a00004 	mov	r0, r4
   11ff4:	e1a01006 	mov	r1, r6
   11ff8:	ebffdd40 	bl	9500 <RTMP_SetupURL>
   11ffc:	e3500000 	cmp	r0, #0
   12000:	1a00000f 	bne	12044 <RTMP_SendPacket_reconnect+0x220>
			{
				RTMP_Log(RTMP_LOGINFO, "*** setup url fail");
   12004:	e59f12ac 	ldr	r1, [pc, #684]	; 122b8 <RTMP_SendPacket_reconnect+0x494>
   12008:	e3a00003 	mov	r0, #3
   1200c:	e08f1001 	add	r1, pc, r1
   12010:	eb000e65 	bl	159ac <RTMP_Log>
        pConfig->bKeyFramePutted = FALSE;
        RTMP_Log(RTMP_LOGINFO," push : change state to : reconnect begin \n");
        int try_time = pConfig->iWaitTime/1000;
        RTMP_Log(RTMP_LOGINFO," push : send fail,so connect,%d   %d \n",r->m_sb.sb_socket,try_time);
        int fail_num = 0;
        for(fail_num = 0; fail_num < try_time; fail_num++)
   12014:	e59d3000 	ldr	r3, [sp]
   12018:	e2877001 	add	r7, r7, #1
   1201c:	e1530007 	cmp	r3, r7
   12020:	1affffc5 	bne	11f3c <RTMP_SendPacket_reconnect+0x118>
                continue;
            }
            else
                break;
        }
        if((fail_num < try_time) && ret)
   12024:	e59d3010 	ldr	r3, [sp, #16]
   12028:	e2933000 	adds	r3, r3, #0
   1202c:	13a03001 	movne	r3, #1
            ChangeState(reconnect_success);
            pConfig->bKeyFramePutted = FALSE;
        }
    }
	
    if(ret)
   12030:	e3530000 	cmp	r3, #0
   12034:	1a000031 	bne	12100 <RTMP_SendPacket_reconnect+0x2dc>
}

int RTMP_SendPacket_reconnect(RTMPMetadata *pMetadata, BufferConfig *pConfig, RTMPPacket *packet,RTMPAccess *pAccess,void (*ChangeState)(int))
{
    if(!pConfig || !pConfig->pRTMP)
        return 0;
   12038:	e3a00000 	mov	r0, #0
        r->m_send_data += (packet->m_nBodySize + 13);
        pthread_mutex_unlock(&r->lock_speed);
    }
	
    return ret;
}
   1203c:	e28ddf8d 	add	sp, sp, #564	; 0x234
   12040:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
			{
				RTMP_Log(RTMP_LOGINFO, "*** setup url fail");
				continue;
			}
            
            RTMP_EnableWrite(r);
   12044:	e1a00004 	mov	r0, r4
   12048:	ebffda68 	bl	89f0 <RTMP_EnableWrite>
            RTMP_Log(RTMP_LOGINFO, "push: reconnect tcurl:%s  %d", r->Link.tcUrl.av_val, r->Link.tcUrl.av_len);
   1204c:	e2843901 	add	r3, r4, #16384	; 0x4000
   12050:	e5932114 	ldr	r2, [r3, #276]	; 0x114
   12054:	e3a00003 	mov	r0, #3
   12058:	e5933118 	ldr	r3, [r3, #280]	; 0x118
   1205c:	e59d100c 	ldr	r1, [sp, #12]
   12060:	eb000e51 	bl	159ac <RTMP_Log>
            if (!RTMP_Connect(r, NULL) ||  !RTMP_ConnectStream(r, 0))
   12064:	e1a00004 	mov	r0, r4
   12068:	e3a01000 	mov	r1, #0
   1206c:	ebfff61e 	bl	f8ec <RTMP_Connect>
   12070:	e3500000 	cmp	r0, #0
   12074:	0a000004 	beq	1208c <RTMP_SendPacket_reconnect+0x268>
   12078:	e1a00004 	mov	r0, r4
   1207c:	e3a01000 	mov	r1, #0
   12080:	ebfffcd0 	bl	113c8 <RTMP_ConnectStream>
   12084:	e3500000 	cmp	r0, #0
   12088:	1a00002c 	bne	12140 <RTMP_SendPacket_reconnect+0x31c>
            {
                RTMP_Log(RTMP_LOGINFO, "push: reconnect fail");
   1208c:	e59f1228 	ldr	r1, [pc, #552]	; 122bc <RTMP_SendPacket_reconnect+0x498>
   12090:	e3a00003 	mov	r0, #3
   12094:	e08f1001 	add	r1, pc, r1
   12098:	eb000e43 	bl	159ac <RTMP_Log>
                continue;
   1209c:	eaffffa2 	b	11f2c <RTMP_SendPacket_reconnect+0x108>
                }
                memcpy(pAccess,&r->access,sizeof(RTMPAccess));
            }
            else
            {
                memcpy(rtmp_url,pAccess->src_url,strlen(pAccess->src_url));
   120a0:	e1a00005 	mov	r0, r5
   120a4:	ebffcc15 	bl	5100 <strlen@plt>
   120a8:	e1a01005 	mov	r1, r5
   120ac:	e1a02000 	mov	r2, r0
   120b0:	e1a00006 	mov	r0, r6
   120b4:	ebffcc44 	bl	51cc <memcpy@plt>
   120b8:	eaffffc8 	b	11fe0 <RTMP_SendPacket_reconnect+0x1bc>
        pConfig->bKeyFramePutted = FALSE;
        RTMP_Log(RTMP_LOGINFO," push : change state to : reconnect begin \n");
        int try_time = pConfig->iWaitTime/1000;
        RTMP_Log(RTMP_LOGINFO," push : send fail,so connect,%d   %d \n",r->m_sb.sb_socket,try_time);
        int fail_num = 0;
        for(fail_num = 0; fail_num < try_time; fail_num++)
   120bc:	e59d7000 	ldr	r7, [sp]
                continue;
            }
            else
                break;
        }
        if((fail_num < try_time) && ret)
   120c0:	e59d2010 	ldr	r2, [sp, #16]
   120c4:	e59d1000 	ldr	r1, [sp]
   120c8:	e2923000 	adds	r3, r2, #0
   120cc:	13a03001 	movne	r3, #1
   120d0:	e3520000 	cmp	r2, #0
   120d4:	11570001 	cmpne	r7, r1
   120d8:	aaffffd4 	bge	12030 <RTMP_SendPacket_reconnect+0x20c>
        {
            RTMP_Log(RTMP_LOGINFO, "push: change state to : reconnect success");
   120dc:	e59f11dc 	ldr	r1, [pc, #476]	; 122c0 <RTMP_SendPacket_reconnect+0x49c>
   120e0:	e3a00003 	mov	r0, #3
   120e4:	e08f1001 	add	r1, pc, r1
   120e8:	eb000e2f 	bl	159ac <RTMP_Log>
            ChangeState(reconnect_success);
   120ec:	e59d3258 	ldr	r3, [sp, #600]	; 0x258
   120f0:	e3a00007 	mov	r0, #7
   120f4:	e12fff33 	blx	r3
            pConfig->bKeyFramePutted = FALSE;
   120f8:	e3a03000 	mov	r3, #0
   120fc:	e58a3038 	str	r3, [sl, #56]	; 0x38
        }
    }
	
    if(ret)
    {
        pthread_mutex_lock(&r->lock_speed);
   12100:	e2844c4b 	add	r4, r4, #19200	; 0x4b00
   12104:	e28450a8 	add	r5, r4, #168	; 0xa8
   12108:	e1a00005 	mov	r0, r5
   1210c:	ebffcc52 	bl	525c <pthread_mutex_lock@plt>
        r->m_send_data += (packet->m_nBodySize + 13);
   12110:	e59d3014 	ldr	r3, [sp, #20]
        pthread_mutex_unlock(&r->lock_speed);
   12114:	e1a00005 	mov	r0, r5
    }
	
    if(ret)
    {
        pthread_mutex_lock(&r->lock_speed);
        r->m_send_data += (packet->m_nBodySize + 13);
   12118:	e5931010 	ldr	r1, [r3, #16]
   1211c:	e1c429d8 	ldrd	r2, [r4, #152]	; 0x98
   12120:	e281100d 	add	r1, r1, #13
   12124:	e0922001 	adds	r2, r2, r1
   12128:	e2a33000 	adc	r3, r3, #0
   1212c:	e1c429f8 	strd	r2, [r4, #152]	; 0x98
        pthread_mutex_unlock(&r->lock_speed);
   12130:	ebffcc4c 	bl	5268 <pthread_mutex_unlock@plt>
   12134:	e59d0010 	ldr	r0, [sp, #16]
    }
	
    return ret;
}
   12138:	e28ddf8d 	add	sp, sp, #564	; 0x234
   1213c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
            {
                RTMP_Log(RTMP_LOGINFO, "push: reconnect fail");
                continue;
            }
			
            ret = RTMP_SendChunkSize(r);
   12140:	e1a00004 	mov	r0, r4
   12144:	ebffeb39 	bl	ce30 <RTMP_SendChunkSize>
            if(!ret)
   12148:	e2503000 	subs	r3, r0, #0
   1214c:	e58d3010 	str	r3, [sp, #16]
   12150:	0a00000a 	beq	12180 <RTMP_SendPacket_reconnect+0x35c>
            {
                RTMP_Log(RTMP_LOGINFO, "push : send reconnect chunksize fail");
                continue;
            }
            
			ret = SendMetadataPacket(pConfig->pRTMP, pMetadata);
   12154:	e59a0000 	ldr	r0, [sl]
   12158:	e59d1018 	ldr	r1, [sp, #24]
   1215c:	eb001ec0 	bl	19c64 <SendMetadataPacket>
			if (!ret)
   12160:	e2503000 	subs	r3, r0, #0
   12164:	e58d3010 	str	r3, [sp, #16]
   12168:	1a000022 	bne	121f8 <RTMP_SendPacket_reconnect+0x3d4>
			{
				RTMP_Log(RTMP_LOGINFO, "push : send reconnect meta-data fail");
   1216c:	e59f1150 	ldr	r1, [pc, #336]	; 122c4 <RTMP_SendPacket_reconnect+0x4a0>
   12170:	e3a00003 	mov	r0, #3
   12174:	e08f1001 	add	r1, pc, r1
   12178:	eb000e0b 	bl	159ac <RTMP_Log>
				continue;
   1217c:	eaffff6a 	b	11f2c <RTMP_SendPacket_reconnect+0x108>
            }
			
            ret = RTMP_SendChunkSize(r);
            if(!ret)
            {
                RTMP_Log(RTMP_LOGINFO, "push : send reconnect chunksize fail");
   12180:	e59f1140 	ldr	r1, [pc, #320]	; 122c8 <RTMP_SendPacket_reconnect+0x4a4>
   12184:	e3a00003 	mov	r0, #3
   12188:	e08f1001 	add	r1, pc, r1
   1218c:	eb000e06 	bl	159ac <RTMP_Log>
                continue;
   12190:	eaffff65 	b	11f2c <RTMP_SendPacket_reconnect+0x108>
}

int RTMP_SendPacket_reconnect(RTMPMetadata *pMetadata, BufferConfig *pConfig, RTMPPacket *packet,RTMPAccess *pAccess,void (*ChangeState)(int))
{
    if(!pConfig || !pConfig->pRTMP)
        return 0;
   12194:	e3a00000 	mov	r0, #0
        r->m_send_data += (packet->m_nBodySize + 13);
        pthread_mutex_unlock(&r->lock_speed);
    }
	
    return ret;
}
   12198:	e12fff1e 	bx	lr
//        RTMP_Log(RTMP_LOGINFO,"yq log : ts:%d  cur_ts:%d\n",ts, cur_ts);
//#define RTMP_PACKET_TYPE_AUDIO              0x08
//#define RTMP_PACKET_TYPE_VIDEO              0x09
        
        
        uint8_t  type = packet->m_packetType;
   1219c:	e59d3014 	ldr	r3, [sp, #20]
        
        char s1[20],s2[20];
     
        
        
        sprintf(s1,"pts=%d",ts);
   121a0:	e59f1124 	ldr	r1, [pc, #292]	; 122cc <RTMP_SendPacket_reconnect+0x4a8>
   121a4:	e28d6028 	add	r6, sp, #40	; 0x28
//#define RTMP_PACKET_TYPE_AUDIO              0x08
//#define RTMP_PACKET_TYPE_VIDEO              0x09
        
        
        uint8_t  type = packet->m_packetType;
        uint32_t size = packet->m_nBodySize;
   121a8:	e5935010 	ldr	r5, [r3, #16]
        
        char s1[20],s2[20];
     
        
        
        sprintf(s1,"pts=%d",ts);
   121ac:	e5932008 	ldr	r2, [r3, #8]
   121b0:	e1a00006 	mov	r0, r6
   121b4:	e08f1001 	add	r1, pc, r1
//        RTMP_Log(RTMP_LOGINFO,"yq log : ts:%d  cur_ts:%d\n",ts, cur_ts);
//#define RTMP_PACKET_TYPE_AUDIO              0x08
//#define RTMP_PACKET_TYPE_VIDEO              0x09
        
        
        uint8_t  type = packet->m_packetType;
   121b8:	e5d37001 	ldrb	r7, [r3, #1]
        
        char s1[20],s2[20];
     
        
        
        sprintf(s1,"pts=%d",ts);
   121bc:	ebffcbea 	bl	516c <sprintf@plt>
        sprintf(s2,"type=%d,size=%d",type,size);
   121c0:	e59f1108 	ldr	r1, [pc, #264]	; 122d0 <RTMP_SendPacket_reconnect+0x4ac>
   121c4:	e1a03005 	mov	r3, r5
   121c8:	e28d503c 	add	r5, sp, #60	; 0x3c
   121cc:	e1a02007 	mov	r2, r7
   121d0:	e1a00005 	mov	r0, r5
   121d4:	e08f1001 	add	r1, pc, r1
   121d8:	ebffcbe3 	bl	516c <sprintf@plt>
   121dc:	e59f30f0 	ldr	r3, [pc, #240]	; 122d4 <RTMP_SendPacket_reconnect+0x4b0>
      
        
        g_func_rtmpSetProc(s1,s2);
   121e0:	e1a00006 	mov	r0, r6
   121e4:	e79f3003 	ldr	r3, [pc, r3]
   121e8:	e1a01005 	mov	r1, r5
   121ec:	e5933000 	ldr	r3, [r3]
   121f0:	e12fff33 	blx	r3
   121f4:	eaffffc1 	b	12100 <RTMP_SendPacket_reconnect+0x2dc>
				RTMP_Log(RTMP_LOGINFO, "push : send reconnect meta-data fail");
				continue;
			}
			
            //send sh begin
            ret = RTMP_Send_Sequence(r,pConfig->pVideoBuffer,packet->m_nTimeStamp);
   121f8:	e59d3014 	ldr	r3, [sp, #20]
   121fc:	e1a00004 	mov	r0, r4
   12200:	e5932008 	ldr	r2, [r3, #8]
   12204:	e59a1004 	ldr	r1, [sl, #4]
   12208:	eb0021a6 	bl	1a8a8 <RTMP_Send_Sequence>
            if(!ret)
   1220c:	e2503000 	subs	r3, r0, #0
   12210:	e58d3010 	str	r3, [sp, #16]
   12214:	0a00000b 	beq	12248 <RTMP_SendPacket_reconnect+0x424>
            {
                RTMP_Log(RTMP_LOGINFO, "push: send reconnect video sh fail");
                continue;
            }
			
            ret = RTMP_Send_Sequence(r,pConfig->pAudioBuffer,packet->m_nTimeStamp);
   12218:	e59d3014 	ldr	r3, [sp, #20]
   1221c:	e1a00004 	mov	r0, r4
   12220:	e5932008 	ldr	r2, [r3, #8]
   12224:	e59a1008 	ldr	r1, [sl, #8]
   12228:	eb00219e 	bl	1a8a8 <RTMP_Send_Sequence>
            if(!ret)
   1222c:	e2503000 	subs	r3, r0, #0
   12230:	e58d3010 	str	r3, [sp, #16]
   12234:	1a000007 	bne	12258 <RTMP_SendPacket_reconnect+0x434>
            {
                RTMP_Log(RTMP_LOGINFO, "push: send reconnect audio sh fail");
   12238:	e3a00003 	mov	r0, #3
   1223c:	e59d1020 	ldr	r1, [sp, #32]
   12240:	eb000dd9 	bl	159ac <RTMP_Log>
                continue;
   12244:	eaffff38 	b	11f2c <RTMP_SendPacket_reconnect+0x108>
			
            //send sh begin
            ret = RTMP_Send_Sequence(r,pConfig->pVideoBuffer,packet->m_nTimeStamp);
            if(!ret)
            {
                RTMP_Log(RTMP_LOGINFO, "push: send reconnect video sh fail");
   12248:	e3a00003 	mov	r0, #3
   1224c:	e59d101c 	ldr	r1, [sp, #28]
   12250:	eb000dd5 	bl	159ac <RTMP_Log>
                continue;
   12254:	eaffff34 	b	11f2c <RTMP_SendPacket_reconnect+0x108>
            if(!ret)
            {
                RTMP_Log(RTMP_LOGINFO, "push: send reconnect audio sh fail");
                continue;
            }
            sleep(1);
   12258:	e3a00001 	mov	r0, #1
   1225c:	ebffcc8b 	bl	5490 <sleep@plt>
			
            //send sh end
            //send data
            ret = RTMP_SendPacket(r,packet,0);
   12260:	e1a00004 	mov	r0, r4
   12264:	e59d1014 	ldr	r1, [sp, #20]
   12268:	e3a02000 	mov	r2, #0
   1226c:	ebffe462 	bl	b3fc <RTMP_SendPacket>
            if(!ret)
   12270:	e2503000 	subs	r3, r0, #0
   12274:	e58d3010 	str	r3, [sp, #16]
   12278:	1affff90 	bne	120c0 <RTMP_SendPacket_reconnect+0x29c>
            {
                RTMP_Log(RTMP_LOGINFO, "push: send reconnect packet fail");
   1227c:	e3a00003 	mov	r0, #3
   12280:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
   12284:	eb000dc8 	bl	159ac <RTMP_Log>
                continue;
   12288:	eaffff27 	b	11f2c <RTMP_SendPacket_reconnect+0x108>
   1228c:	0000e848 	.word	0x0000e848
   12290:	10624dd3 	.word	0x10624dd3
   12294:	0000e84c 	.word	0x0000e84c
   12298:	0000e670 	.word	0x0000e670
   1229c:	0000e6a4 	.word	0x0000e6a4
   122a0:	0000e6c4 	.word	0x0000e6c4
   122a4:	0000e788 	.word	0x0000e788
   122a8:	0000e758 	.word	0x0000e758
   122ac:	0000e728 	.word	0x0000e728
   122b0:	0000e63c 	.word	0x0000e63c
   122b4:	0000098c 	.word	0x0000098c
   122b8:	0000e58c 	.word	0x0000e58c
   122bc:	0000e538 	.word	0x0000e538
   122c0:	0000e5bc 	.word	0x0000e5bc
   122c4:	0000e498 	.word	0x0000e498
   122c8:	0000e45c 	.word	0x0000e45c
   122cc:	0000e370 	.word	0x0000e370
   122d0:	0000e358 	.word	0x0000e358
   122d4:	00011b90 	.word	0x00011b90

000122d8 <RTMP_Read>:
};

#define HEADERBUF	(128*1024)
int
RTMP_Read(RTMP *r, char *buf, int size)
{
   122d8:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
            char *mybuf = malloc(HEADERBUF), *end = mybuf + HEADERBUF;
            int cnt = 0;
            r->m_read.buf = mybuf;
            r->m_read.buflen = HEADERBUF;
            
            memcpy(mybuf, flvHeader, sizeof(flvHeader));
   122dc:	e59f729c 	ldr	r7, [pc, #668]	; 12580 <RTMP_Read+0x2a8>
   122e0:	e5d050a2 	ldrb	r5, [r0, #162]	; 0xa2
   122e4:	e08f7007 	add	r7, pc, r7
};

#define HEADERBUF	(128*1024)
int
RTMP_Read(RTMP *r, char *buf, int size)
{
   122e8:	e24dd00c 	sub	sp, sp, #12
            char *mybuf = malloc(HEADERBUF), *end = mybuf + HEADERBUF;
            int cnt = 0;
            r->m_read.buf = mybuf;
            r->m_read.buflen = HEADERBUF;
            
            memcpy(mybuf, flvHeader, sizeof(flvHeader));
   122ec:	e2473ea7 	sub	r3, r7, #2672	; 0xa70
};

#define HEADERBUF	(128*1024)
int
RTMP_Read(RTMP *r, char *buf, int size)
{
   122f0:	e1a04000 	mov	r4, r0
   122f4:	e1a0a001 	mov	sl, r1
   122f8:	e1a09002 	mov	r9, r2
    int nRead = 0, total = 0;
   122fc:	e3a0b000 	mov	fp, #0
            char *mybuf = malloc(HEADERBUF), *end = mybuf + HEADERBUF;
            int cnt = 0;
            r->m_read.buf = mybuf;
            r->m_read.buflen = HEADERBUF;
            
            memcpy(mybuf, flvHeader, sizeof(flvHeader));
   12300:	e58d3004 	str	r3, [sp, #4]
{
    int nRead = 0, total = 0;
    
    /* can't continue */
fail:
    switch (r->m_read.status) {
   12304:	e1a05c05 	lsl	r5, r5, #24
   12308:	e1a03c45 	asr	r3, r5, #24
   1230c:	e3730002 	cmn	r3, #2
   12310:	0a000067 	beq	124b4 <RTMP_Read+0x1dc>
   12314:	e3730001 	cmn	r3, #1
   12318:	0a000062 	beq	124a8 <RTMP_Read+0x1d0>
   1231c:	e3730003 	cmn	r3, #3
   12320:	0a000060 	beq	124a8 <RTMP_Read+0x1d0>
        default:
            break;
    }
    
    /* first time thru */
    if (!(r->m_read.flags & RTMP_READ_HEADER))
   12324:	e5d430a1 	ldrb	r3, [r4, #161]	; 0xa1
   12328:	e3130001 	tst	r3, #1
   1232c:	1a00008f 	bne	12570 <RTMP_Read+0x298>
    {
        if (!(r->m_read.flags & RTMP_READ_RESUME))
   12330:	e3130002 	tst	r3, #2
   12334:	1a00008f 	bne	12578 <RTMP_Read+0x2a0>
        {
            char *mybuf = malloc(HEADERBUF), *end = mybuf + HEADERBUF;
   12338:	e3a00802 	mov	r0, #131072	; 0x20000
   1233c:	ebffcb36 	bl	501c <malloc@plt>
            int cnt = 0;
            r->m_read.buf = mybuf;
            r->m_read.buflen = HEADERBUF;
            
            memcpy(mybuf, flvHeader, sizeof(flvHeader));
   12340:	e59d3004 	ldr	r3, [sp, #4]
            r->m_read.buf += sizeof(flvHeader);
            r->m_read.buflen -= sizeof(flvHeader);
   12344:	e59fc238 	ldr	ip, [pc, #568]	; 12584 <RTMP_Read+0x2ac>
   12348:	e584c098 	str	ip, [r4, #152]	; 0x98
    /* first time thru */
    if (!(r->m_read.flags & RTMP_READ_HEADER))
    {
        if (!(r->m_read.flags & RTMP_READ_RESUME))
        {
            char *mybuf = malloc(HEADERBUF), *end = mybuf + HEADERBUF;
   1234c:	e1a06000 	mov	r6, r0
            int cnt = 0;
            r->m_read.buf = mybuf;
            r->m_read.buflen = HEADERBUF;
            
            memcpy(mybuf, flvHeader, sizeof(flvHeader));
   12350:	e813000f 	ldmda	r3, {r0, r1, r2, r3}
            r->m_read.buf += sizeof(flvHeader);
   12354:	e286500d 	add	r5, r6, #13
            char *mybuf = malloc(HEADERBUF), *end = mybuf + HEADERBUF;
            int cnt = 0;
            r->m_read.buf = mybuf;
            r->m_read.buflen = HEADERBUF;
            
            memcpy(mybuf, flvHeader, sizeof(flvHeader));
   12358:	e1a0e006 	mov	lr, r6
   1235c:	e8ae0007 	stmia	lr!, {r0, r1, r2}
            r->m_read.buf += sizeof(flvHeader);
   12360:	e5845090 	str	r5, [r4, #144]	; 0x90
            char *mybuf = malloc(HEADERBUF), *end = mybuf + HEADERBUF;
            int cnt = 0;
            r->m_read.buf = mybuf;
            r->m_read.buflen = HEADERBUF;
            
            memcpy(mybuf, flvHeader, sizeof(flvHeader));
   12364:	e5ce3000 	strb	r3, [lr]
    /* first time thru */
    if (!(r->m_read.flags & RTMP_READ_HEADER))
    {
        if (!(r->m_read.flags & RTMP_READ_RESUME))
        {
            char *mybuf = malloc(HEADERBUF), *end = mybuf + HEADERBUF;
   12368:	e2868802 	add	r8, r6, #131072	; 0x20000
            r->m_read.buflen = HEADERBUF;
            
            memcpy(mybuf, flvHeader, sizeof(flvHeader));
            r->m_read.buf += sizeof(flvHeader);
            r->m_read.buflen -= sizeof(flvHeader);
            cnt += sizeof(flvHeader);
   1236c:	e3a0500d 	mov	r5, #13
            
            while (r->m_read.timestamp == 0)
   12370:	ea000015 	b	123cc <RTMP_Read+0xf4>
            {
                
                nRead = Read_1_Packet(r, r->m_read.buf, r->m_read.buflen);
   12374:	e5941090 	ldr	r1, [r4, #144]	; 0x90
   12378:	e5942098 	ldr	r2, [r4, #152]	; 0x98
   1237c:	ebfffc96 	bl	115dc <Read_1_Packet>
                if (nRead < 0)
   12380:	e250b000 	subs	fp, r0, #0
   12384:	ba000070 	blt	1254c <RTMP_Read+0x274>
                    r->m_read.buflen = 0;
                    r->m_read.status = nRead;
                    goto fail;
                }
                /* buffer overflow, fix buffer and give up */
                if (r->m_read.buf < mybuf || r->m_read.buf > end) {
   12388:	e5943090 	ldr	r3, [r4, #144]	; 0x90
   1238c:	e1560003 	cmp	r6, r3
   12390:	93a02000 	movls	r2, #0
   12394:	83a02001 	movhi	r2, #1
   12398:	e1580003 	cmp	r8, r3
   1239c:	33822001 	orrcc	r2, r2, #1
   123a0:	e3520000 	cmp	r2, #0
                    free(r->m_read.buf);
                    r->m_read.buf = mybuf+cnt+nRead;
                    break;
                }
                cnt += nRead;
                r->m_read.buf += nRead;
   123a4:	e083300b 	add	r3, r3, fp
                    r->m_read.buflen = 0;
                    r->m_read.status = nRead;
                    goto fail;
                }
                /* buffer overflow, fix buffer and give up */
                if (r->m_read.buf < mybuf || r->m_read.buf > end) {
   123a8:	1a00004f 	bne	124ec <RTMP_Read+0x214>
                    r->m_read.buf = mybuf+cnt+nRead;
                    break;
                }
                cnt += nRead;
                r->m_read.buf += nRead;
                r->m_read.buflen -= nRead;
   123ac:	e5942098 	ldr	r2, [r4, #152]	; 0x98
                if (r->m_read.dataType == 5)
   123b0:	e5d410a0 	ldrb	r1, [r4, #160]	; 0xa0
                    r->m_read.buf = mybuf+cnt+nRead;
                    break;
                }
                cnt += nRead;
                r->m_read.buf += nRead;
                r->m_read.buflen -= nRead;
   123b4:	e06b2002 	rsb	r2, fp, r2
                if (r->m_read.dataType == 5)
   123b8:	e3510005 	cmp	r1, #5
                    memcpy(mybuf+cnt, r->m_read.buf, nRead);
                    free(r->m_read.buf);
                    r->m_read.buf = mybuf+cnt+nRead;
                    break;
                }
                cnt += nRead;
   123bc:	e085500b 	add	r5, r5, fp
                r->m_read.buf += nRead;
   123c0:	e5843090 	str	r3, [r4, #144]	; 0x90
                r->m_read.buflen -= nRead;
   123c4:	e5842098 	str	r2, [r4, #152]	; 0x98
                if (r->m_read.dataType == 5)
   123c8:	0a000004 	beq	123e0 <RTMP_Read+0x108>
            memcpy(mybuf, flvHeader, sizeof(flvHeader));
            r->m_read.buf += sizeof(flvHeader);
            r->m_read.buflen -= sizeof(flvHeader);
            cnt += sizeof(flvHeader);
            
            while (r->m_read.timestamp == 0)
   123cc:	e594709c 	ldr	r7, [r4, #156]	; 0x9c
            {
                
                nRead = Read_1_Packet(r, r->m_read.buf, r->m_read.buflen);
   123d0:	e1a00004 	mov	r0, r4
            memcpy(mybuf, flvHeader, sizeof(flvHeader));
            r->m_read.buf += sizeof(flvHeader);
            r->m_read.buflen -= sizeof(flvHeader);
            cnt += sizeof(flvHeader);
            
            while (r->m_read.timestamp == 0)
   123d4:	e3570000 	cmp	r7, #0
   123d8:	0affffe5 	beq	12374 <RTMP_Read+0x9c>
   123dc:	e5d410a0 	ldrb	r1, [r4, #160]	; 0xa0
                r->m_read.buflen -= nRead;
                if (r->m_read.dataType == 5)
                    break;
            }
                
            mybuf[4] = r->m_read.dataType;
   123e0:	e5c61004 	strb	r1, [r6, #4]
            r->m_read.buflen = r->m_read.buf - mybuf;
   123e4:	e5942090 	ldr	r2, [r4, #144]	; 0x90
   123e8:	e5d430a1 	ldrb	r3, [r4, #161]	; 0xa1
   123ec:	e0662002 	rsb	r2, r6, r2
            r->m_read.buf = mybuf;
            r->m_read.bufpos = mybuf;
   123f0:	e1a00006 	mov	r0, r6
   123f4:	e5846094 	str	r6, [r4, #148]	; 0x94
                if (r->m_read.dataType == 5)
                    break;
            }
                
            mybuf[4] = r->m_read.dataType;
            r->m_read.buflen = r->m_read.buf - mybuf;
   123f8:	e5842098 	str	r2, [r4, #152]	; 0x98
            r->m_read.buf = mybuf;
   123fc:	e5846090 	str	r6, [r4, #144]	; 0x90
            r->m_read.bufpos = mybuf;
        }
        r->m_read.flags |= RTMP_READ_HEADER;
   12400:	e3833001 	orr	r3, r3, #1
   12404:	e5c430a1 	strb	r3, [r4, #161]	; 0xa1
    }
    
    if ((r->m_read.flags & RTMP_READ_SEEKING) && r->m_read.buf)
   12408:	e3130020 	tst	r3, #32
   1240c:	1a00002e 	bne	124cc <RTMP_Read+0x1f4>
        r->m_read.bufpos = NULL;
        r->m_read.buflen = 0;
    }
    
    /* If there's leftover data buffered, use it up */
    if (r->m_read.buf)
   12410:	e3500000 	cmp	r0, #0
   12414:	0a000053 	beq	12568 <RTMP_Read+0x290>
    {
        nRead = r->m_read.buflen;
   12418:	e5943098 	ldr	r3, [r4, #152]	; 0x98
        if (nRead > size)
            nRead = size;
        memcpy(buf, r->m_read.bufpos, nRead);
   1241c:	e1a0000a 	mov	r0, sl
   12420:	e1590003 	cmp	r9, r3
   12424:	b1a0b009 	movlt	fp, r9
   12428:	a1a0b003 	movge	fp, r3
   1242c:	e1a0200b 	mov	r2, fp
   12430:	e5941094 	ldr	r1, [r4, #148]	; 0x94
   12434:	ebffcb64 	bl	51cc <memcpy@plt>
        r->m_read.buflen -= nRead;
   12438:	e5945098 	ldr	r5, [r4, #152]	; 0x98
   1243c:	e06b5005 	rsb	r5, fp, r5
        if (!r->m_read.buflen)
   12440:	e3550000 	cmp	r5, #0
    {
        nRead = r->m_read.buflen;
        if (nRead > size)
            nRead = size;
        memcpy(buf, r->m_read.bufpos, nRead);
        r->m_read.buflen -= nRead;
   12444:	e5845098 	str	r5, [r4, #152]	; 0x98
        if (!r->m_read.buflen)
   12448:	0a00003a 	beq	12538 <RTMP_Read+0x260>
            r->m_read.buf = NULL;
            r->m_read.bufpos = NULL;
        }
        else
        {
            r->m_read.bufpos += nRead;
   1244c:	e5943094 	ldr	r3, [r4, #148]	; 0x94
   12450:	e083300b 	add	r3, r3, fp
   12454:	e5843094 	str	r3, [r4, #148]	; 0x94
        }
        buf += nRead;
   12458:	e08aa00b 	add	sl, sl, fp
        total += nRead;
        size -= nRead;
   1245c:	e06b9009 	rsb	r9, fp, r9
        else
        {
            r->m_read.bufpos += nRead;
        }
        buf += nRead;
        total += nRead;
   12460:	e1a0500b 	mov	r5, fp
        size -= nRead;
    }
    
    while (size > 0 && (nRead = Read_1_Packet(r, buf, size)) >= 0)
   12464:	e3590000 	cmp	r9, #0
   12468:	da00002e 	ble	12528 <RTMP_Read+0x250>
   1246c:	e1a00004 	mov	r0, r4
   12470:	e1a0100a 	mov	r1, sl
   12474:	e1a02009 	mov	r2, r9
   12478:	ebfffc57 	bl	115dc <Read_1_Packet>
   1247c:	e250b000 	subs	fp, r0, #0
   12480:	ba00002a 	blt	12530 <RTMP_Read+0x258>
    {
        if (!nRead) continue;
   12484:	0afffff8 	beq	1246c <RTMP_Read+0x194>
        buf += nRead;
        total += nRead;
   12488:	e085500b 	add	r5, r5, fp
        size -= nRead;
   1248c:	e06b9009 	rsb	r9, fp, r9
        break;
    }
    if (nRead < 0)
        r->m_read.status = nRead;
    
    if (size < 0)
   12490:	e3590000 	cmp	r9, #0
        total += size;
   12494:	b0850009 	addlt	r0, r5, r9
        break;
    }
    if (nRead < 0)
        r->m_read.status = nRead;
    
    if (size < 0)
   12498:	ba000003 	blt	124ac <RTMP_Read+0x1d4>
   1249c:	e1a00005 	mov	r0, r5
        total += size;
    
//     RTMP_Log(RTMP_LOGINFO,"rtmp read: %d",total);
    return total;
}
   124a0:	e28dd00c 	add	sp, sp, #12
   124a4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    /* can't continue */
fail:
    switch (r->m_read.status) {
        case RTMP_READ_EOF:
        case RTMP_READ_COMPLETE:
            return 0;
   124a8:	e3a00000 	mov	r0, #0
    if (size < 0)
        total += size;
    
//     RTMP_Log(RTMP_LOGINFO,"rtmp read: %d",total);
    return total;
}
   124ac:	e28dd00c 	add	sp, sp, #12
   124b0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    switch (r->m_read.status) {
        case RTMP_READ_EOF:
        case RTMP_READ_COMPLETE:
            return 0;
        case RTMP_READ_ERROR:  /* corrupted stream, resume failed */
            SetSockError(EINVAL);
   124b4:	ebffcbb9 	bl	53a0 <__errno@plt>
   124b8:	e3a03016 	mov	r3, #22
   124bc:	e5803000 	str	r3, [r0]
            return -1;
   124c0:	e3e00000 	mvn	r0, #0
    if (size < 0)
        total += size;
    
//     RTMP_Log(RTMP_LOGINFO,"rtmp read: %d",total);
    return total;
}
   124c4:	e28dd00c 	add	sp, sp, #12
   124c8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
            r->m_read.bufpos = mybuf;
        }
        r->m_read.flags |= RTMP_READ_HEADER;
    }
    
    if ((r->m_read.flags & RTMP_READ_SEEKING) && r->m_read.buf)
   124cc:	e3500000 	cmp	r0, #0
   124d0:	0a000024 	beq	12568 <RTMP_Read+0x290>
    {
        /* drop whatever's here */
        free(r->m_read.buf);
        r->m_read.buf = NULL;
   124d4:	e3a05000 	mov	r5, #0
    }
    
    if ((r->m_read.flags & RTMP_READ_SEEKING) && r->m_read.buf)
    {
        /* drop whatever's here */
        free(r->m_read.buf);
   124d8:	ebffcac9 	bl	5004 <free@plt>
        r->m_read.buf = NULL;
   124dc:	e5845090 	str	r5, [r4, #144]	; 0x90
        r->m_read.bufpos = NULL;
   124e0:	e5845094 	str	r5, [r4, #148]	; 0x94
        r->m_read.buflen = 0;
   124e4:	e5845098 	str	r5, [r4, #152]	; 0x98
   124e8:	eaffffdd 	b	12464 <RTMP_Read+0x18c>
                    r->m_read.status = nRead;
                    goto fail;
                }
                /* buffer overflow, fix buffer and give up */
                if (r->m_read.buf < mybuf || r->m_read.buf > end) {
                    mybuf = realloc(mybuf, cnt + nRead);
   124ec:	e085700b 	add	r7, r5, fp
   124f0:	e1a01007 	mov	r1, r7
   124f4:	e1a00006 	mov	r0, r6
   124f8:	ebffcbe1 	bl	5484 <realloc@plt>
                    memcpy(mybuf+cnt, r->m_read.buf, nRead);
   124fc:	e5941090 	ldr	r1, [r4, #144]	; 0x90
   12500:	e1a0200b 	mov	r2, fp
                    r->m_read.status = nRead;
                    goto fail;
                }
                /* buffer overflow, fix buffer and give up */
                if (r->m_read.buf < mybuf || r->m_read.buf > end) {
                    mybuf = realloc(mybuf, cnt + nRead);
   12504:	e1a06000 	mov	r6, r0
                    memcpy(mybuf+cnt, r->m_read.buf, nRead);
   12508:	e0800005 	add	r0, r0, r5
   1250c:	ebffcb2e 	bl	51cc <memcpy@plt>
                    free(r->m_read.buf);
                    r->m_read.buf = mybuf+cnt+nRead;
   12510:	e0867007 	add	r7, r6, r7
                }
                /* buffer overflow, fix buffer and give up */
                if (r->m_read.buf < mybuf || r->m_read.buf > end) {
                    mybuf = realloc(mybuf, cnt + nRead);
                    memcpy(mybuf+cnt, r->m_read.buf, nRead);
                    free(r->m_read.buf);
   12514:	e5940090 	ldr	r0, [r4, #144]	; 0x90
   12518:	ebffcab9 	bl	5004 <free@plt>
                    r->m_read.buf = mybuf+cnt+nRead;
   1251c:	e5847090 	str	r7, [r4, #144]	; 0x90
   12520:	e5d410a0 	ldrb	r1, [r4, #160]	; 0xa0
                    break;
   12524:	eaffffad 	b	123e0 <RTMP_Read+0x108>
        buf += nRead;
        total += nRead;
        size -= nRead;
        break;
    }
    if (nRead < 0)
   12528:	e35b0000 	cmp	fp, #0
   1252c:	aaffffd7 	bge	12490 <RTMP_Read+0x1b8>
        r->m_read.status = nRead;
   12530:	e5c4b0a2 	strb	fp, [r4, #162]	; 0xa2
   12534:	eaffffd5 	b	12490 <RTMP_Read+0x1b8>
            nRead = size;
        memcpy(buf, r->m_read.bufpos, nRead);
        r->m_read.buflen -= nRead;
        if (!r->m_read.buflen)
        {
            free(r->m_read.buf);
   12538:	e5940090 	ldr	r0, [r4, #144]	; 0x90
   1253c:	ebffcab0 	bl	5004 <free@plt>
            r->m_read.buf = NULL;
   12540:	e5845090 	str	r5, [r4, #144]	; 0x90
            r->m_read.bufpos = NULL;
   12544:	e5845094 	str	r5, [r4, #148]	; 0x94
   12548:	eaffffc2 	b	12458 <RTMP_Read+0x180>
            {
                
                nRead = Read_1_Packet(r, r->m_read.buf, r->m_read.buflen);
                if (nRead < 0)
                {
                    free(mybuf);
   1254c:	e1a00006 	mov	r0, r6
                    r->m_read.buf = NULL;
                    r->m_read.buflen = 0;
                    r->m_read.status = nRead;
   12550:	e20b50ff 	and	r5, fp, #255	; 0xff
            {
                
                nRead = Read_1_Packet(r, r->m_read.buf, r->m_read.buflen);
                if (nRead < 0)
                {
                    free(mybuf);
   12554:	ebffcaaa 	bl	5004 <free@plt>
                    r->m_read.buf = NULL;
   12558:	e5847090 	str	r7, [r4, #144]	; 0x90
                    r->m_read.buflen = 0;
   1255c:	e5847098 	str	r7, [r4, #152]	; 0x98
                    r->m_read.status = nRead;
   12560:	e5c450a2 	strb	r5, [r4, #162]	; 0xa2
                    goto fail;
   12564:	eaffff66 	b	12304 <RTMP_Read+0x2c>

#define HEADERBUF	(128*1024)
int
RTMP_Read(RTMP *r, char *buf, int size)
{
    int nRead = 0, total = 0;
   12568:	e1a05000 	mov	r5, r0
   1256c:	eaffffbc 	b	12464 <RTMP_Read+0x18c>
   12570:	e5940090 	ldr	r0, [r4, #144]	; 0x90
   12574:	eaffffa3 	b	12408 <RTMP_Read+0x130>
   12578:	e5940090 	ldr	r0, [r4, #144]	; 0x90
   1257c:	eaffff9f 	b	12400 <RTMP_Read+0x128>
   12580:	0000c4fc 	.word	0x0000c4fc
   12584:	0001fff3 	.word	0x0001fff3

00012588 <RTMP_Write>:

static const AVal av_setDataFrame = AVC("@setDataFrame");

int
RTMP_Write(RTMP *r, const char *buf, int size)
{
   12588:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
            }
            enc = pkt->m_body;
            pend = enc + pkt->m_nBodySize;
            if (pkt->m_packetType == RTMP_PACKET_TYPE_INFO)
            {
                enc = AMF_EncodeString(enc, pend, &av_setDataFrame);
   1258c:	e59f9234 	ldr	r9, [pc, #564]	; 127c8 <RTMP_Write+0x240>

static const AVal av_setDataFrame = AVC("@setDataFrame");

int
RTMP_Write(RTMP *r, const char *buf, int size)
{
   12590:	e1a06002 	mov	r6, r2
            }
            enc = pkt->m_body;
            pend = enc + pkt->m_nBodySize;
            if (pkt->m_packetType == RTMP_PACKET_TYPE_INFO)
            {
                enc = AMF_EncodeString(enc, pend, &av_setDataFrame);
   12594:	e08f9009 	add	r9, pc, r9
    RTMPPacket *pkt = &r->m_write;
    char *pend, *enc;
    int s2 = size, ret, num;
    
    pkt->m_nChannel = 0x04;	/* source channel */
    pkt->m_nInfoField2 = r->m_stream_id;
   12598:	e5903018 	ldr	r3, [r0, #24]

static const AVal av_setDataFrame = AVC("@setDataFrame");

int
RTMP_Write(RTMP *r, const char *buf, int size)
{
   1259c:	e24dd00c 	sub	sp, sp, #12
    RTMPPacket *pkt = &r->m_write;
    char *pend, *enc;
    int s2 = size, ret, num;
    
    pkt->m_nChannel = 0x04;	/* source channel */
   125a0:	e3a02004 	mov	r2, #4
    pkt->m_nInfoField2 = r->m_stream_id;
   125a4:	e58030cc 	str	r3, [r0, #204]	; 0xcc

static const AVal av_setDataFrame = AVC("@setDataFrame");

int
RTMP_Write(RTMP *r, const char *buf, int size)
{
   125a8:	e1a05000 	mov	r5, r0
            }
            enc = pkt->m_body;
            pend = enc + pkt->m_nBodySize;
            if (pkt->m_packetType == RTMP_PACKET_TYPE_INFO)
            {
                enc = AMF_EncodeString(enc, pend, &av_setDataFrame);
   125ac:	e2893fde 	add	r3, r9, #888	; 0x378

static const AVal av_setDataFrame = AVC("@setDataFrame");

int
RTMP_Write(RTMP *r, const char *buf, int size)
{
   125b0:	e1a0b001 	mov	fp, r1
    RTMPPacket *pkt = &r->m_write;
   125b4:	e28070c0 	add	r7, r0, #192	; 0xc0
    int s2 = size, ret, num;
    
    pkt->m_nChannel = 0x04;	/* source channel */
    pkt->m_nInfoField2 = r->m_stream_id;
    
    while (s2)
   125b8:	e1a0a006 	mov	sl, r6
                if (pkt->m_packetType == RTMP_PACKET_TYPE_INFO)
                    pkt->m_nBodySize += 16;
            }
            else
            {
                pkt->m_headerType = RTMP_PACKET_SIZE_MEDIUM;
   125bc:	e3a08001 	mov	r8, #1
            
            if (((pkt->m_packetType == RTMP_PACKET_TYPE_AUDIO
                  || pkt->m_packetType == RTMP_PACKET_TYPE_VIDEO) &&
                 !pkt->m_nTimeStamp) || pkt->m_packetType == RTMP_PACKET_TYPE_INFO)
            {
                pkt->m_headerType = RTMP_PACKET_SIZE_LARGE;
   125c0:	e3a09000 	mov	r9, #0
{
    RTMPPacket *pkt = &r->m_write;
    char *pend, *enc;
    int s2 = size, ret, num;
    
    pkt->m_nChannel = 0x04;	/* source channel */
   125c4:	e58020c4 	str	r2, [r0, #196]	; 0xc4
            }
            enc = pkt->m_body;
            pend = enc + pkt->m_nBodySize;
            if (pkt->m_packetType == RTMP_PACKET_TYPE_INFO)
            {
                enc = AMF_EncodeString(enc, pend, &av_setDataFrame);
   125c8:	e58d3004 	str	r3, [sp, #4]
    int s2 = size, ret, num;
    
    pkt->m_nChannel = 0x04;	/* source channel */
    pkt->m_nInfoField2 = r->m_stream_id;
    
    while (s2)
   125cc:	e35a0000 	cmp	sl, #0
   125d0:	0a000063 	beq	12764 <RTMP_Write+0x1dc>
   125d4:	e59530d4 	ldr	r3, [r5, #212]	; 0xd4
   125d8:	ea000032 	b	126a8 <RTMP_Write+0x120>
    {
        if (!pkt->m_nBytesRead)
        {
            if (size < 11) {
   125dc:	e356000a 	cmp	r6, #10
   125e0:	da000072 	ble	127b0 <RTMP_Write+0x228>
                /* FLV pkt too small */
                return 0;
            }
            
            if (buf[0] == 'F' && buf[1] == 'L' && buf[2] == 'V')
   125e4:	e5db3000 	ldrb	r3, [fp]
   125e8:	e3530046 	cmp	r3, #70	; 0x46
   125ec:	0a000033 	beq	126c0 <RTMP_Write+0x138>
            {
                buf += 13;
                s2 -= 13;
            }
            
            pkt->m_packetType = *buf++;
   125f0:	e5c530c1 	strb	r3, [r5, #193]	; 0xc1
            pkt->m_nBodySize = AMF_DecodeInt24(buf);
   125f4:	e28b0001 	add	r0, fp, #1
   125f8:	eb000e1d 	bl	15e74 <AMF_DecodeInt24>
            buf += 3;
            pkt->m_nTimeStamp = AMF_DecodeInt24(buf);
            buf += 3;
            pkt->m_nTimeStamp |= *buf++ << 24;
            buf += 3;
            s2 -= 11;
   125fc:	e24aa00b 	sub	sl, sl, #11
                buf += 13;
                s2 -= 13;
            }
            
            pkt->m_packetType = *buf++;
            pkt->m_nBodySize = AMF_DecodeInt24(buf);
   12600:	e58500d0 	str	r0, [r5, #208]	; 0xd0
            buf += 3;
            pkt->m_nTimeStamp = AMF_DecodeInt24(buf);
   12604:	e28b0004 	add	r0, fp, #4
   12608:	eb000e19 	bl	15e74 <AMF_DecodeInt24>
            buf += 3;
            pkt->m_nTimeStamp |= *buf++ << 24;
            buf += 3;
            s2 -= 11;
            
            if (((pkt->m_packetType == RTMP_PACKET_TYPE_AUDIO
   1260c:	e5d530c1 	ldrb	r3, [r5, #193]	; 0xc1
            pkt->m_nBodySize = AMF_DecodeInt24(buf);
            buf += 3;
            pkt->m_nTimeStamp = AMF_DecodeInt24(buf);
            buf += 3;
            pkt->m_nTimeStamp |= *buf++ << 24;
            buf += 3;
   12610:	e28bb00b 	add	fp, fp, #11
            s2 -= 11;
            
            if (((pkt->m_packetType == RTMP_PACKET_TYPE_AUDIO
   12614:	e2432008 	sub	r2, r3, #8
   12618:	e3520001 	cmp	r2, #1
            }
            
            pkt->m_packetType = *buf++;
            pkt->m_nBodySize = AMF_DecodeInt24(buf);
            buf += 3;
            pkt->m_nTimeStamp = AMF_DecodeInt24(buf);
   1261c:	e58500c8 	str	r0, [r5, #200]	; 0xc8
            buf += 3;
            pkt->m_nTimeStamp |= *buf++ << 24;
   12620:	e55b1004 	ldrb	r1, [fp, #-4]
   12624:	e1800c01 	orr	r0, r0, r1, lsl #24
   12628:	e58500c8 	str	r0, [r5, #200]	; 0xc8
            buf += 3;
            s2 -= 11;
            
            if (((pkt->m_packetType == RTMP_PACKET_TYPE_AUDIO
   1262c:	9a00002c 	bls	126e4 <RTMP_Write+0x15c>
                  || pkt->m_packetType == RTMP_PACKET_TYPE_VIDEO) &&
                 !pkt->m_nTimeStamp) || pkt->m_packetType == RTMP_PACKET_TYPE_INFO)
   12630:	e3530012 	cmp	r3, #18
   12634:	0a00003d 	beq	12730 <RTMP_Write+0x1a8>
   12638:	e59510d0 	ldr	r1, [r5, #208]	; 0xd0
                if (pkt->m_packetType == RTMP_PACKET_TYPE_INFO)
                    pkt->m_nBodySize += 16;
            }
            else
            {
                pkt->m_headerType = RTMP_PACKET_SIZE_MEDIUM;
   1263c:	e5c580c0 	strb	r8, [r5, #192]	; 0xc0
            }
            
            if (!RTMPPacket_Alloc(pkt, pkt->m_nBodySize))
   12640:	e1a00007 	mov	r0, r7
   12644:	ebffd839 	bl	8730 <RTMPPacket_Alloc>
   12648:	e2504000 	subs	r4, r0, #0
   1264c:	0a00002c 	beq	12704 <RTMP_Write+0x17c>
                RTMP_Log(RTMP_LOGDEBUG, "%s, failed to allocate packet", __FUNCTION__);
                return FALSE;
            }
            enc = pkt->m_body;
            pend = enc + pkt->m_nBodySize;
            if (pkt->m_packetType == RTMP_PACKET_TYPE_INFO)
   12650:	e5d530c1 	ldrb	r3, [r5, #193]	; 0xc1
            if (!RTMPPacket_Alloc(pkt, pkt->m_nBodySize))
            {
                RTMP_Log(RTMP_LOGDEBUG, "%s, failed to allocate packet", __FUNCTION__);
                return FALSE;
            }
            enc = pkt->m_body;
   12654:	e59500dc 	ldr	r0, [r5, #220]	; 0xdc
            pend = enc + pkt->m_nBodySize;
            if (pkt->m_packetType == RTMP_PACKET_TYPE_INFO)
   12658:	e3530012 	cmp	r3, #18
            {
                RTMP_Log(RTMP_LOGDEBUG, "%s, failed to allocate packet", __FUNCTION__);
                return FALSE;
            }
            enc = pkt->m_body;
            pend = enc + pkt->m_nBodySize;
   1265c:	e59510d0 	ldr	r1, [r5, #208]	; 0xd0
            if (pkt->m_packetType == RTMP_PACKET_TYPE_INFO)
   12660:	0a000037 	beq	12744 <RTMP_Write+0x1bc>
   12664:	e59530d4 	ldr	r3, [r5, #212]	; 0xd4
        }
        else
        {
            enc = pkt->m_body + pkt->m_nBytesRead;
        }
        num = pkt->m_nBodySize - pkt->m_nBytesRead;
   12668:	e0634001 	rsb	r4, r3, r1
   1266c:	e154000a 	cmp	r4, sl
   12670:	a1a0400a 	movge	r4, sl
        if (num > s2)
            num = s2;
        memcpy(enc, buf, num);
   12674:	e1a02004 	mov	r2, r4
   12678:	e1a0100b 	mov	r1, fp
   1267c:	ebffcad2 	bl	51cc <memcpy@plt>
        pkt->m_nBytesRead += num;
   12680:	e59530d4 	ldr	r3, [r5, #212]	; 0xd4
        s2 -= num;
        buf += num;
        if (pkt->m_nBytesRead == pkt->m_nBodySize)
   12684:	e59520d0 	ldr	r2, [r5, #208]	; 0xd0
        }
        num = pkt->m_nBodySize - pkt->m_nBytesRead;
        if (num > s2)
            num = s2;
        memcpy(enc, buf, num);
        pkt->m_nBytesRead += num;
   12688:	e0843003 	add	r3, r4, r3
        s2 -= num;
        buf += num;
        if (pkt->m_nBytesRead == pkt->m_nBodySize)
   1268c:	e1530002 	cmp	r3, r2
        num = pkt->m_nBodySize - pkt->m_nBytesRead;
        if (num > s2)
            num = s2;
        memcpy(enc, buf, num);
        pkt->m_nBytesRead += num;
        s2 -= num;
   12690:	e064a00a 	rsb	sl, r4, sl
        buf += num;
   12694:	e08bb004 	add	fp, fp, r4
        }
        num = pkt->m_nBodySize - pkt->m_nBytesRead;
        if (num > s2)
            num = s2;
        memcpy(enc, buf, num);
        pkt->m_nBytesRead += num;
   12698:	e58530d4 	str	r3, [r5, #212]	; 0xd4
        s2 -= num;
        buf += num;
        if (pkt->m_nBytesRead == pkt->m_nBodySize)
   1269c:	0a000035 	beq	12778 <RTMP_Write+0x1f0>
    int s2 = size, ret, num;
    
    pkt->m_nChannel = 0x04;	/* source channel */
    pkt->m_nInfoField2 = r->m_stream_id;
    
    while (s2)
   126a0:	e35a0000 	cmp	sl, #0
   126a4:	0a00002e 	beq	12764 <RTMP_Write+0x1dc>
    {
        if (!pkt->m_nBytesRead)
   126a8:	e3530000 	cmp	r3, #0
   126ac:	0affffca 	beq	125dc <RTMP_Write+0x54>
                pkt->m_nBytesRead = enc - pkt->m_body;
            }
        }
        else
        {
            enc = pkt->m_body + pkt->m_nBytesRead;
   126b0:	e59500dc 	ldr	r0, [r5, #220]	; 0xdc
   126b4:	e59510d0 	ldr	r1, [r5, #208]	; 0xd0
   126b8:	e0800003 	add	r0, r0, r3
   126bc:	eaffffe9 	b	12668 <RTMP_Write+0xe0>
            if (size < 11) {
                /* FLV pkt too small */
                return 0;
            }
            
            if (buf[0] == 'F' && buf[1] == 'L' && buf[2] == 'V')
   126c0:	e5db2001 	ldrb	r2, [fp, #1]
   126c4:	e352004c 	cmp	r2, #76	; 0x4c
   126c8:	1affffc8 	bne	125f0 <RTMP_Write+0x68>
   126cc:	e5db2002 	ldrb	r2, [fp, #2]
   126d0:	e3520056 	cmp	r2, #86	; 0x56
   126d4:	05db300d 	ldrbeq	r3, [fp, #13]
            {
                buf += 13;
                s2 -= 13;
   126d8:	024aa00d 	subeq	sl, sl, #13
                return 0;
            }
            
            if (buf[0] == 'F' && buf[1] == 'L' && buf[2] == 'V')
            {
                buf += 13;
   126dc:	028bb00d 	addeq	fp, fp, #13
   126e0:	eaffffc2 	b	125f0 <RTMP_Write+0x68>
            pkt->m_nTimeStamp |= *buf++ << 24;
            buf += 3;
            s2 -= 11;
            
            if (((pkt->m_packetType == RTMP_PACKET_TYPE_AUDIO
                  || pkt->m_packetType == RTMP_PACKET_TYPE_VIDEO) &&
   126e4:	e3500000 	cmp	r0, #0
   126e8:	1affffd2 	bne	12638 <RTMP_Write+0xb0>
                 !pkt->m_nTimeStamp) || pkt->m_packetType == RTMP_PACKET_TYPE_INFO)
            {
                pkt->m_headerType = RTMP_PACKET_SIZE_LARGE;
   126ec:	e5c500c0 	strb	r0, [r5, #192]	; 0xc0
   126f0:	e59510d0 	ldr	r1, [r5, #208]	; 0xd0
            else
            {
                pkt->m_headerType = RTMP_PACKET_SIZE_MEDIUM;
            }
            
            if (!RTMPPacket_Alloc(pkt, pkt->m_nBodySize))
   126f4:	e1a00007 	mov	r0, r7
   126f8:	ebffd80c 	bl	8730 <RTMPPacket_Alloc>
   126fc:	e2504000 	subs	r4, r0, #0
   12700:	1affffd2 	bne	12650 <RTMP_Write+0xc8>
            {
                RTMP_Log(RTMP_LOGDEBUG, "%s, failed to allocate packet", __FUNCTION__);
   12704:	e59f20c0 	ldr	r2, [pc, #192]	; 127cc <RTMP_Write+0x244>
   12708:	e59f10c0 	ldr	r1, [pc, #192]	; 127d0 <RTMP_Write+0x248>
   1270c:	e08f2002 	add	r2, pc, r2
   12710:	e2422ea6 	sub	r2, r2, #2656	; 0xa60
   12714:	e3a00004 	mov	r0, #4
   12718:	e242200c 	sub	r2, r2, #12
   1271c:	e08f1001 	add	r1, pc, r1
   12720:	eb000ca1 	bl	159ac <RTMP_Log>
            if (s2 < 0)
                break;
        }
    }
    return size+s2;
}
   12724:	e1a00004 	mov	r0, r4
   12728:	e28dd00c 	add	sp, sp, #12
   1272c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
                  || pkt->m_packetType == RTMP_PACKET_TYPE_VIDEO) &&
                 !pkt->m_nTimeStamp) || pkt->m_packetType == RTMP_PACKET_TYPE_INFO)
            {
                pkt->m_headerType = RTMP_PACKET_SIZE_LARGE;
                if (pkt->m_packetType == RTMP_PACKET_TYPE_INFO)
                    pkt->m_nBodySize += 16;
   12730:	e59510d0 	ldr	r1, [r5, #208]	; 0xd0
            
            if (((pkt->m_packetType == RTMP_PACKET_TYPE_AUDIO
                  || pkt->m_packetType == RTMP_PACKET_TYPE_VIDEO) &&
                 !pkt->m_nTimeStamp) || pkt->m_packetType == RTMP_PACKET_TYPE_INFO)
            {
                pkt->m_headerType = RTMP_PACKET_SIZE_LARGE;
   12734:	e5c590c0 	strb	r9, [r5, #192]	; 0xc0
                if (pkt->m_packetType == RTMP_PACKET_TYPE_INFO)
                    pkt->m_nBodySize += 16;
   12738:	e2811010 	add	r1, r1, #16
   1273c:	e58510d0 	str	r1, [r5, #208]	; 0xd0
   12740:	eaffffbe 	b	12640 <RTMP_Write+0xb8>
            }
            enc = pkt->m_body;
            pend = enc + pkt->m_nBodySize;
            if (pkt->m_packetType == RTMP_PACKET_TYPE_INFO)
            {
                enc = AMF_EncodeString(enc, pend, &av_setDataFrame);
   12744:	e0801001 	add	r1, r0, r1
   12748:	e59d2004 	ldr	r2, [sp, #4]
   1274c:	eb000e25 	bl	15fe8 <AMF_EncodeString>
                pkt->m_nBytesRead = enc - pkt->m_body;
   12750:	e59530dc 	ldr	r3, [r5, #220]	; 0xdc
   12754:	e59510d0 	ldr	r1, [r5, #208]	; 0xd0
   12758:	e0633000 	rsb	r3, r3, r0
   1275c:	e58530d4 	str	r3, [r5, #212]	; 0xd4
   12760:	eaffffc0 	b	12668 <RTMP_Write+0xe0>
    int s2 = size, ret, num;
    
    pkt->m_nChannel = 0x04;	/* source channel */
    pkt->m_nInfoField2 = r->m_stream_id;
    
    while (s2)
   12764:	e3a0a000 	mov	sl, #0
            s2 -= 4;
            if (s2 < 0)
                break;
        }
    }
    return size+s2;
   12768:	e086400a 	add	r4, r6, sl
}
   1276c:	e1a00004 	mov	r0, r4
   12770:	e28dd00c 	add	sp, sp, #12
   12774:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        pkt->m_nBytesRead += num;
        s2 -= num;
        buf += num;
        if (pkt->m_nBytesRead == pkt->m_nBodySize)
        {
            ret = RTMP_SendPacket(r, pkt, FALSE);
   12778:	e1a01007 	mov	r1, r7
   1277c:	e3a02000 	mov	r2, #0
   12780:	e1a00005 	mov	r0, r5
   12784:	ebffe31c 	bl	b3fc <RTMP_SendPacket>
   12788:	e1a04000 	mov	r4, r0
            RTMPPacket_Free(pkt);
   1278c:	e1a00007 	mov	r0, r7
   12790:	ebffd7f2 	bl	8760 <RTMPPacket_Free>
            pkt->m_nBytesRead = 0;
            if (!ret)
   12794:	e3540000 	cmp	r4, #0
        buf += num;
        if (pkt->m_nBytesRead == pkt->m_nBodySize)
        {
            ret = RTMP_SendPacket(r, pkt, FALSE);
            RTMPPacket_Free(pkt);
            pkt->m_nBytesRead = 0;
   12798:	e58590d4 	str	r9, [r5, #212]	; 0xd4
            if (!ret)
   1279c:	0a000007 	beq	127c0 <RTMP_Write+0x238>
                return -1;
            buf += 4;
            s2 -= 4;
            if (s2 < 0)
   127a0:	e25aa004 	subs	sl, sl, #4
            ret = RTMP_SendPacket(r, pkt, FALSE);
            RTMPPacket_Free(pkt);
            pkt->m_nBytesRead = 0;
            if (!ret)
                return -1;
            buf += 4;
   127a4:	e28bb004 	add	fp, fp, #4
            s2 -= 4;
            if (s2 < 0)
   127a8:	5affff87 	bpl	125cc <RTMP_Write+0x44>
   127ac:	eaffffed 	b	12768 <RTMP_Write+0x1e0>
    {
        if (!pkt->m_nBytesRead)
        {
            if (size < 11) {
                /* FLV pkt too small */
                return 0;
   127b0:	e1a04003 	mov	r4, r3
            if (s2 < 0)
                break;
        }
    }
    return size+s2;
}
   127b4:	e1a00004 	mov	r0, r4
   127b8:	e28dd00c 	add	sp, sp, #12
   127bc:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        {
            ret = RTMP_SendPacket(r, pkt, FALSE);
            RTMPPacket_Free(pkt);
            pkt->m_nBytesRead = 0;
            if (!ret)
                return -1;
   127c0:	e3e04000 	mvn	r4, #0
   127c4:	eaffffe8 	b	1276c <RTMP_Write+0x1e4>
   127c8:	000112b4 	.word	0x000112b4
   127cc:	0000c0d4 	.word	0x0000c0d4
   127d0:	0000cf1c 	.word	0x0000cf1c

000127d4 <RTMP_Connect_kk>:
    }
    return size+s2;
}

int RTMP_Connect_kk(RTMP *pRtmp,const char * url)
{
   127d4:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
    RTMP_Log(RTMP_LOGINFO, "rtmp_url: %s", url);
   127d8:	e1a02001 	mov	r2, r1
    }
    return size+s2;
}

int RTMP_Connect_kk(RTMP *pRtmp,const char * url)
{
   127dc:	e1a06001 	mov	r6, r1
    RTMP_Log(RTMP_LOGINFO, "rtmp_url: %s", url);
   127e0:	e59f10d0 	ldr	r1, [pc, #208]	; 128b8 <RTMP_Connect_kk+0xe4>
    }
    return size+s2;
}

int RTMP_Connect_kk(RTMP *pRtmp,const char * url)
{
   127e4:	e1a04000 	mov	r4, r0
    RTMP_Log(RTMP_LOGINFO, "rtmp_url: %s", url);
   127e8:	e08f1001 	add	r1, pc, r1
   127ec:	e3a00003 	mov	r0, #3
   127f0:	eb000c6d 	bl	159ac <RTMP_Log>
        
        RTMP_EnableWrite(pRtmp);
        
        if (!RTMP_Connect(pRtmp, NULL) || !RTMP_ConnectStream(pRtmp, 0))
        {
            RTMP_Log(RTMP_LOGINFO, "connect fail. times = %d", i);
   127f4:	e59f70c0 	ldr	r7, [pc, #192]	; 128bc <RTMP_Connect_kk+0xe8>
int RTMP_Connect_kk(RTMP *pRtmp,const char * url)
{
    RTMP_Log(RTMP_LOGINFO, "rtmp_url: %s", url);
    
    int i;
    for (i = 0; i < 8; ++i)
   127f8:	e3a05000 	mov	r5, #0
        
        RTMP_EnableWrite(pRtmp);
        
        if (!RTMP_Connect(pRtmp, NULL) || !RTMP_ConnectStream(pRtmp, 0))
        {
            RTMP_Log(RTMP_LOGINFO, "connect fail. times = %d", i);
   127fc:	e08f7007 	add	r7, pc, r7
    RTMP_Log(RTMP_LOGINFO, "rtmp_url: %s", url);
    
    int i;
    for (i = 0; i < 8; ++i)
    {
        if (RTMP_SetupURL(pRtmp, url) == FALSE)
   12800:	e1a00004 	mov	r0, r4
   12804:	e1a01006 	mov	r1, r6
   12808:	ebffdb3c 	bl	9500 <RTMP_SetupURL>
   1280c:	e2503000 	subs	r3, r0, #0
        {
            return FALSE;
        }
        
        RTMP_EnableWrite(pRtmp);
   12810:	e1a00004 	mov	r0, r4
    RTMP_Log(RTMP_LOGINFO, "rtmp_url: %s", url);
    
    int i;
    for (i = 0; i < 8; ++i)
    {
        if (RTMP_SetupURL(pRtmp, url) == FALSE)
   12814:	0a00001f 	beq	12898 <RTMP_Connect_kk+0xc4>
        {
            return FALSE;
        }
        
        RTMP_EnableWrite(pRtmp);
   12818:	ebffd874 	bl	89f0 <RTMP_EnableWrite>
        
        if (!RTMP_Connect(pRtmp, NULL) || !RTMP_ConnectStream(pRtmp, 0))
   1281c:	e3a01000 	mov	r1, #0
   12820:	e1a00004 	mov	r0, r4
   12824:	ebfff430 	bl	f8ec <RTMP_Connect>
   12828:	e3a01000 	mov	r1, #0
   1282c:	e1500001 	cmp	r0, r1
   12830:	e1a00004 	mov	r0, r4
   12834:	0a000002 	beq	12844 <RTMP_Connect_kk+0x70>
   12838:	ebfffae2 	bl	113c8 <RTMP_ConnectStream>
   1283c:	e3500000 	cmp	r0, #0
   12840:	1a000016 	bne	128a0 <RTMP_Connect_kk+0xcc>
        {
            RTMP_Log(RTMP_LOGINFO, "connect fail. times = %d", i);
   12844:	e1a02005 	mov	r2, r5
   12848:	e3a00003 	mov	r0, #3
   1284c:	e1a01007 	mov	r1, r7
   12850:	eb000c55 	bl	159ac <RTMP_Log>
            
            CloseInternal(pRtmp, 0);
   12854:	e3a01000 	mov	r1, #0
   12858:	e1a00004 	mov	r0, r4
   1285c:	ebffe16d 	bl	ae18 <CloseInternal>
            
            RTMP_Init(pRtmp);
   12860:	e1a00004 	mov	r0, r4
   12864:	ebffd828 	bl	890c <RTMP_Init>
int RTMP_Connect_kk(RTMP *pRtmp,const char * url)
{
    RTMP_Log(RTMP_LOGINFO, "rtmp_url: %s", url);
    
    int i;
    for (i = 0; i < 8; ++i)
   12868:	e2855001 	add	r5, r5, #1
            
            CloseInternal(pRtmp, 0);
            
            RTMP_Init(pRtmp);
            
            sleep(1);
   1286c:	e3a00001 	mov	r0, #1
   12870:	ebffcb06 	bl	5490 <sleep@plt>
int RTMP_Connect_kk(RTMP *pRtmp,const char * url)
{
    RTMP_Log(RTMP_LOGINFO, "rtmp_url: %s", url);
    
    int i;
    for (i = 0; i < 8; ++i)
   12874:	e3550008 	cmp	r5, #8
   12878:	1affffe0 	bne	12800 <RTMP_Connect_kk+0x2c>
            RTMP_Log(RTMP_LOGINFO, "connect success");
            return TRUE;
        }
    }
    
    RTMP_Log(RTMP_LOGINFO, "connect fail, finally.");
   1287c:	e59f103c 	ldr	r1, [pc, #60]	; 128c0 <RTMP_Connect_kk+0xec>
   12880:	e3a00003 	mov	r0, #3
   12884:	e08f1001 	add	r1, pc, r1
   12888:	eb000c47 	bl	159ac <RTMP_Log>
    RTMP_Close(pRtmp);
   1288c:	e1a00004 	mov	r0, r4
   12890:	ebffe231 	bl	b15c <RTMP_Close>
    
    return FALSE;
   12894:	e3a03000 	mov	r3, #0
}
   12898:	e1a00003 	mov	r0, r3
   1289c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
            
            sleep(1);
        }
        else
        {
            RTMP_Log(RTMP_LOGINFO, "connect success");
   128a0:	e59f101c 	ldr	r1, [pc, #28]	; 128c4 <RTMP_Connect_kk+0xf0>
   128a4:	e3a00003 	mov	r0, #3
   128a8:	e08f1001 	add	r1, pc, r1
   128ac:	eb000c3e 	bl	159ac <RTMP_Log>
            return TRUE;
   128b0:	e3a03001 	mov	r3, #1
   128b4:	eafffff7 	b	12898 <RTMP_Connect_kk+0xc4>
   128b8:	0000df38 	.word	0x0000df38
   128bc:	0000df34 	.word	0x0000df34
   128c0:	0000ded8 	.word	0x0000ded8
   128c4:	0000dea4 	.word	0x0000dea4

000128c8 <RTMP_Close_kk>:
}


void RTMP_Close_kk(RTMP *pRtmp)
{
    if(pRtmp)
   128c8:	e3500000 	cmp	r0, #0
   128cc:	012fff1e 	bxeq	lr
    {
        RTMP_Close(pRtmp);
   128d0:	eaffe221 	b	b15c <RTMP_Close>

000128d4 <parse_hex4>:
}

static unsigned parse_hex4(const char *str)
{
	unsigned h=0;
	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
   128d4:	e5d02000 	ldrb	r2, [r0]
   128d8:	e2423030 	sub	r3, r2, #48	; 0x30
   128dc:	e20310ff 	and	r1, r3, #255	; 0xff
   128e0:	e3510009 	cmp	r1, #9
   128e4:	9a000007 	bls	12908 <parse_hex4+0x34>
   128e8:	e2423041 	sub	r3, r2, #65	; 0x41
   128ec:	e3530005 	cmp	r3, #5
   128f0:	92423037 	subls	r3, r2, #55	; 0x37
   128f4:	9a000003 	bls	12908 <parse_hex4+0x34>
   128f8:	e2423061 	sub	r3, r2, #97	; 0x61
   128fc:	e3530005 	cmp	r3, #5
   12900:	8a000033 	bhi	129d4 <parse_hex4+0x100>
   12904:	e2423057 	sub	r3, r2, #87	; 0x57
	h=h<<4;str++;
	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
   12908:	e5d01001 	ldrb	r1, [r0, #1]

static unsigned parse_hex4(const char *str)
{
	unsigned h=0;
	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
	h=h<<4;str++;
   1290c:	e1a03203 	lsl	r3, r3, #4
	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
   12910:	e2412030 	sub	r2, r1, #48	; 0x30
   12914:	e202c0ff 	and	ip, r2, #255	; 0xff
   12918:	e35c0009 	cmp	ip, #9
   1291c:	90823003 	addls	r3, r2, r3
   12920:	9a000009 	bls	1294c <parse_hex4+0x78>
   12924:	e2412041 	sub	r2, r1, #65	; 0x41
   12928:	e3520005 	cmp	r2, #5
   1292c:	92411037 	subls	r1, r1, #55	; 0x37
   12930:	90813003 	addls	r3, r1, r3
   12934:	9a000004 	bls	1294c <parse_hex4+0x78>
   12938:	e2412061 	sub	r2, r1, #97	; 0x61
   1293c:	e3520005 	cmp	r2, #5
   12940:	8a000023 	bhi	129d4 <parse_hex4+0x100>
   12944:	e2411057 	sub	r1, r1, #87	; 0x57
   12948:	e0813003 	add	r3, r1, r3
	h=h<<4;str++;
	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
   1294c:	e5d01002 	ldrb	r1, [r0, #2]
{
	unsigned h=0;
	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
	h=h<<4;str++;
	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
	h=h<<4;str++;
   12950:	e1a03203 	lsl	r3, r3, #4
	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
   12954:	e2412030 	sub	r2, r1, #48	; 0x30
   12958:	e202c0ff 	and	ip, r2, #255	; 0xff
   1295c:	e35c0009 	cmp	ip, #9
   12960:	90823003 	addls	r3, r2, r3
   12964:	9a000009 	bls	12990 <parse_hex4+0xbc>
   12968:	e2412041 	sub	r2, r1, #65	; 0x41
   1296c:	e3520005 	cmp	r2, #5
   12970:	92411037 	subls	r1, r1, #55	; 0x37
   12974:	90813003 	addls	r3, r1, r3
   12978:	9a000004 	bls	12990 <parse_hex4+0xbc>
   1297c:	e2412061 	sub	r2, r1, #97	; 0x61
   12980:	e3520005 	cmp	r2, #5
   12984:	8a000012 	bhi	129d4 <parse_hex4+0x100>
   12988:	e2411057 	sub	r1, r1, #87	; 0x57
   1298c:	e0813003 	add	r3, r1, r3
	h=h<<4;str++;
	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
   12990:	e5d02003 	ldrb	r2, [r0, #3]
	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
	h=h<<4;str++;
	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
	h=h<<4;str++;
	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
	h=h<<4;str++;
   12994:	e1a03203 	lsl	r3, r3, #4
	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
   12998:	e2420030 	sub	r0, r2, #48	; 0x30
   1299c:	e20010ff 	and	r1, r0, #255	; 0xff
   129a0:	e3510009 	cmp	r1, #9
   129a4:	8a000001 	bhi	129b0 <parse_hex4+0xdc>
   129a8:	e0800003 	add	r0, r0, r3
   129ac:	e12fff1e 	bx	lr
   129b0:	e2421041 	sub	r1, r2, #65	; 0x41
   129b4:	e3510005 	cmp	r1, #5
   129b8:	9a000007 	bls	129dc <parse_hex4+0x108>
   129bc:	e2421061 	sub	r1, r2, #97	; 0x61
   129c0:	e3510005 	cmp	r1, #5
   129c4:	8a000002 	bhi	129d4 <parse_hex4+0x100>
   129c8:	e2422057 	sub	r2, r2, #87	; 0x57
   129cc:	e0820003 	add	r0, r2, r3
   129d0:	e12fff1e 	bx	lr
}

static unsigned parse_hex4(const char *str)
{
	unsigned h=0;
	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
   129d4:	e3a00000 	mov	r0, #0
	h=h<<4;str++;
	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
	h=h<<4;str++;
	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
	return h;
}
   129d8:	e12fff1e 	bx	lr
   129dc:	e2422037 	sub	r2, r2, #55	; 0x37
	h=h<<4;str++;
	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
	h=h<<4;str++;
	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
	h=h<<4;str++;
	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
   129e0:	e0820003 	add	r0, r2, r3
   129e4:	e12fff1e 	bx	lr

000129e8 <cJSON_New_Item>:
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(void)
{
	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
   129e8:	e59f302c 	ldr	r3, [pc, #44]	; 12a1c <cJSON_New_Item+0x34>
	cJSON_free	 = (hooks->free_fn)?hooks->free_fn:free;
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(void)
{
   129ec:	e92d4010 	push	{r4, lr}
	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
   129f0:	e08f3003 	add	r3, pc, r3
   129f4:	e3a00028 	mov	r0, #40	; 0x28
   129f8:	e5933000 	ldr	r3, [r3]
   129fc:	e12fff33 	blx	r3
	if (node) memset(node,0,sizeof(cJSON));
   12a00:	e2504000 	subs	r4, r0, #0
   12a04:	0a000002 	beq	12a14 <cJSON_New_Item+0x2c>
   12a08:	e3a01000 	mov	r1, #0
   12a0c:	e3a02028 	mov	r2, #40	; 0x28
   12a10:	ebffc9ae 	bl	50d0 <memset@plt>
	return node;
}
   12a14:	e1a00004 	mov	r0, r4
   12a18:	e8bd8010 	pop	{r4, pc}
   12a1c:	0001160c 	.word	0x0001160c

00012a20 <ensure>:
typedef struct {char *buffer; int length; int offset; } printbuffer;

static char* ensure(printbuffer *p,int needed)
{
	char *newbuffer;int newsize;
	if (!p || !p->buffer) return 0;
   12a20:	e2502000 	subs	r2, r0, #0
   12a24:	0a000023 	beq	12ab8 <ensure+0x98>
   12a28:	e5920000 	ldr	r0, [r2]
   12a2c:	e3500000 	cmp	r0, #0
   12a30:	012fff1e 	bxeq	lr
static int pow2gt (int x)	{	--x;	x|=x>>1;	x|=x>>2;	x|=x>>4;	x|=x>>8;	x|=x>>16;	return x+1;	}

typedef struct {char *buffer; int length; int offset; } printbuffer;

static char* ensure(printbuffer *p,int needed)
{
   12a34:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	char *newbuffer;int newsize;
	if (!p || !p->buffer) return 0;
	needed+=p->offset;
   12a38:	e5923008 	ldr	r3, [r2, #8]
	if (needed<=p->length) return p->buffer+p->offset;
   12a3c:	e592c004 	ldr	ip, [r2, #4]

static char* ensure(printbuffer *p,int needed)
{
	char *newbuffer;int newsize;
	if (!p || !p->buffer) return 0;
	needed+=p->offset;
   12a40:	e0831001 	add	r1, r3, r1
	if (needed<=p->length) return p->buffer+p->offset;
   12a44:	e151000c 	cmp	r1, ip
   12a48:	ca000001 	bgt	12a54 <ensure+0x34>
   12a4c:	e0800003 	add	r0, r0, r3
   12a50:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	item->valueint=(int)n;
	item->type=cJSON_Number;
	return num;
}

static int pow2gt (int x)	{	--x;	x|=x>>1;	x|=x>>2;	x|=x>>4;	x|=x>>8;	x|=x>>16;	return x+1;	}
   12a54:	e2413001 	sub	r3, r1, #1
   12a58:	e18330c3 	orr	r3, r3, r3, asr #1
   12a5c:	e1833143 	orr	r3, r3, r3, asr #2
   12a60:	e1833243 	orr	r3, r3, r3, asr #4
   12a64:	e1833443 	orr	r3, r3, r3, asr #8
	if (!p || !p->buffer) return 0;
	needed+=p->offset;
	if (needed<=p->length) return p->buffer+p->offset;

	newsize=pow2gt(needed);
	newbuffer=(char*)cJSON_malloc(newsize);
   12a68:	e59f706c 	ldr	r7, [pc, #108]	; 12adc <ensure+0xbc>
	item->valueint=(int)n;
	item->type=cJSON_Number;
	return num;
}

static int pow2gt (int x)	{	--x;	x|=x>>1;	x|=x>>2;	x|=x>>4;	x|=x>>8;	x|=x>>16;	return x+1;	}
   12a6c:	e1833843 	orr	r3, r3, r3, asr #16
   12a70:	e2834001 	add	r4, r3, #1
	if (!p || !p->buffer) return 0;
	needed+=p->offset;
	if (needed<=p->length) return p->buffer+p->offset;

	newsize=pow2gt(needed);
	newbuffer=(char*)cJSON_malloc(newsize);
   12a74:	e08f7007 	add	r7, pc, r7
   12a78:	e1a00004 	mov	r0, r4
   12a7c:	e5973000 	ldr	r3, [r7]
   12a80:	e1a05002 	mov	r5, r2
   12a84:	e12fff33 	blx	r3
	if (!newbuffer) {cJSON_free(p->buffer);p->length=0,p->buffer=0;return 0;}
   12a88:	e2506000 	subs	r6, r0, #0
   12a8c:	0a00000b 	beq	12ac0 <ensure+0xa0>
	if (newbuffer) memcpy(newbuffer,p->buffer,p->length);
   12a90:	e8950006 	ldm	r5, {r1, r2}
   12a94:	ebffc9cc 	bl	51cc <memcpy@plt>
	cJSON_free(p->buffer);
   12a98:	e5950000 	ldr	r0, [r5]
   12a9c:	e5973004 	ldr	r3, [r7, #4]
   12aa0:	e12fff33 	blx	r3
	p->length=newsize;
	p->buffer=newbuffer;
	return newbuffer+p->offset;
   12aa4:	e5950008 	ldr	r0, [r5, #8]
	newsize=pow2gt(needed);
	newbuffer=(char*)cJSON_malloc(newsize);
	if (!newbuffer) {cJSON_free(p->buffer);p->length=0,p->buffer=0;return 0;}
	if (newbuffer) memcpy(newbuffer,p->buffer,p->length);
	cJSON_free(p->buffer);
	p->length=newsize;
   12aa8:	e5854004 	str	r4, [r5, #4]
	p->buffer=newbuffer;
   12aac:	e5856000 	str	r6, [r5]
	return newbuffer+p->offset;
   12ab0:	e0860000 	add	r0, r6, r0
   12ab4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
typedef struct {char *buffer; int length; int offset; } printbuffer;

static char* ensure(printbuffer *p,int needed)
{
	char *newbuffer;int newsize;
	if (!p || !p->buffer) return 0;
   12ab8:	e1a00002 	mov	r0, r2
   12abc:	e12fff1e 	bx	lr
	needed+=p->offset;
	if (needed<=p->length) return p->buffer+p->offset;

	newsize=pow2gt(needed);
	newbuffer=(char*)cJSON_malloc(newsize);
	if (!newbuffer) {cJSON_free(p->buffer);p->length=0,p->buffer=0;return 0;}
   12ac0:	e5950000 	ldr	r0, [r5]
   12ac4:	e5973004 	ldr	r3, [r7, #4]
   12ac8:	e12fff33 	blx	r3
   12acc:	e5856004 	str	r6, [r5, #4]
   12ad0:	e5856000 	str	r6, [r5]
   12ad4:	e1a00006 	mov	r0, r6
   12ad8:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
   12adc:	00011588 	.word	0x00011588

00012ae0 <cJSON_strdup>:

static void *(*cJSON_malloc)(size_t sz) = malloc;
static void (*cJSON_free)(void *ptr) = free;

static char* cJSON_strdup(const char* str)
{
   12ae0:	e92d4070 	push	{r4, r5, r6, lr}
   12ae4:	e1a06000 	mov	r6, r0
      size_t len;
      char* copy;

      len = strlen(str) + 1;
   12ae8:	ebffc984 	bl	5100 <strlen@plt>
      if (!(copy = (char*)cJSON_malloc(len))) return 0;
   12aec:	e59f302c 	ldr	r3, [pc, #44]	; 12b20 <cJSON_strdup+0x40>
   12af0:	e08f3003 	add	r3, pc, r3
   12af4:	e5933000 	ldr	r3, [r3]
static char* cJSON_strdup(const char* str)
{
      size_t len;
      char* copy;

      len = strlen(str) + 1;
   12af8:	e2804001 	add	r4, r0, #1
      if (!(copy = (char*)cJSON_malloc(len))) return 0;
   12afc:	e1a00004 	mov	r0, r4
   12b00:	e12fff33 	blx	r3
   12b04:	e2505000 	subs	r5, r0, #0
   12b08:	0a000002 	beq	12b18 <cJSON_strdup+0x38>
      memcpy(copy,str,len);
   12b0c:	e1a01006 	mov	r1, r6
   12b10:	e1a02004 	mov	r2, r4
   12b14:	ebffc9ac 	bl	51cc <memcpy@plt>
      return copy;
}
   12b18:	e1a00005 	mov	r0, r5
   12b1c:	e8bd8070 	pop	{r4, r5, r6, pc}
   12b20:	0001150c 	.word	0x0001150c

00012b24 <print_number>:
	return p->offset+strlen(str);
}

/* Render the number nicely from the given item into a string. */
static char *print_number(cJSON *item,printbuffer *p)
{
   12b24:	e92d4ff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	char *str=0;
	double d=item->valuedouble;
   12b28:	e590501c 	ldr	r5, [r0, #28]
   12b2c:	e5904018 	ldr	r4, [r0, #24]
	return p->offset+strlen(str);
}

/* Render the number nicely from the given item into a string. */
static char *print_number(cJSON *item,printbuffer *p)
{
   12b30:	e1a08000 	mov	r8, r0
   12b34:	e1a09001 	mov	r9, r1
	char *str=0;
	double d=item->valuedouble;
	if (d==0)
   12b38:	e3a02000 	mov	r2, #0
   12b3c:	e3a03000 	mov	r3, #0
   12b40:	e1a00004 	mov	r0, r4
   12b44:	e1a01005 	mov	r1, r5
   12b48:	eb002624 	bl	1c3e0 <__aeabi_dcmpeq>
   12b4c:	e1a07005 	mov	r7, r5
   12b50:	e3500000 	cmp	r0, #0
   12b54:	0a00000e 	beq	12b94 <print_number+0x70>
	{
		if (p)	str=ensure(p,2);
   12b58:	e3590000 	cmp	r9, #0
   12b5c:	0a000077 	beq	12d40 <print_number+0x21c>
   12b60:	e1a00009 	mov	r0, r9
   12b64:	e3a01002 	mov	r1, #2
   12b68:	ebffffac 	bl	12a20 <ensure>
   12b6c:	e1a06000 	mov	r6, r0
		else	str=(char*)cJSON_malloc(2);	/* special case for 0. */
		if (str) strcpy(str,"0");
   12b70:	e3560000 	cmp	r6, #0
   12b74:	0a000004 	beq	12b8c <print_number+0x68>
   12b78:	e59f1234 	ldr	r1, [pc, #564]	; 12db4 <print_number+0x290>
   12b7c:	e1a00006 	mov	r0, r6
   12b80:	e08f1001 	add	r1, pc, r1
   12b84:	e3a02002 	mov	r2, #2
   12b88:	ebffc98f 	bl	51cc <memcpy@plt>
			else if (fabs(d)<1.0e-6 || fabs(d)>1.0e9)			sprintf(str,"%e",d);
			else												sprintf(str,"%f",d);
		}
	}
	return str;
}
   12b8c:	e1a00006 	mov	r0, r6
   12b90:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	{
		if (p)	str=ensure(p,2);
		else	str=(char*)cJSON_malloc(2);	/* special case for 0. */
		if (str) strcpy(str,"0");
	}
	else if (fabs(((double)item->valueint)-d)<=DBL_EPSILON && d<=INT_MAX && d>=INT_MIN)
   12b94:	e1a01005 	mov	r1, r5
   12b98:	e3a02000 	mov	r2, #0
   12b9c:	e59f3214 	ldr	r3, [pc, #532]	; 12db8 <print_number+0x294>
   12ba0:	e1a00004 	mov	r0, r4
   12ba4:	eb00261c 	bl	1c41c <__aeabi_dcmpge>
   12ba8:	e3a0b001 	mov	fp, #1
   12bac:	e59f2208 	ldr	r2, [pc, #520]	; 12dbc <print_number+0x298>
   12bb0:	e59f3208 	ldr	r3, [pc, #520]	; 12dc0 <print_number+0x29c>
   12bb4:	e1a01005 	mov	r1, r5
   12bb8:	e3a0a001 	mov	sl, #1
   12bbc:	e3500000 	cmp	r0, #0
   12bc0:	01a0b000 	moveq	fp, r0
   12bc4:	e1a00004 	mov	r0, r4
   12bc8:	eb00260e 	bl	1c408 <__aeabi_dcmple>
   12bcc:	e3500000 	cmp	r0, #0
   12bd0:	01a0a000 	moveq	sl, r0
   12bd4:	e5980014 	ldr	r0, [r8, #20]
   12bd8:	eb00247b 	bl	1bdcc <__aeabi_i2d>
   12bdc:	e1a02004 	mov	r2, r4
   12be0:	e1a03005 	mov	r3, r5
   12be4:	eb0023c3 	bl	1baf8 <__aeabi_dsub>
   12be8:	e3a02000 	mov	r2, #0
   12bec:	e59f31d0 	ldr	r3, [pc, #464]	; 12dc4 <print_number+0x2a0>
   12bf0:	e00bb00a 	and	fp, fp, sl
   12bf4:	e3a0a001 	mov	sl, #1
   12bf8:	e3c17102 	bic	r7, r1, #-2147483648	; 0x80000000
   12bfc:	e1a01007 	mov	r1, r7
   12c00:	eb002600 	bl	1c408 <__aeabi_dcmple>
   12c04:	e3500000 	cmp	r0, #0
   12c08:	01a0a000 	moveq	sl, r0
   12c0c:	e00aa00b 	and	sl, sl, fp
   12c10:	e31a00ff 	tst	sl, #255	; 0xff
   12c14:	1a00002c 	bne	12ccc <print_number+0x1a8>
		else	str=(char*)cJSON_malloc(21);	/* 2^64+1 can be represented in 21 chars. */
		if (str)	sprintf(str,"%d",item->valueint);
	}
	else
	{
		if (p)	str=ensure(p,64);
   12c18:	e3590000 	cmp	r9, #0
   12c1c:	0a000056 	beq	12d7c <print_number+0x258>
   12c20:	e1a00009 	mov	r0, r9
   12c24:	e3a01040 	mov	r1, #64	; 0x40
   12c28:	ebffff7c 	bl	12a20 <ensure>
   12c2c:	e1a06000 	mov	r6, r0
		else	str=(char*)cJSON_malloc(64);	/* This is a nice tradeoff. */
		if (str)
   12c30:	e3560000 	cmp	r6, #0
   12c34:	0affffd4 	beq	12b8c <print_number+0x68>
		{
			if (fabs(floor(d)-d)<=DBL_EPSILON && fabs(d)<1.0e60)sprintf(str,"%.0f",d);
   12c38:	e1a00004 	mov	r0, r4
   12c3c:	e1a01005 	mov	r1, r5
   12c40:	ebffca24 	bl	54d8 <floor@plt>
   12c44:	e1a02004 	mov	r2, r4
   12c48:	e1a03005 	mov	r3, r5
   12c4c:	eb0023a9 	bl	1baf8 <__aeabi_dsub>
   12c50:	e3a02000 	mov	r2, #0
   12c54:	e59f3168 	ldr	r3, [pc, #360]	; 12dc4 <print_number+0x2a0>
   12c58:	e3c19102 	bic	r9, r1, #-2147483648	; 0x80000000
   12c5c:	e1a01009 	mov	r1, r9
   12c60:	e1a08000 	mov	r8, r0
   12c64:	eb0025e7 	bl	1c408 <__aeabi_dcmple>
   12c68:	e3500000 	cmp	r0, #0
   12c6c:	1a000024 	bne	12d04 <print_number+0x1e0>
   12c70:	e3c57102 	bic	r7, r5, #-2147483648	; 0x80000000
			else if (fabs(d)<1.0e-6 || fabs(d)>1.0e9)			sprintf(str,"%e",d);
   12c74:	e1a00004 	mov	r0, r4
   12c78:	e1a01007 	mov	r1, r7
   12c7c:	e59f2144 	ldr	r2, [pc, #324]	; 12dc8 <print_number+0x2a4>
   12c80:	e59f3144 	ldr	r3, [pc, #324]	; 12dcc <print_number+0x2a8>
   12c84:	eb0025da 	bl	1c3f4 <__aeabi_dcmplt>
   12c88:	e3500000 	cmp	r0, #0
   12c8c:	1a000006 	bne	12cac <print_number+0x188>
   12c90:	e1a00004 	mov	r0, r4
   12c94:	e1a01007 	mov	r1, r7
   12c98:	e3a02000 	mov	r2, #0
   12c9c:	e59f312c 	ldr	r3, [pc, #300]	; 12dd0 <print_number+0x2ac>
   12ca0:	eb0025e2 	bl	1c430 <__aeabi_dcmpgt>
   12ca4:	e3500000 	cmp	r0, #0
   12ca8:	0a00002b 	beq	12d5c <print_number+0x238>
   12cac:	e59f1120 	ldr	r1, [pc, #288]	; 12dd4 <print_number+0x2b0>
   12cb0:	e1a02004 	mov	r2, r4
   12cb4:	e1a03005 	mov	r3, r5
   12cb8:	e1a00006 	mov	r0, r6
   12cbc:	e08f1001 	add	r1, pc, r1
   12cc0:	ebffc929 	bl	516c <sprintf@plt>
			else												sprintf(str,"%f",d);
		}
	}
	return str;
}
   12cc4:	e1a00006 	mov	r0, r6
   12cc8:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		else	str=(char*)cJSON_malloc(2);	/* special case for 0. */
		if (str) strcpy(str,"0");
	}
	else if (fabs(((double)item->valueint)-d)<=DBL_EPSILON && d<=INT_MAX && d>=INT_MIN)
	{
		if (p)	str=ensure(p,21);
   12ccc:	e3590000 	cmp	r9, #0
   12cd0:	0a000030 	beq	12d98 <print_number+0x274>
   12cd4:	e1a00009 	mov	r0, r9
   12cd8:	e3a01015 	mov	r1, #21
   12cdc:	ebffff4f 	bl	12a20 <ensure>
   12ce0:	e1a06000 	mov	r6, r0
		else	str=(char*)cJSON_malloc(21);	/* 2^64+1 can be represented in 21 chars. */
		if (str)	sprintf(str,"%d",item->valueint);
   12ce4:	e3560000 	cmp	r6, #0
   12ce8:	0affffa7 	beq	12b8c <print_number+0x68>
   12cec:	e59f10e4 	ldr	r1, [pc, #228]	; 12dd8 <print_number+0x2b4>
   12cf0:	e5982014 	ldr	r2, [r8, #20]
   12cf4:	e1a00006 	mov	r0, r6
   12cf8:	e08f1001 	add	r1, pc, r1
   12cfc:	ebffc91a 	bl	516c <sprintf@plt>
   12d00:	eaffffa1 	b	12b8c <print_number+0x68>
	{
		if (p)	str=ensure(p,64);
		else	str=(char*)cJSON_malloc(64);	/* This is a nice tradeoff. */
		if (str)
		{
			if (fabs(floor(d)-d)<=DBL_EPSILON && fabs(d)<1.0e60)sprintf(str,"%.0f",d);
   12d04:	e3c57102 	bic	r7, r5, #-2147483648	; 0x80000000
   12d08:	e1a00004 	mov	r0, r4
   12d0c:	e1a01007 	mov	r1, r7
   12d10:	e59f20c4 	ldr	r2, [pc, #196]	; 12ddc <print_number+0x2b8>
   12d14:	e59f30c4 	ldr	r3, [pc, #196]	; 12de0 <print_number+0x2bc>
   12d18:	eb0025b5 	bl	1c3f4 <__aeabi_dcmplt>
   12d1c:	e3500000 	cmp	r0, #0
   12d20:	0affffd3 	beq	12c74 <print_number+0x150>
   12d24:	e59f10b8 	ldr	r1, [pc, #184]	; 12de4 <print_number+0x2c0>
   12d28:	e1a02004 	mov	r2, r4
   12d2c:	e1a03005 	mov	r3, r5
   12d30:	e1a00006 	mov	r0, r6
   12d34:	e08f1001 	add	r1, pc, r1
   12d38:	ebffc90b 	bl	516c <sprintf@plt>
   12d3c:	eaffff92 	b	12b8c <print_number+0x68>
	char *str=0;
	double d=item->valuedouble;
	if (d==0)
	{
		if (p)	str=ensure(p,2);
		else	str=(char*)cJSON_malloc(2);	/* special case for 0. */
   12d40:	e59f30a0 	ldr	r3, [pc, #160]	; 12de8 <print_number+0x2c4>
   12d44:	e3a00002 	mov	r0, #2
   12d48:	e08f3003 	add	r3, pc, r3
   12d4c:	e5933000 	ldr	r3, [r3]
   12d50:	e12fff33 	blx	r3
   12d54:	e1a06000 	mov	r6, r0
   12d58:	eaffff84 	b	12b70 <print_number+0x4c>
		else	str=(char*)cJSON_malloc(64);	/* This is a nice tradeoff. */
		if (str)
		{
			if (fabs(floor(d)-d)<=DBL_EPSILON && fabs(d)<1.0e60)sprintf(str,"%.0f",d);
			else if (fabs(d)<1.0e-6 || fabs(d)>1.0e9)			sprintf(str,"%e",d);
			else												sprintf(str,"%f",d);
   12d5c:	e59f1088 	ldr	r1, [pc, #136]	; 12dec <print_number+0x2c8>
   12d60:	e1a02004 	mov	r2, r4
   12d64:	e1a03005 	mov	r3, r5
   12d68:	e1a00006 	mov	r0, r6
   12d6c:	e08f1001 	add	r1, pc, r1
   12d70:	ebffc8fd 	bl	516c <sprintf@plt>
		}
	}
	return str;
}
   12d74:	e1a00006 	mov	r0, r6
   12d78:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (str)	sprintf(str,"%d",item->valueint);
	}
	else
	{
		if (p)	str=ensure(p,64);
		else	str=(char*)cJSON_malloc(64);	/* This is a nice tradeoff. */
   12d7c:	e59f306c 	ldr	r3, [pc, #108]	; 12df0 <print_number+0x2cc>
   12d80:	e3a00040 	mov	r0, #64	; 0x40
   12d84:	e08f3003 	add	r3, pc, r3
   12d88:	e5933000 	ldr	r3, [r3]
   12d8c:	e12fff33 	blx	r3
   12d90:	e1a06000 	mov	r6, r0
   12d94:	eaffffa5 	b	12c30 <print_number+0x10c>
		if (str) strcpy(str,"0");
	}
	else if (fabs(((double)item->valueint)-d)<=DBL_EPSILON && d<=INT_MAX && d>=INT_MIN)
	{
		if (p)	str=ensure(p,21);
		else	str=(char*)cJSON_malloc(21);	/* 2^64+1 can be represented in 21 chars. */
   12d98:	e59f3054 	ldr	r3, [pc, #84]	; 12df4 <print_number+0x2d0>
   12d9c:	e3a00015 	mov	r0, #21
   12da0:	e08f3003 	add	r3, pc, r3
   12da4:	e5933000 	ldr	r3, [r3]
   12da8:	e12fff33 	blx	r3
   12dac:	e1a06000 	mov	r6, r0
   12db0:	eaffffcb 	b	12ce4 <print_number+0x1c0>
   12db4:	0000bac4 	.word	0x0000bac4
   12db8:	c1e00000 	.word	0xc1e00000
   12dbc:	ffc00000 	.word	0xffc00000
   12dc0:	41dfffff 	.word	0x41dfffff
   12dc4:	3cb00000 	.word	0x3cb00000
   12dc8:	a0b5ed8d 	.word	0xa0b5ed8d
   12dcc:	3eb0c6f7 	.word	0x3eb0c6f7
   12dd0:	41cdcd65 	.word	0x41cdcd65
   12dd4:	0000df9c 	.word	0x0000df9c
   12dd8:	0000b984 	.word	0x0000b984
   12ddc:	e4c2f344 	.word	0xe4c2f344
   12de0:	4c63e9e4 	.word	0x4c63e9e4
   12de4:	0000df1c 	.word	0x0000df1c
   12de8:	000112b4 	.word	0x000112b4
   12dec:	0000def0 	.word	0x0000def0
   12df0:	00011278 	.word	0x00011278
   12df4:	0001125c 	.word	0x0001125c

00012df8 <print_string_ptr>:
	return ptr;
}

/* Render the cstring provided to an escaped version that can be printed. */
static char *print_string_ptr(const char *str,printbuffer *p)
{
   12df8:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
	const char *ptr;char *ptr2,*out;int len=0,flag=0;unsigned char token;
	
	for (ptr=str;*ptr;ptr++) flag|=((*ptr>0 && *ptr<32)||(*ptr=='\"')||(*ptr=='\\'))?1:0;
   12dfc:	e5d07000 	ldrb	r7, [r0]
	return ptr;
}

/* Render the cstring provided to an escaped version that can be printed. */
static char *print_string_ptr(const char *str,printbuffer *p)
{
   12e00:	e24dd00c 	sub	sp, sp, #12
	const char *ptr;char *ptr2,*out;int len=0,flag=0;unsigned char token;
	
	for (ptr=str;*ptr;ptr++) flag|=((*ptr>0 && *ptr<32)||(*ptr=='\"')||(*ptr=='\\'))?1:0;
   12e04:	e3570000 	cmp	r7, #0
	return ptr;
}

/* Render the cstring provided to an escaped version that can be printed. */
static char *print_string_ptr(const char *str,printbuffer *p)
{
   12e08:	e1a05000 	mov	r5, r0
   12e0c:	e1a06001 	mov	r6, r1
	const char *ptr;char *ptr2,*out;int len=0,flag=0;unsigned char token;
	
	for (ptr=str;*ptr;ptr++) flag|=((*ptr>0 && *ptr<32)||(*ptr=='\"')||(*ptr=='\\'))?1:0;
   12e10:	0a00008a 	beq	13040 <print_string_ptr+0x248>
   12e14:	e1a01007 	mov	r1, r7
   12e18:	e1a02000 	mov	r2, r0
   12e1c:	e3a03000 	mov	r3, #0
   12e20:	e3510022 	cmp	r1, #34	; 0x22
   12e24:	1351005c 	cmpne	r1, #92	; 0x5c
   12e28:	e2410001 	sub	r0, r1, #1
   12e2c:	e5f21001 	ldrb	r1, [r2, #1]!
   12e30:	03a04001 	moveq	r4, #1
   12e34:	13a04000 	movne	r4, #0
   12e38:	e350001e 	cmp	r0, #30
   12e3c:	93844001 	orrls	r4, r4, #1
   12e40:	e3510000 	cmp	r1, #0
   12e44:	e1833004 	orr	r3, r3, r4
   12e48:	1afffff4 	bne	12e20 <print_string_ptr+0x28>
	if (!flag)
   12e4c:	e3530000 	cmp	r3, #0
   12e50:	0a00005e 	beq	12fd0 <print_string_ptr+0x1d8>
		else	out=(char*)cJSON_malloc(3);
		if (!out) return 0;
		strcpy(out,"\"\"");
		return out;
	}
	ptr=str;while ((token=*ptr) && ++len) {if (strchr("\"\\\b\f\n\r\t",token)) len++; else if (token<32) len+=5;ptr++;}
   12e54:	e59f922c 	ldr	r9, [pc, #556]	; 13088 <print_string_ptr+0x290>
static char *print_string_ptr(const char *str,printbuffer *p)
{
	const char *ptr;char *ptr2,*out;int len=0,flag=0;unsigned char token;
	
	for (ptr=str;*ptr;ptr++) flag|=((*ptr>0 && *ptr<32)||(*ptr=='\"')||(*ptr=='\\'))?1:0;
	if (!flag)
   12e58:	e1a04001 	mov	r4, r1
		else	out=(char*)cJSON_malloc(3);
		if (!out) return 0;
		strcpy(out,"\"\"");
		return out;
	}
	ptr=str;while ((token=*ptr) && ++len) {if (strchr("\"\\\b\f\n\r\t",token)) len++; else if (token<32) len+=5;ptr++;}
   12e5c:	e08f9009 	add	r9, pc, r9
   12e60:	e1a08005 	mov	r8, r5
   12e64:	ea000005 	b	12e80 <print_string_ptr+0x88>
   12e68:	e357001f 	cmp	r7, #31
   12e6c:	e5f87001 	ldrb	r7, [r8, #1]!
   12e70:	82844001 	addhi	r4, r4, #1
   12e74:	92844006 	addls	r4, r4, #6
   12e78:	e3570000 	cmp	r7, #0
   12e7c:	0a000008 	beq	12ea4 <print_string_ptr+0xac>
   12e80:	e1a00009 	mov	r0, r9
   12e84:	e1a01007 	mov	r1, r7
   12e88:	ebffc896 	bl	50e8 <strchr@plt>
   12e8c:	e3500000 	cmp	r0, #0
   12e90:	12844002 	addne	r4, r4, #2
   12e94:	0afffff3 	beq	12e68 <print_string_ptr+0x70>
   12e98:	e5f87001 	ldrb	r7, [r8, #1]!
   12e9c:	e3570000 	cmp	r7, #0
   12ea0:	1afffff6 	bne	12e80 <print_string_ptr+0x88>
	
	if (p)	out=ensure(p,len+3);
   12ea4:	e3560000 	cmp	r6, #0
   12ea8:	e2841003 	add	r1, r4, #3
   12eac:	0a00006c 	beq	13064 <print_string_ptr+0x26c>
   12eb0:	e1a00006 	mov	r0, r6
   12eb4:	ebfffed9 	bl	12a20 <ensure>
   12eb8:	e1a06000 	mov	r6, r0
	else	out=(char*)cJSON_malloc(len+3);
	if (!out) return 0;
   12ebc:	e3560000 	cmp	r6, #0
   12ec0:	0a00006e 	beq	13080 <print_string_ptr+0x288>

	ptr2=out;ptr=str;
	*ptr2++='\"';
   12ec4:	e3a03022 	mov	r3, #34	; 0x22
   12ec8:	e5c63000 	strb	r3, [r6]
				case '\b':	*ptr2++='b';	break;
				case '\f':	*ptr2++='f';	break;
				case '\n':	*ptr2++='n';	break;
				case '\r':	*ptr2++='r';	break;
				case '\t':	*ptr2++='t';	break;
				default: sprintf(ptr2,"u%04x",token);ptr2+=5;	break;	/* escape and print */
   12ecc:	e59f31b8 	ldr	r3, [pc, #440]	; 1308c <print_string_ptr+0x294>
   12ed0:	e2857001 	add	r7, r5, #1
	while (*ptr)
	{
		if ((unsigned char)*ptr>31 && *ptr!='\"' && *ptr!='\\') *ptr2++=*ptr++;
		else
		{
			*ptr2++='\\';
   12ed4:	e3a0805c 	mov	r8, #92	; 0x5c
	if (p)	out=ensure(p,len+3);
	else	out=(char*)cJSON_malloc(len+3);
	if (!out) return 0;

	ptr2=out;ptr=str;
	*ptr2++='\"';
   12ed8:	e2865001 	add	r5, r6, #1
			switch (token=*ptr++)
			{
				case '\\':	*ptr2++='\\';	break;
				case '\"':	*ptr2++='\"';	break;
				case '\b':	*ptr2++='b';	break;
				case '\f':	*ptr2++='f';	break;
   12edc:	e3a0c066 	mov	ip, #102	; 0x66
				case '\n':	*ptr2++='n';	break;
				case '\r':	*ptr2++='r';	break;
				case '\t':	*ptr2++='t';	break;
				default: sprintf(ptr2,"u%04x",token);ptr2+=5;	break;	/* escape and print */
   12ee0:	e08f3003 	add	r3, pc, r3
				case '\\':	*ptr2++='\\';	break;
				case '\"':	*ptr2++='\"';	break;
				case '\b':	*ptr2++='b';	break;
				case '\f':	*ptr2++='f';	break;
				case '\n':	*ptr2++='n';	break;
				case '\r':	*ptr2++='r';	break;
   12ee4:	e3a0b072 	mov	fp, #114	; 0x72
				case '\t':	*ptr2++='t';	break;
   12ee8:	e3a0a074 	mov	sl, #116	; 0x74
			{
				case '\\':	*ptr2++='\\';	break;
				case '\"':	*ptr2++='\"';	break;
				case '\b':	*ptr2++='b';	break;
				case '\f':	*ptr2++='f';	break;
				case '\n':	*ptr2++='n';	break;
   12eec:	e3a0906e 	mov	r9, #110	; 0x6e
	else	out=(char*)cJSON_malloc(len+3);
	if (!out) return 0;

	ptr2=out;ptr=str;
	*ptr2++='\"';
	while (*ptr)
   12ef0:	ea000002 	b	12f00 <print_string_ptr+0x108>
	{
		if ((unsigned char)*ptr>31 && *ptr!='\"' && *ptr!='\\') *ptr2++=*ptr++;
   12ef4:	e5c54000 	strb	r4, [r5]
   12ef8:	e2855001 	add	r5, r5, #1
   12efc:	e2877001 	add	r7, r7, #1
	else	out=(char*)cJSON_malloc(len+3);
	if (!out) return 0;

	ptr2=out;ptr=str;
	*ptr2++='\"';
	while (*ptr)
   12f00:	e5574001 	ldrb	r4, [r7, #-1]
   12f04:	e3540000 	cmp	r4, #0
   12f08:	0a00002a 	beq	12fb8 <print_string_ptr+0x1c0>
	{
		if ((unsigned char)*ptr>31 && *ptr!='\"' && *ptr!='\\') *ptr2++=*ptr++;
   12f0c:	e3540022 	cmp	r4, #34	; 0x22
   12f10:	1354001f 	cmpne	r4, #31
   12f14:	83a02001 	movhi	r2, #1
   12f18:	93a02000 	movls	r2, #0
   12f1c:	e354005c 	cmp	r4, #92	; 0x5c
   12f20:	03a02000 	moveq	r2, #0
   12f24:	12022001 	andne	r2, r2, #1
   12f28:	e3520000 	cmp	r2, #0
   12f2c:	1afffff0 	bne	12ef4 <print_string_ptr+0xfc>
		else
		{
			*ptr2++='\\';
   12f30:	e5c58000 	strb	r8, [r5]
			switch (token=*ptr++)
   12f34:	e5572001 	ldrb	r2, [r7, #-1]
   12f38:	e352000c 	cmp	r2, #12
   12f3c:	0a000039 	beq	13028 <print_string_ptr+0x230>
   12f40:	8a00000f 	bhi	12f84 <print_string_ptr+0x18c>
   12f44:	e3520009 	cmp	r2, #9
   12f48:	0a000039 	beq	13034 <print_string_ptr+0x23c>
   12f4c:	e352000a 	cmp	r2, #10
			{
				case '\\':	*ptr2++='\\';	break;
				case '\"':	*ptr2++='\"';	break;
				case '\b':	*ptr2++='b';	break;
				case '\f':	*ptr2++='f';	break;
				case '\n':	*ptr2++='n';	break;
   12f50:	05c59001 	strbeq	r9, [r5, #1]
   12f54:	02855002 	addeq	r5, r5, #2
	{
		if ((unsigned char)*ptr>31 && *ptr!='\"' && *ptr!='\\') *ptr2++=*ptr++;
		else
		{
			*ptr2++='\\';
			switch (token=*ptr++)
   12f58:	0affffe7 	beq	12efc <print_string_ptr+0x104>
   12f5c:	e3520008 	cmp	r2, #8
   12f60:	0a000010 	beq	12fa8 <print_string_ptr+0x1b0>
				case '\b':	*ptr2++='b';	break;
				case '\f':	*ptr2++='f';	break;
				case '\n':	*ptr2++='n';	break;
				case '\r':	*ptr2++='r';	break;
				case '\t':	*ptr2++='t';	break;
				default: sprintf(ptr2,"u%04x",token);ptr2+=5;	break;	/* escape and print */
   12f64:	e2850001 	add	r0, r5, #1
   12f68:	e1a01003 	mov	r1, r3
   12f6c:	e58dc004 	str	ip, [sp, #4]
   12f70:	e58d3000 	str	r3, [sp]
   12f74:	e2855006 	add	r5, r5, #6
   12f78:	ebffc87b 	bl	516c <sprintf@plt>
   12f7c:	e89d1008 	ldm	sp, {r3, ip}
   12f80:	eaffffdd 	b	12efc <print_string_ptr+0x104>
	{
		if ((unsigned char)*ptr>31 && *ptr!='\"' && *ptr!='\\') *ptr2++=*ptr++;
		else
		{
			*ptr2++='\\';
			switch (token=*ptr++)
   12f84:	e3520022 	cmp	r2, #34	; 0x22
   12f88:	0a000007 	beq	12fac <print_string_ptr+0x1b4>
   12f8c:	e352005c 	cmp	r2, #92	; 0x5c
   12f90:	0a000005 	beq	12fac <print_string_ptr+0x1b4>
   12f94:	e352000d 	cmp	r2, #13
   12f98:	1afffff1 	bne	12f64 <print_string_ptr+0x16c>
				case '\\':	*ptr2++='\\';	break;
				case '\"':	*ptr2++='\"';	break;
				case '\b':	*ptr2++='b';	break;
				case '\f':	*ptr2++='f';	break;
				case '\n':	*ptr2++='n';	break;
				case '\r':	*ptr2++='r';	break;
   12f9c:	e5c5b001 	strb	fp, [r5, #1]
   12fa0:	e2855002 	add	r5, r5, #2
   12fa4:	eaffffd4 	b	12efc <print_string_ptr+0x104>
			*ptr2++='\\';
			switch (token=*ptr++)
			{
				case '\\':	*ptr2++='\\';	break;
				case '\"':	*ptr2++='\"';	break;
				case '\b':	*ptr2++='b';	break;
   12fa8:	e3a02062 	mov	r2, #98	; 0x62
   12fac:	e5c52001 	strb	r2, [r5, #1]
   12fb0:	e2855002 	add	r5, r5, #2
   12fb4:	eaffffd0 	b	12efc <print_string_ptr+0x104>
				case '\t':	*ptr2++='t';	break;
				default: sprintf(ptr2,"u%04x",token);ptr2+=5;	break;	/* escape and print */
			}
		}
	}
	*ptr2++='\"';*ptr2++=0;
   12fb8:	e3a03022 	mov	r3, #34	; 0x22
	return out;
   12fbc:	e1a00006 	mov	r0, r6
				case '\t':	*ptr2++='t';	break;
				default: sprintf(ptr2,"u%04x",token);ptr2+=5;	break;	/* escape and print */
			}
		}
	}
	*ptr2++='\"';*ptr2++=0;
   12fc0:	e5c54001 	strb	r4, [r5, #1]
   12fc4:	e5c53000 	strb	r3, [r5]
	return out;
}
   12fc8:	e28dd00c 	add	sp, sp, #12
   12fcc:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12fd0:	e0657002 	rsb	r7, r5, r2
   12fd4:	e2871003 	add	r1, r7, #3
	
	for (ptr=str;*ptr;ptr++) flag|=((*ptr>0 && *ptr<32)||(*ptr=='\"')||(*ptr=='\\'))?1:0;
	if (!flag)
	{
		len=ptr-str;
		if (p) out=ensure(p,len+3);
   12fd8:	e3560000 	cmp	r6, #0
   12fdc:	0a000019 	beq	13048 <print_string_ptr+0x250>
   12fe0:	e1a00006 	mov	r0, r6
   12fe4:	ebfffe8d 	bl	12a20 <ensure>
   12fe8:	e1a06000 	mov	r6, r0
		else		out=(char*)cJSON_malloc(len+3);
		if (!out) return 0;
   12fec:	e3560000 	cmp	r6, #0
   12ff0:	0a000022 	beq	13080 <print_string_ptr+0x288>
		ptr2=out;*ptr2++='\"';
   12ff4:	e2863001 	add	r3, r6, #1
   12ff8:	e3a04022 	mov	r4, #34	; 0x22
		strcpy(ptr2,str);
   12ffc:	e1a01005 	mov	r1, r5
   13000:	e1a00003 	mov	r0, r3
	{
		len=ptr-str;
		if (p) out=ensure(p,len+3);
		else		out=(char*)cJSON_malloc(len+3);
		if (!out) return 0;
		ptr2=out;*ptr2++='\"';
   13004:	e5c64000 	strb	r4, [r6]
		strcpy(ptr2,str);
   13008:	ebffc87b 	bl	51fc <strcpy@plt>
		ptr2[len]='\"';
		ptr2[len+1]=0;
   1300c:	e3a02000 	mov	r2, #0
		len=ptr-str;
		if (p) out=ensure(p,len+3);
		else		out=(char*)cJSON_malloc(len+3);
		if (!out) return 0;
		ptr2=out;*ptr2++='\"';
		strcpy(ptr2,str);
   13010:	e1a03000 	mov	r3, r0
		ptr2[len]='\"';
		ptr2[len+1]=0;
		return out;
   13014:	e1a00006 	mov	r0, r6
		if (p) out=ensure(p,len+3);
		else		out=(char*)cJSON_malloc(len+3);
		if (!out) return 0;
		ptr2=out;*ptr2++='\"';
		strcpy(ptr2,str);
		ptr2[len]='\"';
   13018:	e7e34007 	strb	r4, [r3, r7]!
		ptr2[len+1]=0;
   1301c:	e5c32001 	strb	r2, [r3, #1]
			}
		}
	}
	*ptr2++='\"';*ptr2++=0;
	return out;
}
   13020:	e28dd00c 	add	sp, sp, #12
   13024:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
			switch (token=*ptr++)
			{
				case '\\':	*ptr2++='\\';	break;
				case '\"':	*ptr2++='\"';	break;
				case '\b':	*ptr2++='b';	break;
				case '\f':	*ptr2++='f';	break;
   13028:	e5c5c001 	strb	ip, [r5, #1]
   1302c:	e2855002 	add	r5, r5, #2
   13030:	eaffffb1 	b	12efc <print_string_ptr+0x104>
				case '\n':	*ptr2++='n';	break;
				case '\r':	*ptr2++='r';	break;
				case '\t':	*ptr2++='t';	break;
   13034:	e5c5a001 	strb	sl, [r5, #1]
   13038:	e2855002 	add	r5, r5, #2
   1303c:	eaffffae 	b	12efc <print_string_ptr+0x104>
/* Render the cstring provided to an escaped version that can be printed. */
static char *print_string_ptr(const char *str,printbuffer *p)
{
	const char *ptr;char *ptr2,*out;int len=0,flag=0;unsigned char token;
	
	for (ptr=str;*ptr;ptr++) flag|=((*ptr>0 && *ptr<32)||(*ptr=='\"')||(*ptr=='\\'))?1:0;
   13040:	e3a01003 	mov	r1, #3
   13044:	eaffffe3 	b	12fd8 <print_string_ptr+0x1e0>
	if (!flag)
	{
		len=ptr-str;
		if (p) out=ensure(p,len+3);
		else		out=(char*)cJSON_malloc(len+3);
   13048:	e59f3040 	ldr	r3, [pc, #64]	; 13090 <print_string_ptr+0x298>
   1304c:	e1a00001 	mov	r0, r1
   13050:	e08f3003 	add	r3, pc, r3
   13054:	e5933000 	ldr	r3, [r3]
   13058:	e12fff33 	blx	r3
   1305c:	e1a06000 	mov	r6, r0
   13060:	eaffffe1 	b	12fec <print_string_ptr+0x1f4>
		return out;
	}
	ptr=str;while ((token=*ptr) && ++len) {if (strchr("\"\\\b\f\n\r\t",token)) len++; else if (token<32) len+=5;ptr++;}
	
	if (p)	out=ensure(p,len+3);
	else	out=(char*)cJSON_malloc(len+3);
   13064:	e59f3028 	ldr	r3, [pc, #40]	; 13094 <print_string_ptr+0x29c>
   13068:	e1a00001 	mov	r0, r1
   1306c:	e08f3003 	add	r3, pc, r3
   13070:	e5933000 	ldr	r3, [r3]
   13074:	e12fff33 	blx	r3
   13078:	e1a06000 	mov	r6, r0
   1307c:	eaffff8e 	b	12ebc <print_string_ptr+0xc4>
	if (!out) return 0;
   13080:	e1a00006 	mov	r0, r6
   13084:	eaffffcf 	b	12fc8 <print_string_ptr+0x1d0>
   13088:	0000de04 	.word	0x0000de04
   1308c:	0000dd88 	.word	0x0000dd88
   13090:	00010fac 	.word	0x00010fac
   13094:	00010f90 	.word	0x00010f90

00013098 <cJSON_strcasecmp>:

const char *cJSON_GetErrorPtr(void) {return ep;}

static int cJSON_strcasecmp(const char *s1,const char *s2)
{
	if (!s1) return (s1==s2)?0:1;if (!s2) return 1;
   13098:	e3500000 	cmp	r0, #0
   1309c:	0a000013 	beq	130f0 <cJSON_strcasecmp+0x58>
   130a0:	e3510000 	cmp	r1, #0
   130a4:	0a000014 	beq	130fc <cJSON_strcasecmp+0x64>
static const char *ep;

const char *cJSON_GetErrorPtr(void) {return ep;}

static int cJSON_strcasecmp(const char *s1,const char *s2)
{
   130a8:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
   130ac:	e2406001 	sub	r6, r0, #1
   130b0:	e2415001 	sub	r5, r1, #1
   130b4:	ea000001 	b	130c0 <cJSON_strcasecmp+0x28>
	if (!s1) return (s1==s2)?0:1;if (!s2) return 1;
	for(; tolower(*s1) == tolower(*s2); ++s1, ++s2)	if(*s1 == 0)	return 0;
   130b8:	e3540000 	cmp	r4, #0
   130bc:	0a000009 	beq	130e8 <cJSON_strcasecmp+0x50>
   130c0:	e5f64001 	ldrb	r4, [r6, #1]!
   130c4:	e1a00004 	mov	r0, r4
   130c8:	ebffc905 	bl	54e4 <tolower@plt>
   130cc:	e1a07000 	mov	r7, r0
   130d0:	e5f50001 	ldrb	r0, [r5, #1]!
   130d4:	ebffc902 	bl	54e4 <tolower@plt>
   130d8:	e1570000 	cmp	r7, r0
   130dc:	0afffff5 	beq	130b8 <cJSON_strcasecmp+0x20>
	return tolower(*(const unsigned char *)s1) - tolower(*(const unsigned char *)s2);
   130e0:	e0600007 	rsb	r0, r0, r7
   130e4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
const char *cJSON_GetErrorPtr(void) {return ep;}

static int cJSON_strcasecmp(const char *s1,const char *s2)
{
	if (!s1) return (s1==s2)?0:1;if (!s2) return 1;
	for(; tolower(*s1) == tolower(*s2); ++s1, ++s2)	if(*s1 == 0)	return 0;
   130e8:	e1a00004 	mov	r0, r4
	return tolower(*(const unsigned char *)s1) - tolower(*(const unsigned char *)s2);
}
   130ec:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

const char *cJSON_GetErrorPtr(void) {return ep;}

static int cJSON_strcasecmp(const char *s1,const char *s2)
{
	if (!s1) return (s1==s2)?0:1;if (!s2) return 1;
   130f0:	e2910000 	adds	r0, r1, #0
   130f4:	13a00001 	movne	r0, #1
	for(; tolower(*s1) == tolower(*s2); ++s1, ++s2)	if(*s1 == 0)	return 0;
	return tolower(*(const unsigned char *)s1) - tolower(*(const unsigned char *)s2);
}
   130f8:	e12fff1e 	bx	lr

const char *cJSON_GetErrorPtr(void) {return ep;}

static int cJSON_strcasecmp(const char *s1,const char *s2)
{
	if (!s1) return (s1==s2)?0:1;if (!s2) return 1;
   130fc:	e3a00001 	mov	r0, #1
   13100:	e12fff1e 	bx	lr

00013104 <parse_string.isra.0>:
	return h;
}

/* Parse the input text into an unescaped cstring, and populate item. */
static const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
static const char *parse_string(cJSON *item,const char *str)
   13104:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
{
	const char *ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;
	if (*str!='\"') {ep=str;return 0;}	/* not a string! */
   13108:	e5d23000 	ldrb	r3, [r2]
	return h;
}

/* Parse the input text into an unescaped cstring, and populate item. */
static const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
static const char *parse_string(cJSON *item,const char *str)
   1310c:	e24dd014 	sub	sp, sp, #20
{
	const char *ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;
	if (*str!='\"') {ep=str;return 0;}	/* not a string! */
   13110:	e3530022 	cmp	r3, #34	; 0x22

/* Parse the input text into an unescaped cstring, and populate item. */
static const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
static const char *parse_string(cJSON *item,const char *str)
{
	const char *ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;
   13114:	e2825001 	add	r5, r2, #1
	if (*str!='\"') {ep=str;return 0;}	/* not a string! */
   13118:	1a000094 	bne	13370 <parse_string.isra.0+0x26c>
   1311c:	e1a04005 	mov	r4, r5
   13120:	e3a06000 	mov	r6, #0
	
	while (*ptr!='\"' && *ptr && ++len) if (*ptr++ == '\\') ptr++;	/* Skip escaped quotes. */
   13124:	e5d43000 	ldrb	r3, [r4]
   13128:	e3530000 	cmp	r3, #0
   1312c:	13530022 	cmpne	r3, #34	; 0x22
   13130:	0a000008 	beq	13158 <parse_string.isra.0+0x54>
   13134:	e353005c 	cmp	r3, #92	; 0x5c
   13138:	e2866001 	add	r6, r6, #1
   1313c:	12844001 	addne	r4, r4, #1
   13140:	1afffff7 	bne	13124 <parse_string.isra.0+0x20>
   13144:	e2844002 	add	r4, r4, #2
   13148:	e5d43000 	ldrb	r3, [r4]
   1314c:	e3530000 	cmp	r3, #0
   13150:	13530022 	cmpne	r3, #34	; 0x22
   13154:	1afffff6 	bne	13134 <parse_string.isra.0+0x30>
	
	out=(char*)cJSON_malloc(len+1);	/* This is how long we need for the string, roughly. */
   13158:	e59f3304 	ldr	r3, [pc, #772]	; 13464 <parse_string.isra.0+0x360>
   1315c:	e1a07000 	mov	r7, r0
   13160:	e08f3003 	add	r3, pc, r3
   13164:	e2860001 	add	r0, r6, #1
   13168:	e5933000 	ldr	r3, [r3]
   1316c:	e1a08001 	mov	r8, r1
   13170:	e1a0a002 	mov	sl, r2
   13174:	e12fff33 	blx	r3
	if (!out) return 0;
   13178:	e2509000 	subs	r9, r0, #0
   1317c:	0a0000b6 	beq	1345c <parse_string.isra.0+0x358>
					
					switch (len) {
						case 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
						case 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
						case 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
						case 1: *--ptr2 =(uc | firstByteMark[len]);
   13180:	e59f32e0 	ldr	r3, [pc, #736]	; 13468 <parse_string.isra.0+0x364>
   13184:	e5da4001 	ldrb	r4, [sl, #1]
				case 'r': *ptr2++='\r';	break;
				case 't': *ptr2++='\t';	break;
				case 'u':	 /* transcode utf16 to utf8. */
					uc=parse_hex4(ptr+1);ptr+=4;	/* get the unicode char. */

					if ((uc>=0xDC00 && uc<=0xDFFF) || uc==0)	break;	/* check for invalid.	*/
   13188:	e59fb2dc 	ldr	fp, [pc, #732]	; 1346c <parse_string.isra.0+0x368>
					
					switch (len) {
						case 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
						case 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
						case 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
						case 1: *--ptr2 =(uc | firstByteMark[len]);
   1318c:	e08f3003 	add	r3, pc, r3
	if (*str!='\"') {ep=str;return 0;}	/* not a string! */
	
	while (*ptr!='\"' && *ptr && ++len) if (*ptr++ == '\\') ptr++;	/* Skip escaped quotes. */
	
	out=(char*)cJSON_malloc(len+1);	/* This is how long we need for the string, roughly. */
	if (!out) return 0;
   13190:	e1a06009 	mov	r6, r9
			{
				case 'b': *ptr2++='\b';	break;
				case 'f': *ptr2++='\f';	break;
				case 'n': *ptr2++='\n';	break;
				case 'r': *ptr2++='\r';	break;
				case 't': *ptr2++='\t';	break;
   13194:	e3a0c009 	mov	ip, #9
			switch (*ptr)
			{
				case 'b': *ptr2++='\b';	break;
				case 'f': *ptr2++='\f';	break;
				case 'n': *ptr2++='\n';	break;
				case 'r': *ptr2++='\r';	break;
   13198:	e3a0100d 	mov	r1, #13
			ptr++;
			switch (*ptr)
			{
				case 'b': *ptr2++='\b';	break;
				case 'f': *ptr2++='\f';	break;
				case 'n': *ptr2++='\n';	break;
   1319c:	e3a0200a 	mov	r2, #10
					
					switch (len) {
						case 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
						case 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
						case 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
						case 1: *--ptr2 =(uc | firstByteMark[len]);
   131a0:	e58d3000 	str	r3, [sp]
	
	out=(char*)cJSON_malloc(len+1);	/* This is how long we need for the string, roughly. */
	if (!out) return 0;
	
	ptr=str+1;ptr2=out;
	while (*ptr!='\"' && *ptr)
   131a4:	e3540000 	cmp	r4, #0
   131a8:	13540022 	cmpne	r4, #34	; 0x22
   131ac:	13a03001 	movne	r3, #1
   131b0:	03a03000 	moveq	r3, #0
   131b4:	0a000020 	beq	1323c <parse_string.isra.0+0x138>
	{
		if (*ptr!='\\') *ptr2++=*ptr++;
   131b8:	e354005c 	cmp	r4, #92	; 0x5c
   131bc:	0a000004 	beq	131d4 <parse_string.isra.0+0xd0>
   131c0:	e5c64000 	strb	r4, [r6]
   131c4:	e2855001 	add	r5, r5, #1
   131c8:	e5d54000 	ldrb	r4, [r5]
   131cc:	e2866001 	add	r6, r6, #1
   131d0:	eafffff3 	b	131a4 <parse_string.isra.0+0xa0>
		else
		{
			ptr++;
			switch (*ptr)
   131d4:	e5d50001 	ldrb	r0, [r5, #1]
	while (*ptr!='\"' && *ptr)
	{
		if (*ptr!='\\') *ptr2++=*ptr++;
		else
		{
			ptr++;
   131d8:	e285e001 	add	lr, r5, #1
			switch (*ptr)
   131dc:	e2403062 	sub	r3, r0, #98	; 0x62
   131e0:	e3530013 	cmp	r3, #19
   131e4:	908ff103 	addls	pc, pc, r3, lsl #2
   131e8:	ea00005c 	b	13360 <parse_string.isra.0+0x25c>
   131ec:	ea000056 	b	1334c <parse_string.isra.0+0x248>
   131f0:	ea00005a 	b	13360 <parse_string.isra.0+0x25c>
   131f4:	ea000059 	b	13360 <parse_string.isra.0+0x25c>
   131f8:	ea000058 	b	13360 <parse_string.isra.0+0x25c>
   131fc:	ea00004d 	b	13338 <parse_string.isra.0+0x234>
   13200:	ea000056 	b	13360 <parse_string.isra.0+0x25c>
   13204:	ea000055 	b	13360 <parse_string.isra.0+0x25c>
   13208:	ea000054 	b	13360 <parse_string.isra.0+0x25c>
   1320c:	ea000053 	b	13360 <parse_string.isra.0+0x25c>
   13210:	ea000052 	b	13360 <parse_string.isra.0+0x25c>
   13214:	ea000051 	b	13360 <parse_string.isra.0+0x25c>
   13218:	ea000050 	b	13360 <parse_string.isra.0+0x25c>
   1321c:	ea000041 	b	13328 <parse_string.isra.0+0x224>
   13220:	ea00004e 	b	13360 <parse_string.isra.0+0x25c>
   13224:	ea00004d 	b	13360 <parse_string.isra.0+0x25c>
   13228:	ea00004c 	b	13360 <parse_string.isra.0+0x25c>
   1322c:	ea000039 	b	13318 <parse_string.isra.0+0x214>
   13230:	ea00004a 	b	13360 <parse_string.isra.0+0x25c>
   13234:	ea000032 	b	13304 <parse_string.isra.0+0x200>
   13238:	ea000009 	b	13264 <parse_string.isra.0+0x160>
				default:  *ptr2++=*ptr; break;
			}
			ptr++;
		}
	}
	*ptr2=0;
   1323c:	e5c63000 	strb	r3, [r6]
	if (*ptr=='\"') ptr++;
   13240:	e5d53000 	ldrb	r3, [r5]
	item->valuestring=out;
   13244:	e5889000 	str	r9, [r8]
			}
			ptr++;
		}
	}
	*ptr2=0;
	if (*ptr=='\"') ptr++;
   13248:	e3530022 	cmp	r3, #34	; 0x22
   1324c:	02855001 	addeq	r5, r5, #1
	item->valuestring=out;
	item->type=cJSON_String;
   13250:	e3a03004 	mov	r3, #4
	return ptr;
   13254:	e1a00005 	mov	r0, r5
		}
	}
	*ptr2=0;
	if (*ptr=='\"') ptr++;
	item->valuestring=out;
	item->type=cJSON_String;
   13258:	e5873000 	str	r3, [r7]
	return ptr;
}
   1325c:	e28dd014 	add	sp, sp, #20
   13260:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
				case 'f': *ptr2++='\f';	break;
				case 'n': *ptr2++='\n';	break;
				case 'r': *ptr2++='\r';	break;
				case 't': *ptr2++='\t';	break;
				case 'u':	 /* transcode utf16 to utf8. */
					uc=parse_hex4(ptr+1);ptr+=4;	/* get the unicode char. */
   13264:	e2850002 	add	r0, r5, #2
   13268:	e58d200c 	str	r2, [sp, #12]
   1326c:	e58d1008 	str	r1, [sp, #8]
   13270:	e58dc004 	str	ip, [sp, #4]
   13274:	ebfffd96 	bl	128d4 <parse_hex4>
   13278:	e285e005 	add	lr, r5, #5

					if ((uc>=0xDC00 && uc<=0xDFFF) || uc==0)	break;	/* check for invalid.	*/
   1327c:	e59dc004 	ldr	ip, [sp, #4]
   13280:	e59d1008 	ldr	r1, [sp, #8]
   13284:	e59d200c 	ldr	r2, [sp, #12]
   13288:	e2403b37 	sub	r3, r0, #56320	; 0xdc00
   1328c:	e3500000 	cmp	r0, #0
   13290:	1153000b 	cmpne	r3, fp
				case 'f': *ptr2++='\f';	break;
				case 'n': *ptr2++='\n';	break;
				case 'r': *ptr2++='\r';	break;
				case 't': *ptr2++='\t';	break;
				case 'u':	 /* transcode utf16 to utf8. */
					uc=parse_hex4(ptr+1);ptr+=4;	/* get the unicode char. */
   13294:	e1a0a000 	mov	sl, r0

					if ((uc>=0xDC00 && uc<=0xDFFF) || uc==0)	break;	/* check for invalid.	*/
   13298:	93a03001 	movls	r3, #1
   1329c:	83a03000 	movhi	r3, #0
   132a0:	9a000038 	bls	13388 <parse_string.isra.0+0x284>

					if (uc>=0xD800 && uc<=0xDBFF)	/* UTF16 surrogate pairs.	*/
   132a4:	e2400b36 	sub	r0, r0, #55296	; 0xd800
   132a8:	e150000b 	cmp	r0, fp
   132ac:	8a000037 	bhi	13390 <parse_string.isra.0+0x28c>
					{
						if (ptr[1]!='\\' || ptr[2]!='u')	break;	/* missing second-half of surrogate.	*/
   132b0:	e5d53006 	ldrb	r3, [r5, #6]
   132b4:	e353005c 	cmp	r3, #92	; 0x5c
   132b8:	11a04003 	movne	r4, r3
   132bc:	1a000013 	bne	13310 <parse_string.isra.0+0x20c>
   132c0:	e5d53007 	ldrb	r3, [r5, #7]
   132c4:	e3530075 	cmp	r3, #117	; 0x75
   132c8:	1a000010 	bne	13310 <parse_string.isra.0+0x20c>
						uc2=parse_hex4(ptr+3);ptr+=6;
   132cc:	e2850008 	add	r0, r5, #8
   132d0:	e58d200c 	str	r2, [sp, #12]
   132d4:	e58d1008 	str	r1, [sp, #8]
   132d8:	e58dc004 	str	ip, [sp, #4]
   132dc:	ebfffd7c 	bl	128d4 <parse_hex4>
   132e0:	e285e00b 	add	lr, r5, #11
						if (uc2<0xDC00 || uc2>0xDFFF)		break;	/* invalid second-half of surrogate.	*/
   132e4:	e59dc004 	ldr	ip, [sp, #4]
   132e8:	e59d1008 	ldr	r1, [sp, #8]
   132ec:	e59d200c 	ldr	r2, [sp, #12]
   132f0:	e2403b37 	sub	r3, r0, #56320	; 0xdc00
   132f4:	e153000b 	cmp	r3, fp
   132f8:	9a00003c 	bls	133f0 <parse_string.isra.0+0x2ec>
   132fc:	e5d5400c 	ldrb	r4, [r5, #12]
   13300:	ea000002 	b	13310 <parse_string.isra.0+0x20c>
			{
				case 'b': *ptr2++='\b';	break;
				case 'f': *ptr2++='\f';	break;
				case 'n': *ptr2++='\n';	break;
				case 'r': *ptr2++='\r';	break;
				case 't': *ptr2++='\t';	break;
   13304:	e5c6c000 	strb	ip, [r6]
   13308:	e5d54002 	ldrb	r4, [r5, #2]
   1330c:	e2866001 	add	r6, r6, #1
					}
					ptr2+=len;
					break;
				default:  *ptr2++=*ptr; break;
			}
			ptr++;
   13310:	e28e5001 	add	r5, lr, #1
   13314:	eaffffa2 	b	131a4 <parse_string.isra.0+0xa0>
			switch (*ptr)
			{
				case 'b': *ptr2++='\b';	break;
				case 'f': *ptr2++='\f';	break;
				case 'n': *ptr2++='\n';	break;
				case 'r': *ptr2++='\r';	break;
   13318:	e5c61000 	strb	r1, [r6]
   1331c:	e2866001 	add	r6, r6, #1
   13320:	e5d54002 	ldrb	r4, [r5, #2]
   13324:	eafffff9 	b	13310 <parse_string.isra.0+0x20c>
			ptr++;
			switch (*ptr)
			{
				case 'b': *ptr2++='\b';	break;
				case 'f': *ptr2++='\f';	break;
				case 'n': *ptr2++='\n';	break;
   13328:	e5c62000 	strb	r2, [r6]
   1332c:	e2866001 	add	r6, r6, #1
   13330:	e5d54002 	ldrb	r4, [r5, #2]
   13334:	eafffff5 	b	13310 <parse_string.isra.0+0x20c>
		{
			ptr++;
			switch (*ptr)
			{
				case 'b': *ptr2++='\b';	break;
				case 'f': *ptr2++='\f';	break;
   13338:	e3a0300c 	mov	r3, #12
   1333c:	e5c63000 	strb	r3, [r6]
   13340:	e2866001 	add	r6, r6, #1
   13344:	e5d54002 	ldrb	r4, [r5, #2]
   13348:	eafffff0 	b	13310 <parse_string.isra.0+0x20c>
		else
		{
			ptr++;
			switch (*ptr)
			{
				case 'b': *ptr2++='\b';	break;
   1334c:	e3a03008 	mov	r3, #8
   13350:	e5c63000 	strb	r3, [r6]
   13354:	e2866001 	add	r6, r6, #1
   13358:	e5d54002 	ldrb	r4, [r5, #2]
   1335c:	eaffffeb 	b	13310 <parse_string.isra.0+0x20c>
						case 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
						case 1: *--ptr2 =(uc | firstByteMark[len]);
					}
					ptr2+=len;
					break;
				default:  *ptr2++=*ptr; break;
   13360:	e5c60000 	strb	r0, [r6]
   13364:	e2866001 	add	r6, r6, #1
   13368:	e5d54002 	ldrb	r4, [r5, #2]
   1336c:	eaffffe7 	b	13310 <parse_string.isra.0+0x20c>
/* Parse the input text into an unescaped cstring, and populate item. */
static const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
static const char *parse_string(cJSON *item,const char *str)
{
	const char *ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;
	if (*str!='\"') {ep=str;return 0;}	/* not a string! */
   13370:	e59f30f8 	ldr	r3, [pc, #248]	; 13470 <parse_string.isra.0+0x36c>
   13374:	e3a00000 	mov	r0, #0
   13378:	e08f3003 	add	r3, pc, r3
   1337c:	e5832000 	str	r2, [r3]
	*ptr2=0;
	if (*ptr=='\"') ptr++;
	item->valuestring=out;
	item->type=cJSON_String;
	return ptr;
}
   13380:	e28dd014 	add	sp, sp, #20
   13384:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
   13388:	e5d54006 	ldrb	r4, [r5, #6]
   1338c:	eaffffdf 	b	13310 <parse_string.isra.0+0x20c>
						uc2=parse_hex4(ptr+3);ptr+=6;
						if (uc2<0xDC00 || uc2>0xDFFF)		break;	/* invalid second-half of surrogate.	*/
						uc=0x10000 + (((uc&0x3FF)<<10) | (uc2&0x3FF));
					}

					len=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len;
   13390:	e35a007f 	cmp	sl, #127	; 0x7f
   13394:	92865001 	addls	r5, r6, #1
   13398:	93a00001 	movls	r0, #1
   1339c:	8a000006 	bhi	133bc <parse_string.isra.0+0x2b8>
					
					switch (len) {
						case 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
						case 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
						case 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
						case 1: *--ptr2 =(uc | firstByteMark[len]);
   133a0:	e59d4000 	ldr	r4, [sp]
					}
					ptr2+=len;
   133a4:	e0856003 	add	r6, r5, r3
					
					switch (len) {
						case 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
						case 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
						case 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
						case 1: *--ptr2 =(uc | firstByteMark[len]);
   133a8:	e7d44000 	ldrb	r4, [r4, r0]
   133ac:	e18aa004 	orr	sl, sl, r4
   133b0:	e545a001 	strb	sl, [r5, #-1]
   133b4:	e5de4001 	ldrb	r4, [lr, #1]
   133b8:	eaffffd4 	b	13310 <parse_string.isra.0+0x20c>
						uc2=parse_hex4(ptr+3);ptr+=6;
						if (uc2<0xDC00 || uc2>0xDFFF)		break;	/* invalid second-half of surrogate.	*/
						uc=0x10000 + (((uc&0x3FF)<<10) | (uc2&0x3FF));
					}

					len=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len;
   133bc:	e59f30b0 	ldr	r3, [pc, #176]	; 13474 <parse_string.isra.0+0x370>
   133c0:	e15a0003 	cmp	sl, r3
   133c4:	8a00000e 	bhi	13404 <parse_string.isra.0+0x300>
   133c8:	e2866002 	add	r6, r6, #2
   133cc:	e3a03001 	mov	r3, #1
   133d0:	e3a00002 	mov	r0, #2
					
					switch (len) {
						case 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
						case 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
						case 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
   133d4:	e20a403f 	and	r4, sl, #63	; 0x3f
   133d8:	e1e04c84 	mvn	r4, r4, lsl #25
   133dc:	e1e04ca4 	mvn	r4, r4, lsr #25
   133e0:	e1a0a32a 	lsr	sl, sl, #6
   133e4:	e2465001 	sub	r5, r6, #1
   133e8:	e5464001 	strb	r4, [r6, #-1]
   133ec:	eaffffeb 	b	133a0 <parse_string.isra.0+0x29c>
					if (uc>=0xD800 && uc<=0xDBFF)	/* UTF16 surrogate pairs.	*/
					{
						if (ptr[1]!='\\' || ptr[2]!='u')	break;	/* missing second-half of surrogate.	*/
						uc2=parse_hex4(ptr+3);ptr+=6;
						if (uc2<0xDC00 || uc2>0xDFFF)		break;	/* invalid second-half of surrogate.	*/
						uc=0x10000 + (((uc&0x3FF)<<10) | (uc2&0x3FF));
   133f0:	e1a0ab0a 	lsl	sl, sl, #22
   133f4:	e1a0562a 	lsr	r5, sl, #12
   133f8:	e1a00b00 	lsl	r0, r0, #22
   133fc:	e185ab20 	orr	sl, r5, r0, lsr #22
   13400:	e28aa801 	add	sl, sl, #65536	; 0x10000
					}

					len=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len;
   13404:	e59f306c 	ldr	r3, [pc, #108]	; 13478 <parse_string.isra.0+0x374>
   13408:	e15a0003 	cmp	sl, r3
   1340c:	8a000009 	bhi	13438 <parse_string.isra.0+0x334>
   13410:	e2865003 	add	r5, r6, #3
   13414:	e3a03002 	mov	r3, #2
   13418:	e3a00003 	mov	r0, #3
					
					switch (len) {
						case 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
						case 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
   1341c:	e20a403f 	and	r4, sl, #63	; 0x3f
   13420:	e1e04c84 	mvn	r4, r4, lsl #25
   13424:	e1e04ca4 	mvn	r4, r4, lsr #25
   13428:	e1a0a32a 	lsr	sl, sl, #6
   1342c:	e2456001 	sub	r6, r5, #1
   13430:	e5454001 	strb	r4, [r5, #-1]
   13434:	eaffffe6 	b	133d4 <parse_string.isra.0+0x2d0>
					}

					len=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len;
					
					switch (len) {
						case 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
   13438:	e20a303f 	and	r3, sl, #63	; 0x3f
   1343c:	e1e03c83 	mvn	r3, r3, lsl #25
   13440:	e1e03ca3 	mvn	r3, r3, lsr #25
   13444:	e5c63003 	strb	r3, [r6, #3]
   13448:	e2865003 	add	r5, r6, #3
   1344c:	e1a0a32a 	lsr	sl, sl, #6
   13450:	e3a03003 	mov	r3, #3
						uc2=parse_hex4(ptr+3);ptr+=6;
						if (uc2<0xDC00 || uc2>0xDFFF)		break;	/* invalid second-half of surrogate.	*/
						uc=0x10000 + (((uc&0x3FF)<<10) | (uc2&0x3FF));
					}

					len=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len;
   13454:	e3a00004 	mov	r0, #4
   13458:	eaffffef 	b	1341c <parse_string.isra.0+0x318>
	if (*str!='\"') {ep=str;return 0;}	/* not a string! */
	
	while (*ptr!='\"' && *ptr && ++len) if (*ptr++ == '\\') ptr++;	/* Skip escaped quotes. */
	
	out=(char*)cJSON_malloc(len+1);	/* This is how long we need for the string, roughly. */
	if (!out) return 0;
   1345c:	e1a00009 	mov	r0, r9
   13460:	eaffff7d 	b	1325c <parse_string.isra.0+0x158>
   13464:	00010e9c 	.word	0x00010e9c
   13468:	0000e85c 	.word	0x0000e85c
   1346c:	000003ff 	.word	0x000003ff
   13470:	000134a4 	.word	0x000134a4
   13474:	000007ff 	.word	0x000007ff
   13478:	0000ffff 	.word	0x0000ffff

0001347c <parse_value>:
}


/* Parser core - when encountering text, process appropriately. */
static const char *parse_value(cJSON *item,const char *value)
{
   1347c:	e92d4ff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!value)						return 0;	/* Fail on null. */
   13480:	e251a000 	subs	sl, r1, #0
   13484:	0a00006c 	beq	1363c <parse_value+0x1c0>
	if (!strncmp(value,"null",4))	{ item->type=cJSON_NULL;  return value+4; }
   13488:	e59f1824 	ldr	r1, [pc, #2084]	; 13cb4 <parse_value+0x838>
   1348c:	e1a0b000 	mov	fp, r0
   13490:	e08f1001 	add	r1, pc, r1
   13494:	e1a0000a 	mov	r0, sl
   13498:	e3a02004 	mov	r2, #4
   1349c:	ebffc7c5 	bl	53b8 <strncmp@plt>
   134a0:	e3500000 	cmp	r0, #0
   134a4:	0a00003c 	beq	1359c <parse_value+0x120>
	if (!strncmp(value,"false",5))	{ item->type=cJSON_False; return value+5; }
   134a8:	e59f1808 	ldr	r1, [pc, #2056]	; 13cb8 <parse_value+0x83c>
   134ac:	e1a0000a 	mov	r0, sl
   134b0:	e08f1001 	add	r1, pc, r1
   134b4:	e3a02005 	mov	r2, #5
   134b8:	ebffc7be 	bl	53b8 <strncmp@plt>
   134bc:	e3500000 	cmp	r0, #0
   134c0:	058b000c 	streq	r0, [fp, #12]
   134c4:	028a3005 	addeq	r3, sl, #5
   134c8:	0a000031 	beq	13594 <parse_value+0x118>
	if (!strncmp(value,"true",4))	{ item->type=cJSON_True; item->valueint=1;	return value+4; }
   134cc:	e59f17e8 	ldr	r1, [pc, #2024]	; 13cbc <parse_value+0x840>
   134d0:	e1a0000a 	mov	r0, sl
   134d4:	e08f1001 	add	r1, pc, r1
   134d8:	e3a02004 	mov	r2, #4
   134dc:	ebffc7b5 	bl	53b8 <strncmp@plt>
   134e0:	e3500000 	cmp	r0, #0
   134e4:	0a000057 	beq	13648 <parse_value+0x1cc>
	if (*value=='\"')				{ return parse_string(item,value); }
   134e8:	e5da0000 	ldrb	r0, [sl]
   134ec:	e3500022 	cmp	r0, #34	; 0x22
   134f0:	0a00013f 	beq	139f4 <parse_value+0x578>
	if (*value=='-' || (*value>='0' && *value<='9'))	{ return parse_number(item,value); }
   134f4:	e240202d 	sub	r2, r0, #45	; 0x2d
   134f8:	e16f2f12 	clz	r2, r2
   134fc:	e2403030 	sub	r3, r0, #48	; 0x30
   13500:	e1a022a2 	lsr	r2, r2, #5
   13504:	e3530009 	cmp	r3, #9
   13508:	81a03002 	movhi	r3, r2
   1350c:	93823001 	orrls	r3, r2, #1
   13510:	e3530000 	cmp	r3, #0
   13514:	1a000055 	bne	13670 <parse_value+0x1f4>
	if (*value=='[')				{ return parse_array(item,value); }
   13518:	e350005b 	cmp	r0, #91	; 0x5b
   1351c:	0a000167 	beq	13ac0 <parse_value+0x644>
	if (*value=='{')				{ return parse_object(item,value); }
   13520:	e350007b 	cmp	r0, #123	; 0x7b
   13524:	1a00004d 	bne	13660 <parse_value+0x1e4>
static const char *parse_object(cJSON *item,const char *value)
{
	cJSON *child;
	if (*value!='{')	{ep=value;return 0;}	/* not an object! */
	
	item->type=cJSON_Object;
   13528:	e3a03006 	mov	r3, #6
static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);
static const char *parse_object(cJSON *item,const char *value);
static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);

/* Utility to jump whitespace and cr/lf */
static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}
   1352c:	e29a6001 	adds	r6, sl, #1
static const char *parse_object(cJSON *item,const char *value)
{
	cJSON *child;
	if (*value!='{')	{ep=value;return 0;}	/* not an object! */
	
	item->type=cJSON_Object;
   13530:	e58b300c 	str	r3, [fp, #12]
static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);
static const char *parse_object(cJSON *item,const char *value);
static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);

/* Utility to jump whitespace and cr/lf */
static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}
   13534:	0a00000c 	beq	1356c <parse_value+0xf0>
   13538:	e5da3001 	ldrb	r3, [sl, #1]
   1353c:	e2432001 	sub	r2, r3, #1
   13540:	e352001f 	cmp	r2, #31
   13544:	8a000019 	bhi	135b0 <parse_value+0x134>
   13548:	e28aa002 	add	sl, sl, #2
   1354c:	ea000004 	b	13564 <parse_value+0xe8>
   13550:	e5da3000 	ldrb	r3, [sl]
   13554:	e286a001 	add	sl, r6, #1
   13558:	e2432001 	sub	r2, r3, #1
   1355c:	e352001f 	cmp	r2, #31
   13560:	8a000012 	bhi	135b0 <parse_value+0x134>
   13564:	e25a6000 	subs	r6, sl, #0
   13568:	1afffff8 	bne	13550 <parse_value+0xd4>
	cJSON *child;
	if (*value!='{')	{ep=value;return 0;}	/* not an object! */
	
	item->type=cJSON_Object;
	value=skip(value+1);
	if (*value=='}') return value+1;	/* empty array. */
   1356c:	e3a03000 	mov	r3, #0
   13570:	e5d33000 	ldrb	r3, [r3]
   13574:	e7f000f0 	udf	#0
	child->string=child->valuestring;child->valuestring=0;
	if (*value!=':') {ep=value;return 0;}	/* fail! */
	value=skip(parse_value(child,skip(value+1)));	/* skip any spacing, get the value. */
	if (!value) return 0;
	
	while (*value==',')
   13578:	e352002c 	cmp	r2, #44	; 0x2c
   1357c:	e1a0a006 	mov	sl, r6
   13580:	0a0000ca 	beq	138b0 <parse_value+0x434>
   13584:	e1a03002 	mov	r3, r2
		value=skip(parse_value(child,skip(value+1)));	/* skip any spacing, get the value. */
		if (!value) return 0;
		
	}
	
	if (*value=='}') return value+1;	/* end of array */
   13588:	e353007d 	cmp	r3, #125	; 0x7d
   1358c:	1a0001c3 	bne	13ca0 <parse_value+0x824>
   13590:	e2843001 	add	r3, r4, #1
	if (*value=='-' || (*value>='0' && *value<='9'))	{ return parse_number(item,value); }
	if (*value=='[')				{ return parse_array(item,value); }
	if (*value=='{')				{ return parse_object(item,value); }

	ep=value;return 0;	/* failure. */
}
   13594:	e1a00003 	mov	r0, r3
   13598:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

/* Parser core - when encountering text, process appropriately. */
static const char *parse_value(cJSON *item,const char *value)
{
	if (!value)						return 0;	/* Fail on null. */
	if (!strncmp(value,"null",4))	{ item->type=cJSON_NULL;  return value+4; }
   1359c:	e3a02002 	mov	r2, #2
   135a0:	e28a3004 	add	r3, sl, #4
   135a4:	e58b200c 	str	r2, [fp, #12]
	if (*value=='-' || (*value>='0' && *value<='9'))	{ return parse_number(item,value); }
	if (*value=='[')				{ return parse_array(item,value); }
	if (*value=='{')				{ return parse_object(item,value); }

	ep=value;return 0;	/* failure. */
}
   135a8:	e1a00003 	mov	r0, r3
   135ac:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	cJSON *child;
	if (*value!='{')	{ep=value;return 0;}	/* not an object! */
	
	item->type=cJSON_Object;
	value=skip(value+1);
	if (*value=='}') return value+1;	/* empty array. */
   135b0:	e353007d 	cmp	r3, #125	; 0x7d
   135b4:	0a00008f 	beq	137f8 <parse_value+0x37c>
	
	item->child=child=cJSON_New_Item();
   135b8:	ebfffd0a 	bl	129e8 <cJSON_New_Item>
	if (!item->child) return 0;
   135bc:	e3500000 	cmp	r0, #0
	
	item->type=cJSON_Object;
	value=skip(value+1);
	if (*value=='}') return value+1;	/* empty array. */
	
	item->child=child=cJSON_New_Item();
   135c0:	e1a0a000 	mov	sl, r0
   135c4:	e58b0008 	str	r0, [fp, #8]
	if (!item->child) return 0;
   135c8:	0a00001b 	beq	1363c <parse_value+0x1c0>
static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);
static const char *parse_object(cJSON *item,const char *value);
static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);

/* Utility to jump whitespace and cr/lf */
static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}
   135cc:	e5d63000 	ldrb	r3, [r6]
   135d0:	e1a02006 	mov	r2, r6
   135d4:	e2433001 	sub	r3, r3, #1
   135d8:	e353001f 	cmp	r3, #31
   135dc:	e2866001 	add	r6, r6, #1
   135e0:	8a000002 	bhi	135f0 <parse_value+0x174>
   135e4:	e3560000 	cmp	r6, #0
   135e8:	1afffff7 	bne	135cc <parse_value+0x150>
   135ec:	e1a02006 	mov	r2, r6
	value=skip(value+1);
	if (*value=='}') return value+1;	/* empty array. */
	
	item->child=child=cJSON_New_Item();
	if (!item->child) return 0;
	value=skip(parse_string(child,skip(value)));
   135f0:	e28a000c 	add	r0, sl, #12
   135f4:	e28a1010 	add	r1, sl, #16
   135f8:	ebfffec1 	bl	13104 <parse_string.isra.0>
static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);
static const char *parse_object(cJSON *item,const char *value);
static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);

/* Utility to jump whitespace and cr/lf */
static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}
   135fc:	e3500000 	cmp	r0, #0
   13600:	0a00000d 	beq	1363c <parse_value+0x1c0>
   13604:	e5d03000 	ldrb	r3, [r0]
   13608:	e2433001 	sub	r3, r3, #1
   1360c:	e353001f 	cmp	r3, #31
   13610:	8a00007a 	bhi	13800 <parse_value+0x384>
   13614:	e2803001 	add	r3, r0, #1
   13618:	ea000004 	b	13630 <parse_value+0x1b4>
   1361c:	e5d32000 	ldrb	r2, [r3]
   13620:	e2833001 	add	r3, r3, #1
   13624:	e2422001 	sub	r2, r2, #1
   13628:	e352001f 	cmp	r2, #31
   1362c:	8a000073 	bhi	13800 <parse_value+0x384>
   13630:	e3530000 	cmp	r3, #0
   13634:	e1a00003 	mov	r0, r3
   13638:	1afffff7 	bne	1361c <parse_value+0x1a0>


/* Parser core - when encountering text, process appropriately. */
static const char *parse_value(cJSON *item,const char *value)
{
	if (!value)						return 0;	/* Fail on null. */
   1363c:	e3a03000 	mov	r3, #0
	if (*value=='-' || (*value>='0' && *value<='9'))	{ return parse_number(item,value); }
	if (*value=='[')				{ return parse_array(item,value); }
	if (*value=='{')				{ return parse_object(item,value); }

	ep=value;return 0;	/* failure. */
}
   13640:	e1a00003 	mov	r0, r3
   13644:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
static const char *parse_value(cJSON *item,const char *value)
{
	if (!value)						return 0;	/* Fail on null. */
	if (!strncmp(value,"null",4))	{ item->type=cJSON_NULL;  return value+4; }
	if (!strncmp(value,"false",5))	{ item->type=cJSON_False; return value+5; }
	if (!strncmp(value,"true",4))	{ item->type=cJSON_True; item->valueint=1;	return value+4; }
   13648:	e3a02001 	mov	r2, #1
   1364c:	e28a3004 	add	r3, sl, #4
   13650:	e58b200c 	str	r2, [fp, #12]
   13654:	e58b2014 	str	r2, [fp, #20]
	if (*value=='-' || (*value>='0' && *value<='9'))	{ return parse_number(item,value); }
	if (*value=='[')				{ return parse_array(item,value); }
	if (*value=='{')				{ return parse_object(item,value); }

	ep=value;return 0;	/* failure. */
}
   13658:	e1a00003 	mov	r0, r3
   1365c:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (*value=='\"')				{ return parse_string(item,value); }
	if (*value=='-' || (*value>='0' && *value<='9'))	{ return parse_number(item,value); }
	if (*value=='[')				{ return parse_array(item,value); }
	if (*value=='{')				{ return parse_object(item,value); }

	ep=value;return 0;	/* failure. */
   13660:	e59f2658 	ldr	r2, [pc, #1624]	; 13cc0 <parse_value+0x844>
   13664:	e08f2002 	add	r2, pc, r2
   13668:	e582a000 	str	sl, [r2]
   1366c:	eaffffc8 	b	13594 <parse_value+0x118>
/* Parse the input text to generate a number, and populate the result into item. */
static const char *parse_number(cJSON *item,const char *num)
{
	double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;

	if (*num=='-') sign=-1,num++;	/* Has sign? */
   13670:	e3520000 	cmp	r2, #0
   13674:	15da0001 	ldrbne	r0, [sl, #1]
   13678:	13a08000 	movne	r8, #0
   1367c:	159f9640 	ldrne	r9, [pc, #1600]	; 13cc4 <parse_value+0x848>
   13680:	128aa001 	addne	sl, sl, #1
}

/* Parse the input text to generate a number, and populate the result into item. */
static const char *parse_number(cJSON *item,const char *num)
{
	double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;
   13684:	03a08000 	moveq	r8, #0
   13688:	059f9638 	ldreq	r9, [pc, #1592]	; 13cc8 <parse_value+0x84c>

	if (*num=='-') sign=-1,num++;	/* Has sign? */
	if (*num=='0') num++;			/* is zero */
   1368c:	e3500030 	cmp	r0, #48	; 0x30
   13690:	05da0001 	ldrbeq	r0, [sl, #1]
   13694:	028aa001 	addeq	sl, sl, #1
	if (*num>='1' && *num<='9')	do	n=(n*10.0)+(*num++ -'0');	while (*num>='0' && *num<='9');	/* Number? */
   13698:	e2403031 	sub	r3, r0, #49	; 0x31
   1369c:	e3530008 	cmp	r3, #8
   136a0:	e3a04000 	mov	r4, #0
   136a4:	e3a05000 	mov	r5, #0
   136a8:	9a00003c 	bls	137a0 <parse_value+0x324>
	if (*num=='.' && num[1]>='0' && num[1]<='9') {num++;		do	n=(n*10.0)+(*num++ -'0'),scale--; while (*num>='0' && *num<='9');}	/* Fractional part? */
   136ac:	e350002e 	cmp	r0, #46	; 0x2e
}

/* Parse the input text to generate a number, and populate the result into item. */
static const char *parse_number(cJSON *item,const char *num)
{
	double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;
   136b0:	13a06000 	movne	r6, #0
   136b4:	13a07000 	movne	r7, #0

	if (*num=='-') sign=-1,num++;	/* Has sign? */
	if (*num=='0') num++;			/* is zero */
	if (*num>='1' && *num<='9')	do	n=(n*10.0)+(*num++ -'0');	while (*num>='0' && *num<='9');	/* Number? */
	if (*num=='.' && num[1]>='0' && num[1]<='9') {num++;		do	n=(n*10.0)+(*num++ -'0'),scale--; while (*num>='0' && *num<='9');}	/* Fractional part? */
   136b8:	0a0000da 	beq	13a28 <parse_value+0x5ac>
	if (*num=='e' || *num=='E')		/* Exponent? */
   136bc:	e20000df 	and	r0, r0, #223	; 0xdf
   136c0:	e3500045 	cmp	r0, #69	; 0x45
   136c4:	1a0000cf 	bne	13a08 <parse_value+0x58c>
	{	num++;if (*num=='+') num++;	else if (*num=='-') signsubscale=-1,num++;		/* With sign? */
   136c8:	e5da3001 	ldrb	r3, [sl, #1]
   136cc:	e353002b 	cmp	r3, #43	; 0x2b
   136d0:	0a000132 	beq	13ba0 <parse_value+0x724>
   136d4:	e353002d 	cmp	r3, #45	; 0x2d
   136d8:	05da3002 	ldrbeq	r3, [sl, #2]
   136dc:	128aa001 	addne	sl, sl, #1
}

/* Parse the input text to generate a number, and populate the result into item. */
static const char *parse_number(cJSON *item,const char *num)
{
	double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;
   136e0:	13a00001 	movne	r0, #1
	if (*num=='-') sign=-1,num++;	/* Has sign? */
	if (*num=='0') num++;			/* is zero */
	if (*num>='1' && *num<='9')	do	n=(n*10.0)+(*num++ -'0');	while (*num>='0' && *num<='9');	/* Number? */
	if (*num=='.' && num[1]>='0' && num[1]<='9') {num++;		do	n=(n*10.0)+(*num++ -'0'),scale--; while (*num>='0' && *num<='9');}	/* Fractional part? */
	if (*num=='e' || *num=='E')		/* Exponent? */
	{	num++;if (*num=='+') num++;	else if (*num=='-') signsubscale=-1,num++;		/* With sign? */
   136e4:	03e00000 	mvneq	r0, #0
   136e8:	028aa002 	addeq	sl, sl, #2
		while (*num>='0' && *num<='9') subscale=(subscale*10)+(*num++ - '0');	/* Number? */
   136ec:	e2432030 	sub	r2, r3, #48	; 0x30
   136f0:	e20230ff 	and	r3, r2, #255	; 0xff
   136f4:	e3530009 	cmp	r3, #9
   136f8:	93a03000 	movls	r3, #0
   136fc:	8a0000c1 	bhi	13a08 <parse_value+0x58c>
   13700:	e5fa1001 	ldrb	r1, [sl, #1]!
   13704:	e0833103 	add	r3, r3, r3, lsl #2
   13708:	e0823083 	add	r3, r2, r3, lsl #1
   1370c:	e2412030 	sub	r2, r1, #48	; 0x30
   13710:	e20210ff 	and	r1, r2, #255	; 0xff
   13714:	e3510009 	cmp	r1, #9
   13718:	9afffff8 	bls	13700 <parse_value+0x284>
   1371c:	e0000093 	mul	r0, r3, r0
   13720:	eb0021a9 	bl	1bdcc <__aeabi_i2d>
   13724:	e1a02000 	mov	r2, r0
   13728:	e1a03001 	mov	r3, r1
   1372c:	e1a00006 	mov	r0, r6
   13730:	e1a01007 	mov	r1, r7
   13734:	eb0020f0 	bl	1bafc <__adddf3>
   13738:	e1a06000 	mov	r6, r0
   1373c:	e1a07001 	mov	r7, r1
	}

	n=sign*n*pow(10.0,(scale+subscale*signsubscale));	/* number = +/- number.fraction * 10^+/- exponent */
   13740:	e1a02004 	mov	r2, r4
   13744:	e1a03005 	mov	r3, r5
   13748:	e1a00008 	mov	r0, r8
   1374c:	e1a01009 	mov	r1, r9
   13750:	eb0021d4 	bl	1bea8 <__aeabi_dmul>
   13754:	e1a02006 	mov	r2, r6
   13758:	e1a03007 	mov	r3, r7
   1375c:	e1a04000 	mov	r4, r0
   13760:	e1a05001 	mov	r5, r1
   13764:	e3a00000 	mov	r0, #0
   13768:	e59f155c 	ldr	r1, [pc, #1372]	; 13ccc <parse_value+0x850>
   1376c:	ebffc75f 	bl	54f0 <pow@plt>
   13770:	e1a02000 	mov	r2, r0
   13774:	e1a03001 	mov	r3, r1
   13778:	e1a00004 	mov	r0, r4
   1377c:	e1a01005 	mov	r1, r5
   13780:	eb0021c8 	bl	1bea8 <__aeabi_dmul>
	
	item->valuedouble=n;
   13784:	e1cb01f8 	strd	r0, [fp, #24]
	item->valueint=(int)n;
   13788:	eb00232d 	bl	1c444 <__aeabi_d2iz>
	item->type=cJSON_Number;
   1378c:	e3a02003 	mov	r2, #3
	if (!value)						return 0;	/* Fail on null. */
	if (!strncmp(value,"null",4))	{ item->type=cJSON_NULL;  return value+4; }
	if (!strncmp(value,"false",5))	{ item->type=cJSON_False; return value+5; }
	if (!strncmp(value,"true",4))	{ item->type=cJSON_True; item->valueint=1;	return value+4; }
	if (*value=='\"')				{ return parse_string(item,value); }
	if (*value=='-' || (*value>='0' && *value<='9'))	{ return parse_number(item,value); }
   13790:	e1a0300a 	mov	r3, sl

	n=sign*n*pow(10.0,(scale+subscale*signsubscale));	/* number = +/- number.fraction * 10^+/- exponent */
	
	item->valuedouble=n;
	item->valueint=(int)n;
	item->type=cJSON_Number;
   13794:	e58b200c 	str	r2, [fp, #12]
	}

	n=sign*n*pow(10.0,(scale+subscale*signsubscale));	/* number = +/- number.fraction * 10^+/- exponent */
	
	item->valuedouble=n;
	item->valueint=(int)n;
   13798:	e58b0014 	str	r0, [fp, #20]
   1379c:	eaffff7c 	b	13594 <parse_value+0x118>
{
	double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;

	if (*num=='-') sign=-1,num++;	/* Has sign? */
	if (*num=='0') num++;			/* is zero */
	if (*num>='1' && *num<='9')	do	n=(n*10.0)+(*num++ -'0');	while (*num>='0' && *num<='9');	/* Number? */
   137a0:	e3a02000 	mov	r2, #0
   137a4:	e59f3520 	ldr	r3, [pc, #1312]	; 13ccc <parse_value+0x850>
   137a8:	e1a00004 	mov	r0, r4
   137ac:	e1a01005 	mov	r1, r5
   137b0:	eb0021bc 	bl	1bea8 <__aeabi_dmul>
   137b4:	e1a04000 	mov	r4, r0
   137b8:	e4da0001 	ldrb	r0, [sl], #1
   137bc:	e1a05001 	mov	r5, r1
   137c0:	e2400030 	sub	r0, r0, #48	; 0x30
   137c4:	eb002180 	bl	1bdcc <__aeabi_i2d>
   137c8:	e1a03001 	mov	r3, r1
   137cc:	e1a02000 	mov	r2, r0
   137d0:	e1a01005 	mov	r1, r5
   137d4:	e1a00004 	mov	r0, r4
   137d8:	eb0020c7 	bl	1bafc <__adddf3>
   137dc:	e1a04000 	mov	r4, r0
   137e0:	e5da0000 	ldrb	r0, [sl]
   137e4:	e1a05001 	mov	r5, r1
   137e8:	e2403030 	sub	r3, r0, #48	; 0x30
   137ec:	e3530009 	cmp	r3, #9
   137f0:	9affffea 	bls	137a0 <parse_value+0x324>
   137f4:	eaffffac 	b	136ac <parse_value+0x230>
	cJSON *child;
	if (*value!='{')	{ep=value;return 0;}	/* not an object! */
	
	item->type=cJSON_Object;
	value=skip(value+1);
	if (*value=='}') return value+1;	/* empty array. */
   137f8:	e2863001 	add	r3, r6, #1
   137fc:	eaffff64 	b	13594 <parse_value+0x118>
	
	item->child=child=cJSON_New_Item();
	if (!item->child) return 0;
	value=skip(parse_string(child,skip(value)));
	if (!value) return 0;
	child->string=child->valuestring;child->valuestring=0;
   13800:	e59a2010 	ldr	r2, [sl, #16]
   13804:	e3a03000 	mov	r3, #0
   13808:	e58a2020 	str	r2, [sl, #32]
   1380c:	e58a3010 	str	r3, [sl, #16]
	if (*value!=':') {ep=value;return 0;}	/* fail! */
   13810:	e5d02000 	ldrb	r2, [r0]
   13814:	e352003a 	cmp	r2, #58	; 0x3a
   13818:	1a0000dc 	bne	13b90 <parse_value+0x714>
static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);
static const char *parse_object(cJSON *item,const char *value);
static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);

/* Utility to jump whitespace and cr/lf */
static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}
   1381c:	e2901001 	adds	r1, r0, #1
   13820:	0a00000d 	beq	1385c <parse_value+0x3e0>
   13824:	e5d03001 	ldrb	r3, [r0, #1]
   13828:	e2433001 	sub	r3, r3, #1
   1382c:	e353001f 	cmp	r3, #31
   13830:	8a000009 	bhi	1385c <parse_value+0x3e0>
   13834:	e2800002 	add	r0, r0, #2
   13838:	ea000004 	b	13850 <parse_value+0x3d4>
   1383c:	e5d03000 	ldrb	r3, [r0]
   13840:	e2800001 	add	r0, r0, #1
   13844:	e2433001 	sub	r3, r3, #1
   13848:	e353001f 	cmp	r3, #31
   1384c:	8a000002 	bhi	1385c <parse_value+0x3e0>
   13850:	e3500000 	cmp	r0, #0
   13854:	e1a01000 	mov	r1, r0
   13858:	1afffff7 	bne	1383c <parse_value+0x3c0>
	if (!item->child) return 0;
	value=skip(parse_string(child,skip(value)));
	if (!value) return 0;
	child->string=child->valuestring;child->valuestring=0;
	if (*value!=':') {ep=value;return 0;}	/* fail! */
	value=skip(parse_value(child,skip(value+1)));	/* skip any spacing, get the value. */
   1385c:	e1a0000a 	mov	r0, sl
   13860:	ebffff05 	bl	1347c <parse_value>
static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);
static const char *parse_object(cJSON *item,const char *value);
static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);

/* Utility to jump whitespace and cr/lf */
static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}
   13864:	e2504000 	subs	r4, r0, #0
   13868:	0affff73 	beq	1363c <parse_value+0x1c0>
   1386c:	e5d43000 	ldrb	r3, [r4]
   13870:	e2432001 	sub	r2, r3, #1
   13874:	e352001f 	cmp	r2, #31
   13878:	8a000009 	bhi	138a4 <parse_value+0x428>
   1387c:	e2842001 	add	r2, r4, #1
   13880:	ea000004 	b	13898 <parse_value+0x41c>
   13884:	e5d23000 	ldrb	r3, [r2]
   13888:	e2842001 	add	r2, r4, #1
   1388c:	e2431001 	sub	r1, r3, #1
   13890:	e351001f 	cmp	r1, #31
   13894:	8a000002 	bhi	138a4 <parse_value+0x428>
   13898:	e2524000 	subs	r4, r2, #0
   1389c:	1afffff8 	bne	13884 <parse_value+0x408>
   138a0:	eaffff65 	b	1363c <parse_value+0x1c0>
	child->string=child->valuestring;child->valuestring=0;
	if (*value!=':') {ep=value;return 0;}	/* fail! */
	value=skip(parse_value(child,skip(value+1)));	/* skip any spacing, get the value. */
	if (!value) return 0;
	
	while (*value==',')
   138a4:	e353002c 	cmp	r3, #44	; 0x2c
		cJSON *new_item;
		if (!(new_item=cJSON_New_Item()))	return 0; /* memory fail */
		child->next=new_item;new_item->prev=child;child=new_item;
		value=skip(parse_string(child,skip(value+1)));
		if (!value) return 0;
		child->string=child->valuestring;child->valuestring=0;
   138a8:	03a05000 	moveq	r5, #0
	child->string=child->valuestring;child->valuestring=0;
	if (*value!=':') {ep=value;return 0;}	/* fail! */
	value=skip(parse_value(child,skip(value+1)));	/* skip any spacing, get the value. */
	if (!value) return 0;
	
	while (*value==',')
   138ac:	1affff35 	bne	13588 <parse_value+0x10c>
	{
		cJSON *new_item;
		if (!(new_item=cJSON_New_Item()))	return 0; /* memory fail */
   138b0:	ebfffc4c 	bl	129e8 <cJSON_New_Item>
   138b4:	e2506000 	subs	r6, r0, #0
   138b8:	0affff5f 	beq	1363c <parse_value+0x1c0>
static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);
static const char *parse_object(cJSON *item,const char *value);
static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);

/* Utility to jump whitespace and cr/lf */
static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}
   138bc:	e2942001 	adds	r2, r4, #1
	
	while (*value==',')
	{
		cJSON *new_item;
		if (!(new_item=cJSON_New_Item()))	return 0; /* memory fail */
		child->next=new_item;new_item->prev=child;child=new_item;
   138c0:	e58a6000 	str	r6, [sl]
   138c4:	e586a004 	str	sl, [r6, #4]
static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);
static const char *parse_object(cJSON *item,const char *value);
static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);

/* Utility to jump whitespace and cr/lf */
static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}
   138c8:	0a00000d 	beq	13904 <parse_value+0x488>
   138cc:	e5d43001 	ldrb	r3, [r4, #1]
   138d0:	e2433001 	sub	r3, r3, #1
   138d4:	e353001f 	cmp	r3, #31
   138d8:	8a000009 	bhi	13904 <parse_value+0x488>
   138dc:	e2843002 	add	r3, r4, #2
   138e0:	ea000004 	b	138f8 <parse_value+0x47c>
   138e4:	e5d31000 	ldrb	r1, [r3]
   138e8:	e2833001 	add	r3, r3, #1
   138ec:	e2411001 	sub	r1, r1, #1
   138f0:	e351001f 	cmp	r1, #31
   138f4:	8a000002 	bhi	13904 <parse_value+0x488>
   138f8:	e3530000 	cmp	r3, #0
   138fc:	e1a02003 	mov	r2, r3
   13900:	1afffff7 	bne	138e4 <parse_value+0x468>
	while (*value==',')
	{
		cJSON *new_item;
		if (!(new_item=cJSON_New_Item()))	return 0; /* memory fail */
		child->next=new_item;new_item->prev=child;child=new_item;
		value=skip(parse_string(child,skip(value+1)));
   13904:	e286000c 	add	r0, r6, #12
   13908:	e2861010 	add	r1, r6, #16
   1390c:	ebfffdfc 	bl	13104 <parse_string.isra.0>
static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);
static const char *parse_object(cJSON *item,const char *value);
static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);

/* Utility to jump whitespace and cr/lf */
static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}
   13910:	e3500000 	cmp	r0, #0
   13914:	0affff48 	beq	1363c <parse_value+0x1c0>
   13918:	e5d03000 	ldrb	r3, [r0]
   1391c:	e2433001 	sub	r3, r3, #1
   13920:	e353001f 	cmp	r3, #31
   13924:	8a00000a 	bhi	13954 <parse_value+0x4d8>
   13928:	e2803001 	add	r3, r0, #1
   1392c:	ea000004 	b	13944 <parse_value+0x4c8>
   13930:	e5d32000 	ldrb	r2, [r3]
   13934:	e2833001 	add	r3, r3, #1
   13938:	e2422001 	sub	r2, r2, #1
   1393c:	e352001f 	cmp	r2, #31
   13940:	8a000003 	bhi	13954 <parse_value+0x4d8>
   13944:	e3530000 	cmp	r3, #0
   13948:	e1a00003 	mov	r0, r3
   1394c:	1afffff7 	bne	13930 <parse_value+0x4b4>
   13950:	eaffff39 	b	1363c <parse_value+0x1c0>
		cJSON *new_item;
		if (!(new_item=cJSON_New_Item()))	return 0; /* memory fail */
		child->next=new_item;new_item->prev=child;child=new_item;
		value=skip(parse_string(child,skip(value+1)));
		if (!value) return 0;
		child->string=child->valuestring;child->valuestring=0;
   13954:	e5963010 	ldr	r3, [r6, #16]
   13958:	e5863020 	str	r3, [r6, #32]
   1395c:	e5865010 	str	r5, [r6, #16]
		if (*value!=':') {ep=value;return 0;}	/* fail! */
   13960:	e5d03000 	ldrb	r3, [r0]
   13964:	e353003a 	cmp	r3, #58	; 0x3a
   13968:	1a0000c5 	bne	13c84 <parse_value+0x808>
static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);
static const char *parse_object(cJSON *item,const char *value);
static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);

/* Utility to jump whitespace and cr/lf */
static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}
   1396c:	e2901001 	adds	r1, r0, #1
   13970:	0a00000d 	beq	139ac <parse_value+0x530>
   13974:	e5d03001 	ldrb	r3, [r0, #1]
   13978:	e2433001 	sub	r3, r3, #1
   1397c:	e353001f 	cmp	r3, #31
   13980:	8a000009 	bhi	139ac <parse_value+0x530>
   13984:	e2800002 	add	r0, r0, #2
   13988:	ea000004 	b	139a0 <parse_value+0x524>
   1398c:	e5d03000 	ldrb	r3, [r0]
   13990:	e2800001 	add	r0, r0, #1
   13994:	e2433001 	sub	r3, r3, #1
   13998:	e353001f 	cmp	r3, #31
   1399c:	8a000002 	bhi	139ac <parse_value+0x530>
   139a0:	e3500000 	cmp	r0, #0
   139a4:	e1a01000 	mov	r1, r0
   139a8:	1afffff7 	bne	1398c <parse_value+0x510>
		child->next=new_item;new_item->prev=child;child=new_item;
		value=skip(parse_string(child,skip(value+1)));
		if (!value) return 0;
		child->string=child->valuestring;child->valuestring=0;
		if (*value!=':') {ep=value;return 0;}	/* fail! */
		value=skip(parse_value(child,skip(value+1)));	/* skip any spacing, get the value. */
   139ac:	e1a00006 	mov	r0, r6
   139b0:	ebfffeb1 	bl	1347c <parse_value>
static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);
static const char *parse_object(cJSON *item,const char *value);
static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);

/* Utility to jump whitespace and cr/lf */
static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}
   139b4:	e2504000 	subs	r4, r0, #0
   139b8:	0affff1f 	beq	1363c <parse_value+0x1c0>
   139bc:	e5d42000 	ldrb	r2, [r4]
   139c0:	e2423001 	sub	r3, r2, #1
   139c4:	e353001f 	cmp	r3, #31
   139c8:	8afffeea 	bhi	13578 <parse_value+0xfc>
   139cc:	e2843001 	add	r3, r4, #1
   139d0:	ea000004 	b	139e8 <parse_value+0x56c>
   139d4:	e5d32000 	ldrb	r2, [r3]
   139d8:	e2843001 	add	r3, r4, #1
   139dc:	e2421001 	sub	r1, r2, #1
   139e0:	e351001f 	cmp	r1, #31
   139e4:	8afffee3 	bhi	13578 <parse_value+0xfc>
   139e8:	e2534000 	subs	r4, r3, #0
   139ec:	1afffff8 	bne	139d4 <parse_value+0x558>
   139f0:	eaffff11 	b	1363c <parse_value+0x1c0>
{
	if (!value)						return 0;	/* Fail on null. */
	if (!strncmp(value,"null",4))	{ item->type=cJSON_NULL;  return value+4; }
	if (!strncmp(value,"false",5))	{ item->type=cJSON_False; return value+5; }
	if (!strncmp(value,"true",4))	{ item->type=cJSON_True; item->valueint=1;	return value+4; }
	if (*value=='\"')				{ return parse_string(item,value); }
   139f4:	e1a0200a 	mov	r2, sl
   139f8:	e28b000c 	add	r0, fp, #12
   139fc:	e28b1010 	add	r1, fp, #16
	if (*value=='-' || (*value>='0' && *value<='9'))	{ return parse_number(item,value); }
	if (*value=='[')				{ return parse_array(item,value); }
	if (*value=='{')				{ return parse_object(item,value); }

	ep=value;return 0;	/* failure. */
}
   13a00:	e8bd4ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
{
	if (!value)						return 0;	/* Fail on null. */
	if (!strncmp(value,"null",4))	{ item->type=cJSON_NULL;  return value+4; }
	if (!strncmp(value,"false",5))	{ item->type=cJSON_False; return value+5; }
	if (!strncmp(value,"true",4))	{ item->type=cJSON_True; item->valueint=1;	return value+4; }
	if (*value=='\"')				{ return parse_string(item,value); }
   13a04:	eafffdbe 	b	13104 <parse_string.isra.0>
   13a08:	e1a00006 	mov	r0, r6
   13a0c:	e1a01007 	mov	r1, r7
   13a10:	e3a02000 	mov	r2, #0
   13a14:	e3a03000 	mov	r3, #0
   13a18:	eb002037 	bl	1bafc <__adddf3>
   13a1c:	e1a06000 	mov	r6, r0
   13a20:	e1a07001 	mov	r7, r1
   13a24:	eaffff45 	b	13740 <parse_value+0x2c4>
	double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;

	if (*num=='-') sign=-1,num++;	/* Has sign? */
	if (*num=='0') num++;			/* is zero */
	if (*num>='1' && *num<='9')	do	n=(n*10.0)+(*num++ -'0');	while (*num>='0' && *num<='9');	/* Number? */
	if (*num=='.' && num[1]>='0' && num[1]<='9') {num++;		do	n=(n*10.0)+(*num++ -'0'),scale--; while (*num>='0' && *num<='9');}	/* Fractional part? */
   13a28:	e5da3001 	ldrb	r3, [sl, #1]
   13a2c:	e2433030 	sub	r3, r3, #48	; 0x30
   13a30:	e3530009 	cmp	r3, #9
   13a34:	83a06000 	movhi	r6, #0
   13a38:	83a07000 	movhi	r7, #0
   13a3c:	8affff3f 	bhi	13740 <parse_value+0x2c4>
   13a40:	e28aa001 	add	sl, sl, #1
}

/* Parse the input text to generate a number, and populate the result into item. */
static const char *parse_number(cJSON *item,const char *num)
{
	double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;
   13a44:	e3a06000 	mov	r6, #0
   13a48:	e3a07000 	mov	r7, #0

	if (*num=='-') sign=-1,num++;	/* Has sign? */
	if (*num=='0') num++;			/* is zero */
	if (*num>='1' && *num<='9')	do	n=(n*10.0)+(*num++ -'0');	while (*num>='0' && *num<='9');	/* Number? */
	if (*num=='.' && num[1]>='0' && num[1]<='9') {num++;		do	n=(n*10.0)+(*num++ -'0'),scale--; while (*num>='0' && *num<='9');}	/* Fractional part? */
   13a4c:	e3a02000 	mov	r2, #0
   13a50:	e59f3274 	ldr	r3, [pc, #628]	; 13ccc <parse_value+0x850>
   13a54:	e1a00004 	mov	r0, r4
   13a58:	e1a01005 	mov	r1, r5
   13a5c:	eb002111 	bl	1bea8 <__aeabi_dmul>
   13a60:	e1a04000 	mov	r4, r0
   13a64:	e4da0001 	ldrb	r0, [sl], #1
   13a68:	e1a05001 	mov	r5, r1
   13a6c:	e2400030 	sub	r0, r0, #48	; 0x30
   13a70:	eb0020d5 	bl	1bdcc <__aeabi_i2d>
   13a74:	e1a02000 	mov	r2, r0
   13a78:	e1a03001 	mov	r3, r1
   13a7c:	e1a00004 	mov	r0, r4
   13a80:	e1a01005 	mov	r1, r5
   13a84:	eb00201c 	bl	1bafc <__adddf3>
   13a88:	e59f3238 	ldr	r3, [pc, #568]	; 13cc8 <parse_value+0x84c>
   13a8c:	e3a02000 	mov	r2, #0
   13a90:	e1a04000 	mov	r4, r0
   13a94:	e1a05001 	mov	r5, r1
   13a98:	e1a00006 	mov	r0, r6
   13a9c:	e1a01007 	mov	r1, r7
   13aa0:	eb002014 	bl	1baf8 <__aeabi_dsub>
   13aa4:	e1a06000 	mov	r6, r0
   13aa8:	e5da0000 	ldrb	r0, [sl]
   13aac:	e1a07001 	mov	r7, r1
   13ab0:	e2403030 	sub	r3, r0, #48	; 0x30
   13ab4:	e3530009 	cmp	r3, #9
   13ab8:	9affffe3 	bls	13a4c <parse_value+0x5d0>
   13abc:	eafffefe 	b	136bc <parse_value+0x240>
static const char *parse_array(cJSON *item,const char *value)
{
	cJSON *child;
	if (*value!='[')	{ep=value;return 0;}	/* not an array! */

	item->type=cJSON_Array;
   13ac0:	e3a03005 	mov	r3, #5
static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);
static const char *parse_object(cJSON *item,const char *value);
static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);

/* Utility to jump whitespace and cr/lf */
static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}
   13ac4:	e29a6001 	adds	r6, sl, #1
static const char *parse_array(cJSON *item,const char *value)
{
	cJSON *child;
	if (*value!='[')	{ep=value;return 0;}	/* not an array! */

	item->type=cJSON_Array;
   13ac8:	e58b300c 	str	r3, [fp, #12]
static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);
static const char *parse_object(cJSON *item,const char *value);
static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);

/* Utility to jump whitespace and cr/lf */
static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}
   13acc:	0afffea6 	beq	1356c <parse_value+0xf0>
   13ad0:	e5da3001 	ldrb	r3, [sl, #1]
   13ad4:	e2432001 	sub	r2, r3, #1
   13ad8:	e352001f 	cmp	r2, #31
   13adc:	8a000009 	bhi	13b08 <parse_value+0x68c>
   13ae0:	e28aa002 	add	sl, sl, #2
   13ae4:	ea000004 	b	13afc <parse_value+0x680>
   13ae8:	e5da3000 	ldrb	r3, [sl]
   13aec:	e286a001 	add	sl, r6, #1
   13af0:	e2432001 	sub	r2, r3, #1
   13af4:	e352001f 	cmp	r2, #31
   13af8:	8a000002 	bhi	13b08 <parse_value+0x68c>
   13afc:	e25a6000 	subs	r6, sl, #0
   13b00:	1afffff8 	bne	13ae8 <parse_value+0x66c>
   13b04:	eafffe98 	b	1356c <parse_value+0xf0>
	cJSON *child;
	if (*value!='[')	{ep=value;return 0;}	/* not an array! */

	item->type=cJSON_Array;
	value=skip(value+1);
	if (*value==']') return value+1;	/* empty array. */
   13b08:	e353005d 	cmp	r3, #93	; 0x5d
   13b0c:	0affff39 	beq	137f8 <parse_value+0x37c>

	item->child=child=cJSON_New_Item();
   13b10:	ebfffbb4 	bl	129e8 <cJSON_New_Item>
	if (!item->child) return 0;		 /* memory fail */
   13b14:	e3500000 	cmp	r0, #0

	item->type=cJSON_Array;
	value=skip(value+1);
	if (*value==']') return value+1;	/* empty array. */

	item->child=child=cJSON_New_Item();
   13b18:	e1a07000 	mov	r7, r0
   13b1c:	e58b0008 	str	r0, [fp, #8]
	if (!item->child) return 0;		 /* memory fail */
   13b20:	1a000002 	bne	13b30 <parse_value+0x6b4>
   13b24:	eafffec4 	b	1363c <parse_value+0x1c0>
static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);
static const char *parse_object(cJSON *item,const char *value);
static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);

/* Utility to jump whitespace and cr/lf */
static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}
   13b28:	e3560000 	cmp	r6, #0
   13b2c:	0a000059 	beq	13c98 <parse_value+0x81c>
   13b30:	e5d63000 	ldrb	r3, [r6]
   13b34:	e1a01006 	mov	r1, r6
   13b38:	e2433001 	sub	r3, r3, #1
   13b3c:	e353001f 	cmp	r3, #31
   13b40:	e2866001 	add	r6, r6, #1
   13b44:	9afffff7 	bls	13b28 <parse_value+0x6ac>
	value=skip(value+1);
	if (*value==']') return value+1;	/* empty array. */

	item->child=child=cJSON_New_Item();
	if (!item->child) return 0;		 /* memory fail */
	value=skip(parse_value(child,skip(value)));	/* skip any spacing, get the value. */
   13b48:	e1a00007 	mov	r0, r7
   13b4c:	ebfffe4a 	bl	1347c <parse_value>
static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);
static const char *parse_object(cJSON *item,const char *value);
static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);

/* Utility to jump whitespace and cr/lf */
static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}
   13b50:	e2504000 	subs	r4, r0, #0
   13b54:	0afffeb8 	beq	1363c <parse_value+0x1c0>
   13b58:	e5d43000 	ldrb	r3, [r4]
   13b5c:	e2432001 	sub	r2, r3, #1
   13b60:	e352001f 	cmp	r2, #31
   13b64:	8a000011 	bhi	13bb0 <parse_value+0x734>
   13b68:	e2842001 	add	r2, r4, #1
   13b6c:	ea000004 	b	13b84 <parse_value+0x708>
   13b70:	e5d23000 	ldrb	r3, [r2]
   13b74:	e2842001 	add	r2, r4, #1
   13b78:	e2431001 	sub	r1, r3, #1
   13b7c:	e351001f 	cmp	r1, #31
   13b80:	8a00000a 	bhi	13bb0 <parse_value+0x734>
   13b84:	e2524000 	subs	r4, r2, #0
   13b88:	1afffff8 	bne	13b70 <parse_value+0x6f4>
   13b8c:	eafffeaa 	b	1363c <parse_value+0x1c0>
	item->child=child=cJSON_New_Item();
	if (!item->child) return 0;
	value=skip(parse_string(child,skip(value)));
	if (!value) return 0;
	child->string=child->valuestring;child->valuestring=0;
	if (*value!=':') {ep=value;return 0;}	/* fail! */
   13b90:	e59f2138 	ldr	r2, [pc, #312]	; 13cd0 <parse_value+0x854>
   13b94:	e08f2002 	add	r2, pc, r2
   13b98:	e5820000 	str	r0, [r2]
   13b9c:	eafffe7c 	b	13594 <parse_value+0x118>
   13ba0:	e5da3002 	ldrb	r3, [sl, #2]
}

/* Parse the input text to generate a number, and populate the result into item. */
static const char *parse_number(cJSON *item,const char *num)
{
	double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;
   13ba4:	e3a00001 	mov	r0, #1
	if (*num=='-') sign=-1,num++;	/* Has sign? */
	if (*num=='0') num++;			/* is zero */
	if (*num>='1' && *num<='9')	do	n=(n*10.0)+(*num++ -'0');	while (*num>='0' && *num<='9');	/* Number? */
	if (*num=='.' && num[1]>='0' && num[1]<='9') {num++;		do	n=(n*10.0)+(*num++ -'0'),scale--; while (*num>='0' && *num<='9');}	/* Fractional part? */
	if (*num=='e' || *num=='E')		/* Exponent? */
	{	num++;if (*num=='+') num++;	else if (*num=='-') signsubscale=-1,num++;		/* With sign? */
   13ba8:	e28aa002 	add	sl, sl, #2
   13bac:	eafffece 	b	136ec <parse_value+0x270>
	item->child=child=cJSON_New_Item();
	if (!item->child) return 0;		 /* memory fail */
	value=skip(parse_value(child,skip(value)));	/* skip any spacing, get the value. */
	if (!value) return 0;

	while (*value==',')
   13bb0:	e353002c 	cmp	r3, #44	; 0x2c
   13bb4:	1a00002b 	bne	13c68 <parse_value+0x7ec>
	{
		cJSON *new_item;
		if (!(new_item=cJSON_New_Item())) return 0; 	/* memory fail */
   13bb8:	ebfffb8a 	bl	129e8 <cJSON_New_Item>
   13bbc:	e2505000 	subs	r5, r0, #0
   13bc0:	0afffe9d 	beq	1363c <parse_value+0x1c0>
static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);
static const char *parse_object(cJSON *item,const char *value);
static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);

/* Utility to jump whitespace and cr/lf */
static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}
   13bc4:	e2941001 	adds	r1, r4, #1

	while (*value==',')
	{
		cJSON *new_item;
		if (!(new_item=cJSON_New_Item())) return 0; 	/* memory fail */
		child->next=new_item;new_item->prev=child;child=new_item;
   13bc8:	e5875000 	str	r5, [r7]
   13bcc:	e5857004 	str	r7, [r5, #4]
static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);
static const char *parse_object(cJSON *item,const char *value);
static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);

/* Utility to jump whitespace and cr/lf */
static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}
   13bd0:	0a00000d 	beq	13c0c <parse_value+0x790>
   13bd4:	e5d43001 	ldrb	r3, [r4, #1]
   13bd8:	e2433001 	sub	r3, r3, #1
   13bdc:	e353001f 	cmp	r3, #31
   13be0:	8a000009 	bhi	13c0c <parse_value+0x790>
   13be4:	e2842002 	add	r2, r4, #2
   13be8:	ea000004 	b	13c00 <parse_value+0x784>
   13bec:	e5d23000 	ldrb	r3, [r2]
   13bf0:	e2822001 	add	r2, r2, #1
   13bf4:	e2433001 	sub	r3, r3, #1
   13bf8:	e353001f 	cmp	r3, #31
   13bfc:	8a000002 	bhi	13c0c <parse_value+0x790>
   13c00:	e3520000 	cmp	r2, #0
   13c04:	e1a01002 	mov	r1, r2
   13c08:	1afffff7 	bne	13bec <parse_value+0x770>
	while (*value==',')
	{
		cJSON *new_item;
		if (!(new_item=cJSON_New_Item())) return 0; 	/* memory fail */
		child->next=new_item;new_item->prev=child;child=new_item;
		value=skip(parse_value(child,skip(value+1)));
   13c0c:	e1a00005 	mov	r0, r5
   13c10:	ebfffe19 	bl	1347c <parse_value>
static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);
static const char *parse_object(cJSON *item,const char *value);
static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);

/* Utility to jump whitespace and cr/lf */
static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}
   13c14:	e2504000 	subs	r4, r0, #0
   13c18:	0afffe87 	beq	1363c <parse_value+0x1c0>
   13c1c:	e5d43000 	ldrb	r3, [r4]
   13c20:	e2432001 	sub	r2, r3, #1
   13c24:	e352001f 	cmp	r2, #31
   13c28:	8a000009 	bhi	13c54 <parse_value+0x7d8>
   13c2c:	e2843001 	add	r3, r4, #1
   13c30:	ea000004 	b	13c48 <parse_value+0x7cc>
   13c34:	e5d31000 	ldrb	r1, [r3]
   13c38:	e2843001 	add	r3, r4, #1
   13c3c:	e2410001 	sub	r0, r1, #1
   13c40:	e350001f 	cmp	r0, #31
   13c44:	8a000003 	bhi	13c58 <parse_value+0x7dc>
   13c48:	e2534000 	subs	r4, r3, #0
   13c4c:	1afffff8 	bne	13c34 <parse_value+0x7b8>
   13c50:	eafffe79 	b	1363c <parse_value+0x1c0>
   13c54:	e1a01003 	mov	r1, r3
	item->child=child=cJSON_New_Item();
	if (!item->child) return 0;		 /* memory fail */
	value=skip(parse_value(child,skip(value)));	/* skip any spacing, get the value. */
	if (!value) return 0;

	while (*value==',')
   13c58:	e351002c 	cmp	r1, #44	; 0x2c
   13c5c:	e1a07005 	mov	r7, r5
   13c60:	0affffd4 	beq	13bb8 <parse_value+0x73c>
   13c64:	e1a03001 	mov	r3, r1
		value=skip(parse_value(child,skip(value+1)));
		
		if (!value) return 0;	/* memory fail */
	}

	if (*value==']') return value+1;	/* end of array */
   13c68:	e353005d 	cmp	r3, #93	; 0x5d
   13c6c:	0afffe47 	beq	13590 <parse_value+0x114>
	ep=value;return 0;	/* malformed. */
   13c70:	e59f205c 	ldr	r2, [pc, #92]	; 13cd4 <parse_value+0x858>
   13c74:	e3a03000 	mov	r3, #0
   13c78:	e08f2002 	add	r2, pc, r2
   13c7c:	e5824000 	str	r4, [r2]
   13c80:	eafffe43 	b	13594 <parse_value+0x118>
		if (!(new_item=cJSON_New_Item()))	return 0; /* memory fail */
		child->next=new_item;new_item->prev=child;child=new_item;
		value=skip(parse_string(child,skip(value+1)));
		if (!value) return 0;
		child->string=child->valuestring;child->valuestring=0;
		if (*value!=':') {ep=value;return 0;}	/* fail! */
   13c84:	e59f204c 	ldr	r2, [pc, #76]	; 13cd8 <parse_value+0x85c>
   13c88:	e3a03000 	mov	r3, #0
   13c8c:	e08f2002 	add	r2, pc, r2
   13c90:	e5820000 	str	r0, [r2]
   13c94:	eafffe3e 	b	13594 <parse_value+0x118>
static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);
static const char *parse_object(cJSON *item,const char *value);
static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);

/* Utility to jump whitespace and cr/lf */
static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}
   13c98:	e1a01006 	mov	r1, r6
   13c9c:	eaffffa9 	b	13b48 <parse_value+0x6cc>
		if (!value) return 0;
		
	}
	
	if (*value=='}') return value+1;	/* end of array */
	ep=value;return 0;	/* malformed. */
   13ca0:	e59f2034 	ldr	r2, [pc, #52]	; 13cdc <parse_value+0x860>
   13ca4:	e3a03000 	mov	r3, #0
   13ca8:	e08f2002 	add	r2, pc, r2
   13cac:	e5824000 	str	r4, [r2]
   13cb0:	eafffe37 	b	13594 <parse_value+0x118>
   13cb4:	0000d7e0 	.word	0x0000d7e0
   13cb8:	0000d7c8 	.word	0x0000d7c8
   13cbc:	0000b4ec 	.word	0x0000b4ec
   13cc0:	000131b8 	.word	0x000131b8
   13cc4:	bff00000 	.word	0xbff00000
   13cc8:	3ff00000 	.word	0x3ff00000
   13ccc:	40240000 	.word	0x40240000
   13cd0:	00012c88 	.word	0x00012c88
   13cd4:	00012ba4 	.word	0x00012ba4
   13cd8:	00012b90 	.word	0x00012b90
   13cdc:	00012b74 	.word	0x00012b74

00013ce0 <print_object.isra.5>:
}

/* Render an object to text. */
static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p)
   13ce0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
{
	char **entries=0,**names=0;
	char *out=0,*ptr,*ret,*str;int len=7,i=0,j;
	cJSON *child=item->child;
   13ce4:	e5908000 	ldr	r8, [r0]
	if (*value=='}') return value+1;	/* end of array */
	ep=value;return 0;	/* malformed. */
}

/* Render an object to text. */
static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p)
   13ce8:	e24dd02c 	sub	sp, sp, #44	; 0x2c
	char *out=0,*ptr,*ret,*str;int len=7,i=0,j;
	cJSON *child=item->child;
	int numentries=0,fail=0;
	size_t tmplen=0;
	/* Count the number of entries. */
	while (child) numentries++,child=child->next;
   13cec:	e3580000 	cmp	r8, #0
	if (*value=='}') return value+1;	/* end of array */
	ep=value;return 0;	/* malformed. */
}

/* Render an object to text. */
static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p)
   13cf0:	e1a07000 	mov	r7, r0
   13cf4:	e58d1000 	str	r1, [sp]
   13cf8:	e1a06002 	mov	r6, r2
   13cfc:	e1a0b003 	mov	fp, r3
	char *out=0,*ptr,*ret,*str;int len=7,i=0,j;
	cJSON *child=item->child;
	int numentries=0,fail=0;
	size_t tmplen=0;
	/* Count the number of entries. */
	while (child) numentries++,child=child->next;
   13d00:	0a000085 	beq	13f1c <print_object.isra.5+0x23c>
   13d04:	e3a04000 	mov	r4, #0
   13d08:	ea000000 	b	13d10 <print_object.isra.5+0x30>
   13d0c:	e1a04005 	mov	r4, r5
   13d10:	e5988000 	ldr	r8, [r8]
   13d14:	e2845001 	add	r5, r4, #1
   13d18:	e3580000 	cmp	r8, #0
   13d1c:	1afffffa 	bne	13d0c <print_object.isra.5+0x2c>
		ptr=out;*ptr++='{';
		if (fmt) {*ptr++='\n';for (i=0;i<depth-1;i++) *ptr++='\t';}
		*ptr++='}';*ptr++=0;
		return out;
	}
	if (p)
   13d20:	e35b0000 	cmp	fp, #0
   13d24:	0a0000c4 	beq	1403c <print_object.isra.5+0x35c>
	{
		/* Compose the output: */
		i=p->offset;
   13d28:	e59b3008 	ldr	r3, [fp, #8]
		len=fmt?2:1;	ptr=ensure(p,len+1);	if (!ptr) return 0;
   13d2c:	e3560000 	cmp	r6, #0
		return out;
	}
	if (p)
	{
		/* Compose the output: */
		i=p->offset;
   13d30:	e58d3004 	str	r3, [sp, #4]
		len=fmt?2:1;	ptr=ensure(p,len+1);	if (!ptr) return 0;
   13d34:	1a000099 	bne	13fa0 <print_object.isra.5+0x2c0>
   13d38:	e1a0000b 	mov	r0, fp
   13d3c:	e3a01002 	mov	r1, #2
   13d40:	ebfffb36 	bl	12a20 <ensure>
   13d44:	e3500000 	cmp	r0, #0
   13d48:	0a00012c 	beq	14200 <print_object.isra.5+0x520>
		*ptr++='{';	if (fmt) *ptr++='\n';	*ptr=0;	p->offset+=len;
   13d4c:	e3a0307b 	mov	r3, #123	; 0x7b
   13d50:	e5c06001 	strb	r6, [r0, #1]
   13d54:	e5c03000 	strb	r3, [r0]
   13d58:	e59b3008 	ldr	r3, [fp, #8]
		child=item->child;depth++;
   13d5c:	e5974000 	ldr	r4, [r7]
	if (p)
	{
		/* Compose the output: */
		i=p->offset;
		len=fmt?2:1;	ptr=ensure(p,len+1);	if (!ptr) return 0;
		*ptr++='{';	if (fmt) *ptr++='\n';	*ptr=0;	p->offset+=len;
   13d60:	e2833001 	add	r3, r3, #1
   13d64:	e58b3008 	str	r3, [fp, #8]
		child=item->child;depth++;
   13d68:	e59d3000 	ldr	r3, [sp]
		while (child)
   13d6c:	e3540000 	cmp	r4, #0
	{
		/* Compose the output: */
		i=p->offset;
		len=fmt?2:1;	ptr=ensure(p,len+1);	if (!ptr) return 0;
		*ptr++='{';	if (fmt) *ptr++='\n';	*ptr=0;	p->offset+=len;
		child=item->child;depth++;
   13d70:	e2837001 	add	r7, r3, #1
		while (child)
   13d74:	0a00012d 	beq	14230 <print_object.isra.5+0x550>
		{
			if (fmt)
			{
				ptr=ensure(p,depth);	if (!ptr) return 0;
				for (j=0;j<depth;j++) *ptr++='\t';
   13d78:	e3a05009 	mov	r5, #9
}

static int update(printbuffer *p)
{
	char *str;
	if (!p || !p->buffer) return 0;
   13d7c:	e3a08000 	mov	r8, #0
		len=fmt?2:1;	ptr=ensure(p,len+1);	if (!ptr) return 0;
		*ptr++='{';	if (fmt) *ptr++='\n';	*ptr=0;	p->offset+=len;
		child=item->child;depth++;
		while (child)
		{
			if (fmt)
   13d80:	e3560000 	cmp	r6, #0
   13d84:	0a000098 	beq	13fec <print_object.isra.5+0x30c>
			{
				ptr=ensure(p,depth);	if (!ptr) return 0;
   13d88:	e1a0000b 	mov	r0, fp
   13d8c:	e1a01007 	mov	r1, r7
   13d90:	ebfffb22 	bl	12a20 <ensure>
   13d94:	e3500000 	cmp	r0, #0
   13d98:	0a000118 	beq	14200 <print_object.isra.5+0x520>
				for (j=0;j<depth;j++) *ptr++='\t';
   13d9c:	e3570000 	cmp	r7, #0
   13da0:	c0803007 	addgt	r3, r0, r7
   13da4:	da000002 	ble	13db4 <print_object.isra.5+0xd4>
   13da8:	e4c05001 	strb	r5, [r0], #1
   13dac:	e1500003 	cmp	r0, r3
   13db0:	1afffffc 	bne	13da8 <print_object.isra.5+0xc8>
				p->offset+=depth;
   13db4:	e59b3008 	ldr	r3, [fp, #8]
			}
			print_string_ptr(child->string,p);
   13db8:	e5940020 	ldr	r0, [r4, #32]
		{
			if (fmt)
			{
				ptr=ensure(p,depth);	if (!ptr) return 0;
				for (j=0;j<depth;j++) *ptr++='\t';
				p->offset+=depth;
   13dbc:	e0833007 	add	r3, r3, r7
   13dc0:	e58b3008 	str	r3, [fp, #8]
			}
			print_string_ptr(child->string,p);
   13dc4:	e1a0100b 	mov	r1, fp
   13dc8:	ebfffc0a 	bl	12df8 <print_string_ptr>
}

static int update(printbuffer *p)
{
	char *str;
	if (!p || !p->buffer) return 0;
   13dcc:	e59b0000 	ldr	r0, [fp]
   13dd0:	e3500000 	cmp	r0, #0
   13dd4:	0a000003 	beq	13de8 <print_object.isra.5+0x108>
	str=p->buffer+p->offset;
   13dd8:	e59b9008 	ldr	r9, [fp, #8]
	return p->offset+strlen(str);
   13ddc:	e0800009 	add	r0, r0, r9
   13de0:	ebffc4c6 	bl	5100 <strlen@plt>
   13de4:	e0800009 	add	r0, r0, r9
				ptr=ensure(p,depth);	if (!ptr) return 0;
				for (j=0;j<depth;j++) *ptr++='\t';
				p->offset+=depth;
			}
			print_string_ptr(child->string,p);
			p->offset=update(p);
   13de8:	e58b0008 	str	r0, [fp, #8]
			
			len=fmt?2:1;
			ptr=ensure(p,len);	if (!ptr) return 0;
   13dec:	e3a01002 	mov	r1, #2
   13df0:	e1a0000b 	mov	r0, fp
   13df4:	ebfffb09 	bl	12a20 <ensure>
   13df8:	e3500000 	cmp	r0, #0
   13dfc:	0a0000ff 	beq	14200 <print_object.isra.5+0x520>
			*ptr++=':';if (fmt) *ptr++='\t';
   13e00:	e3a0303a 	mov	r3, #58	; 0x3a
				p->offset+=depth;
			}
			print_string_ptr(child->string,p);
			p->offset=update(p);
			
			len=fmt?2:1;
   13e04:	e3a02002 	mov	r2, #2
			ptr=ensure(p,len);	if (!ptr) return 0;
			*ptr++=':';if (fmt) *ptr++='\t';
   13e08:	e5c03000 	strb	r3, [r0]
   13e0c:	e5c05001 	strb	r5, [r0, #1]
			p->offset+=len;
   13e10:	e59b3008 	ldr	r3, [fp, #8]
			
			print_value(child,depth,fmt,p);
   13e14:	e1a00004 	mov	r0, r4
			p->offset=update(p);
			
			len=fmt?2:1;
			ptr=ensure(p,len);	if (!ptr) return 0;
			*ptr++=':';if (fmt) *ptr++='\t';
			p->offset+=len;
   13e18:	e0833002 	add	r3, r3, r2
   13e1c:	e58b3008 	str	r3, [fp, #8]
			
			print_value(child,depth,fmt,p);
   13e20:	e1a01007 	mov	r1, r7
   13e24:	e1a02006 	mov	r2, r6
   13e28:	e1a0300b 	mov	r3, fp
   13e2c:	eb0001a7 	bl	144d0 <print_value>
}

static int update(printbuffer *p)
{
	char *str;
	if (!p || !p->buffer) return 0;
   13e30:	e59b0000 	ldr	r0, [fp]
   13e34:	e3500000 	cmp	r0, #0
   13e38:	0a000003 	beq	13e4c <print_object.isra.5+0x16c>
	str=p->buffer+p->offset;
   13e3c:	e59ba008 	ldr	sl, [fp, #8]
	return p->offset+strlen(str);
   13e40:	e080000a 	add	r0, r0, sl
   13e44:	ebffc4ad 	bl	5100 <strlen@plt>
   13e48:	e080000a 	add	r0, r0, sl
			p->offset+=len;
			
			print_value(child,depth,fmt,p);
			p->offset=update(p);

			len=(fmt?1:0)+(child->next?1:0);
   13e4c:	e296a000 	adds	sl, r6, #0
   13e50:	e5949000 	ldr	r9, [r4]
   13e54:	13a0a001 	movne	sl, #1
   13e58:	e3590000 	cmp	r9, #0
   13e5c:	01a0900a 	moveq	r9, sl
   13e60:	128a9001 	addne	r9, sl, #1
			ptr=ensure(p,len);	if (!ptr) return 0;
			*ptr++=':';if (fmt) *ptr++='\t';
			p->offset+=len;
			
			print_value(child,depth,fmt,p);
			p->offset=update(p);
   13e64:	e58b0008 	str	r0, [fp, #8]

			len=(fmt?1:0)+(child->next?1:0);
			ptr=ensure(p,len+1); if (!ptr) return 0;
   13e68:	e2891001 	add	r1, r9, #1
   13e6c:	e1a0000b 	mov	r0, fp
   13e70:	ebfffaea 	bl	12a20 <ensure>
   13e74:	e3500000 	cmp	r0, #0
   13e78:	0a0000e0 	beq	14200 <print_object.isra.5+0x520>
			if (child->next) *ptr++=',';
   13e7c:	e5943000 	ldr	r3, [r4]
   13e80:	e3530000 	cmp	r3, #0
   13e84:	13a0302c 	movne	r3, #44	; 0x2c
   13e88:	15c03000 	strbne	r3, [r0]
   13e8c:	12800001 	addne	r0, r0, #1
			if (fmt) *ptr++='\n';*ptr=0;
   13e90:	e35a0000 	cmp	sl, #0
   13e94:	13a0300a 	movne	r3, #10
   13e98:	15c03000 	strbne	r3, [r0]
   13e9c:	12800001 	addne	r0, r0, #1
   13ea0:	e5c08000 	strb	r8, [r0]
			p->offset+=len;
   13ea4:	e59b3008 	ldr	r3, [fp, #8]
			child=child->next;
   13ea8:	e5944000 	ldr	r4, [r4]

			len=(fmt?1:0)+(child->next?1:0);
			ptr=ensure(p,len+1); if (!ptr) return 0;
			if (child->next) *ptr++=',';
			if (fmt) *ptr++='\n';*ptr=0;
			p->offset+=len;
   13eac:	e0839009 	add	r9, r3, r9
		/* Compose the output: */
		i=p->offset;
		len=fmt?2:1;	ptr=ensure(p,len+1);	if (!ptr) return 0;
		*ptr++='{';	if (fmt) *ptr++='\n';	*ptr=0;	p->offset+=len;
		child=item->child;depth++;
		while (child)
   13eb0:	e3540000 	cmp	r4, #0

			len=(fmt?1:0)+(child->next?1:0);
			ptr=ensure(p,len+1); if (!ptr) return 0;
			if (child->next) *ptr++=',';
			if (fmt) *ptr++='\n';*ptr=0;
			p->offset+=len;
   13eb4:	e58b9008 	str	r9, [fp, #8]
		/* Compose the output: */
		i=p->offset;
		len=fmt?2:1;	ptr=ensure(p,len+1);	if (!ptr) return 0;
		*ptr++='{';	if (fmt) *ptr++='\n';	*ptr=0;	p->offset+=len;
		child=item->child;depth++;
		while (child)
   13eb8:	1affffb0 	bne	13d80 <print_object.isra.5+0xa0>
			if (child->next) *ptr++=',';
			if (fmt) *ptr++='\n';*ptr=0;
			p->offset+=len;
			child=child->next;
		}
		ptr=ensure(p,fmt?(depth+1):2);	 if (!ptr) return 0;
   13ebc:	e3560000 	cmp	r6, #0
   13ec0:	0a0000da 	beq	14230 <print_object.isra.5+0x550>
   13ec4:	e59d4000 	ldr	r4, [sp]
   13ec8:	e1a0000b 	mov	r0, fp
   13ecc:	e2841002 	add	r1, r4, #2
   13ed0:	ebfffad2 	bl	12a20 <ensure>
   13ed4:	e2505000 	subs	r5, r0, #0
   13ed8:	0a0000c8 	beq	14200 <print_object.isra.5+0x520>
		if (fmt)	for (i=0;i<depth-1;i++) *ptr++='\t';
   13edc:	e3540000 	cmp	r4, #0
   13ee0:	da000162 	ble	14470 <print_object.isra.5+0x790>
   13ee4:	e1a00004 	mov	r0, r4
   13ee8:	e0856004 	add	r6, r5, r4
   13eec:	e3a03009 	mov	r3, #9
   13ef0:	e4c53001 	strb	r3, [r5], #1
   13ef4:	e1550006 	cmp	r5, r6
   13ef8:	1afffffc 	bne	13ef0 <print_object.isra.5+0x210>
		*ptr++='}';*ptr=0;
   13efc:	e3a0207d 	mov	r2, #125	; 0x7d
   13f00:	e3a03000 	mov	r3, #0
   13f04:	e5c62000 	strb	r2, [r6]
   13f08:	e5c63001 	strb	r3, [r6, #1]
		out=(p->buffer)+i;
   13f0c:	e59b4000 	ldr	r4, [fp]
   13f10:	e0840000 	add	r0, r4, r0
		cJSON_free(names);cJSON_free(entries);
		if (fmt) for (i=0;i<depth-1;i++) *ptr++='\t';
		*ptr++='}';*ptr++=0;
	}
	return out;	
}
   13f14:	e28dd02c 	add	sp, sp, #44	; 0x2c
   13f18:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
	/* Count the number of entries. */
	while (child) numentries++,child=child->next;
	/* Explicitly handle empty object case */
	if (!numentries)
	{
		if (p) out=ensure(p,fmt?depth+4:3);
   13f1c:	e3530000 	cmp	r3, #0
   13f20:	0a0000b9 	beq	1420c <print_object.isra.5+0x52c>
   13f24:	e3520000 	cmp	r2, #0
   13f28:	159d3000 	ldrne	r3, [sp]
   13f2c:	03a01003 	moveq	r1, #3
   13f30:	12831004 	addne	r1, r3, #4
   13f34:	e1a0000b 	mov	r0, fp
   13f38:	ebfffab8 	bl	12a20 <ensure>
		else	out=(char*)cJSON_malloc(fmt?depth+4:3);
		if (!out)	return 0;
   13f3c:	e3500000 	cmp	r0, #0
   13f40:	0a0000ae 	beq	14200 <print_object.isra.5+0x520>
		ptr=out;*ptr++='{';
   13f44:	e3a0307b 	mov	r3, #123	; 0x7b
		if (fmt) {*ptr++='\n';for (i=0;i<depth-1;i++) *ptr++='\t';}
   13f48:	e3560000 	cmp	r6, #0
	if (!numentries)
	{
		if (p) out=ensure(p,fmt?depth+4:3);
		else	out=(char*)cJSON_malloc(fmt?depth+4:3);
		if (!out)	return 0;
		ptr=out;*ptr++='{';
   13f4c:	e5c03000 	strb	r3, [r0]
   13f50:	02803001 	addeq	r3, r0, #1
		if (fmt) {*ptr++='\n';for (i=0;i<depth-1;i++) *ptr++='\t';}
   13f54:	0a00000b 	beq	13f88 <print_object.isra.5+0x2a8>
   13f58:	e59d2000 	ldr	r2, [sp]
   13f5c:	e3a0300a 	mov	r3, #10
   13f60:	e3520001 	cmp	r2, #1
   13f64:	e5c03001 	strb	r3, [r0, #1]
   13f68:	e2804002 	add	r4, r0, #2
   13f6c:	da0000b6 	ble	1424c <print_object.isra.5+0x56c>
   13f70:	e2423001 	sub	r3, r2, #1
   13f74:	e0843003 	add	r3, r4, r3
   13f78:	e3a02009 	mov	r2, #9
   13f7c:	e4c42001 	strb	r2, [r4], #1
   13f80:	e1540003 	cmp	r4, r3
   13f84:	1afffffc 	bne	13f7c <print_object.isra.5+0x29c>
		*ptr++='}';*ptr++=0;
   13f88:	e3a0107d 	mov	r1, #125	; 0x7d
   13f8c:	e3a02000 	mov	r2, #0
   13f90:	e5c31000 	strb	r1, [r3]
   13f94:	e5c32001 	strb	r2, [r3, #1]
		cJSON_free(names);cJSON_free(entries);
		if (fmt) for (i=0;i<depth-1;i++) *ptr++='\t';
		*ptr++='}';*ptr++=0;
	}
	return out;	
}
   13f98:	e28dd02c 	add	sp, sp, #44	; 0x2c
   13f9c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
	}
	if (p)
	{
		/* Compose the output: */
		i=p->offset;
		len=fmt?2:1;	ptr=ensure(p,len+1);	if (!ptr) return 0;
   13fa0:	e1a0000b 	mov	r0, fp
   13fa4:	e3a01003 	mov	r1, #3
   13fa8:	ebfffa9c 	bl	12a20 <ensure>
   13fac:	e3500000 	cmp	r0, #0
   13fb0:	0a000092 	beq	14200 <print_object.isra.5+0x520>
		*ptr++='{';	if (fmt) *ptr++='\n';	*ptr=0;	p->offset+=len;
   13fb4:	e3a0300a 	mov	r3, #10
   13fb8:	e3a0207b 	mov	r2, #123	; 0x7b
   13fbc:	e5c08002 	strb	r8, [r0, #2]
   13fc0:	e5c02000 	strb	r2, [r0]
   13fc4:	e5c03001 	strb	r3, [r0, #1]
   13fc8:	e59b3008 	ldr	r3, [fp, #8]
		child=item->child;depth++;
   13fcc:	e5974000 	ldr	r4, [r7]
	if (p)
	{
		/* Compose the output: */
		i=p->offset;
		len=fmt?2:1;	ptr=ensure(p,len+1);	if (!ptr) return 0;
		*ptr++='{';	if (fmt) *ptr++='\n';	*ptr=0;	p->offset+=len;
   13fd0:	e2833002 	add	r3, r3, #2
   13fd4:	e58b3008 	str	r3, [fp, #8]
		child=item->child;depth++;
   13fd8:	e59d3000 	ldr	r3, [sp]
		while (child)
   13fdc:	e3540000 	cmp	r4, #0
	{
		/* Compose the output: */
		i=p->offset;
		len=fmt?2:1;	ptr=ensure(p,len+1);	if (!ptr) return 0;
		*ptr++='{';	if (fmt) *ptr++='\n';	*ptr=0;	p->offset+=len;
		child=item->child;depth++;
   13fe0:	e2837001 	add	r7, r3, #1
		while (child)
   13fe4:	1affff63 	bne	13d78 <print_object.isra.5+0x98>
   13fe8:	eaffffb5 	b	13ec4 <print_object.isra.5+0x1e4>
			{
				ptr=ensure(p,depth);	if (!ptr) return 0;
				for (j=0;j<depth;j++) *ptr++='\t';
				p->offset+=depth;
			}
			print_string_ptr(child->string,p);
   13fec:	e5940020 	ldr	r0, [r4, #32]
   13ff0:	e1a0100b 	mov	r1, fp
   13ff4:	ebfffb7f 	bl	12df8 <print_string_ptr>
}

static int update(printbuffer *p)
{
	char *str;
	if (!p || !p->buffer) return 0;
   13ff8:	e59b0000 	ldr	r0, [fp]
   13ffc:	e3500000 	cmp	r0, #0
   14000:	0a000129 	beq	144ac <print_object.isra.5+0x7cc>
	str=p->buffer+p->offset;
   14004:	e59b9008 	ldr	r9, [fp, #8]
	return p->offset+strlen(str);
   14008:	e0800009 	add	r0, r0, r9
   1400c:	ebffc43b 	bl	5100 <strlen@plt>
   14010:	e0800009 	add	r0, r0, r9
				ptr=ensure(p,depth);	if (!ptr) return 0;
				for (j=0;j<depth;j++) *ptr++='\t';
				p->offset+=depth;
			}
			print_string_ptr(child->string,p);
			p->offset=update(p);
   14014:	e58b0008 	str	r0, [fp, #8]
			
			len=fmt?2:1;
			ptr=ensure(p,len);	if (!ptr) return 0;
   14018:	e1a0000b 	mov	r0, fp
   1401c:	e3a01001 	mov	r1, #1
   14020:	ebfffa7e 	bl	12a20 <ensure>
   14024:	e3500000 	cmp	r0, #0
   14028:	0a000074 	beq	14200 <print_object.isra.5+0x520>
			*ptr++=':';if (fmt) *ptr++='\t';
   1402c:	e3a0303a 	mov	r3, #58	; 0x3a
   14030:	e5c03000 	strb	r3, [r0]
				p->offset+=depth;
			}
			print_string_ptr(child->string,p);
			p->offset=update(p);
			
			len=fmt?2:1;
   14034:	e3a02001 	mov	r2, #1
   14038:	eaffff74 	b	13e10 <print_object.isra.5+0x130>
		out=(p->buffer)+i;
	}
	else
	{
		/* Allocate space for the names and the objects */
		entries=(char**)cJSON_malloc(numentries*sizeof(char*));
   1403c:	e59f9470 	ldr	r9, [pc, #1136]	; 144b4 <print_object.isra.5+0x7d4>
   14040:	e1a08105 	lsl	r8, r5, #2
   14044:	e08f9009 	add	r9, pc, r9
   14048:	e5993000 	ldr	r3, [r9]
   1404c:	e1a00008 	mov	r0, r8
   14050:	e12fff33 	blx	r3
		if (!entries) return 0;
   14054:	e2503000 	subs	r3, r0, #0
   14058:	e58d300c 	str	r3, [sp, #12]
   1405c:	0a000067 	beq	14200 <print_object.isra.5+0x520>
		names=(char**)cJSON_malloc(numentries*sizeof(char*));
   14060:	e5993000 	ldr	r3, [r9]
   14064:	e1a00008 	mov	r0, r8
   14068:	e12fff33 	blx	r3
		if (!names) {cJSON_free(entries);return 0;}
   1406c:	e2503000 	subs	r3, r0, #0
   14070:	e58d3014 	str	r3, [sp, #20]
   14074:	0a000100 	beq	1447c <print_object.isra.5+0x79c>
		memset(entries,0,sizeof(char*)*numentries);
   14078:	e1a02008 	mov	r2, r8
   1407c:	e1a0100b 	mov	r1, fp
   14080:	e59d000c 	ldr	r0, [sp, #12]
   14084:	ebffc411 	bl	50d0 <memset@plt>
		memset(names,0,sizeof(char*)*numentries);
   14088:	e1a02008 	mov	r2, r8
   1408c:	e59d0014 	ldr	r0, [sp, #20]
   14090:	e1a0100b 	mov	r1, fp
   14094:	ebffc40d 	bl	50d0 <memset@plt>

		/* Collect all the results into our arrays: */
		child=item->child;depth++;if (fmt) len+=depth;
   14098:	e59d3000 	ldr	r3, [sp]
   1409c:	e3560000 	cmp	r6, #0
   140a0:	e2833001 	add	r3, r3, #1
   140a4:	e5977000 	ldr	r7, [r7]
   140a8:	e58d3004 	str	r3, [sp, #4]
   140ac:	159d3000 	ldrne	r3, [sp]

/* Render an object to text. */
static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p)
{
	char **entries=0,**names=0;
	char *out=0,*ptr,*ret,*str;int len=7,i=0,j;
   140b0:	03a08007 	moveq	r8, #7
		if (!names) {cJSON_free(entries);return 0;}
		memset(entries,0,sizeof(char*)*numentries);
		memset(names,0,sizeof(char*)*numentries);

		/* Collect all the results into our arrays: */
		child=item->child;depth++;if (fmt) len+=depth;
   140b4:	12838008 	addne	r8, r3, #8
		while (child)
   140b8:	e3570000 	cmp	r7, #0
   140bc:	0a000064 	beq	14254 <print_object.isra.5+0x574>
   140c0:	e59d3000 	ldr	r3, [sp]
   140c4:	e3560000 	cmp	r6, #0
   140c8:	e59d2014 	ldr	r2, [sp, #20]
   140cc:	e59d100c 	ldr	r1, [sp, #12]
   140d0:	12833003 	addne	r3, r3, #3
   140d4:	03a03000 	moveq	r3, #0
   140d8:	e2422004 	sub	r2, r2, #4
   140dc:	e2411004 	sub	r1, r1, #4
   140e0:	e2833002 	add	r3, r3, #2
		{
			names[i]=str=print_string_ptr(child->string,0);
			entries[i++]=ret=print_value(child,depth,fmt,0);
			if (str && ret) len+=strlen(ret)+strlen(str)+2+(fmt?2+depth:0); else fail=1;
   140e4:	e59db004 	ldr	fp, [sp, #4]
   140e8:	e58d3010 	str	r3, [sp, #16]
   140ec:	e1a0a002 	mov	sl, r2
   140f0:	e3a03000 	mov	r3, #0
   140f4:	e1a09001 	mov	r9, r1
   140f8:	e58d201c 	str	r2, [sp, #28]
   140fc:	e58d1018 	str	r1, [sp, #24]
   14100:	e58d3008 	str	r3, [sp, #8]
   14104:	e58d5020 	str	r5, [sp, #32]
   14108:	e58d4024 	str	r4, [sp, #36]	; 0x24

		/* Collect all the results into our arrays: */
		child=item->child;depth++;if (fmt) len+=depth;
		while (child)
		{
			names[i]=str=print_string_ptr(child->string,0);
   1410c:	e3a01000 	mov	r1, #0
   14110:	e5970020 	ldr	r0, [r7, #32]
   14114:	ebfffb37 	bl	12df8 <print_string_ptr>
			entries[i++]=ret=print_value(child,depth,fmt,0);
   14118:	e3a03000 	mov	r3, #0
   1411c:	e1a0100b 	mov	r1, fp
   14120:	e1a02006 	mov	r2, r6

		/* Collect all the results into our arrays: */
		child=item->child;depth++;if (fmt) len+=depth;
		while (child)
		{
			names[i]=str=print_string_ptr(child->string,0);
   14124:	e1a05000 	mov	r5, r0
   14128:	e5aa0004 	str	r0, [sl, #4]!
			entries[i++]=ret=print_value(child,depth,fmt,0);
   1412c:	e1a00007 	mov	r0, r7
   14130:	eb0000e6 	bl	144d0 <print_value>
			if (str && ret) len+=strlen(ret)+strlen(str)+2+(fmt?2+depth:0); else fail=1;
   14134:	e3500000 	cmp	r0, #0
   14138:	13550000 	cmpne	r5, #0
		/* Collect all the results into our arrays: */
		child=item->child;depth++;if (fmt) len+=depth;
		while (child)
		{
			names[i]=str=print_string_ptr(child->string,0);
			entries[i++]=ret=print_value(child,depth,fmt,0);
   1413c:	e1a03000 	mov	r3, r0
			if (str && ret) len+=strlen(ret)+strlen(str)+2+(fmt?2+depth:0); else fail=1;
   14140:	03a03001 	moveq	r3, #1
		/* Collect all the results into our arrays: */
		child=item->child;depth++;if (fmt) len+=depth;
		while (child)
		{
			names[i]=str=print_string_ptr(child->string,0);
			entries[i++]=ret=print_value(child,depth,fmt,0);
   14144:	e5a90004 	str	r0, [r9, #4]!
			if (str && ret) len+=strlen(ret)+strlen(str)+2+(fmt?2+depth:0); else fail=1;
   14148:	058d3008 	streq	r3, [sp, #8]
   1414c:	0a000007 	beq	14170 <print_object.isra.5+0x490>
   14150:	ebffc3ea 	bl	5100 <strlen@plt>
   14154:	e1a04000 	mov	r4, r0
   14158:	e1a00005 	mov	r0, r5
   1415c:	ebffc3e7 	bl	5100 <strlen@plt>
   14160:	e59d3010 	ldr	r3, [sp, #16]
   14164:	e0838008 	add	r8, r3, r8
   14168:	e0888004 	add	r8, r8, r4
   1416c:	e0888000 	add	r8, r8, r0
			child=child->next;
   14170:	e5977000 	ldr	r7, [r7]
		memset(entries,0,sizeof(char*)*numentries);
		memset(names,0,sizeof(char*)*numentries);

		/* Collect all the results into our arrays: */
		child=item->child;depth++;if (fmt) len+=depth;
		while (child)
   14174:	e3570000 	cmp	r7, #0
   14178:	1affffe3 	bne	1410c <print_object.isra.5+0x42c>
			if (str && ret) len+=strlen(ret)+strlen(str)+2+(fmt?2+depth:0); else fail=1;
			child=child->next;
		}
		
		/* Try to allocate the output string */
		if (!fail)	out=(char*)cJSON_malloc(len);
   1417c:	e59d3008 	ldr	r3, [sp, #8]
   14180:	e59d5020 	ldr	r5, [sp, #32]
   14184:	e3530000 	cmp	r3, #0
   14188:	e59d4024 	ldr	r4, [sp, #36]	; 0x24
   1418c:	0a000030 	beq	14254 <print_object.isra.5+0x574>
		if (!out) fail=1;

		/* Handle failure */
		if (fail)
		{
			for (i=0;i<numentries;i++) {if (names[i]) cJSON_free(names[i]);if (entries[i]) cJSON_free(entries[i]);}
   14190:	e59f9320 	ldr	r9, [pc, #800]	; 144b8 <print_object.isra.5+0x7d8>
   14194:	e59f8320 	ldr	r8, [pc, #800]	; 144bc <print_object.isra.5+0x7dc>
   14198:	e59d701c 	ldr	r7, [sp, #28]
   1419c:	e59d6018 	ldr	r6, [sp, #24]
		child=item->child;depth++;if (fmt) len+=depth;
		while (child)
		{
			names[i]=str=print_string_ptr(child->string,0);
			entries[i++]=ret=print_value(child,depth,fmt,0);
			if (str && ret) len+=strlen(ret)+strlen(str)+2+(fmt?2+depth:0); else fail=1;
   141a0:	e3a04000 	mov	r4, #0
		if (!out) fail=1;

		/* Handle failure */
		if (fail)
		{
			for (i=0;i<numentries;i++) {if (names[i]) cJSON_free(names[i]);if (entries[i]) cJSON_free(entries[i]);}
   141a4:	e08f9009 	add	r9, pc, r9
   141a8:	e08f8008 	add	r8, pc, r8
   141ac:	e5b73004 	ldr	r3, [r7, #4]!
   141b0:	e2844001 	add	r4, r4, #1
   141b4:	e2530000 	subs	r0, r3, #0
   141b8:	0a000001 	beq	141c4 <print_object.isra.5+0x4e4>
   141bc:	e5993004 	ldr	r3, [r9, #4]
   141c0:	e12fff33 	blx	r3
   141c4:	e5b63004 	ldr	r3, [r6, #4]!
   141c8:	e2530000 	subs	r0, r3, #0
   141cc:	0a000001 	beq	141d8 <print_object.isra.5+0x4f8>
   141d0:	e5983004 	ldr	r3, [r8, #4]
   141d4:	e12fff33 	blx	r3
   141d8:	e1540005 	cmp	r4, r5
   141dc:	1afffff2 	bne	141ac <print_object.isra.5+0x4cc>
			cJSON_free(names);cJSON_free(entries);
   141e0:	e59f42d8 	ldr	r4, [pc, #728]	; 144c0 <print_object.isra.5+0x7e0>
   141e4:	e59d0014 	ldr	r0, [sp, #20]
   141e8:	e08f4004 	add	r4, pc, r4
   141ec:	e5943004 	ldr	r3, [r4, #4]
   141f0:	e12fff33 	blx	r3
   141f4:	e5943004 	ldr	r3, [r4, #4]
   141f8:	e59d000c 	ldr	r0, [sp, #12]
   141fc:	e12fff33 	blx	r3
			return 0;
   14200:	e3a00000 	mov	r0, #0
		cJSON_free(names);cJSON_free(entries);
		if (fmt) for (i=0;i<depth-1;i++) *ptr++='\t';
		*ptr++='}';*ptr++=0;
	}
	return out;	
}
   14204:	e28dd02c 	add	sp, sp, #44	; 0x2c
   14208:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
	while (child) numentries++,child=child->next;
	/* Explicitly handle empty object case */
	if (!numentries)
	{
		if (p) out=ensure(p,fmt?depth+4:3);
		else	out=(char*)cJSON_malloc(fmt?depth+4:3);
   1420c:	e3520000 	cmp	r2, #0
   14210:	e59f32ac 	ldr	r3, [pc, #684]	; 144c4 <print_object.isra.5+0x7e4>
   14214:	159d2000 	ldrne	r2, [sp]
   14218:	e08f3003 	add	r3, pc, r3
   1421c:	e5933000 	ldr	r3, [r3]
   14220:	12820004 	addne	r0, r2, #4
   14224:	03a00003 	moveq	r0, #3
   14228:	e12fff33 	blx	r3
   1422c:	eaffff42 	b	13f3c <print_object.isra.5+0x25c>
			if (child->next) *ptr++=',';
			if (fmt) *ptr++='\n';*ptr=0;
			p->offset+=len;
			child=child->next;
		}
		ptr=ensure(p,fmt?(depth+1):2);	 if (!ptr) return 0;
   14230:	e1a0000b 	mov	r0, fp
   14234:	e3a01002 	mov	r1, #2
   14238:	ebfff9f8 	bl	12a20 <ensure>
   1423c:	e2506000 	subs	r6, r0, #0
   14240:	0affffee 	beq	14200 <print_object.isra.5+0x520>
   14244:	e59d0004 	ldr	r0, [sp, #4]
   14248:	eaffff2b 	b	13efc <print_object.isra.5+0x21c>
	{
		if (p) out=ensure(p,fmt?depth+4:3);
		else	out=(char*)cJSON_malloc(fmt?depth+4:3);
		if (!out)	return 0;
		ptr=out;*ptr++='{';
		if (fmt) {*ptr++='\n';for (i=0;i<depth-1;i++) *ptr++='\t';}
   1424c:	e1a03004 	mov	r3, r4
   14250:	eaffff4c 	b	13f88 <print_object.isra.5+0x2a8>
			if (str && ret) len+=strlen(ret)+strlen(str)+2+(fmt?2+depth:0); else fail=1;
			child=child->next;
		}
		
		/* Try to allocate the output string */
		if (!fail)	out=(char*)cJSON_malloc(len);
   14254:	e59f326c 	ldr	r3, [pc, #620]	; 144c8 <print_object.isra.5+0x7e8>
   14258:	e1a00008 	mov	r0, r8
   1425c:	e08f3003 	add	r3, pc, r3
   14260:	e5933000 	ldr	r3, [r3]
   14264:	e12fff33 	blx	r3
		if (!out) fail=1;
   14268:	e2503000 	subs	r3, r0, #0
   1426c:	e58d3018 	str	r3, [sp, #24]
   14270:	0a000086 	beq	14490 <print_object.isra.5+0x7b0>
			cJSON_free(names);cJSON_free(entries);
			return 0;
		}
		
		/* Compose the output: */
		*out='{';ptr=out+1;if (fmt)*ptr++='\n';*ptr=0;
   14274:	e59d2018 	ldr	r2, [sp, #24]
   14278:	e3a0307b 	mov	r3, #123	; 0x7b
   1427c:	e3560000 	cmp	r6, #0
   14280:	e5c23000 	strb	r3, [r2]
   14284:	01a03002 	moveq	r3, r2
   14288:	02837001 	addeq	r7, r3, #1
   1428c:	159d2018 	ldrne	r2, [sp, #24]
   14290:	13a0300a 	movne	r3, #10
   14294:	12827002 	addne	r7, r2, #2
   14298:	15c23001 	strbne	r3, [r2, #1]
			tmplen=strlen(names[i]);memcpy(ptr,names[i],tmplen);ptr+=tmplen;
			*ptr++=':';if (fmt) *ptr++='\t';
			strcpy(ptr,entries[i]);ptr+=strlen(entries[i]);
			if (i!=numentries-1) *ptr++=',';
			if (fmt) *ptr++='\n';*ptr=0;
			cJSON_free(names[i]);cJSON_free(entries[i]);
   1429c:	e59fa228 	ldr	sl, [pc, #552]	; 144cc <print_object.isra.5+0x7ec>
   142a0:	e59d2014 	ldr	r2, [sp, #20]
			cJSON_free(names);cJSON_free(entries);
			return 0;
		}
		
		/* Compose the output: */
		*out='{';ptr=out+1;if (fmt)*ptr++='\n';*ptr=0;
   142a4:	e3a03000 	mov	r3, #0
   142a8:	e59d900c 	ldr	r9, [sp, #12]
   142ac:	e58d4008 	str	r4, [sp, #8]
		for (i=0;i<numentries;i++)
   142b0:	e1a0b003 	mov	fp, r3
			tmplen=strlen(names[i]);memcpy(ptr,names[i],tmplen);ptr+=tmplen;
			*ptr++=':';if (fmt) *ptr++='\t';
			strcpy(ptr,entries[i]);ptr+=strlen(entries[i]);
			if (i!=numentries-1) *ptr++=',';
			if (fmt) *ptr++='\n';*ptr=0;
			cJSON_free(names[i]);cJSON_free(entries[i]);
   142b4:	e08fa00a 	add	sl, pc, sl
		*out='{';ptr=out+1;if (fmt)*ptr++='\n';*ptr=0;
		for (i=0;i<numentries;i++)
		{
			if (fmt) for (j=0;j<depth;j++) *ptr++='\t';
			tmplen=strlen(names[i]);memcpy(ptr,names[i],tmplen);ptr+=tmplen;
			*ptr++=':';if (fmt) *ptr++='\t';
   142b8:	e3a08009 	mov	r8, #9
			cJSON_free(names);cJSON_free(entries);
			return 0;
		}
		
		/* Compose the output: */
		*out='{';ptr=out+1;if (fmt)*ptr++='\n';*ptr=0;
   142bc:	e1a04002 	mov	r4, r2
   142c0:	e5c73000 	strb	r3, [r7]
		for (i=0;i<numentries;i++)
		{
			if (fmt) for (j=0;j<depth;j++) *ptr++='\t';
   142c4:	e3560000 	cmp	r6, #0
   142c8:	0a00004b 	beq	143fc <print_object.isra.5+0x71c>
   142cc:	e59d3004 	ldr	r3, [sp, #4]
   142d0:	e3530000 	cmp	r3, #0
   142d4:	da000007 	ble	142f8 <print_object.isra.5+0x618>
   142d8:	e59d3000 	ldr	r3, [sp]
   142dc:	e2472001 	sub	r2, r7, #1
   142e0:	e0871003 	add	r1, r7, r3
   142e4:	e5e28001 	strb	r8, [r2, #1]!
   142e8:	e1520001 	cmp	r2, r1
   142ec:	1afffffc 	bne	142e4 <print_object.isra.5+0x604>
   142f0:	e59d3004 	ldr	r3, [sp, #4]
   142f4:	e0877003 	add	r7, r7, r3
			tmplen=strlen(names[i]);memcpy(ptr,names[i],tmplen);ptr+=tmplen;
   142f8:	e5941000 	ldr	r1, [r4]
   142fc:	e58d1010 	str	r1, [sp, #16]
   14300:	e1a00001 	mov	r0, r1
   14304:	ebffc37d 	bl	5100 <strlen@plt>
   14308:	e59d1010 	ldr	r1, [sp, #16]
   1430c:	e1a0c000 	mov	ip, r0
   14310:	e1a0200c 	mov	r2, ip
   14314:	e1a00007 	mov	r0, r7
   14318:	e58dc010 	str	ip, [sp, #16]
   1431c:	ebffc3aa 	bl	51cc <memcpy@plt>
   14320:	e59dc010 	ldr	ip, [sp, #16]
			*ptr++=':';if (fmt) *ptr++='\t';
   14324:	e3a0303a 	mov	r3, #58	; 0x3a
		/* Compose the output: */
		*out='{';ptr=out+1;if (fmt)*ptr++='\n';*ptr=0;
		for (i=0;i<numentries;i++)
		{
			if (fmt) for (j=0;j<depth;j++) *ptr++='\t';
			tmplen=strlen(names[i]);memcpy(ptr,names[i],tmplen);ptr+=tmplen;
   14328:	e087100c 	add	r1, r7, ip
			*ptr++=':';if (fmt) *ptr++='\t';
   1432c:	e2812002 	add	r2, r1, #2
   14330:	e7c7300c 	strb	r3, [r7, ip]
			strcpy(ptr,entries[i]);ptr+=strlen(entries[i]);
   14334:	e1a00002 	mov	r0, r2
		*out='{';ptr=out+1;if (fmt)*ptr++='\n';*ptr=0;
		for (i=0;i<numentries;i++)
		{
			if (fmt) for (j=0;j<depth;j++) *ptr++='\t';
			tmplen=strlen(names[i]);memcpy(ptr,names[i],tmplen);ptr+=tmplen;
			*ptr++=':';if (fmt) *ptr++='\t';
   14338:	e5c18001 	strb	r8, [r1, #1]
			strcpy(ptr,entries[i]);ptr+=strlen(entries[i]);
   1433c:	e5991000 	ldr	r1, [r9]
   14340:	e58d2010 	str	r2, [sp, #16]
   14344:	ebffc3ac 	bl	51fc <strcpy@plt>
   14348:	e5990000 	ldr	r0, [r9]
   1434c:	ebffc36b 	bl	5100 <strlen@plt>
			if (i!=numentries-1) *ptr++=',';
   14350:	e59d3008 	ldr	r3, [sp, #8]
		for (i=0;i<numentries;i++)
		{
			if (fmt) for (j=0;j<depth;j++) *ptr++='\t';
			tmplen=strlen(names[i]);memcpy(ptr,names[i],tmplen);ptr+=tmplen;
			*ptr++=':';if (fmt) *ptr++='\t';
			strcpy(ptr,entries[i]);ptr+=strlen(entries[i]);
   14354:	e59d2010 	ldr	r2, [sp, #16]
			if (i!=numentries-1) *ptr++=',';
   14358:	e153000b 	cmp	r3, fp
   1435c:	13a0302c 	movne	r3, #44	; 0x2c
		for (i=0;i<numentries;i++)
		{
			if (fmt) for (j=0;j<depth;j++) *ptr++='\t';
			tmplen=strlen(names[i]);memcpy(ptr,names[i],tmplen);ptr+=tmplen;
			*ptr++=':';if (fmt) *ptr++='\t';
			strcpy(ptr,entries[i]);ptr+=strlen(entries[i]);
   14360:	e0821000 	add	r1, r2, r0
			if (i!=numentries-1) *ptr++=',';
   14364:	12811001 	addne	r1, r1, #1
   14368:	17c23000 	strbne	r3, [r2, r0]
			if (fmt) *ptr++='\n';*ptr=0;
   1436c:	e2817001 	add	r7, r1, #1
   14370:	e3a0300a 	mov	r3, #10
   14374:	e5c13000 	strb	r3, [r1]
   14378:	e3a03000 	mov	r3, #0
   1437c:	e5c73000 	strb	r3, [r7]
			cJSON_free(names[i]);cJSON_free(entries[i]);
   14380:	e59a2004 	ldr	r2, [sl, #4]
   14384:	e4940004 	ldr	r0, [r4], #4
   14388:	e12fff32 	blx	r2
			return 0;
		}
		
		/* Compose the output: */
		*out='{';ptr=out+1;if (fmt)*ptr++='\n';*ptr=0;
		for (i=0;i<numentries;i++)
   1438c:	e28bb001 	add	fp, fp, #1
			tmplen=strlen(names[i]);memcpy(ptr,names[i],tmplen);ptr+=tmplen;
			*ptr++=':';if (fmt) *ptr++='\t';
			strcpy(ptr,entries[i]);ptr+=strlen(entries[i]);
			if (i!=numentries-1) *ptr++=',';
			if (fmt) *ptr++='\n';*ptr=0;
			cJSON_free(names[i]);cJSON_free(entries[i]);
   14390:	e59a2004 	ldr	r2, [sl, #4]
   14394:	e4990004 	ldr	r0, [r9], #4
   14398:	e12fff32 	blx	r2
			return 0;
		}
		
		/* Compose the output: */
		*out='{';ptr=out+1;if (fmt)*ptr++='\n';*ptr=0;
		for (i=0;i<numentries;i++)
   1439c:	e15b0005 	cmp	fp, r5
   143a0:	1affffc7 	bne	142c4 <print_object.isra.5+0x5e4>
			if (i!=numentries-1) *ptr++=',';
			if (fmt) *ptr++='\n';*ptr=0;
			cJSON_free(names[i]);cJSON_free(entries[i]);
		}
		
		cJSON_free(names);cJSON_free(entries);
   143a4:	e59d0014 	ldr	r0, [sp, #20]
   143a8:	e59a3004 	ldr	r3, [sl, #4]
   143ac:	e12fff33 	blx	r3
   143b0:	e59a3004 	ldr	r3, [sl, #4]
   143b4:	e59d000c 	ldr	r0, [sp, #12]
   143b8:	e12fff33 	blx	r3
		if (fmt) for (i=0;i<depth-1;i++) *ptr++='\t';
   143bc:	e3560000 	cmp	r6, #0
   143c0:	0a000007 	beq	143e4 <print_object.isra.5+0x704>
   143c4:	e59d3000 	ldr	r3, [sp]
   143c8:	e3530000 	cmp	r3, #0
   143cc:	da000004 	ble	143e4 <print_object.isra.5+0x704>
   143d0:	e0873003 	add	r3, r7, r3
   143d4:	e3a04009 	mov	r4, #9
   143d8:	e4c74001 	strb	r4, [r7], #1
   143dc:	e1570003 	cmp	r7, r3
   143e0:	1afffffc 	bne	143d8 <print_object.isra.5+0x6f8>
		*ptr++='}';*ptr++=0;
   143e4:	e3a0207d 	mov	r2, #125	; 0x7d
   143e8:	e3a03000 	mov	r3, #0
   143ec:	e59d0018 	ldr	r0, [sp, #24]
   143f0:	e5c72000 	strb	r2, [r7]
   143f4:	e5c73001 	strb	r3, [r7, #1]
   143f8:	eafffee6 	b	13f98 <print_object.isra.5+0x2b8>
		/* Compose the output: */
		*out='{';ptr=out+1;if (fmt)*ptr++='\n';*ptr=0;
		for (i=0;i<numentries;i++)
		{
			if (fmt) for (j=0;j<depth;j++) *ptr++='\t';
			tmplen=strlen(names[i]);memcpy(ptr,names[i],tmplen);ptr+=tmplen;
   143fc:	e5941000 	ldr	r1, [r4]
   14400:	e58d1010 	str	r1, [sp, #16]
   14404:	e1a00001 	mov	r0, r1
   14408:	ebffc33c 	bl	5100 <strlen@plt>
   1440c:	e59d1010 	ldr	r1, [sp, #16]
   14410:	e1a0c000 	mov	ip, r0
   14414:	e1a0200c 	mov	r2, ip
   14418:	e1a00007 	mov	r0, r7
   1441c:	e58dc010 	str	ip, [sp, #16]
   14420:	ebffc369 	bl	51cc <memcpy@plt>
   14424:	e59dc010 	ldr	ip, [sp, #16]
			*ptr++=':';if (fmt) *ptr++='\t';
   14428:	e3a0303a 	mov	r3, #58	; 0x3a
		/* Compose the output: */
		*out='{';ptr=out+1;if (fmt)*ptr++='\n';*ptr=0;
		for (i=0;i<numentries;i++)
		{
			if (fmt) for (j=0;j<depth;j++) *ptr++='\t';
			tmplen=strlen(names[i]);memcpy(ptr,names[i],tmplen);ptr+=tmplen;
   1442c:	e087200c 	add	r2, r7, ip
			*ptr++=':';if (fmt) *ptr++='\t';
   14430:	e2822001 	add	r2, r2, #1
   14434:	e7c7300c 	strb	r3, [r7, ip]
			strcpy(ptr,entries[i]);ptr+=strlen(entries[i]);
   14438:	e1a00002 	mov	r0, r2
   1443c:	e5991000 	ldr	r1, [r9]
   14440:	e58d2010 	str	r2, [sp, #16]
   14444:	ebffc36c 	bl	51fc <strcpy@plt>
   14448:	e5990000 	ldr	r0, [r9]
   1444c:	ebffc32b 	bl	5100 <strlen@plt>
			if (i!=numentries-1) *ptr++=',';
   14450:	e59d3008 	ldr	r3, [sp, #8]
		for (i=0;i<numentries;i++)
		{
			if (fmt) for (j=0;j<depth;j++) *ptr++='\t';
			tmplen=strlen(names[i]);memcpy(ptr,names[i],tmplen);ptr+=tmplen;
			*ptr++=':';if (fmt) *ptr++='\t';
			strcpy(ptr,entries[i]);ptr+=strlen(entries[i]);
   14454:	e59d2010 	ldr	r2, [sp, #16]
			if (i!=numentries-1) *ptr++=',';
   14458:	e153000b 	cmp	r3, fp
   1445c:	13a0302c 	movne	r3, #44	; 0x2c
		for (i=0;i<numentries;i++)
		{
			if (fmt) for (j=0;j<depth;j++) *ptr++='\t';
			tmplen=strlen(names[i]);memcpy(ptr,names[i],tmplen);ptr+=tmplen;
			*ptr++=':';if (fmt) *ptr++='\t';
			strcpy(ptr,entries[i]);ptr+=strlen(entries[i]);
   14460:	e0827000 	add	r7, r2, r0
			if (i!=numentries-1) *ptr++=',';
   14464:	12877001 	addne	r7, r7, #1
   14468:	17c23000 	strbne	r3, [r2, r0]
   1446c:	eaffffc1 	b	14378 <print_object.isra.5+0x698>
			if (fmt) *ptr++='\n';*ptr=0;
			p->offset+=len;
			child=child->next;
		}
		ptr=ensure(p,fmt?(depth+1):2);	 if (!ptr) return 0;
		if (fmt)	for (i=0;i<depth-1;i++) *ptr++='\t';
   14470:	e1a06005 	mov	r6, r5
   14474:	e3a00000 	mov	r0, #0
   14478:	eafffe9f 	b	13efc <print_object.isra.5+0x21c>
	{
		/* Allocate space for the names and the objects */
		entries=(char**)cJSON_malloc(numentries*sizeof(char*));
		if (!entries) return 0;
		names=(char**)cJSON_malloc(numentries*sizeof(char*));
		if (!names) {cJSON_free(entries);return 0;}
   1447c:	e59d000c 	ldr	r0, [sp, #12]
   14480:	e5993004 	ldr	r3, [r9, #4]
   14484:	e12fff33 	blx	r3
   14488:	e1a0000b 	mov	r0, fp
   1448c:	eafffec1 	b	13f98 <print_object.isra.5+0x2b8>
   14490:	e59d3014 	ldr	r3, [sp, #20]
   14494:	e2433004 	sub	r3, r3, #4
   14498:	e58d301c 	str	r3, [sp, #28]
   1449c:	e59d300c 	ldr	r3, [sp, #12]
   144a0:	e2433004 	sub	r3, r3, #4
   144a4:	e58d3018 	str	r3, [sp, #24]
   144a8:	eaffff38 	b	14190 <print_object.isra.5+0x4b0>
				ptr=ensure(p,depth);	if (!ptr) return 0;
				for (j=0;j<depth;j++) *ptr++='\t';
				p->offset+=depth;
			}
			print_string_ptr(child->string,p);
			p->offset=update(p);
   144ac:	e58b6008 	str	r6, [fp, #8]
   144b0:	eafffed8 	b	14018 <print_object.isra.5+0x338>
   144b4:	0000ffb8 	.word	0x0000ffb8
   144b8:	0000fe58 	.word	0x0000fe58
   144bc:	0000fe54 	.word	0x0000fe54
   144c0:	0000fe14 	.word	0x0000fe14
   144c4:	0000fde4 	.word	0x0000fde4
   144c8:	0000fda0 	.word	0x0000fda0
   144cc:	0000fd48 	.word	0x0000fd48

000144d0 <print_value>:

/* Render a value to text. */
static char *print_value(cJSON *item,int depth,int fmt,printbuffer *p)
{
	char *out=0;
	if (!item) return 0;
   144d0:	e3500000 	cmp	r0, #0
	ep=value;return 0;	/* failure. */
}

/* Render a value to text. */
static char *print_value(cJSON *item,int depth,int fmt,printbuffer *p)
{
   144d4:	e92d4010 	push	{r4, lr}
	char *out=0;
	if (!item) return 0;
   144d8:	08bd8010 	popeq	{r4, pc}
	if (p)
   144dc:	e3530000 	cmp	r3, #0
   144e0:	0a000038 	beq	145c8 <print_value+0xf8>
	{
		switch ((item->type)&255)
   144e4:	e5d0c00c 	ldrb	ip, [r0, #12]
   144e8:	e35c0006 	cmp	ip, #6
   144ec:	908ff10c 	addls	pc, pc, ip, lsl #2
   144f0:	ea00005c 	b	14668 <print_value+0x198>
   144f4:	ea000008 	b	1451c <print_value+0x4c>
   144f8:	ea000012 	b	14548 <print_value+0x78>
   144fc:	ea00001c 	b	14574 <print_value+0xa4>
   14500:	ea000026 	b	145a0 <print_value+0xd0>
   14504:	ea000028 	b	145ac <print_value+0xdc>
   14508:	ea00002b 	b	145bc <print_value+0xec>
   1450c:	eaffffff 	b	14510 <print_value+0x40>
			case cJSON_False:	{out=ensure(p,6);	if (out) strcpy(out,"false");	break;}
			case cJSON_True:	{out=ensure(p,5);	if (out) strcpy(out,"true");	break;}
			case cJSON_Number:	out=print_number(item,p);break;
			case cJSON_String:	out=print_string(item,p);break;
			case cJSON_Array:	out=print_array(item,depth,fmt,p);break;
			case cJSON_Object:	out=print_object(item,depth,fmt,p);break;
   14510:	e2800008 	add	r0, r0, #8
			case cJSON_Array:	out=print_array(item,depth,fmt,0);break;
			case cJSON_Object:	out=print_object(item,depth,fmt,0);break;
		}
	}
	return out;
}
   14514:	e8bd4010 	pop	{r4, lr}
			case cJSON_False:	{out=ensure(p,6);	if (out) strcpy(out,"false");	break;}
			case cJSON_True:	{out=ensure(p,5);	if (out) strcpy(out,"true");	break;}
			case cJSON_Number:	out=print_number(item,p);break;
			case cJSON_String:	out=print_string(item,p);break;
			case cJSON_Array:	out=print_array(item,depth,fmt,p);break;
			case cJSON_Object:	out=print_object(item,depth,fmt,p);break;
   14518:	eafffdf0 	b	13ce0 <print_object.isra.5>
	if (p)
	{
		switch ((item->type)&255)
		{
			case cJSON_NULL:	{out=ensure(p,5);	if (out) strcpy(out,"null");	break;}
			case cJSON_False:	{out=ensure(p,6);	if (out) strcpy(out,"false");	break;}
   1451c:	e1a00003 	mov	r0, r3
   14520:	e3a01006 	mov	r1, #6
   14524:	ebfff93d 	bl	12a20 <ensure>
   14528:	e2504000 	subs	r4, r0, #0
   1452c:	0a000030 	beq	145f4 <print_value+0x124>
   14530:	e59f1138 	ldr	r1, [pc, #312]	; 14670 <print_value+0x1a0>
   14534:	e3a02006 	mov	r2, #6
   14538:	e08f1001 	add	r1, pc, r1
   1453c:	ebffc322 	bl	51cc <memcpy@plt>
   14540:	e1a00004 	mov	r0, r4
   14544:	e8bd8010 	pop	{r4, pc}
			case cJSON_True:	{out=ensure(p,5);	if (out) strcpy(out,"true");	break;}
   14548:	e1a00003 	mov	r0, r3
   1454c:	e3a01005 	mov	r1, #5
   14550:	ebfff932 	bl	12a20 <ensure>
   14554:	e2504000 	subs	r4, r0, #0
   14558:	0a000025 	beq	145f4 <print_value+0x124>
   1455c:	e59f1110 	ldr	r1, [pc, #272]	; 14674 <print_value+0x1a4>
   14560:	e3a02005 	mov	r2, #5
   14564:	e08f1001 	add	r1, pc, r1
   14568:	ebffc317 	bl	51cc <memcpy@plt>
   1456c:	e1a00004 	mov	r0, r4
   14570:	e8bd8010 	pop	{r4, pc}
	if (!item) return 0;
	if (p)
	{
		switch ((item->type)&255)
		{
			case cJSON_NULL:	{out=ensure(p,5);	if (out) strcpy(out,"null");	break;}
   14574:	e1a00003 	mov	r0, r3
   14578:	e3a01005 	mov	r1, #5
   1457c:	ebfff927 	bl	12a20 <ensure>
   14580:	e2504000 	subs	r4, r0, #0
   14584:	0a00001a 	beq	145f4 <print_value+0x124>
   14588:	e59f10e8 	ldr	r1, [pc, #232]	; 14678 <print_value+0x1a8>
   1458c:	e3a02005 	mov	r2, #5
   14590:	e08f1001 	add	r1, pc, r1
   14594:	ebffc30c 	bl	51cc <memcpy@plt>
   14598:	e1a00004 	mov	r0, r4
   1459c:	e8bd8010 	pop	{r4, pc}
			case cJSON_False:	{out=ensure(p,6);	if (out) strcpy(out,"false");	break;}
			case cJSON_True:	{out=ensure(p,5);	if (out) strcpy(out,"true");	break;}
			case cJSON_Number:	out=print_number(item,p);break;
   145a0:	e1a01003 	mov	r1, r3
			case cJSON_Array:	out=print_array(item,depth,fmt,0);break;
			case cJSON_Object:	out=print_object(item,depth,fmt,0);break;
		}
	}
	return out;
}
   145a4:	e8bd4010 	pop	{r4, lr}
		switch ((item->type)&255)
		{
			case cJSON_NULL:	{out=ensure(p,5);	if (out) strcpy(out,"null");	break;}
			case cJSON_False:	{out=ensure(p,6);	if (out) strcpy(out,"false");	break;}
			case cJSON_True:	{out=ensure(p,5);	if (out) strcpy(out,"true");	break;}
			case cJSON_Number:	out=print_number(item,p);break;
   145a8:	eafff95d 	b	12b24 <print_number>
	}
	*ptr2++='\"';*ptr2++=0;
	return out;
}
/* Invote print_string_ptr (which is useful) on an item. */
static char *print_string(cJSON *item,printbuffer *p)	{return print_string_ptr(item->valuestring,p);}
   145ac:	e5900010 	ldr	r0, [r0, #16]
   145b0:	e1a01003 	mov	r1, r3
			case cJSON_Array:	out=print_array(item,depth,fmt,0);break;
			case cJSON_Object:	out=print_object(item,depth,fmt,0);break;
		}
	}
	return out;
}
   145b4:	e8bd4010 	pop	{r4, lr}
	}
	*ptr2++='\"';*ptr2++=0;
	return out;
}
/* Invote print_string_ptr (which is useful) on an item. */
static char *print_string(cJSON *item,printbuffer *p)	{return print_string_ptr(item->valuestring,p);}
   145b8:	eafffa0e 	b	12df8 <print_string_ptr>
			case cJSON_NULL:	{out=ensure(p,5);	if (out) strcpy(out,"null");	break;}
			case cJSON_False:	{out=ensure(p,6);	if (out) strcpy(out,"false");	break;}
			case cJSON_True:	{out=ensure(p,5);	if (out) strcpy(out,"true");	break;}
			case cJSON_Number:	out=print_number(item,p);break;
			case cJSON_String:	out=print_string(item,p);break;
			case cJSON_Array:	out=print_array(item,depth,fmt,p);break;
   145bc:	e2800008 	add	r0, r0, #8
			case cJSON_Array:	out=print_array(item,depth,fmt,0);break;
			case cJSON_Object:	out=print_object(item,depth,fmt,0);break;
		}
	}
	return out;
}
   145c0:	e8bd4010 	pop	{r4, lr}
			case cJSON_NULL:	{out=ensure(p,5);	if (out) strcpy(out,"null");	break;}
			case cJSON_False:	{out=ensure(p,6);	if (out) strcpy(out,"false");	break;}
			case cJSON_True:	{out=ensure(p,5);	if (out) strcpy(out,"true");	break;}
			case cJSON_Number:	out=print_number(item,p);break;
			case cJSON_String:	out=print_string(item,p);break;
			case cJSON_Array:	out=print_array(item,depth,fmt,p);break;
   145c4:	ea00002f 	b	14688 <print_array.isra.6>
			case cJSON_Object:	out=print_object(item,depth,fmt,p);break;
		}
	}
	else
	{
		switch ((item->type)&255)
   145c8:	e5d0300c 	ldrb	r3, [r0, #12]
   145cc:	e3530006 	cmp	r3, #6
   145d0:	908ff103 	addls	pc, pc, r3, lsl #2
   145d4:	ea000023 	b	14668 <print_value+0x198>
   145d8:	ea00001e 	b	14658 <print_value+0x188>
   145dc:	ea000019 	b	14648 <print_value+0x178>
   145e0:	ea000014 	b	14638 <print_value+0x168>
   145e4:	ea000010 	b	1462c <print_value+0x15c>
   145e8:	ea00000b 	b	1461c <print_value+0x14c>
   145ec:	ea000006 	b	1460c <print_value+0x13c>
   145f0:	ea000001 	b	145fc <print_value+0x12c>
   145f4:	e1a00004 	mov	r0, r4
   145f8:	e8bd8010 	pop	{r4, pc}
			case cJSON_False:	out=cJSON_strdup("false");break;
			case cJSON_True:	out=cJSON_strdup("true"); break;
			case cJSON_Number:	out=print_number(item,0);break;
			case cJSON_String:	out=print_string(item,0);break;
			case cJSON_Array:	out=print_array(item,depth,fmt,0);break;
			case cJSON_Object:	out=print_object(item,depth,fmt,0);break;
   145fc:	e2800008 	add	r0, r0, #8
   14600:	e3a03000 	mov	r3, #0
		}
	}
	return out;
}
   14604:	e8bd4010 	pop	{r4, lr}
			case cJSON_False:	out=cJSON_strdup("false");break;
			case cJSON_True:	out=cJSON_strdup("true"); break;
			case cJSON_Number:	out=print_number(item,0);break;
			case cJSON_String:	out=print_string(item,0);break;
			case cJSON_Array:	out=print_array(item,depth,fmt,0);break;
			case cJSON_Object:	out=print_object(item,depth,fmt,0);break;
   14608:	eafffdb4 	b	13ce0 <print_object.isra.5>
			case cJSON_NULL:	out=cJSON_strdup("null");	break;
			case cJSON_False:	out=cJSON_strdup("false");break;
			case cJSON_True:	out=cJSON_strdup("true"); break;
			case cJSON_Number:	out=print_number(item,0);break;
			case cJSON_String:	out=print_string(item,0);break;
			case cJSON_Array:	out=print_array(item,depth,fmt,0);break;
   1460c:	e2800008 	add	r0, r0, #8
   14610:	e3a03000 	mov	r3, #0
			case cJSON_Object:	out=print_object(item,depth,fmt,0);break;
		}
	}
	return out;
}
   14614:	e8bd4010 	pop	{r4, lr}
			case cJSON_NULL:	out=cJSON_strdup("null");	break;
			case cJSON_False:	out=cJSON_strdup("false");break;
			case cJSON_True:	out=cJSON_strdup("true"); break;
			case cJSON_Number:	out=print_number(item,0);break;
			case cJSON_String:	out=print_string(item,0);break;
			case cJSON_Array:	out=print_array(item,depth,fmt,0);break;
   14618:	ea00001a 	b	14688 <print_array.isra.6>
	}
	*ptr2++='\"';*ptr2++=0;
	return out;
}
/* Invote print_string_ptr (which is useful) on an item. */
static char *print_string(cJSON *item,printbuffer *p)	{return print_string_ptr(item->valuestring,p);}
   1461c:	e5900010 	ldr	r0, [r0, #16]
   14620:	e3a01000 	mov	r1, #0
			case cJSON_Array:	out=print_array(item,depth,fmt,0);break;
			case cJSON_Object:	out=print_object(item,depth,fmt,0);break;
		}
	}
	return out;
}
   14624:	e8bd4010 	pop	{r4, lr}
	}
	*ptr2++='\"';*ptr2++=0;
	return out;
}
/* Invote print_string_ptr (which is useful) on an item. */
static char *print_string(cJSON *item,printbuffer *p)	{return print_string_ptr(item->valuestring,p);}
   14628:	eafff9f2 	b	12df8 <print_string_ptr>
		switch ((item->type)&255)
		{
			case cJSON_NULL:	out=cJSON_strdup("null");	break;
			case cJSON_False:	out=cJSON_strdup("false");break;
			case cJSON_True:	out=cJSON_strdup("true"); break;
			case cJSON_Number:	out=print_number(item,0);break;
   1462c:	e3a01000 	mov	r1, #0
			case cJSON_Array:	out=print_array(item,depth,fmt,0);break;
			case cJSON_Object:	out=print_object(item,depth,fmt,0);break;
		}
	}
	return out;
}
   14630:	e8bd4010 	pop	{r4, lr}
		switch ((item->type)&255)
		{
			case cJSON_NULL:	out=cJSON_strdup("null");	break;
			case cJSON_False:	out=cJSON_strdup("false");break;
			case cJSON_True:	out=cJSON_strdup("true"); break;
			case cJSON_Number:	out=print_number(item,0);break;
   14634:	eafff93a 	b	12b24 <print_number>
	}
	else
	{
		switch ((item->type)&255)
		{
			case cJSON_NULL:	out=cJSON_strdup("null");	break;
   14638:	e59f003c 	ldr	r0, [pc, #60]	; 1467c <print_value+0x1ac>
			case cJSON_Array:	out=print_array(item,depth,fmt,0);break;
			case cJSON_Object:	out=print_object(item,depth,fmt,0);break;
		}
	}
	return out;
}
   1463c:	e8bd4010 	pop	{r4, lr}
	}
	else
	{
		switch ((item->type)&255)
		{
			case cJSON_NULL:	out=cJSON_strdup("null");	break;
   14640:	e08f0000 	add	r0, pc, r0
   14644:	eafff925 	b	12ae0 <cJSON_strdup>
			case cJSON_False:	out=cJSON_strdup("false");break;
			case cJSON_True:	out=cJSON_strdup("true"); break;
   14648:	e59f0030 	ldr	r0, [pc, #48]	; 14680 <print_value+0x1b0>
			case cJSON_Array:	out=print_array(item,depth,fmt,0);break;
			case cJSON_Object:	out=print_object(item,depth,fmt,0);break;
		}
	}
	return out;
}
   1464c:	e8bd4010 	pop	{r4, lr}
	{
		switch ((item->type)&255)
		{
			case cJSON_NULL:	out=cJSON_strdup("null");	break;
			case cJSON_False:	out=cJSON_strdup("false");break;
			case cJSON_True:	out=cJSON_strdup("true"); break;
   14650:	e08f0000 	add	r0, pc, r0
   14654:	eafff921 	b	12ae0 <cJSON_strdup>
	else
	{
		switch ((item->type)&255)
		{
			case cJSON_NULL:	out=cJSON_strdup("null");	break;
			case cJSON_False:	out=cJSON_strdup("false");break;
   14658:	e59f0024 	ldr	r0, [pc, #36]	; 14684 <print_value+0x1b4>
			case cJSON_Array:	out=print_array(item,depth,fmt,0);break;
			case cJSON_Object:	out=print_object(item,depth,fmt,0);break;
		}
	}
	return out;
}
   1465c:	e8bd4010 	pop	{r4, lr}
	else
	{
		switch ((item->type)&255)
		{
			case cJSON_NULL:	out=cJSON_strdup("null");	break;
			case cJSON_False:	out=cJSON_strdup("false");break;
   14660:	e08f0000 	add	r0, pc, r0
   14664:	eafff91d 	b	12ae0 <cJSON_strdup>
}

/* Render a value to text. */
static char *print_value(cJSON *item,int depth,int fmt,printbuffer *p)
{
	char *out=0;
   14668:	e3a00000 	mov	r0, #0
			case cJSON_Array:	out=print_array(item,depth,fmt,0);break;
			case cJSON_Object:	out=print_object(item,depth,fmt,0);break;
		}
	}
	return out;
}
   1466c:	e8bd8010 	pop	{r4, pc}
   14670:	0000c740 	.word	0x0000c740
   14674:	0000a45c 	.word	0x0000a45c
   14678:	0000c6e0 	.word	0x0000c6e0
   1467c:	0000c630 	.word	0x0000c630
   14680:	0000a370 	.word	0x0000a370
   14684:	0000c618 	.word	0x0000c618

00014688 <print_array.isra.6>:
	if (*value==']') return value+1;	/* end of array */
	ep=value;return 0;	/* malformed. */
}

/* Render an array to text */
static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p)
   14688:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
{
	char **entries;
	char *out=0,*ptr,*ret;int len=5;
	cJSON *child=item->child;
   1468c:	e5907000 	ldr	r7, [r0]
	if (*value==']') return value+1;	/* end of array */
	ep=value;return 0;	/* malformed. */
}

/* Render an array to text */
static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p)
   14690:	e24dd014 	sub	sp, sp, #20
	cJSON *child=item->child;
	int numentries=0,i=0,fail=0;
	size_t tmplen=0;
	
	/* How many entries in the array? */
	while (child) numentries++,child=child->next;
   14694:	e3570000 	cmp	r7, #0
	if (*value==']') return value+1;	/* end of array */
	ep=value;return 0;	/* malformed. */
}

/* Render an array to text */
static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p)
   14698:	e1a0b000 	mov	fp, r0
   1469c:	e1a08003 	mov	r8, r3
	cJSON *child=item->child;
	int numentries=0,i=0,fail=0;
	size_t tmplen=0;
	
	/* How many entries in the array? */
	while (child) numentries++,child=child->next;
   146a0:	0a000048 	beq	147c8 <print_array.isra.6+0x140>
   146a4:	e1a09001 	mov	r9, r1
   146a8:	e1a06002 	mov	r6, r2
   146ac:	e3a04000 	mov	r4, #0
   146b0:	ea000000 	b	146b8 <print_array.isra.6+0x30>
   146b4:	e1a04005 	mov	r4, r5
   146b8:	e5977000 	ldr	r7, [r7]
   146bc:	e2845001 	add	r5, r4, #1
   146c0:	e3570000 	cmp	r7, #0
   146c4:	1afffffa 	bne	146b4 <print_array.isra.6+0x2c>
		else	out=(char*)cJSON_malloc(3);
		if (out) strcpy(out,"[]");
		return out;
	}

	if (p)
   146c8:	e3580000 	cmp	r8, #0
   146cc:	0a000075 	beq	148a8 <print_array.isra.6+0x220>
	{
		/* Compose the output array. */
		i=p->offset;
   146d0:	e5983008 	ldr	r3, [r8, #8]
		ptr=ensure(p,1);if (!ptr) return 0;	*ptr='[';	p->offset++;
   146d4:	e1a00008 	mov	r0, r8
   146d8:	e3a01001 	mov	r1, #1
	}

	if (p)
	{
		/* Compose the output array. */
		i=p->offset;
   146dc:	e58d3000 	str	r3, [sp]
		ptr=ensure(p,1);if (!ptr) return 0;	*ptr='[';	p->offset++;
   146e0:	ebfff8ce 	bl	12a20 <ensure>
   146e4:	e3500000 	cmp	r0, #0
   146e8:	0a000056 	beq	14848 <print_array.isra.6+0x1c0>
   146ec:	e3a0305b 	mov	r3, #91	; 0x5b
   146f0:	e5c03000 	strb	r3, [r0]
		child=item->child;
   146f4:	e59b4000 	ldr	r4, [fp]

	if (p)
	{
		/* Compose the output array. */
		i=p->offset;
		ptr=ensure(p,1);if (!ptr) return 0;	*ptr='[';	p->offset++;
   146f8:	e5983008 	ldr	r3, [r8, #8]
		child=item->child;
		while (child && !fail)
   146fc:	e3540000 	cmp	r4, #0

	if (p)
	{
		/* Compose the output array. */
		i=p->offset;
		ptr=ensure(p,1);if (!ptr) return 0;	*ptr='[';	p->offset++;
   14700:	e2833001 	add	r3, r3, #1
   14704:	e5883008 	str	r3, [r8, #8]
   14708:	12899001 	addne	r9, r9, #1
		child=item->child;
		while (child && !fail)
		{
			print_value(child,depth+1,fmt,p);
			p->offset=update(p);
			if (child->next) {len=fmt?2:1;ptr=ensure(p,len+1);if (!ptr) return 0;*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;p->offset+=len;}
   1470c:	13a0502c 	movne	r5, #44	; 0x2c
   14710:	13a0b020 	movne	fp, #32
	{
		/* Compose the output array. */
		i=p->offset;
		ptr=ensure(p,1);if (!ptr) return 0;	*ptr='[';	p->offset++;
		child=item->child;
		while (child && !fail)
   14714:	1a000010 	bne	1475c <print_array.isra.6+0xd4>
   14718:	ea00004d 	b	14854 <print_array.isra.6+0x1cc>
		{
			print_value(child,depth+1,fmt,p);
			p->offset=update(p);
			if (child->next) {len=fmt?2:1;ptr=ensure(p,len+1);if (!ptr) return 0;*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;p->offset+=len;}
   1471c:	e1a00008 	mov	r0, r8
   14720:	e3a01003 	mov	r1, #3
   14724:	ebfff8bd 	bl	12a20 <ensure>
   14728:	e3500000 	cmp	r0, #0
   1472c:	0a000045 	beq	14848 <print_array.isra.6+0x1c0>
   14730:	e1a03000 	mov	r3, r0
   14734:	e3a02002 	mov	r2, #2
   14738:	e4c35002 	strb	r5, [r3], #2
   1473c:	e5c0b001 	strb	fp, [r0, #1]
   14740:	e5c37000 	strb	r7, [r3]
			child=child->next;
   14744:	e5944000 	ldr	r4, [r4]
		child=item->child;
		while (child && !fail)
		{
			print_value(child,depth+1,fmt,p);
			p->offset=update(p);
			if (child->next) {len=fmt?2:1;ptr=ensure(p,len+1);if (!ptr) return 0;*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;p->offset+=len;}
   14748:	e5983008 	ldr	r3, [r8, #8]
	{
		/* Compose the output array. */
		i=p->offset;
		ptr=ensure(p,1);if (!ptr) return 0;	*ptr='[';	p->offset++;
		child=item->child;
		while (child && !fail)
   1474c:	e3540000 	cmp	r4, #0
		{
			print_value(child,depth+1,fmt,p);
			p->offset=update(p);
			if (child->next) {len=fmt?2:1;ptr=ensure(p,len+1);if (!ptr) return 0;*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;p->offset+=len;}
   14750:	e0833002 	add	r3, r3, r2
   14754:	e5883008 	str	r3, [r8, #8]
	{
		/* Compose the output array. */
		i=p->offset;
		ptr=ensure(p,1);if (!ptr) return 0;	*ptr='[';	p->offset++;
		child=item->child;
		while (child && !fail)
   14758:	0a00003d 	beq	14854 <print_array.isra.6+0x1cc>
		{
			print_value(child,depth+1,fmt,p);
   1475c:	e1a00004 	mov	r0, r4
   14760:	e1a01009 	mov	r1, r9
   14764:	e1a02006 	mov	r2, r6
   14768:	e1a03008 	mov	r3, r8
   1476c:	ebffff57 	bl	144d0 <print_value>
}

static int update(printbuffer *p)
{
	char *str;
	if (!p || !p->buffer) return 0;
   14770:	e5980000 	ldr	r0, [r8]
   14774:	e3500000 	cmp	r0, #0
   14778:	0a000003 	beq	1478c <print_array.isra.6+0x104>
	str=p->buffer+p->offset;
   1477c:	e598a008 	ldr	sl, [r8, #8]
	return p->offset+strlen(str);
   14780:	e080000a 	add	r0, r0, sl
   14784:	ebffc25d 	bl	5100 <strlen@plt>
   14788:	e080000a 	add	r0, r0, sl
		child=item->child;
		while (child && !fail)
		{
			print_value(child,depth+1,fmt,p);
			p->offset=update(p);
			if (child->next) {len=fmt?2:1;ptr=ensure(p,len+1);if (!ptr) return 0;*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;p->offset+=len;}
   1478c:	e5943000 	ldr	r3, [r4]
		ptr=ensure(p,1);if (!ptr) return 0;	*ptr='[';	p->offset++;
		child=item->child;
		while (child && !fail)
		{
			print_value(child,depth+1,fmt,p);
			p->offset=update(p);
   14790:	e5880008 	str	r0, [r8, #8]
			if (child->next) {len=fmt?2:1;ptr=ensure(p,len+1);if (!ptr) return 0;*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;p->offset+=len;}
   14794:	e3530000 	cmp	r3, #0
   14798:	0a00002d 	beq	14854 <print_array.isra.6+0x1cc>
   1479c:	e3560000 	cmp	r6, #0
   147a0:	1affffdd 	bne	1471c <print_array.isra.6+0x94>
   147a4:	e1a00008 	mov	r0, r8
   147a8:	e3a01002 	mov	r1, #2
   147ac:	ebfff89b 	bl	12a20 <ensure>
   147b0:	e3500000 	cmp	r0, #0
   147b4:	0a000023 	beq	14848 <print_array.isra.6+0x1c0>
   147b8:	e5c05000 	strb	r5, [r0]
   147bc:	e2803001 	add	r3, r0, #1
   147c0:	e3a02001 	mov	r2, #1
   147c4:	eaffffdd 	b	14740 <print_array.isra.6+0xb8>
	/* How many entries in the array? */
	while (child) numentries++,child=child->next;
	/* Explicitly handle numentries==0 */
	if (!numentries)
	{
		if (p)	out=ensure(p,3);
   147c8:	e3530000 	cmp	r3, #0
   147cc:	0a00002e 	beq	1488c <print_array.isra.6+0x204>
   147d0:	e1a00003 	mov	r0, r3
   147d4:	e3a01003 	mov	r1, #3
   147d8:	ebfff890 	bl	12a20 <ensure>
   147dc:	e1a03000 	mov	r3, r0
		else	out=(char*)cJSON_malloc(3);
		if (out) strcpy(out,"[]");
   147e0:	e2530000 	subs	r0, r3, #0
   147e4:	0a000003 	beq	147f8 <print_array.isra.6+0x170>
   147e8:	e59f1248 	ldr	r1, [pc, #584]	; 14a38 <print_array.isra.6+0x3b0>
   147ec:	e3a02003 	mov	r2, #3
   147f0:	e08f1001 	add	r1, pc, r1
   147f4:	ebffc274 	bl	51cc <memcpy@plt>
		}
		cJSON_free(entries);
		*ptr++=']';*ptr++=0;
	}
	return out;	
}
   147f8:	e28dd014 	add	sp, sp, #20
   147fc:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
   14800:	e59d3008 	ldr	r3, [sp, #8]
   14804:	e243a004 	sub	sl, r3, #4
		if (!out) fail=1;

		/* Handle failure. */
		if (fail)
		{
			for (i=0;i<numentries;i++) if (entries[i]) cJSON_free(entries[i]);
   14808:	e59f622c 	ldr	r6, [pc, #556]	; 14a3c <print_array.isra.6+0x3b4>
		entries=(char**)cJSON_malloc(numentries*sizeof(char*));
		if (!entries) return 0;
		memset(entries,0,numentries*sizeof(char*));
		/* Retrieve all the results: */
		child=item->child;
		while (child && !fail)
   1480c:	e3a04000 	mov	r4, #0
		if (!out) fail=1;

		/* Handle failure. */
		if (fail)
		{
			for (i=0;i<numentries;i++) if (entries[i]) cJSON_free(entries[i]);
   14810:	e08f6006 	add	r6, pc, r6
   14814:	e5ba3004 	ldr	r3, [sl, #4]!
   14818:	e2844001 	add	r4, r4, #1
   1481c:	e2530000 	subs	r0, r3, #0
   14820:	0a000001 	beq	1482c <print_array.isra.6+0x1a4>
   14824:	e5963004 	ldr	r3, [r6, #4]
   14828:	e12fff33 	blx	r3
   1482c:	e1540005 	cmp	r4, r5
   14830:	1afffff7 	bne	14814 <print_array.isra.6+0x18c>
			cJSON_free(entries);
   14834:	e59f3204 	ldr	r3, [pc, #516]	; 14a40 <print_array.isra.6+0x3b8>
   14838:	e59d0008 	ldr	r0, [sp, #8]
   1483c:	e08f3003 	add	r3, pc, r3
   14840:	e5933004 	ldr	r3, [r3, #4]
   14844:	e12fff33 	blx	r3
			return 0;
   14848:	e3a00000 	mov	r0, #0
		}
		cJSON_free(entries);
		*ptr++=']';*ptr++=0;
	}
	return out;	
}
   1484c:	e28dd014 	add	sp, sp, #20
   14850:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
			print_value(child,depth+1,fmt,p);
			p->offset=update(p);
			if (child->next) {len=fmt?2:1;ptr=ensure(p,len+1);if (!ptr) return 0;*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;p->offset+=len;}
			child=child->next;
		}
		ptr=ensure(p,2);if (!ptr) return 0;	*ptr++=']';*ptr=0;
   14854:	e1a00008 	mov	r0, r8
   14858:	e3a01002 	mov	r1, #2
   1485c:	ebfff86f 	bl	12a20 <ensure>
   14860:	e3500000 	cmp	r0, #0
   14864:	0afffff7 	beq	14848 <print_array.isra.6+0x1c0>
   14868:	e3a0205d 	mov	r2, #93	; 0x5d
   1486c:	e3a03000 	mov	r3, #0
   14870:	e5c03001 	strb	r3, [r0, #1]
   14874:	e5c02000 	strb	r2, [r0]
		out=(p->buffer)+i;
   14878:	e59d3000 	ldr	r3, [sp]
   1487c:	e5980000 	ldr	r0, [r8]
   14880:	e0800003 	add	r0, r0, r3
		}
		cJSON_free(entries);
		*ptr++=']';*ptr++=0;
	}
	return out;	
}
   14884:	e28dd014 	add	sp, sp, #20
   14888:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
	while (child) numentries++,child=child->next;
	/* Explicitly handle numentries==0 */
	if (!numentries)
	{
		if (p)	out=ensure(p,3);
		else	out=(char*)cJSON_malloc(3);
   1488c:	e59f31b0 	ldr	r3, [pc, #432]	; 14a44 <print_array.isra.6+0x3bc>
   14890:	e3a00003 	mov	r0, #3
   14894:	e08f3003 	add	r3, pc, r3
   14898:	e5933000 	ldr	r3, [r3]
   1489c:	e12fff33 	blx	r3
   148a0:	e1a03000 	mov	r3, r0
   148a4:	eaffffcd 	b	147e0 <print_array.isra.6+0x158>
		out=(p->buffer)+i;
	}
	else
	{
		/* Allocate an array to hold the values for each */
		entries=(char**)cJSON_malloc(numentries*sizeof(char*));
   148a8:	e59f3198 	ldr	r3, [pc, #408]	; 14a48 <print_array.isra.6+0x3c0>
   148ac:	e1a07105 	lsl	r7, r5, #2
   148b0:	e08f3003 	add	r3, pc, r3
   148b4:	e5933000 	ldr	r3, [r3]
   148b8:	e1a00007 	mov	r0, r7
   148bc:	e12fff33 	blx	r3
		if (!entries) return 0;
   148c0:	e2503000 	subs	r3, r0, #0
   148c4:	e1a0a003 	mov	sl, r3
   148c8:	e58d3008 	str	r3, [sp, #8]
   148cc:	0affffdd 	beq	14848 <print_array.isra.6+0x1c0>
		memset(entries,0,numentries*sizeof(char*));
   148d0:	e1a01008 	mov	r1, r8
   148d4:	e1a02007 	mov	r2, r7
   148d8:	ebffc1fc 	bl	50d0 <memset@plt>
		/* Retrieve all the results: */
		child=item->child;
   148dc:	e59bb000 	ldr	fp, [fp]
		while (child && !fail)
   148e0:	e35b0000 	cmp	fp, #0
   148e4:	0a00004f 	beq	14a28 <print_array.isra.6+0x3a0>
   148e8:	e24aa004 	sub	sl, sl, #4
   148ec:	e2897001 	add	r7, r9, #1
   148f0:	e3a08005 	mov	r8, #5
   148f4:	e1a0900a 	mov	r9, sl
   148f8:	ea000008 	b	14920 <print_array.isra.6+0x298>
		{
			ret=print_value(child,depth+1,fmt,0);
			entries[i++]=ret;
			if (ret) len+=strlen(ret)+2+(fmt?1:0); else fail=1;
   148fc:	ebffc1ff 	bl	5100 <strlen@plt>
   14900:	e3560000 	cmp	r6, #0
			child=child->next;
   14904:	e59bb000 	ldr	fp, [fp]
   14908:	13a03003 	movne	r3, #3
   1490c:	03a03002 	moveq	r3, #2
		entries=(char**)cJSON_malloc(numentries*sizeof(char*));
		if (!entries) return 0;
		memset(entries,0,numentries*sizeof(char*));
		/* Retrieve all the results: */
		child=item->child;
		while (child && !fail)
   14910:	e35b0000 	cmp	fp, #0
   14914:	e0833008 	add	r3, r3, r8
		{
			ret=print_value(child,depth+1,fmt,0);
			entries[i++]=ret;
			if (ret) len+=strlen(ret)+2+(fmt?1:0); else fail=1;
   14918:	e0838000 	add	r8, r3, r0
		entries=(char**)cJSON_malloc(numentries*sizeof(char*));
		if (!entries) return 0;
		memset(entries,0,numentries*sizeof(char*));
		/* Retrieve all the results: */
		child=item->child;
		while (child && !fail)
   1491c:	0a000008 	beq	14944 <print_array.isra.6+0x2bc>
		{
			ret=print_value(child,depth+1,fmt,0);
   14920:	e1a0000b 	mov	r0, fp
   14924:	e1a01007 	mov	r1, r7
   14928:	e1a02006 	mov	r2, r6
   1492c:	e3a03000 	mov	r3, #0
   14930:	ebfffee6 	bl	144d0 <print_value>
			entries[i++]=ret;
			if (ret) len+=strlen(ret)+2+(fmt?1:0); else fail=1;
   14934:	e3500000 	cmp	r0, #0
		/* Retrieve all the results: */
		child=item->child;
		while (child && !fail)
		{
			ret=print_value(child,depth+1,fmt,0);
			entries[i++]=ret;
   14938:	e5a90004 	str	r0, [r9, #4]!
			if (ret) len+=strlen(ret)+2+(fmt?1:0); else fail=1;
   1493c:	1affffee 	bne	148fc <print_array.isra.6+0x274>
   14940:	eaffffb0 	b	14808 <print_array.isra.6+0x180>
   14944:	e1a00008 	mov	r0, r8
			child=child->next;
		}
		
		/* If we didn't fail, try to malloc the output string */
		if (!fail)	out=(char*)cJSON_malloc(len);
   14948:	e59fa0fc 	ldr	sl, [pc, #252]	; 14a4c <print_array.isra.6+0x3c4>
   1494c:	e08fa00a 	add	sl, pc, sl
   14950:	e59a3000 	ldr	r3, [sl]
   14954:	e12fff33 	blx	r3
		/* If that fails, we fail. */
		if (!out) fail=1;
   14958:	e2503000 	subs	r3, r0, #0
   1495c:	e58d300c 	str	r3, [sp, #12]
   14960:	0affffa6 	beq	14800 <print_array.isra.6+0x178>
			cJSON_free(entries);
			return 0;
		}
		
		/* Compose the output array. */
		*out='[';
   14964:	e59d100c 	ldr	r1, [sp, #12]
		ptr=out+1;*ptr=0;
   14968:	e3a03000 	mov	r3, #0
   1496c:	e59d9008 	ldr	r9, [sp, #8]
			cJSON_free(entries);
			return 0;
		}
		
		/* Compose the output array. */
		*out='[';
   14970:	e3a0205b 	mov	r2, #91	; 0x5b
   14974:	e1a07001 	mov	r7, r1
		ptr=out+1;*ptr=0;
		for (i=0;i<numentries;i++)
   14978:	e1a08003 	mov	r8, r3
			cJSON_free(entries);
			return 0;
		}
		
		/* Compose the output array. */
		*out='[';
   1497c:	e4c72001 	strb	r2, [r7], #1
   14980:	e58d5000 	str	r5, [sp]
		ptr=out+1;*ptr=0;
   14984:	e5c13001 	strb	r3, [r1, #1]
   14988:	e58d4004 	str	r4, [sp, #4]
		for (i=0;i<numentries;i++)
		{
			tmplen=strlen(entries[i]);memcpy(ptr,entries[i],tmplen);ptr+=tmplen;
   1498c:	e5995000 	ldr	r5, [r9]
   14990:	e1a04009 	mov	r4, r9
   14994:	e1a00005 	mov	r0, r5
   14998:	ebffc1d8 	bl	5100 <strlen@plt>
   1499c:	e1a01005 	mov	r1, r5
   149a0:	e1a0b000 	mov	fp, r0
   149a4:	e1a0200b 	mov	r2, fp
   149a8:	e1a00007 	mov	r0, r7
   149ac:	ebffc206 	bl	51cc <memcpy@plt>
			if (i!=numentries-1) {*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;}
   149b0:	e59d3004 	ldr	r3, [sp, #4]
   149b4:	e1530008 	cmp	r3, r8
		/* Compose the output array. */
		*out='[';
		ptr=out+1;*ptr=0;
		for (i=0;i<numentries;i++)
		{
			tmplen=strlen(entries[i]);memcpy(ptr,entries[i],tmplen);ptr+=tmplen;
   149b8:	e087300b 	add	r3, r7, fp
			if (i!=numentries-1) {*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;}
   149bc:	0a00001b 	beq	14a30 <print_array.isra.6+0x3a8>
   149c0:	e3560000 	cmp	r6, #0
   149c4:	e3a0202c 	mov	r2, #44	; 0x2c
   149c8:	e7c7200b 	strb	r2, [r7, fp]
   149cc:	13a02020 	movne	r2, #32
   149d0:	e2837002 	add	r7, r3, #2
   149d4:	15c32001 	strbne	r2, [r3, #1]
   149d8:	02837001 	addeq	r7, r3, #1
   149dc:	e3a03000 	mov	r3, #0
   149e0:	e5c73000 	strb	r3, [r7]
			cJSON_free(entries[i]);
   149e4:	e59a3004 	ldr	r3, [sl, #4]
   149e8:	e5940000 	ldr	r0, [r4]
   149ec:	e12fff33 	blx	r3
		}
		
		/* Compose the output array. */
		*out='[';
		ptr=out+1;*ptr=0;
		for (i=0;i<numentries;i++)
   149f0:	e59d3000 	ldr	r3, [sp]
   149f4:	e2888001 	add	r8, r8, #1
   149f8:	e1580003 	cmp	r8, r3
   149fc:	e2899004 	add	r9, r9, #4
   14a00:	1affffe1 	bne	1498c <print_array.isra.6+0x304>
		{
			tmplen=strlen(entries[i]);memcpy(ptr,entries[i],tmplen);ptr+=tmplen;
			if (i!=numentries-1) {*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;}
			cJSON_free(entries[i]);
		}
		cJSON_free(entries);
   14a04:	e59a3004 	ldr	r3, [sl, #4]
   14a08:	e59d0008 	ldr	r0, [sp, #8]
   14a0c:	e12fff33 	blx	r3
		*ptr++=']';*ptr++=0;
   14a10:	e3a0205d 	mov	r2, #93	; 0x5d
   14a14:	e3a03000 	mov	r3, #0
   14a18:	e59d000c 	ldr	r0, [sp, #12]
   14a1c:	e5c72000 	strb	r2, [r7]
   14a20:	e5c73001 	strb	r3, [r7, #1]
   14a24:	eaffff73 	b	147f8 <print_array.isra.6+0x170>
		entries=(char**)cJSON_malloc(numentries*sizeof(char*));
		if (!entries) return 0;
		memset(entries,0,numentries*sizeof(char*));
		/* Retrieve all the results: */
		child=item->child;
		while (child && !fail)
   14a28:	e3a00005 	mov	r0, #5
   14a2c:	eaffffc5 	b	14948 <print_array.isra.6+0x2c0>
		/* Compose the output array. */
		*out='[';
		ptr=out+1;*ptr=0;
		for (i=0;i<numentries;i++)
		{
			tmplen=strlen(entries[i]);memcpy(ptr,entries[i],tmplen);ptr+=tmplen;
   14a30:	e1a07003 	mov	r7, r3
   14a34:	eaffffea 	b	149e4 <print_array.isra.6+0x35c>
   14a38:	0000c490 	.word	0x0000c490
   14a3c:	0000f7ec 	.word	0x0000f7ec
   14a40:	0000f7c0 	.word	0x0000f7c0
   14a44:	0000f768 	.word	0x0000f768
   14a48:	0000f74c 	.word	0x0000f74c
   14a4c:	0000f6b0 	.word	0x0000f6b0

00014a50 <cJSON_GetErrorPtr>:
#include <ctype.h>
#include "cJSON.h"

static const char *ep;

const char *cJSON_GetErrorPtr(void) {return ep;}
   14a50:	e59f3004 	ldr	r3, [pc, #4]	; 14a5c <cJSON_GetErrorPtr+0xc>
   14a54:	e79f0003 	ldr	r0, [pc, r3]
   14a58:	e12fff1e 	bx	lr
   14a5c:	00011dc8 	.word	0x00011dc8

00014a60 <cJSON_InitHooks>:
      memcpy(copy,str,len);
      return copy;
}

void cJSON_InitHooks(cJSON_Hooks* hooks)
{
   14a60:	e59fc078 	ldr	ip, [pc, #120]	; 14ae0 <cJSON_InitHooks+0x80>
    if (!hooks) { /* Reset hooks */
   14a64:	e3500000 	cmp	r0, #0
      memcpy(copy,str,len);
      return copy;
}

void cJSON_InitHooks(cJSON_Hooks* hooks)
{
   14a68:	e08fc00c 	add	ip, pc, ip
    if (!hooks) { /* Reset hooks */
   14a6c:	0a000012 	beq	14abc <cJSON_InitHooks+0x5c>
        cJSON_malloc = malloc;
        cJSON_free = free;
        return;
    }

	cJSON_malloc = (hooks->malloc_fn)?hooks->malloc_fn:malloc;
   14a70:	e5901000 	ldr	r1, [r0]
   14a74:	e3510000 	cmp	r1, #0
   14a78:	0a000009 	beq	14aa4 <cJSON_InitHooks+0x44>
	cJSON_free	 = (hooks->free_fn)?hooks->free_fn:free;
   14a7c:	e5902004 	ldr	r2, [r0, #4]
        cJSON_malloc = malloc;
        cJSON_free = free;
        return;
    }

	cJSON_malloc = (hooks->malloc_fn)?hooks->malloc_fn:malloc;
   14a80:	e59f305c 	ldr	r3, [pc, #92]	; 14ae4 <cJSON_InitHooks+0x84>
	cJSON_free	 = (hooks->free_fn)?hooks->free_fn:free;
   14a84:	e3520000 	cmp	r2, #0
        cJSON_malloc = malloc;
        cJSON_free = free;
        return;
    }

	cJSON_malloc = (hooks->malloc_fn)?hooks->malloc_fn:malloc;
   14a88:	e08f3003 	add	r3, pc, r3
   14a8c:	e5831000 	str	r1, [r3]
	cJSON_free	 = (hooks->free_fn)?hooks->free_fn:free;
   14a90:	0a000006 	beq	14ab0 <cJSON_InitHooks+0x50>
   14a94:	e59f304c 	ldr	r3, [pc, #76]	; 14ae8 <cJSON_InitHooks+0x88>
   14a98:	e08f3003 	add	r3, pc, r3
   14a9c:	e5832004 	str	r2, [r3, #4]
   14aa0:	e12fff1e 	bx	lr
        cJSON_malloc = malloc;
        cJSON_free = free;
        return;
    }

	cJSON_malloc = (hooks->malloc_fn)?hooks->malloc_fn:malloc;
   14aa4:	e59f3040 	ldr	r3, [pc, #64]	; 14aec <cJSON_InitHooks+0x8c>
   14aa8:	e79c1003 	ldr	r1, [ip, r3]
   14aac:	eafffff2 	b	14a7c <cJSON_InitHooks+0x1c>
	cJSON_free	 = (hooks->free_fn)?hooks->free_fn:free;
   14ab0:	e59f3038 	ldr	r3, [pc, #56]	; 14af0 <cJSON_InitHooks+0x90>
   14ab4:	e79c2003 	ldr	r2, [ip, r3]
   14ab8:	eafffff5 	b	14a94 <cJSON_InitHooks+0x34>
}

void cJSON_InitHooks(cJSON_Hooks* hooks)
{
    if (!hooks) { /* Reset hooks */
        cJSON_malloc = malloc;
   14abc:	e59f1028 	ldr	r1, [pc, #40]	; 14aec <cJSON_InitHooks+0x8c>
   14ac0:	e59f302c 	ldr	r3, [pc, #44]	; 14af4 <cJSON_InitHooks+0x94>
        cJSON_free = free;
   14ac4:	e59f2024 	ldr	r2, [pc, #36]	; 14af0 <cJSON_InitHooks+0x90>
}

void cJSON_InitHooks(cJSON_Hooks* hooks)
{
    if (!hooks) { /* Reset hooks */
        cJSON_malloc = malloc;
   14ac8:	e08f3003 	add	r3, pc, r3
   14acc:	e79c1001 	ldr	r1, [ip, r1]
   14ad0:	e5831000 	str	r1, [r3]
        cJSON_free = free;
   14ad4:	e79c2002 	ldr	r2, [ip, r2]
   14ad8:	e5832004 	str	r2, [r3, #4]
        return;
   14adc:	e12fff1e 	bx	lr
   14ae0:	0000f350 	.word	0x0000f350
   14ae4:	0000f574 	.word	0x0000f574
   14ae8:	0000f564 	.word	0x0000f564
   14aec:	ffffffe8 	.word	0xffffffe8
   14af0:	ffffffec 	.word	0xffffffec
   14af4:	0000f534 	.word	0x0000f534

00014af8 <cJSON_Delete>:
	return node;
}

/* Delete a cJSON structure. */
void cJSON_Delete(cJSON *c)
{
   14af8:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
	cJSON *next;
	while (c)
   14afc:	e2504000 	subs	r4, r0, #0
   14b00:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
	{
		next=c->next;
		if (!(c->type&cJSON_IsReference) && c->child) cJSON_Delete(c->child);
		if (!(c->type&cJSON_IsReference) && c->valuestring) cJSON_free(c->valuestring);
   14b04:	e59f809c 	ldr	r8, [pc, #156]	; 14ba8 <cJSON_Delete+0xb0>
		if (!(c->type&cJSON_StringIsConst) && c->string) cJSON_free(c->string);
   14b08:	e59f709c 	ldr	r7, [pc, #156]	; 14bac <cJSON_Delete+0xb4>
		cJSON_free(c);
   14b0c:	e59f609c 	ldr	r6, [pc, #156]	; 14bb0 <cJSON_Delete+0xb8>
	cJSON *next;
	while (c)
	{
		next=c->next;
		if (!(c->type&cJSON_IsReference) && c->child) cJSON_Delete(c->child);
		if (!(c->type&cJSON_IsReference) && c->valuestring) cJSON_free(c->valuestring);
   14b10:	e08f8008 	add	r8, pc, r8
		if (!(c->type&cJSON_StringIsConst) && c->string) cJSON_free(c->string);
   14b14:	e08f7007 	add	r7, pc, r7
		cJSON_free(c);
   14b18:	e08f6006 	add	r6, pc, r6
   14b1c:	ea00000e 	b	14b5c <cJSON_Delete+0x64>
	cJSON *next;
	while (c)
	{
		next=c->next;
		if (!(c->type&cJSON_IsReference) && c->child) cJSON_Delete(c->child);
		if (!(c->type&cJSON_IsReference) && c->valuestring) cJSON_free(c->valuestring);
   14b20:	e5983004 	ldr	r3, [r8, #4]
   14b24:	e12fff33 	blx	r3
   14b28:	e594200c 	ldr	r2, [r4, #12]
		if (!(c->type&cJSON_StringIsConst) && c->string) cJSON_free(c->string);
   14b2c:	e3120c02 	tst	r2, #512	; 0x200
   14b30:	1a000004 	bne	14b48 <cJSON_Delete+0x50>
   14b34:	e5940020 	ldr	r0, [r4, #32]
   14b38:	e3500000 	cmp	r0, #0
   14b3c:	0a000001 	beq	14b48 <cJSON_Delete+0x50>
   14b40:	e5973004 	ldr	r3, [r7, #4]
   14b44:	e12fff33 	blx	r3
		cJSON_free(c);
   14b48:	e1a00004 	mov	r0, r4
   14b4c:	e5963004 	ldr	r3, [r6, #4]
   14b50:	e12fff33 	blx	r3

/* Delete a cJSON structure. */
void cJSON_Delete(cJSON *c)
{
	cJSON *next;
	while (c)
   14b54:	e2554000 	subs	r4, r5, #0
   14b58:	0a000011 	beq	14ba4 <cJSON_Delete+0xac>
	{
		next=c->next;
		if (!(c->type&cJSON_IsReference) && c->child) cJSON_Delete(c->child);
   14b5c:	e594300c 	ldr	r3, [r4, #12]
void cJSON_Delete(cJSON *c)
{
	cJSON *next;
	while (c)
	{
		next=c->next;
   14b60:	e5945000 	ldr	r5, [r4]
		if (!(c->type&cJSON_IsReference) && c->child) cJSON_Delete(c->child);
   14b64:	e3130c01 	tst	r3, #256	; 0x100
   14b68:	e1a02003 	mov	r2, r3
   14b6c:	1affffee 	bne	14b2c <cJSON_Delete+0x34>
   14b70:	e5940008 	ldr	r0, [r4, #8]
   14b74:	e3500000 	cmp	r0, #0
   14b78:	0a000004 	beq	14b90 <cJSON_Delete+0x98>
   14b7c:	ebffffdd 	bl	14af8 <cJSON_Delete>
		if (!(c->type&cJSON_IsReference) && c->valuestring) cJSON_free(c->valuestring);
   14b80:	e594300c 	ldr	r3, [r4, #12]
   14b84:	e3130c01 	tst	r3, #256	; 0x100
   14b88:	e1a02003 	mov	r2, r3
   14b8c:	1affffe6 	bne	14b2c <cJSON_Delete+0x34>
   14b90:	e5940010 	ldr	r0, [r4, #16]
   14b94:	e3500000 	cmp	r0, #0
   14b98:	1affffe0 	bne	14b20 <cJSON_Delete+0x28>
   14b9c:	e1a02003 	mov	r2, r3
   14ba0:	eaffffe1 	b	14b2c <cJSON_Delete+0x34>
   14ba4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
   14ba8:	0000f4ec 	.word	0x0000f4ec
   14bac:	0000f4e8 	.word	0x0000f4e8
   14bb0:	0000f4e4 	.word	0x0000f4e4

00014bb4 <cJSON_ParseWithOpts>:
/* Utility to jump whitespace and cr/lf */
static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}

/* Parse an object - create a new root, and populate. */
cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated)
{
   14bb4:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
   14bb8:	e1a08002 	mov	r8, r2
   14bbc:	e1a04000 	mov	r4, r0
   14bc0:	e1a05001 	mov	r5, r1
	const char *end=0;
	cJSON *c=cJSON_New_Item();
   14bc4:	ebfff787 	bl	129e8 <cJSON_New_Item>
	ep=0;
   14bc8:	e59f30e4 	ldr	r3, [pc, #228]	; 14cb4 <cJSON_ParseWithOpts+0x100>
   14bcc:	e3a02000 	mov	r2, #0
   14bd0:	e08f3003 	add	r3, pc, r3
   14bd4:	e5832000 	str	r2, [r3]
	if (!c) return 0;       /* memory fail */
   14bd8:	e2507000 	subs	r7, r0, #0
   14bdc:	0a00002e 	beq	14c9c <cJSON_ParseWithOpts+0xe8>
static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);
static const char *parse_object(cJSON *item,const char *value);
static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);

/* Utility to jump whitespace and cr/lf */
static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}
   14be0:	e1540002 	cmp	r4, r2
   14be4:	0a00000d 	beq	14c20 <cJSON_ParseWithOpts+0x6c>
   14be8:	e5d43000 	ldrb	r3, [r4]
   14bec:	e2433001 	sub	r3, r3, #1
   14bf0:	e353001f 	cmp	r3, #31
   14bf4:	8a000009 	bhi	14c20 <cJSON_ParseWithOpts+0x6c>
   14bf8:	e2843001 	add	r3, r4, #1
   14bfc:	ea000004 	b	14c14 <cJSON_ParseWithOpts+0x60>
   14c00:	e5d32000 	ldrb	r2, [r3]
   14c04:	e2833001 	add	r3, r3, #1
   14c08:	e2422001 	sub	r2, r2, #1
   14c0c:	e352001f 	cmp	r2, #31
   14c10:	8a000002 	bhi	14c20 <cJSON_ParseWithOpts+0x6c>
   14c14:	e3530000 	cmp	r3, #0
   14c18:	e1a04003 	mov	r4, r3
   14c1c:	1afffff7 	bne	14c00 <cJSON_ParseWithOpts+0x4c>
	const char *end=0;
	cJSON *c=cJSON_New_Item();
	ep=0;
	if (!c) return 0;       /* memory fail */

	end=parse_value(c,skip(value));
   14c20:	e1a01004 	mov	r1, r4
   14c24:	e1a00007 	mov	r0, r7
   14c28:	ebfffa13 	bl	1347c <parse_value>
	if (!end)	{cJSON_Delete(c);return 0;}	/* parse failure. ep is set. */
   14c2c:	e2506000 	subs	r6, r0, #0
   14c30:	0a00001b 	beq	14ca4 <cJSON_ParseWithOpts+0xf0>

	/* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */
	if (require_null_terminated) {end=skip(end);if (*end) {cJSON_Delete(c);ep=end;return 0;}}
   14c34:	e3580000 	cmp	r8, #0
   14c38:	11a02006 	movne	r2, r6
   14c3c:	1a000004 	bne	14c54 <cJSON_ParseWithOpts+0xa0>
	if (return_parse_end) *return_parse_end=end;
   14c40:	e3550000 	cmp	r5, #0
   14c44:	0a000014 	beq	14c9c <cJSON_ParseWithOpts+0xe8>
   14c48:	e5856000 	str	r6, [r5]
   14c4c:	e1a00007 	mov	r0, r7
   14c50:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
   14c54:	e1a06002 	mov	r6, r2
static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);
static const char *parse_object(cJSON *item,const char *value);
static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);

/* Utility to jump whitespace and cr/lf */
static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}
   14c58:	e4d23001 	ldrb	r3, [r2], #1
   14c5c:	e2434001 	sub	r4, r3, #1
   14c60:	e354001f 	cmp	r4, #31
   14c64:	8a000003 	bhi	14c78 <cJSON_ParseWithOpts+0xc4>
   14c68:	e3520000 	cmp	r2, #0
   14c6c:	1afffff8 	bne	14c54 <cJSON_ParseWithOpts+0xa0>

	end=parse_value(c,skip(value));
	if (!end)	{cJSON_Delete(c);return 0;}	/* parse failure. ep is set. */

	/* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */
	if (require_null_terminated) {end=skip(end);if (*end) {cJSON_Delete(c);ep=end;return 0;}}
   14c70:	e5d23000 	ldrb	r3, [r2]
   14c74:	e7f000f0 	udf	#0
   14c78:	e3530000 	cmp	r3, #0
   14c7c:	0affffef 	beq	14c40 <cJSON_ParseWithOpts+0x8c>
   14c80:	e1a00007 	mov	r0, r7
   14c84:	ebffff9b 	bl	14af8 <cJSON_Delete>
   14c88:	e59f3028 	ldr	r3, [pc, #40]	; 14cb8 <cJSON_ParseWithOpts+0x104>
   14c8c:	e3a00000 	mov	r0, #0
   14c90:	e08f3003 	add	r3, pc, r3
   14c94:	e5836000 	str	r6, [r3]
   14c98:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
   14c9c:	e1a00007 	mov	r0, r7
   14ca0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
	cJSON *c=cJSON_New_Item();
	ep=0;
	if (!c) return 0;       /* memory fail */

	end=parse_value(c,skip(value));
	if (!end)	{cJSON_Delete(c);return 0;}	/* parse failure. ep is set. */
   14ca4:	e1a00007 	mov	r0, r7
   14ca8:	ebffff92 	bl	14af8 <cJSON_Delete>
   14cac:	e1a00006 	mov	r0, r6
   14cb0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
   14cb4:	00011c4c 	.word	0x00011c4c
   14cb8:	00011b8c 	.word	0x00011b8c

00014cbc <cJSON_Parse>:
	if (require_null_terminated) {end=skip(end);if (*end) {cJSON_Delete(c);ep=end;return 0;}}
	if (return_parse_end) *return_parse_end=end;
	return c;
}
/* Default options for cJSON_Parse */
cJSON *cJSON_Parse(const char *value) {return cJSON_ParseWithOpts(value,0,0);}
   14cbc:	e3a01000 	mov	r1, #0
   14cc0:	e1a02001 	mov	r2, r1
   14cc4:	eaffffba 	b	14bb4 <cJSON_ParseWithOpts>

00014cc8 <cJSON_Print>:

/* Render a cJSON item/entity/structure to text. */
char *cJSON_Print(cJSON *item)				{return print_value(item,0,1,0);}
   14cc8:	e3a01000 	mov	r1, #0
   14ccc:	e1a03001 	mov	r3, r1
   14cd0:	e3a02001 	mov	r2, #1
   14cd4:	eafffdfd 	b	144d0 <print_value>

00014cd8 <cJSON_PrintUnformatted>:
char *cJSON_PrintUnformatted(cJSON *item)	{return print_value(item,0,0,0);}
   14cd8:	e3a01000 	mov	r1, #0
   14cdc:	e1a02001 	mov	r2, r1
   14ce0:	e1a03001 	mov	r3, r1
   14ce4:	eafffdf9 	b	144d0 <print_value>

00014ce8 <cJSON_PrintBuffered>:

char *cJSON_PrintBuffered(cJSON *item,int prebuffer,int fmt)
{
	printbuffer p;
	p.buffer=(char*)cJSON_malloc(prebuffer);
   14ce8:	e59f3044 	ldr	r3, [pc, #68]	; 14d34 <cJSON_PrintBuffered+0x4c>
/* Render a cJSON item/entity/structure to text. */
char *cJSON_Print(cJSON *item)				{return print_value(item,0,1,0);}
char *cJSON_PrintUnformatted(cJSON *item)	{return print_value(item,0,0,0);}

char *cJSON_PrintBuffered(cJSON *item,int prebuffer,int fmt)
{
   14cec:	e92d4070 	push	{r4, r5, r6, lr}
	printbuffer p;
	p.buffer=(char*)cJSON_malloc(prebuffer);
   14cf0:	e08f3003 	add	r3, pc, r3
/* Render a cJSON item/entity/structure to text. */
char *cJSON_Print(cJSON *item)				{return print_value(item,0,1,0);}
char *cJSON_PrintUnformatted(cJSON *item)	{return print_value(item,0,0,0);}

char *cJSON_PrintBuffered(cJSON *item,int prebuffer,int fmt)
{
   14cf4:	e24dd010 	sub	sp, sp, #16
   14cf8:	e1a05000 	mov	r5, r0
	printbuffer p;
	p.buffer=(char*)cJSON_malloc(prebuffer);
   14cfc:	e5933000 	ldr	r3, [r3]
   14d00:	e1a00001 	mov	r0, r1
/* Render a cJSON item/entity/structure to text. */
char *cJSON_Print(cJSON *item)				{return print_value(item,0,1,0);}
char *cJSON_PrintUnformatted(cJSON *item)	{return print_value(item,0,0,0);}

char *cJSON_PrintBuffered(cJSON *item,int prebuffer,int fmt)
{
   14d04:	e1a04001 	mov	r4, r1
   14d08:	e1a06002 	mov	r6, r2
	printbuffer p;
	p.buffer=(char*)cJSON_malloc(prebuffer);
   14d0c:	e12fff33 	blx	r3
	p.length=prebuffer;
	p.offset=0;
   14d10:	e3a0c000 	mov	ip, #0
	return print_value(item,0,fmt,&p);
   14d14:	e1a02006 	mov	r2, r6
   14d18:	e1a0100c 	mov	r1, ip
   14d1c:	e28d3004 	add	r3, sp, #4
char *cJSON_PrintUnformatted(cJSON *item)	{return print_value(item,0,0,0);}

char *cJSON_PrintBuffered(cJSON *item,int prebuffer,int fmt)
{
	printbuffer p;
	p.buffer=(char*)cJSON_malloc(prebuffer);
   14d20:	e98d1011 	stmib	sp, {r0, r4, ip}
	p.length=prebuffer;
	p.offset=0;
	return print_value(item,0,fmt,&p);
   14d24:	e1a00005 	mov	r0, r5
   14d28:	ebfffde8 	bl	144d0 <print_value>
	return p.buffer;
}
   14d2c:	e28dd010 	add	sp, sp, #16
   14d30:	e8bd8070 	pop	{r4, r5, r6, pc}
   14d34:	0000f30c 	.word	0x0000f30c

00014d38 <cJSON_GetArraySize>:
	}
	return out;	
}

/* Get Array size/item / object item. */
int    cJSON_GetArraySize(cJSON *array)							{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}
   14d38:	e5903008 	ldr	r3, [r0, #8]
   14d3c:	e3530000 	cmp	r3, #0
   14d40:	0a000005 	beq	14d5c <cJSON_GetArraySize+0x24>
   14d44:	e3a00000 	mov	r0, #0
   14d48:	e5933000 	ldr	r3, [r3]
   14d4c:	e2800001 	add	r0, r0, #1
   14d50:	e3530000 	cmp	r3, #0
   14d54:	1afffffb 	bne	14d48 <cJSON_GetArraySize+0x10>
   14d58:	e12fff1e 	bx	lr
   14d5c:	e1a00003 	mov	r0, r3
   14d60:	e12fff1e 	bx	lr

00014d64 <cJSON_GetArrayItem>:
cJSON *cJSON_GetArrayItem(cJSON *array,int item)				{cJSON *c=array->child;  while (c && item>0) item--,c=c->next; return c;}
   14d64:	e5900008 	ldr	r0, [r0, #8]
   14d68:	e3500000 	cmp	r0, #0
   14d6c:	13510000 	cmpne	r1, #0
   14d70:	d12fff1e 	bxle	lr
   14d74:	e5900000 	ldr	r0, [r0]
   14d78:	e2411001 	sub	r1, r1, #1
   14d7c:	e3500000 	cmp	r0, #0
   14d80:	13510000 	cmpne	r1, #0
   14d84:	cafffffa 	bgt	14d74 <cJSON_GetArrayItem+0x10>
   14d88:	e12fff1e 	bx	lr

00014d8c <cJSON_GetObjectItem>:
cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)	{cJSON *c=object->child; while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}
   14d8c:	e92d4038 	push	{r3, r4, r5, lr}
   14d90:	e5904008 	ldr	r4, [r0, #8]
   14d94:	e1a05001 	mov	r5, r1
   14d98:	e3540000 	cmp	r4, #0
   14d9c:	1a000003 	bne	14db0 <cJSON_GetObjectItem+0x24>
   14da0:	ea000007 	b	14dc4 <cJSON_GetObjectItem+0x38>
   14da4:	e5944000 	ldr	r4, [r4]
   14da8:	e3540000 	cmp	r4, #0
   14dac:	0a000004 	beq	14dc4 <cJSON_GetObjectItem+0x38>
   14db0:	e5940020 	ldr	r0, [r4, #32]
   14db4:	e1a01005 	mov	r1, r5
   14db8:	ebfff8b6 	bl	13098 <cJSON_strcasecmp>
   14dbc:	e3500000 	cmp	r0, #0
   14dc0:	1afffff7 	bne	14da4 <cJSON_GetObjectItem+0x18>
   14dc4:	e1a00004 	mov	r0, r4
   14dc8:	e8bd8038 	pop	{r3, r4, r5, pc}

00014dcc <cJSON_AddItemToArray>:
static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}
/* Utility for handling references. */
static cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}

/* Add item to array/object. */
void   cJSON_AddItemToArray(cJSON *array, cJSON *item)						{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}
   14dcc:	e3510000 	cmp	r1, #0
   14dd0:	e5902008 	ldr	r2, [r0, #8]
   14dd4:	012fff1e 	bxeq	lr
   14dd8:	e3520000 	cmp	r2, #0
   14ddc:	05801008 	streq	r1, [r0, #8]
   14de0:	1a000001 	bne	14dec <cJSON_AddItemToArray+0x20>
   14de4:	ea000006 	b	14e04 <cJSON_AddItemToArray+0x38>
   14de8:	e1a02003 	mov	r2, r3
   14dec:	e5923000 	ldr	r3, [r2]
   14df0:	e3530000 	cmp	r3, #0
   14df4:	1afffffb 	bne	14de8 <cJSON_AddItemToArray+0x1c>
int    cJSON_GetArraySize(cJSON *array)							{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}
cJSON *cJSON_GetArrayItem(cJSON *array,int item)				{cJSON *c=array->child;  while (c && item>0) item--,c=c->next; return c;}
cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)	{cJSON *c=object->child; while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}

/* Utility for array list handling. */
static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}
   14df8:	e5821000 	str	r1, [r2]
   14dfc:	e5812004 	str	r2, [r1, #4]
   14e00:	e12fff1e 	bx	lr
   14e04:	e12fff1e 	bx	lr

00014e08 <cJSON_AddItemToObject>:
/* Utility for handling references. */
static cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}

/* Add item to array/object. */
void   cJSON_AddItemToArray(cJSON *array, cJSON *item)						{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}
void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}
   14e08:	e3520000 	cmp	r2, #0
   14e0c:	012fff1e 	bxeq	lr
   14e10:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
   14e14:	e1a07000 	mov	r7, r0
   14e18:	e5920020 	ldr	r0, [r2, #32]
   14e1c:	e1a06001 	mov	r6, r1
   14e20:	e3500000 	cmp	r0, #0
   14e24:	e1a04002 	mov	r4, r2
   14e28:	0a000003 	beq	14e3c <cJSON_AddItemToObject+0x34>
   14e2c:	e59f5050 	ldr	r5, [pc, #80]	; 14e84 <cJSON_AddItemToObject+0x7c>
   14e30:	e08f5005 	add	r5, pc, r5
   14e34:	e5953004 	ldr	r3, [r5, #4]
   14e38:	e12fff33 	blx	r3
static char* cJSON_strdup(const char* str)
{
      size_t len;
      char* copy;

      len = strlen(str) + 1;
   14e3c:	e1a00006 	mov	r0, r6
   14e40:	ebffc0ae 	bl	5100 <strlen@plt>
      if (!(copy = (char*)cJSON_malloc(len))) return 0;
   14e44:	e59f303c 	ldr	r3, [pc, #60]	; 14e88 <cJSON_AddItemToObject+0x80>
   14e48:	e08f3003 	add	r3, pc, r3
   14e4c:	e5933000 	ldr	r3, [r3]
static char* cJSON_strdup(const char* str)
{
      size_t len;
      char* copy;

      len = strlen(str) + 1;
   14e50:	e2805001 	add	r5, r0, #1
      if (!(copy = (char*)cJSON_malloc(len))) return 0;
   14e54:	e1a00005 	mov	r0, r5
   14e58:	e12fff33 	blx	r3
   14e5c:	e2508000 	subs	r8, r0, #0
   14e60:	0a000002 	beq	14e70 <cJSON_AddItemToObject+0x68>
      memcpy(copy,str,len);
   14e64:	e1a01006 	mov	r1, r6
   14e68:	e1a02005 	mov	r2, r5
   14e6c:	ebffc0d6 	bl	51cc <memcpy@plt>
/* Utility for handling references. */
static cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}

/* Add item to array/object. */
void   cJSON_AddItemToArray(cJSON *array, cJSON *item)						{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}
void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}
   14e70:	e5848020 	str	r8, [r4, #32]
   14e74:	e1a00007 	mov	r0, r7
   14e78:	e1a01004 	mov	r1, r4
   14e7c:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
   14e80:	eaffffd1 	b	14dcc <cJSON_AddItemToArray>
   14e84:	0000f1cc 	.word	0x0000f1cc
   14e88:	0000f1b4 	.word	0x0000f1b4

00014e8c <cJSON_AddItemToObjectCS>:
void   cJSON_AddItemToObjectCS(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (!(item->type&cJSON_StringIsConst) && item->string) cJSON_free(item->string);item->string=(char*)string;item->type|=cJSON_StringIsConst;cJSON_AddItemToArray(object,item);}
   14e8c:	e3520000 	cmp	r2, #0
   14e90:	012fff1e 	bxeq	lr
   14e94:	e592300c 	ldr	r3, [r2, #12]
   14e98:	e92d4070 	push	{r4, r5, r6, lr}
   14e9c:	e3130c02 	tst	r3, #512	; 0x200
   14ea0:	e1a06001 	mov	r6, r1
   14ea4:	e1a05000 	mov	r5, r0
   14ea8:	e1a04002 	mov	r4, r2
   14eac:	1a000007 	bne	14ed0 <cJSON_AddItemToObjectCS+0x44>
   14eb0:	e5920020 	ldr	r0, [r2, #32]
   14eb4:	e3500000 	cmp	r0, #0
   14eb8:	0a000004 	beq	14ed0 <cJSON_AddItemToObjectCS+0x44>
   14ebc:	e59f3028 	ldr	r3, [pc, #40]	; 14eec <cJSON_AddItemToObjectCS+0x60>
   14ec0:	e08f3003 	add	r3, pc, r3
   14ec4:	e5933004 	ldr	r3, [r3, #4]
   14ec8:	e12fff33 	blx	r3
   14ecc:	e594300c 	ldr	r3, [r4, #12]
   14ed0:	e3833c02 	orr	r3, r3, #512	; 0x200
   14ed4:	e584300c 	str	r3, [r4, #12]
   14ed8:	e5846020 	str	r6, [r4, #32]
   14edc:	e1a00005 	mov	r0, r5
   14ee0:	e1a01004 	mov	r1, r4
   14ee4:	e8bd4070 	pop	{r4, r5, r6, lr}
   14ee8:	eaffffb7 	b	14dcc <cJSON_AddItemToArray>
   14eec:	0000f13c 	.word	0x0000f13c

00014ef0 <cJSON_AddItemReferenceToArray>:
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(void)
{
	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
   14ef0:	e59f3068 	ldr	r3, [pc, #104]	; 14f60 <cJSON_AddItemReferenceToArray+0x70>

/* Add item to array/object. */
void   cJSON_AddItemToArray(cJSON *array, cJSON *item)						{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}
void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}
void   cJSON_AddItemToObjectCS(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (!(item->type&cJSON_StringIsConst) && item->string) cJSON_free(item->string);item->string=(char*)string;item->type|=cJSON_StringIsConst;cJSON_AddItemToArray(object,item);}
void	cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)						{cJSON_AddItemToArray(array,create_reference(item));}
   14ef4:	e92d4070 	push	{r4, r5, r6, lr}
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(void)
{
	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
   14ef8:	e08f3003 	add	r3, pc, r3

/* Add item to array/object. */
void   cJSON_AddItemToArray(cJSON *array, cJSON *item)						{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}
void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}
void   cJSON_AddItemToObjectCS(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (!(item->type&cJSON_StringIsConst) && item->string) cJSON_free(item->string);item->string=(char*)string;item->type|=cJSON_StringIsConst;cJSON_AddItemToArray(object,item);}
void	cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)						{cJSON_AddItemToArray(array,create_reference(item));}
   14efc:	e1a05000 	mov	r5, r0
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(void)
{
	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
   14f00:	e5933000 	ldr	r3, [r3]
   14f04:	e3a00028 	mov	r0, #40	; 0x28

/* Add item to array/object. */
void   cJSON_AddItemToArray(cJSON *array, cJSON *item)						{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}
void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}
void   cJSON_AddItemToObjectCS(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (!(item->type&cJSON_StringIsConst) && item->string) cJSON_free(item->string);item->string=(char*)string;item->type|=cJSON_StringIsConst;cJSON_AddItemToArray(object,item);}
void	cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)						{cJSON_AddItemToArray(array,create_reference(item));}
   14f08:	e1a06001 	mov	r6, r1
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(void)
{
	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
   14f0c:	e12fff33 	blx	r3
	if (node) memset(node,0,sizeof(cJSON));
   14f10:	e2504000 	subs	r4, r0, #0
   14f14:	0a00000d 	beq	14f50 <cJSON_AddItemReferenceToArray+0x60>
   14f18:	e3a01000 	mov	r1, #0
   14f1c:	e3a02028 	mov	r2, #40	; 0x28
   14f20:	ebffc06a 	bl	50d0 <memset@plt>
cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)	{cJSON *c=object->child; while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}

/* Utility for array list handling. */
static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}
/* Utility for handling references. */
static cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}
   14f24:	e3a02028 	mov	r2, #40	; 0x28
   14f28:	e1a00004 	mov	r0, r4
   14f2c:	e1a01006 	mov	r1, r6
   14f30:	ebffc0a5 	bl	51cc <memcpy@plt>
   14f34:	e594200c 	ldr	r2, [r4, #12]
   14f38:	e3a03000 	mov	r3, #0
   14f3c:	e3822c01 	orr	r2, r2, #256	; 0x100
   14f40:	e584200c 	str	r2, [r4, #12]
   14f44:	e5843020 	str	r3, [r4, #32]
   14f48:	e5843004 	str	r3, [r4, #4]
   14f4c:	e5843000 	str	r3, [r4]

/* Add item to array/object. */
void   cJSON_AddItemToArray(cJSON *array, cJSON *item)						{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}
void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}
void   cJSON_AddItemToObjectCS(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (!(item->type&cJSON_StringIsConst) && item->string) cJSON_free(item->string);item->string=(char*)string;item->type|=cJSON_StringIsConst;cJSON_AddItemToArray(object,item);}
void	cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)						{cJSON_AddItemToArray(array,create_reference(item));}
   14f50:	e1a00005 	mov	r0, r5
   14f54:	e1a01004 	mov	r1, r4
   14f58:	e8bd4070 	pop	{r4, r5, r6, lr}
   14f5c:	eaffff9a 	b	14dcc <cJSON_AddItemToArray>
   14f60:	0000f104 	.word	0x0000f104

00014f64 <cJSON_AddItemReferenceToObject>:
void	cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item)	{cJSON_AddItemToObject(object,string,create_reference(item));}
   14f64:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(void)
{
	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
   14f68:	e59f306c 	ldr	r3, [pc, #108]	; 14fdc <cJSON_AddItemReferenceToObject+0x78>
/* Add item to array/object. */
void   cJSON_AddItemToArray(cJSON *array, cJSON *item)						{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}
void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}
void   cJSON_AddItemToObjectCS(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (!(item->type&cJSON_StringIsConst) && item->string) cJSON_free(item->string);item->string=(char*)string;item->type|=cJSON_StringIsConst;cJSON_AddItemToArray(object,item);}
void	cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)						{cJSON_AddItemToArray(array,create_reference(item));}
void	cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item)	{cJSON_AddItemToObject(object,string,create_reference(item));}
   14f6c:	e1a06000 	mov	r6, r0
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(void)
{
	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
   14f70:	e08f3003 	add	r3, pc, r3
   14f74:	e5933000 	ldr	r3, [r3]
   14f78:	e3a00028 	mov	r0, #40	; 0x28
/* Add item to array/object. */
void   cJSON_AddItemToArray(cJSON *array, cJSON *item)						{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}
void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}
void   cJSON_AddItemToObjectCS(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (!(item->type&cJSON_StringIsConst) && item->string) cJSON_free(item->string);item->string=(char*)string;item->type|=cJSON_StringIsConst;cJSON_AddItemToArray(object,item);}
void	cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)						{cJSON_AddItemToArray(array,create_reference(item));}
void	cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item)	{cJSON_AddItemToObject(object,string,create_reference(item));}
   14f7c:	e1a05001 	mov	r5, r1
   14f80:	e1a07002 	mov	r7, r2
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(void)
{
	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
   14f84:	e12fff33 	blx	r3
	if (node) memset(node,0,sizeof(cJSON));
   14f88:	e2504000 	subs	r4, r0, #0
   14f8c:	0a00000d 	beq	14fc8 <cJSON_AddItemReferenceToObject+0x64>
   14f90:	e3a01000 	mov	r1, #0
   14f94:	e3a02028 	mov	r2, #40	; 0x28
   14f98:	ebffc04c 	bl	50d0 <memset@plt>
cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)	{cJSON *c=object->child; while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}

/* Utility for array list handling. */
static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}
/* Utility for handling references. */
static cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}
   14f9c:	e3a02028 	mov	r2, #40	; 0x28
   14fa0:	e1a00004 	mov	r0, r4
   14fa4:	e1a01007 	mov	r1, r7
   14fa8:	ebffc087 	bl	51cc <memcpy@plt>
   14fac:	e594200c 	ldr	r2, [r4, #12]
   14fb0:	e3a03000 	mov	r3, #0
   14fb4:	e3822c01 	orr	r2, r2, #256	; 0x100
   14fb8:	e584200c 	str	r2, [r4, #12]
   14fbc:	e5843020 	str	r3, [r4, #32]
   14fc0:	e5843004 	str	r3, [r4, #4]
   14fc4:	e5843000 	str	r3, [r4]
/* Add item to array/object. */
void   cJSON_AddItemToArray(cJSON *array, cJSON *item)						{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}
void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}
void   cJSON_AddItemToObjectCS(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (!(item->type&cJSON_StringIsConst) && item->string) cJSON_free(item->string);item->string=(char*)string;item->type|=cJSON_StringIsConst;cJSON_AddItemToArray(object,item);}
void	cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)						{cJSON_AddItemToArray(array,create_reference(item));}
void	cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item)	{cJSON_AddItemToObject(object,string,create_reference(item));}
   14fc8:	e1a00006 	mov	r0, r6
   14fcc:	e1a01005 	mov	r1, r5
   14fd0:	e1a02004 	mov	r2, r4
   14fd4:	e8bd40f8 	pop	{r3, r4, r5, r6, r7, lr}
   14fd8:	eaffff8a 	b	14e08 <cJSON_AddItemToObject>
   14fdc:	0000f08c 	.word	0x0000f08c

00014fe0 <cJSON_DetachItemFromArray>:

cJSON *cJSON_DetachItemFromArray(cJSON *array,int which)			{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return 0;
   14fe0:	e5902008 	ldr	r2, [r0, #8]
   14fe4:	e3520000 	cmp	r2, #0
   14fe8:	13510000 	cmpne	r1, #0
   14fec:	e1a03002 	mov	r3, r2
   14ff0:	da000004 	ble	15008 <cJSON_DetachItemFromArray+0x28>
   14ff4:	e5933000 	ldr	r3, [r3]
   14ff8:	e2411001 	sub	r1, r1, #1
   14ffc:	e3530000 	cmp	r3, #0
   15000:	13510000 	cmpne	r1, #0
   15004:	cafffffa 	bgt	14ff4 <cJSON_DetachItemFromArray+0x14>
   15008:	e3530000 	cmp	r3, #0
   1500c:	0a00000b 	beq	15040 <cJSON_DetachItemFromArray+0x60>
	if (c->prev) c->prev->next=c->next;if (c->next) c->next->prev=c->prev;if (c==array->child) array->child=c->next;c->prev=c->next=0;return c;}
   15010:	e5931004 	ldr	r1, [r3, #4]
   15014:	e3510000 	cmp	r1, #0
   15018:	1593c000 	ldrne	ip, [r3]
   1501c:	1581c000 	strne	ip, [r1]
   15020:	e593c000 	ldr	ip, [r3]
   15024:	e35c0000 	cmp	ip, #0
   15028:	158c1004 	strne	r1, [ip, #4]
   1502c:	e1530002 	cmp	r3, r2
   15030:	e3a02000 	mov	r2, #0
   15034:	0580c008 	streq	ip, [r0, #8]
   15038:	e5832000 	str	r2, [r3]
   1503c:	e5832004 	str	r2, [r3, #4]
   15040:	e1a00003 	mov	r0, r3
   15044:	e12fff1e 	bx	lr

00015048 <cJSON_DeleteItemFromArray>:
void   cJSON_DeleteItemFromArray(cJSON *array,int which)			{cJSON_Delete(cJSON_DetachItemFromArray(array,which));}
   15048:	e92d4008 	push	{r3, lr}
   1504c:	ebffffe3 	bl	14fe0 <cJSON_DetachItemFromArray>
   15050:	e8bd4008 	pop	{r3, lr}
   15054:	eafffea7 	b	14af8 <cJSON_Delete>

00015058 <cJSON_DetachItemFromObject>:
cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string) {int i=0;cJSON *c=object->child;while (c && cJSON_strcasecmp(c->string,string)) i++,c=c->next;if (c) return cJSON_DetachItemFromArray(object,i);return 0;}
   15058:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
   1505c:	e5904008 	ldr	r4, [r0, #8]
   15060:	e3540000 	cmp	r4, #0
   15064:	11a06001 	movne	r6, r1
   15068:	11a07000 	movne	r7, r0
   1506c:	13a05000 	movne	r5, #0
   15070:	1a000004 	bne	15088 <cJSON_DetachItemFromObject+0x30>
   15074:	ea00000c 	b	150ac <cJSON_DetachItemFromObject+0x54>
   15078:	e5944000 	ldr	r4, [r4]
   1507c:	e2855001 	add	r5, r5, #1
   15080:	e3540000 	cmp	r4, #0
   15084:	0a000008 	beq	150ac <cJSON_DetachItemFromObject+0x54>
   15088:	e5940020 	ldr	r0, [r4, #32]
   1508c:	e1a01006 	mov	r1, r6
   15090:	ebfff800 	bl	13098 <cJSON_strcasecmp>
   15094:	e3500000 	cmp	r0, #0
   15098:	1afffff6 	bne	15078 <cJSON_DetachItemFromObject+0x20>
   1509c:	e1a00007 	mov	r0, r7
   150a0:	e1a01005 	mov	r1, r5
   150a4:	e8bd40f8 	pop	{r3, r4, r5, r6, r7, lr}
   150a8:	eaffffcc 	b	14fe0 <cJSON_DetachItemFromArray>
   150ac:	e3a00000 	mov	r0, #0
   150b0:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

000150b4 <cJSON_DeleteItemFromObject>:
void   cJSON_DeleteItemFromObject(cJSON *object,const char *string) {cJSON_Delete(cJSON_DetachItemFromObject(object,string));}
   150b4:	e92d4008 	push	{r3, lr}
   150b8:	ebffffe6 	bl	15058 <cJSON_DetachItemFromObject>
   150bc:	e8bd4008 	pop	{r3, lr}
   150c0:	eafffe8c 	b	14af8 <cJSON_Delete>

000150c4 <cJSON_InsertItemInArray>:

/* Replace array/object items with new ones. */
void   cJSON_InsertItemInArray(cJSON *array,int which,cJSON *newitem)		{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) {cJSON_AddItemToArray(array,newitem);return;}
   150c4:	e590c008 	ldr	ip, [r0, #8]
   150c8:	e35c0000 	cmp	ip, #0
   150cc:	13510000 	cmpne	r1, #0
   150d0:	da000011 	ble	1511c <cJSON_InsertItemInArray+0x58>
   150d4:	e1a0300c 	mov	r3, ip
   150d8:	e5933000 	ldr	r3, [r3]
   150dc:	e2411001 	sub	r1, r1, #1
   150e0:	e3530000 	cmp	r3, #0
   150e4:	13510000 	cmpne	r1, #0
   150e8:	cafffffa 	bgt	150d8 <cJSON_InsertItemInArray+0x14>
   150ec:	e3530000 	cmp	r3, #0
   150f0:	0a000010 	beq	15138 <cJSON_InsertItemInArray+0x74>
	newitem->next=c;newitem->prev=c->prev;c->prev=newitem;if (c==array->child) array->child=newitem; else newitem->prev->next=newitem;}
   150f4:	e5931004 	ldr	r1, [r3, #4]
   150f8:	e15c0003 	cmp	ip, r3
   150fc:	e5823000 	str	r3, [r2]
   15100:	e5821004 	str	r1, [r2, #4]
   15104:	e5832004 	str	r2, [r3, #4]
   15108:	15923004 	ldrne	r3, [r2, #4]
   1510c:	15832000 	strne	r2, [r3]
   15110:	112fff1e 	bxne	lr
   15114:	e5802008 	str	r2, [r0, #8]
   15118:	e12fff1e 	bx	lr
void   cJSON_DeleteItemFromArray(cJSON *array,int which)			{cJSON_Delete(cJSON_DetachItemFromArray(array,which));}
cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string) {int i=0;cJSON *c=object->child;while (c && cJSON_strcasecmp(c->string,string)) i++,c=c->next;if (c) return cJSON_DetachItemFromArray(object,i);return 0;}
void   cJSON_DeleteItemFromObject(cJSON *object,const char *string) {cJSON_Delete(cJSON_DetachItemFromObject(object,string));}

/* Replace array/object items with new ones. */
void   cJSON_InsertItemInArray(cJSON *array,int which,cJSON *newitem)		{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) {cJSON_AddItemToArray(array,newitem);return;}
   1511c:	e35c0000 	cmp	ip, #0
   15120:	0a000004 	beq	15138 <cJSON_InsertItemInArray+0x74>
	newitem->next=c;newitem->prev=c->prev;c->prev=newitem;if (c==array->child) array->child=newitem; else newitem->prev->next=newitem;}
   15124:	e59c3004 	ldr	r3, [ip, #4]
   15128:	e5823004 	str	r3, [r2, #4]
   1512c:	e582c000 	str	ip, [r2]
   15130:	e58c2004 	str	r2, [ip, #4]
   15134:	eafffff6 	b	15114 <cJSON_InsertItemInArray+0x50>
void   cJSON_DeleteItemFromArray(cJSON *array,int which)			{cJSON_Delete(cJSON_DetachItemFromArray(array,which));}
cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string) {int i=0;cJSON *c=object->child;while (c && cJSON_strcasecmp(c->string,string)) i++,c=c->next;if (c) return cJSON_DetachItemFromArray(object,i);return 0;}
void   cJSON_DeleteItemFromObject(cJSON *object,const char *string) {cJSON_Delete(cJSON_DetachItemFromObject(object,string));}

/* Replace array/object items with new ones. */
void   cJSON_InsertItemInArray(cJSON *array,int which,cJSON *newitem)		{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) {cJSON_AddItemToArray(array,newitem);return;}
   15138:	e1a01002 	mov	r1, r2
   1513c:	eaffff22 	b	14dcc <cJSON_AddItemToArray>

00015140 <cJSON_ReplaceItemInArray>:
	newitem->next=c;newitem->prev=c->prev;c->prev=newitem;if (c==array->child) array->child=newitem; else newitem->prev->next=newitem;}
void   cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem)		{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return;
   15140:	e590c008 	ldr	ip, [r0, #8]
   15144:	e35c0000 	cmp	ip, #0
   15148:	13510000 	cmpne	r1, #0
   1514c:	e1a0300c 	mov	r3, ip
   15150:	da000004 	ble	15168 <cJSON_ReplaceItemInArray+0x28>
   15154:	e5933000 	ldr	r3, [r3]
   15158:	e2411001 	sub	r1, r1, #1
   1515c:	e3530000 	cmp	r3, #0
   15160:	13510000 	cmpne	r1, #0
   15164:	cafffffa 	bgt	15154 <cJSON_ReplaceItemInArray+0x14>
   15168:	e3530000 	cmp	r3, #0
   1516c:	012fff1e 	bxeq	lr
   15170:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	newitem->next=c->next;newitem->prev=c->prev;if (newitem->next) newitem->next->prev=newitem;
   15174:	e8934002 	ldm	r3, {r1, lr}
   15178:	e3510000 	cmp	r1, #0
   1517c:	e8824002 	stm	r2, {r1, lr}
   15180:	15812004 	strne	r2, [r1, #4]
	if (c==array->child) array->child=newitem; else newitem->prev->next=newitem;c->next=c->prev=0;cJSON_Delete(c);}
   15184:	e153000c 	cmp	r3, ip
   15188:	15921004 	ldrne	r1, [r2, #4]
   1518c:	05802008 	streq	r2, [r0, #8]
   15190:	15812000 	strne	r2, [r1]
   15194:	e3a02000 	mov	r2, #0
   15198:	e5832004 	str	r2, [r3, #4]
   1519c:	e5832000 	str	r2, [r3]
   151a0:	e1a00003 	mov	r0, r3
   151a4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
   151a8:	eafffe52 	b	14af8 <cJSON_Delete>

000151ac <cJSON_ReplaceItemInObject>:
void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}
   151ac:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
   151b0:	e5904008 	ldr	r4, [r0, #8]
   151b4:	e3540000 	cmp	r4, #0
   151b8:	0a000016 	beq	15218 <cJSON_ReplaceItemInObject+0x6c>
   151bc:	e1a08002 	mov	r8, r2
   151c0:	e1a06001 	mov	r6, r1
   151c4:	e1a07000 	mov	r7, r0
   151c8:	e3a05000 	mov	r5, #0
   151cc:	ea000003 	b	151e0 <cJSON_ReplaceItemInObject+0x34>
   151d0:	e5944000 	ldr	r4, [r4]
   151d4:	e2855001 	add	r5, r5, #1
   151d8:	e3540000 	cmp	r4, #0
   151dc:	0a00000c 	beq	15214 <cJSON_ReplaceItemInObject+0x68>
   151e0:	e5940020 	ldr	r0, [r4, #32]
   151e4:	e1a01006 	mov	r1, r6
   151e8:	ebfff7aa 	bl	13098 <cJSON_strcasecmp>
   151ec:	e3500000 	cmp	r0, #0
   151f0:	1afffff6 	bne	151d0 <cJSON_ReplaceItemInObject+0x24>
   151f4:	e1a00006 	mov	r0, r6
   151f8:	ebfff638 	bl	12ae0 <cJSON_strdup>
   151fc:	e1a01005 	mov	r1, r5
   15200:	e1a02008 	mov	r2, r8
   15204:	e5880020 	str	r0, [r8, #32]
   15208:	e1a00007 	mov	r0, r7
   1520c:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
   15210:	eaffffca 	b	15140 <cJSON_ReplaceItemInArray>
   15214:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
   15218:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

0001521c <cJSON_CreateNull>:
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(void)
{
	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
   1521c:	e59f3034 	ldr	r3, [pc, #52]	; 15258 <cJSON_CreateNull+0x3c>
	newitem->next=c->next;newitem->prev=c->prev;if (newitem->next) newitem->next->prev=newitem;
	if (c==array->child) array->child=newitem; else newitem->prev->next=newitem;c->next=c->prev=0;cJSON_Delete(c);}
void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}

/* Create basic types: */
cJSON *cJSON_CreateNull(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}
   15220:	e92d4010 	push	{r4, lr}
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(void)
{
	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
   15224:	e08f3003 	add	r3, pc, r3
   15228:	e3a00028 	mov	r0, #40	; 0x28
   1522c:	e5933000 	ldr	r3, [r3]
   15230:	e12fff33 	blx	r3
	if (node) memset(node,0,sizeof(cJSON));
   15234:	e2504000 	subs	r4, r0, #0
   15238:	0a000004 	beq	15250 <cJSON_CreateNull+0x34>
   1523c:	e3a01000 	mov	r1, #0
   15240:	e3a02028 	mov	r2, #40	; 0x28
   15244:	ebffbfa1 	bl	50d0 <memset@plt>
	newitem->next=c->next;newitem->prev=c->prev;if (newitem->next) newitem->next->prev=newitem;
	if (c==array->child) array->child=newitem; else newitem->prev->next=newitem;c->next=c->prev=0;cJSON_Delete(c);}
void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}

/* Create basic types: */
cJSON *cJSON_CreateNull(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}
   15248:	e3a03002 	mov	r3, #2
   1524c:	e584300c 	str	r3, [r4, #12]
   15250:	e1a00004 	mov	r0, r4
   15254:	e8bd8010 	pop	{r4, pc}
   15258:	0000edd8 	.word	0x0000edd8

0001525c <cJSON_CreateTrue>:
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(void)
{
	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
   1525c:	e59f3034 	ldr	r3, [pc, #52]	; 15298 <cJSON_CreateTrue+0x3c>
	if (c==array->child) array->child=newitem; else newitem->prev->next=newitem;c->next=c->prev=0;cJSON_Delete(c);}
void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}

/* Create basic types: */
cJSON *cJSON_CreateNull(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}
cJSON *cJSON_CreateTrue(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}
   15260:	e92d4010 	push	{r4, lr}
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(void)
{
	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
   15264:	e08f3003 	add	r3, pc, r3
   15268:	e3a00028 	mov	r0, #40	; 0x28
   1526c:	e5933000 	ldr	r3, [r3]
   15270:	e12fff33 	blx	r3
	if (node) memset(node,0,sizeof(cJSON));
   15274:	e2504000 	subs	r4, r0, #0
   15278:	0a000004 	beq	15290 <cJSON_CreateTrue+0x34>
   1527c:	e3a01000 	mov	r1, #0
   15280:	e3a02028 	mov	r2, #40	; 0x28
   15284:	ebffbf91 	bl	50d0 <memset@plt>
	if (c==array->child) array->child=newitem; else newitem->prev->next=newitem;c->next=c->prev=0;cJSON_Delete(c);}
void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}

/* Create basic types: */
cJSON *cJSON_CreateNull(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}
cJSON *cJSON_CreateTrue(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}
   15288:	e3a03001 	mov	r3, #1
   1528c:	e584300c 	str	r3, [r4, #12]
   15290:	e1a00004 	mov	r0, r4
   15294:	e8bd8010 	pop	{r4, pc}
   15298:	0000ed98 	.word	0x0000ed98

0001529c <cJSON_CreateFalse>:
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(void)
{
	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
   1529c:	e59f3034 	ldr	r3, [pc, #52]	; 152d8 <cJSON_CreateFalse+0x3c>
void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}

/* Create basic types: */
cJSON *cJSON_CreateNull(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}
cJSON *cJSON_CreateTrue(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}
cJSON *cJSON_CreateFalse(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}
   152a0:	e92d4010 	push	{r4, lr}
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(void)
{
	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
   152a4:	e08f3003 	add	r3, pc, r3
   152a8:	e3a00028 	mov	r0, #40	; 0x28
   152ac:	e5933000 	ldr	r3, [r3]
   152b0:	e12fff33 	blx	r3
	if (node) memset(node,0,sizeof(cJSON));
   152b4:	e2504000 	subs	r4, r0, #0
   152b8:	0a000004 	beq	152d0 <cJSON_CreateFalse+0x34>
   152bc:	e3a01000 	mov	r1, #0
   152c0:	e3a02028 	mov	r2, #40	; 0x28
   152c4:	ebffbf81 	bl	50d0 <memset@plt>
void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}

/* Create basic types: */
cJSON *cJSON_CreateNull(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}
cJSON *cJSON_CreateTrue(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}
cJSON *cJSON_CreateFalse(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}
   152c8:	e3a03000 	mov	r3, #0
   152cc:	e584300c 	str	r3, [r4, #12]
   152d0:	e1a00004 	mov	r0, r4
   152d4:	e8bd8010 	pop	{r4, pc}
   152d8:	0000ed58 	.word	0x0000ed58

000152dc <cJSON_CreateBool>:
cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}
   152dc:	e92d4038 	push	{r3, r4, r5, lr}
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(void)
{
	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
   152e0:	e59f3038 	ldr	r3, [pc, #56]	; 15320 <cJSON_CreateBool+0x44>

/* Create basic types: */
cJSON *cJSON_CreateNull(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}
cJSON *cJSON_CreateTrue(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}
cJSON *cJSON_CreateFalse(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}
cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}
   152e4:	e1a04000 	mov	r4, r0
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(void)
{
	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
   152e8:	e08f3003 	add	r3, pc, r3
   152ec:	e5933000 	ldr	r3, [r3]
   152f0:	e3a00028 	mov	r0, #40	; 0x28
   152f4:	e12fff33 	blx	r3
	if (node) memset(node,0,sizeof(cJSON));
   152f8:	e2505000 	subs	r5, r0, #0
   152fc:	0a000005 	beq	15318 <cJSON_CreateBool+0x3c>
   15300:	e3a01000 	mov	r1, #0
   15304:	e3a02028 	mov	r2, #40	; 0x28
   15308:	ebffbf70 	bl	50d0 <memset@plt>

/* Create basic types: */
cJSON *cJSON_CreateNull(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}
cJSON *cJSON_CreateTrue(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}
cJSON *cJSON_CreateFalse(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}
cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}
   1530c:	e2944000 	adds	r4, r4, #0
   15310:	13a04001 	movne	r4, #1
   15314:	e585400c 	str	r4, [r5, #12]
   15318:	e1a00005 	mov	r0, r5
   1531c:	e8bd8038 	pop	{r3, r4, r5, pc}
   15320:	0000ed14 	.word	0x0000ed14

00015324 <cJSON_CreateNumber>:
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(void)
{
	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
   15324:	e59f3050 	ldr	r3, [pc, #80]	; 1537c <cJSON_CreateNumber+0x58>
/* Create basic types: */
cJSON *cJSON_CreateNull(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}
cJSON *cJSON_CreateTrue(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}
cJSON *cJSON_CreateFalse(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}
cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}
cJSON *cJSON_CreateNumber(double num)			{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int)num;}return item;}
   15328:	e92d40d0 	push	{r4, r6, r7, lr}
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(void)
{
	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
   1532c:	e08f3003 	add	r3, pc, r3
/* Create basic types: */
cJSON *cJSON_CreateNull(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}
cJSON *cJSON_CreateTrue(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}
cJSON *cJSON_CreateFalse(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}
cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}
cJSON *cJSON_CreateNumber(double num)			{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int)num;}return item;}
   15330:	e1a06000 	mov	r6, r0
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(void)
{
	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
   15334:	e5933000 	ldr	r3, [r3]
   15338:	e3a00028 	mov	r0, #40	; 0x28
/* Create basic types: */
cJSON *cJSON_CreateNull(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}
cJSON *cJSON_CreateTrue(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}
cJSON *cJSON_CreateFalse(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}
cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}
cJSON *cJSON_CreateNumber(double num)			{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int)num;}return item;}
   1533c:	e1a07001 	mov	r7, r1
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(void)
{
	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
   15340:	e12fff33 	blx	r3
	if (node) memset(node,0,sizeof(cJSON));
   15344:	e2504000 	subs	r4, r0, #0
   15348:	0a000009 	beq	15374 <cJSON_CreateNumber+0x50>
   1534c:	e3a01000 	mov	r1, #0
   15350:	e3a02028 	mov	r2, #40	; 0x28
   15354:	ebffbf5d 	bl	50d0 <memset@plt>
/* Create basic types: */
cJSON *cJSON_CreateNull(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}
cJSON *cJSON_CreateTrue(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}
cJSON *cJSON_CreateFalse(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}
cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}
cJSON *cJSON_CreateNumber(double num)			{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int)num;}return item;}
   15358:	e3a03003 	mov	r3, #3
   1535c:	e1c461f8 	strd	r6, [r4, #24]
   15360:	e1a00006 	mov	r0, r6
   15364:	e1a01007 	mov	r1, r7
   15368:	e584300c 	str	r3, [r4, #12]
   1536c:	eb001c34 	bl	1c444 <__aeabi_d2iz>
   15370:	e5840014 	str	r0, [r4, #20]
   15374:	e1a00004 	mov	r0, r4
   15378:	e8bd80d0 	pop	{r4, r6, r7, pc}
   1537c:	0000ecd0 	.word	0x0000ecd0

00015380 <cJSON_CreateString>:
cJSON *cJSON_CreateString(const char *string)	{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);}return item;}
   15380:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(void)
{
	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
   15384:	e59f5064 	ldr	r5, [pc, #100]	; 153f0 <cJSON_CreateString+0x70>
cJSON *cJSON_CreateNull(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}
cJSON *cJSON_CreateTrue(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}
cJSON *cJSON_CreateFalse(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}
cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}
cJSON *cJSON_CreateNumber(double num)			{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int)num;}return item;}
cJSON *cJSON_CreateString(const char *string)	{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);}return item;}
   15388:	e1a06000 	mov	r6, r0
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(void)
{
	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
   1538c:	e08f5005 	add	r5, pc, r5
   15390:	e5953000 	ldr	r3, [r5]
   15394:	e3a00028 	mov	r0, #40	; 0x28
   15398:	e12fff33 	blx	r3
	if (node) memset(node,0,sizeof(cJSON));
   1539c:	e2504000 	subs	r4, r0, #0
   153a0:	0a000010 	beq	153e8 <cJSON_CreateString+0x68>
   153a4:	e3a01000 	mov	r1, #0
   153a8:	e3a02028 	mov	r2, #40	; 0x28
   153ac:	ebffbf47 	bl	50d0 <memset@plt>
cJSON *cJSON_CreateNull(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}
cJSON *cJSON_CreateTrue(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}
cJSON *cJSON_CreateFalse(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}
cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}
cJSON *cJSON_CreateNumber(double num)			{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int)num;}return item;}
cJSON *cJSON_CreateString(const char *string)	{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);}return item;}
   153b0:	e3a03004 	mov	r3, #4
   153b4:	e584300c 	str	r3, [r4, #12]
static char* cJSON_strdup(const char* str)
{
      size_t len;
      char* copy;

      len = strlen(str) + 1;
   153b8:	e1a00006 	mov	r0, r6
   153bc:	ebffbf4f 	bl	5100 <strlen@plt>
      if (!(copy = (char*)cJSON_malloc(len))) return 0;
   153c0:	e5953000 	ldr	r3, [r5]
static char* cJSON_strdup(const char* str)
{
      size_t len;
      char* copy;

      len = strlen(str) + 1;
   153c4:	e2805001 	add	r5, r0, #1
      if (!(copy = (char*)cJSON_malloc(len))) return 0;
   153c8:	e1a00005 	mov	r0, r5
   153cc:	e12fff33 	blx	r3
   153d0:	e2507000 	subs	r7, r0, #0
   153d4:	0a000002 	beq	153e4 <cJSON_CreateString+0x64>
      memcpy(copy,str,len);
   153d8:	e1a01006 	mov	r1, r6
   153dc:	e1a02005 	mov	r2, r5
   153e0:	ebffbf79 	bl	51cc <memcpy@plt>
cJSON *cJSON_CreateNull(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}
cJSON *cJSON_CreateTrue(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}
cJSON *cJSON_CreateFalse(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}
cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}
cJSON *cJSON_CreateNumber(double num)			{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int)num;}return item;}
cJSON *cJSON_CreateString(const char *string)	{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);}return item;}
   153e4:	e5847010 	str	r7, [r4, #16]
   153e8:	e1a00004 	mov	r0, r4
   153ec:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
   153f0:	0000ec70 	.word	0x0000ec70

000153f4 <cJSON_CreateArray>:
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(void)
{
	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
   153f4:	e59f3034 	ldr	r3, [pc, #52]	; 15430 <cJSON_CreateArray+0x3c>
cJSON *cJSON_CreateTrue(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}
cJSON *cJSON_CreateFalse(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}
cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}
cJSON *cJSON_CreateNumber(double num)			{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int)num;}return item;}
cJSON *cJSON_CreateString(const char *string)	{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);}return item;}
cJSON *cJSON_CreateArray(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}
   153f8:	e92d4010 	push	{r4, lr}
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(void)
{
	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
   153fc:	e08f3003 	add	r3, pc, r3
   15400:	e3a00028 	mov	r0, #40	; 0x28
   15404:	e5933000 	ldr	r3, [r3]
   15408:	e12fff33 	blx	r3
	if (node) memset(node,0,sizeof(cJSON));
   1540c:	e2504000 	subs	r4, r0, #0
   15410:	0a000004 	beq	15428 <cJSON_CreateArray+0x34>
   15414:	e3a01000 	mov	r1, #0
   15418:	e3a02028 	mov	r2, #40	; 0x28
   1541c:	ebffbf2b 	bl	50d0 <memset@plt>
cJSON *cJSON_CreateTrue(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}
cJSON *cJSON_CreateFalse(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}
cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}
cJSON *cJSON_CreateNumber(double num)			{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int)num;}return item;}
cJSON *cJSON_CreateString(const char *string)	{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);}return item;}
cJSON *cJSON_CreateArray(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}
   15420:	e3a03005 	mov	r3, #5
   15424:	e584300c 	str	r3, [r4, #12]
   15428:	e1a00004 	mov	r0, r4
   1542c:	e8bd8010 	pop	{r4, pc}
   15430:	0000ec00 	.word	0x0000ec00

00015434 <cJSON_CreateObject>:
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(void)
{
	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
   15434:	e59f3034 	ldr	r3, [pc, #52]	; 15470 <cJSON_CreateObject+0x3c>
cJSON *cJSON_CreateFalse(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}
cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}
cJSON *cJSON_CreateNumber(double num)			{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int)num;}return item;}
cJSON *cJSON_CreateString(const char *string)	{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);}return item;}
cJSON *cJSON_CreateArray(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}
cJSON *cJSON_CreateObject(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}
   15438:	e92d4010 	push	{r4, lr}
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(void)
{
	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
   1543c:	e08f3003 	add	r3, pc, r3
   15440:	e3a00028 	mov	r0, #40	; 0x28
   15444:	e5933000 	ldr	r3, [r3]
   15448:	e12fff33 	blx	r3
	if (node) memset(node,0,sizeof(cJSON));
   1544c:	e2504000 	subs	r4, r0, #0
   15450:	0a000004 	beq	15468 <cJSON_CreateObject+0x34>
   15454:	e3a01000 	mov	r1, #0
   15458:	e3a02028 	mov	r2, #40	; 0x28
   1545c:	ebffbf1b 	bl	50d0 <memset@plt>
cJSON *cJSON_CreateFalse(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}
cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}
cJSON *cJSON_CreateNumber(double num)			{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int)num;}return item;}
cJSON *cJSON_CreateString(const char *string)	{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);}return item;}
cJSON *cJSON_CreateArray(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}
cJSON *cJSON_CreateObject(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}
   15460:	e3a03006 	mov	r3, #6
   15464:	e584300c 	str	r3, [r4, #12]
   15468:	e1a00004 	mov	r0, r4
   1546c:	e8bd8010 	pop	{r4, pc}
   15470:	0000ebc0 	.word	0x0000ebc0

00015474 <cJSON_CreateIntArray>:

/* Create Arrays: */
cJSON *cJSON_CreateIntArray(const int *numbers,int count)		{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
   15474:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
   15478:	e1a07001 	mov	r7, r1
   1547c:	e1a05000 	mov	r5, r0
   15480:	ebffffdb 	bl	153f4 <cJSON_CreateArray>
   15484:	e3500000 	cmp	r0, #0
   15488:	13570000 	cmpne	r7, #0
   1548c:	e1a08000 	mov	r8, r0
   15490:	da00000d 	ble	154cc <cJSON_CreateIntArray+0x58>
   15494:	e3a06000 	mov	r6, #0
   15498:	e2455004 	sub	r5, r5, #4
   1549c:	e1a04006 	mov	r4, r6
   154a0:	e5b50004 	ldr	r0, [r5, #4]!
   154a4:	eb001a48 	bl	1bdcc <__aeabi_i2d>
   154a8:	ebffff9d 	bl	15324 <cJSON_CreateNumber>
   154ac:	e3540000 	cmp	r4, #0
   154b0:	e2844001 	add	r4, r4, #1
int    cJSON_GetArraySize(cJSON *array)							{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}
cJSON *cJSON_GetArrayItem(cJSON *array,int item)				{cJSON *c=array->child;  while (c && item>0) item--,c=c->next; return c;}
cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)	{cJSON *c=object->child; while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}

/* Utility for array list handling. */
static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}
   154b4:	15860000 	strne	r0, [r6]
cJSON *cJSON_CreateString(const char *string)	{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);}return item;}
cJSON *cJSON_CreateArray(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}
cJSON *cJSON_CreateObject(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}

/* Create Arrays: */
cJSON *cJSON_CreateIntArray(const int *numbers,int count)		{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
   154b8:	05880008 	streq	r0, [r8, #8]
int    cJSON_GetArraySize(cJSON *array)							{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}
cJSON *cJSON_GetArrayItem(cJSON *array,int item)				{cJSON *c=array->child;  while (c && item>0) item--,c=c->next; return c;}
cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)	{cJSON *c=object->child; while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}

/* Utility for array list handling. */
static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}
   154bc:	15806004 	strne	r6, [r0, #4]
cJSON *cJSON_CreateString(const char *string)	{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);}return item;}
cJSON *cJSON_CreateArray(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}
cJSON *cJSON_CreateObject(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}

/* Create Arrays: */
cJSON *cJSON_CreateIntArray(const int *numbers,int count)		{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
   154c0:	e1570004 	cmp	r7, r4
   154c4:	e1a06000 	mov	r6, r0
   154c8:	cafffff4 	bgt	154a0 <cJSON_CreateIntArray+0x2c>
   154cc:	e1a00008 	mov	r0, r8
   154d0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

000154d4 <cJSON_CreateFloatArray>:
cJSON *cJSON_CreateFloatArray(const float *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
   154d4:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
   154d8:	e1a07001 	mov	r7, r1
   154dc:	e1a05000 	mov	r5, r0
   154e0:	ebffffc3 	bl	153f4 <cJSON_CreateArray>
   154e4:	e3500000 	cmp	r0, #0
   154e8:	13570000 	cmpne	r7, #0
   154ec:	e1a08000 	mov	r8, r0
   154f0:	da00000d 	ble	1552c <cJSON_CreateFloatArray+0x58>
   154f4:	e3a06000 	mov	r6, #0
   154f8:	e2455004 	sub	r5, r5, #4
   154fc:	e1a04006 	mov	r4, r6
   15500:	e5b50004 	ldr	r0, [r5, #4]!
   15504:	eb001a3a 	bl	1bdf4 <__aeabi_f2d>
   15508:	ebffff85 	bl	15324 <cJSON_CreateNumber>
   1550c:	e3540000 	cmp	r4, #0
   15510:	e2844001 	add	r4, r4, #1
int    cJSON_GetArraySize(cJSON *array)							{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}
cJSON *cJSON_GetArrayItem(cJSON *array,int item)				{cJSON *c=array->child;  while (c && item>0) item--,c=c->next; return c;}
cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)	{cJSON *c=object->child; while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}

/* Utility for array list handling. */
static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}
   15514:	15860000 	strne	r0, [r6]
cJSON *cJSON_CreateArray(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}
cJSON *cJSON_CreateObject(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}

/* Create Arrays: */
cJSON *cJSON_CreateIntArray(const int *numbers,int count)		{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
cJSON *cJSON_CreateFloatArray(const float *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
   15518:	05880008 	streq	r0, [r8, #8]
int    cJSON_GetArraySize(cJSON *array)							{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}
cJSON *cJSON_GetArrayItem(cJSON *array,int item)				{cJSON *c=array->child;  while (c && item>0) item--,c=c->next; return c;}
cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)	{cJSON *c=object->child; while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}

/* Utility for array list handling. */
static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}
   1551c:	15806004 	strne	r6, [r0, #4]
cJSON *cJSON_CreateArray(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}
cJSON *cJSON_CreateObject(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}

/* Create Arrays: */
cJSON *cJSON_CreateIntArray(const int *numbers,int count)		{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
cJSON *cJSON_CreateFloatArray(const float *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
   15520:	e1570004 	cmp	r7, r4
   15524:	e1a06000 	mov	r6, r0
   15528:	cafffff4 	bgt	15500 <cJSON_CreateFloatArray+0x2c>
   1552c:	e1a00008 	mov	r0, r8
   15530:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

00015534 <cJSON_CreateDoubleArray>:
cJSON *cJSON_CreateDoubleArray(const double *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
   15534:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
   15538:	e1a07001 	mov	r7, r1
   1553c:	e1a05000 	mov	r5, r0
   15540:	ebffffab 	bl	153f4 <cJSON_CreateArray>
   15544:	e3500000 	cmp	r0, #0
   15548:	13570000 	cmpne	r7, #0
   1554c:	e1a08000 	mov	r8, r0
   15550:	da00000c 	ble	15588 <cJSON_CreateDoubleArray+0x54>
   15554:	e3a06000 	mov	r6, #0
   15558:	e2455008 	sub	r5, r5, #8
   1555c:	e1a04006 	mov	r4, r6
   15560:	e1e500d8 	ldrd	r0, [r5, #8]!
   15564:	ebffff6e 	bl	15324 <cJSON_CreateNumber>
   15568:	e3540000 	cmp	r4, #0
   1556c:	e2844001 	add	r4, r4, #1
int    cJSON_GetArraySize(cJSON *array)							{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}
cJSON *cJSON_GetArrayItem(cJSON *array,int item)				{cJSON *c=array->child;  while (c && item>0) item--,c=c->next; return c;}
cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)	{cJSON *c=object->child; while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}

/* Utility for array list handling. */
static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}
   15570:	15860000 	strne	r0, [r6]
cJSON *cJSON_CreateObject(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}

/* Create Arrays: */
cJSON *cJSON_CreateIntArray(const int *numbers,int count)		{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
cJSON *cJSON_CreateFloatArray(const float *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
cJSON *cJSON_CreateDoubleArray(const double *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
   15574:	05880008 	streq	r0, [r8, #8]
int    cJSON_GetArraySize(cJSON *array)							{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}
cJSON *cJSON_GetArrayItem(cJSON *array,int item)				{cJSON *c=array->child;  while (c && item>0) item--,c=c->next; return c;}
cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)	{cJSON *c=object->child; while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}

/* Utility for array list handling. */
static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}
   15578:	15806004 	strne	r6, [r0, #4]
cJSON *cJSON_CreateObject(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}

/* Create Arrays: */
cJSON *cJSON_CreateIntArray(const int *numbers,int count)		{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
cJSON *cJSON_CreateFloatArray(const float *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
cJSON *cJSON_CreateDoubleArray(const double *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
   1557c:	e1570004 	cmp	r7, r4
   15580:	e1a06000 	mov	r6, r0
   15584:	cafffff5 	bgt	15560 <cJSON_CreateDoubleArray+0x2c>
   15588:	e1a00008 	mov	r0, r8
   1558c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

00015590 <cJSON_CreateStringArray>:
cJSON *cJSON_CreateStringArray(const char **strings,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
   15590:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
   15594:	e1a07001 	mov	r7, r1
   15598:	e1a05000 	mov	r5, r0
   1559c:	ebffff94 	bl	153f4 <cJSON_CreateArray>
   155a0:	e3500000 	cmp	r0, #0
   155a4:	13570000 	cmpne	r7, #0
   155a8:	e1a08000 	mov	r8, r0
   155ac:	da00000c 	ble	155e4 <cJSON_CreateStringArray+0x54>
   155b0:	e3a06000 	mov	r6, #0
   155b4:	e2455004 	sub	r5, r5, #4
   155b8:	e1a04006 	mov	r4, r6
   155bc:	e5b50004 	ldr	r0, [r5, #4]!
   155c0:	ebffff6e 	bl	15380 <cJSON_CreateString>
   155c4:	e3540000 	cmp	r4, #0
   155c8:	e2844001 	add	r4, r4, #1
int    cJSON_GetArraySize(cJSON *array)							{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}
cJSON *cJSON_GetArrayItem(cJSON *array,int item)				{cJSON *c=array->child;  while (c && item>0) item--,c=c->next; return c;}
cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)	{cJSON *c=object->child; while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}

/* Utility for array list handling. */
static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}
   155cc:	15860000 	strne	r0, [r6]

/* Create Arrays: */
cJSON *cJSON_CreateIntArray(const int *numbers,int count)		{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
cJSON *cJSON_CreateFloatArray(const float *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
cJSON *cJSON_CreateDoubleArray(const double *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
cJSON *cJSON_CreateStringArray(const char **strings,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
   155d0:	05880008 	streq	r0, [r8, #8]
int    cJSON_GetArraySize(cJSON *array)							{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}
cJSON *cJSON_GetArrayItem(cJSON *array,int item)				{cJSON *c=array->child;  while (c && item>0) item--,c=c->next; return c;}
cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)	{cJSON *c=object->child; while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}

/* Utility for array list handling. */
static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}
   155d4:	15806004 	strne	r6, [r0, #4]

/* Create Arrays: */
cJSON *cJSON_CreateIntArray(const int *numbers,int count)		{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
cJSON *cJSON_CreateFloatArray(const float *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
cJSON *cJSON_CreateDoubleArray(const double *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
cJSON *cJSON_CreateStringArray(const char **strings,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
   155d8:	e1570004 	cmp	r7, r4
   155dc:	e1a06000 	mov	r6, r0
   155e0:	cafffff5 	bgt	155bc <cJSON_CreateStringArray+0x2c>
   155e4:	e1a00008 	mov	r0, r8
   155e8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

000155ec <cJSON_Duplicate>:
/* Duplication */
cJSON *cJSON_Duplicate(cJSON *item,int recurse)
{
	cJSON *newitem,*cptr,*nptr=0,*newchild;
	/* Bail on bad ptr */
	if (!item) return 0;
   155ec:	e3500000 	cmp	r0, #0
   155f0:	0a000036 	beq	156d0 <cJSON_Duplicate+0xe4>
cJSON *cJSON_CreateDoubleArray(const double *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
cJSON *cJSON_CreateStringArray(const char **strings,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}

/* Duplication */
cJSON *cJSON_Duplicate(cJSON *item,int recurse)
{
   155f4:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
   155f8:	e1a05001 	mov	r5, r1
   155fc:	e1a04000 	mov	r4, r0
	cJSON *newitem,*cptr,*nptr=0,*newchild;
	/* Bail on bad ptr */
	if (!item) return 0;
	/* Create new item */
	newitem=cJSON_New_Item();
   15600:	ebfff4f8 	bl	129e8 <cJSON_New_Item>
	if (!newitem) return 0;
   15604:	e2507000 	subs	r7, r0, #0
   15608:	0a000032 	beq	156d8 <cJSON_Duplicate+0xec>
	/* Copy over all vars */
	newitem->type=item->type&(~cJSON_IsReference),newitem->valueint=item->valueint,newitem->valuedouble=item->valuedouble;
   1560c:	e594100c 	ldr	r1, [r4, #12]
	if (item->valuestring)	{newitem->valuestring=cJSON_strdup(item->valuestring);	if (!newitem->valuestring)	{cJSON_Delete(newitem);return 0;}}
   15610:	e5940010 	ldr	r0, [r4, #16]
	if (!item) return 0;
	/* Create new item */
	newitem=cJSON_New_Item();
	if (!newitem) return 0;
	/* Copy over all vars */
	newitem->type=item->type&(~cJSON_IsReference),newitem->valueint=item->valueint,newitem->valuedouble=item->valuedouble;
   15614:	e1c421d8 	ldrd	r2, [r4, #24]
   15618:	e594c014 	ldr	ip, [r4, #20]
   1561c:	e3c11c01 	bic	r1, r1, #256	; 0x100
	if (item->valuestring)	{newitem->valuestring=cJSON_strdup(item->valuestring);	if (!newitem->valuestring)	{cJSON_Delete(newitem);return 0;}}
   15620:	e3500000 	cmp	r0, #0
	if (!item) return 0;
	/* Create new item */
	newitem=cJSON_New_Item();
	if (!newitem) return 0;
	/* Copy over all vars */
	newitem->type=item->type&(~cJSON_IsReference),newitem->valueint=item->valueint,newitem->valuedouble=item->valuedouble;
   15624:	e587100c 	str	r1, [r7, #12]
   15628:	e1c721f8 	strd	r2, [r7, #24]
   1562c:	e587c014 	str	ip, [r7, #20]
	if (item->valuestring)	{newitem->valuestring=cJSON_strdup(item->valuestring);	if (!newitem->valuestring)	{cJSON_Delete(newitem);return 0;}}
   15630:	0a000004 	beq	15648 <cJSON_Duplicate+0x5c>
   15634:	ebfff529 	bl	12ae0 <cJSON_strdup>
   15638:	e3500000 	cmp	r0, #0
   1563c:	e1a06000 	mov	r6, r0
   15640:	e5870010 	str	r0, [r7, #16]
   15644:	0a000025 	beq	156e0 <cJSON_Duplicate+0xf4>
	if (item->string)		{newitem->string=cJSON_strdup(item->string);			if (!newitem->string)		{cJSON_Delete(newitem);return 0;}}
   15648:	e5940020 	ldr	r0, [r4, #32]
   1564c:	e3500000 	cmp	r0, #0
   15650:	0a000004 	beq	15668 <cJSON_Duplicate+0x7c>
   15654:	ebfff521 	bl	12ae0 <cJSON_strdup>
   15658:	e3500000 	cmp	r0, #0
   1565c:	e1a06000 	mov	r6, r0
   15660:	e5870020 	str	r0, [r7, #32]
   15664:	0a00001d 	beq	156e0 <cJSON_Duplicate+0xf4>
	/* If non-recursive, then we're done! */
	if (!recurse) return newitem;
   15668:	e3550000 	cmp	r5, #0
   1566c:	0a000015 	beq	156c8 <cJSON_Duplicate+0xdc>
	/* Walk the ->next chain for the child. */
	cptr=item->child;
   15670:	e5944008 	ldr	r4, [r4, #8]
	while (cptr)
   15674:	e3540000 	cmp	r4, #0
   15678:	0a000012 	beq	156c8 <cJSON_Duplicate+0xdc>
   1567c:	e3a06000 	mov	r6, #0
   15680:	ea000007 	b	156a4 <cJSON_Duplicate+0xb8>
	{
		newchild=cJSON_Duplicate(cptr,1);		/* Duplicate (with recurse) each item in the ->next chain */
		if (!newchild) {cJSON_Delete(newitem);return 0;}
		if (nptr)	{nptr->next=newchild,newchild->prev=nptr;nptr=newchild;}	/* If newitem->child already set, then crosswire ->prev and ->next and move on */
   15684:	e3560000 	cmp	r6, #0
   15688:	15865000 	strne	r5, [r6]
		else		{newitem->child=newchild;nptr=newchild;}					/* Set newitem->child and move to it */
		cptr=cptr->next;
   1568c:	e5944000 	ldr	r4, [r4]
	cptr=item->child;
	while (cptr)
	{
		newchild=cJSON_Duplicate(cptr,1);		/* Duplicate (with recurse) each item in the ->next chain */
		if (!newchild) {cJSON_Delete(newitem);return 0;}
		if (nptr)	{nptr->next=newchild,newchild->prev=nptr;nptr=newchild;}	/* If newitem->child already set, then crosswire ->prev and ->next and move on */
   15690:	15856004 	strne	r6, [r5, #4]
		else		{newitem->child=newchild;nptr=newchild;}					/* Set newitem->child and move to it */
   15694:	05875008 	streq	r5, [r7, #8]
	if (item->string)		{newitem->string=cJSON_strdup(item->string);			if (!newitem->string)		{cJSON_Delete(newitem);return 0;}}
	/* If non-recursive, then we're done! */
	if (!recurse) return newitem;
	/* Walk the ->next chain for the child. */
	cptr=item->child;
	while (cptr)
   15698:	e3540000 	cmp	r4, #0
   1569c:	e1a06005 	mov	r6, r5
   156a0:	0a000008 	beq	156c8 <cJSON_Duplicate+0xdc>
	{
		newchild=cJSON_Duplicate(cptr,1);		/* Duplicate (with recurse) each item in the ->next chain */
   156a4:	e1a00004 	mov	r0, r4
   156a8:	e3a01001 	mov	r1, #1
   156ac:	ebffffce 	bl	155ec <cJSON_Duplicate>
		if (!newchild) {cJSON_Delete(newitem);return 0;}
   156b0:	e2505000 	subs	r5, r0, #0
   156b4:	1afffff2 	bne	15684 <cJSON_Duplicate+0x98>
   156b8:	e1a00007 	mov	r0, r7
   156bc:	ebfffd0d 	bl	14af8 <cJSON_Delete>
   156c0:	e1a00005 	mov	r0, r5
   156c4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	if (item->string)		{newitem->string=cJSON_strdup(item->string);			if (!newitem->string)		{cJSON_Delete(newitem);return 0;}}
	/* If non-recursive, then we're done! */
	if (!recurse) return newitem;
	/* Walk the ->next chain for the child. */
	cptr=item->child;
	while (cptr)
   156c8:	e1a00007 	mov	r0, r7
		if (nptr)	{nptr->next=newchild,newchild->prev=nptr;nptr=newchild;}	/* If newitem->child already set, then crosswire ->prev and ->next and move on */
		else		{newitem->child=newchild;nptr=newchild;}					/* Set newitem->child and move to it */
		cptr=cptr->next;
	}
	return newitem;
}
   156cc:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
/* Duplication */
cJSON *cJSON_Duplicate(cJSON *item,int recurse)
{
	cJSON *newitem,*cptr,*nptr=0,*newchild;
	/* Bail on bad ptr */
	if (!item) return 0;
   156d0:	e3a00000 	mov	r0, #0
		if (nptr)	{nptr->next=newchild,newchild->prev=nptr;nptr=newchild;}	/* If newitem->child already set, then crosswire ->prev and ->next and move on */
		else		{newitem->child=newchild;nptr=newchild;}					/* Set newitem->child and move to it */
		cptr=cptr->next;
	}
	return newitem;
}
   156d4:	e12fff1e 	bx	lr
/* Duplication */
cJSON *cJSON_Duplicate(cJSON *item,int recurse)
{
	cJSON *newitem,*cptr,*nptr=0,*newchild;
	/* Bail on bad ptr */
	if (!item) return 0;
   156d8:	e3a00000 	mov	r0, #0
   156dc:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	newitem=cJSON_New_Item();
	if (!newitem) return 0;
	/* Copy over all vars */
	newitem->type=item->type&(~cJSON_IsReference),newitem->valueint=item->valueint,newitem->valuedouble=item->valuedouble;
	if (item->valuestring)	{newitem->valuestring=cJSON_strdup(item->valuestring);	if (!newitem->valuestring)	{cJSON_Delete(newitem);return 0;}}
	if (item->string)		{newitem->string=cJSON_strdup(item->string);			if (!newitem->string)		{cJSON_Delete(newitem);return 0;}}
   156e0:	e1a00007 	mov	r0, r7
   156e4:	ebfffd03 	bl	14af8 <cJSON_Delete>
   156e8:	e1a00006 	mov	r0, r6
   156ec:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

000156f0 <cJSON_Minify>:
	}
	return newitem;
}

void cJSON_Minify(char *json)
{
   156f0:	e5d03000 	ldrb	r3, [r0]
	char *into=json;
	while (*json)
   156f4:	e1a01000 	mov	r1, r0
   156f8:	ea00000f 	b	1573c <cJSON_Minify+0x4c>
	{
		if (*json==' ') json++;
   156fc:	e3530020 	cmp	r3, #32
   15700:	0a00000b 	beq	15734 <cJSON_Minify+0x44>
		else if (*json=='\t') json++;	/* Whitespace characters. */
   15704:	e3530009 	cmp	r3, #9
   15708:	0a000009 	beq	15734 <cJSON_Minify+0x44>
		else if (*json=='\r') json++;
   1570c:	e353000d 	cmp	r3, #13
   15710:	0a000007 	beq	15734 <cJSON_Minify+0x44>
		else if (*json=='\n') json++;
   15714:	e353000a 	cmp	r3, #10
   15718:	0a000005 	beq	15734 <cJSON_Minify+0x44>
		else if (*json=='/' && json[1]=='/')  while (*json && *json!='\n') json++;	/* double-slash comments, to end of line. */
   1571c:	e353002f 	cmp	r3, #47	; 0x2f
   15720:	0a000009 	beq	1574c <cJSON_Minify+0x5c>
		else if (*json=='/' && json[1]=='*') {while (*json && !(*json=='*' && json[1]=='/')) json++;json+=2;}	/* multiline comments. */
		else if (*json=='\"'){*into++=*json++;while (*json && *json!='\"'){if (*json=='\\') *into++=*json++;*into++=*json++;}*into++=*json++;} /* string literals, which are \" sensitive. */
   15724:	e3530022 	cmp	r3, #34	; 0x22
   15728:	0a000027 	beq	157cc <cJSON_Minify+0xdc>
		else *into++=*json++;			/* All other characters. */
   1572c:	e5c13000 	strb	r3, [r1]
   15730:	e2811001 	add	r1, r1, #1
   15734:	e5d03001 	ldrb	r3, [r0, #1]
   15738:	e2800001 	add	r0, r0, #1
}

void cJSON_Minify(char *json)
{
	char *into=json;
	while (*json)
   1573c:	e3530000 	cmp	r3, #0
   15740:	1affffed 	bne	156fc <cJSON_Minify+0xc>
		else if (*json=='/' && json[1]=='/')  while (*json && *json!='\n') json++;	/* double-slash comments, to end of line. */
		else if (*json=='/' && json[1]=='*') {while (*json && !(*json=='*' && json[1]=='/')) json++;json+=2;}	/* multiline comments. */
		else if (*json=='\"'){*into++=*json++;while (*json && *json!='\"'){if (*json=='\\') *into++=*json++;*into++=*json++;}*into++=*json++;} /* string literals, which are \" sensitive. */
		else *into++=*json++;			/* All other characters. */
	}
	*into=0;	/* and null-terminate. */
   15744:	e5c13000 	strb	r3, [r1]
   15748:	e12fff1e 	bx	lr
	{
		if (*json==' ') json++;
		else if (*json=='\t') json++;	/* Whitespace characters. */
		else if (*json=='\r') json++;
		else if (*json=='\n') json++;
		else if (*json=='/' && json[1]=='/')  while (*json && *json!='\n') json++;	/* double-slash comments, to end of line. */
   1574c:	e5d02001 	ldrb	r2, [r0, #1]
   15750:	e352002f 	cmp	r2, #47	; 0x2f
   15754:	0a000013 	beq	157a8 <cJSON_Minify+0xb8>
		else if (*json=='/' && json[1]=='*') {while (*json && !(*json=='*' && json[1]=='/')) json++;json+=2;}	/* multiline comments. */
   15758:	e352002a 	cmp	r2, #42	; 0x2a
   1575c:	1afffff2 	bne	1572c <cJSON_Minify+0x3c>
   15760:	e5d03001 	ldrb	r3, [r0, #1]
   15764:	e2802001 	add	r2, r0, #1
   15768:	e3530000 	cmp	r3, #0
   1576c:	1a00000a 	bne	1579c <cJSON_Minify+0xac>
   15770:	e5d03003 	ldrb	r3, [r0, #3]
   15774:	e2820002 	add	r0, r2, #2
   15778:	eaffffef 	b	1573c <cJSON_Minify+0x4c>
   1577c:	e5d23001 	ldrb	r3, [r2, #1]
   15780:	e353002f 	cmp	r3, #47	; 0x2f
   15784:	0afffff9 	beq	15770 <cJSON_Minify+0x80>
	}
	return newitem;
}

void cJSON_Minify(char *json)
{
   15788:	e1a00002 	mov	r0, r2
		if (*json==' ') json++;
		else if (*json=='\t') json++;	/* Whitespace characters. */
		else if (*json=='\r') json++;
		else if (*json=='\n') json++;
		else if (*json=='/' && json[1]=='/')  while (*json && *json!='\n') json++;	/* double-slash comments, to end of line. */
		else if (*json=='/' && json[1]=='*') {while (*json && !(*json=='*' && json[1]=='/')) json++;json+=2;}	/* multiline comments. */
   1578c:	e5d03001 	ldrb	r3, [r0, #1]
   15790:	e2802001 	add	r2, r0, #1
   15794:	e3530000 	cmp	r3, #0
   15798:	0afffff4 	beq	15770 <cJSON_Minify+0x80>
   1579c:	e353002a 	cmp	r3, #42	; 0x2a
   157a0:	1afffff8 	bne	15788 <cJSON_Minify+0x98>
   157a4:	eafffff4 	b	1577c <cJSON_Minify+0x8c>
	{
		if (*json==' ') json++;
		else if (*json=='\t') json++;	/* Whitespace characters. */
		else if (*json=='\r') json++;
		else if (*json=='\n') json++;
		else if (*json=='/' && json[1]=='/')  while (*json && *json!='\n') json++;	/* double-slash comments, to end of line. */
   157a8:	e5f03001 	ldrb	r3, [r0, #1]!
   157ac:	e353000a 	cmp	r3, #10
   157b0:	13530000 	cmpne	r3, #0
   157b4:	0affffe0 	beq	1573c <cJSON_Minify+0x4c>
   157b8:	e5f03001 	ldrb	r3, [r0, #1]!
   157bc:	e353000a 	cmp	r3, #10
   157c0:	13530000 	cmpne	r3, #0
   157c4:	1afffff7 	bne	157a8 <cJSON_Minify+0xb8>
   157c8:	eaffffdb 	b	1573c <cJSON_Minify+0x4c>
		else if (*json=='/' && json[1]=='*') {while (*json && !(*json=='*' && json[1]=='/')) json++;json+=2;}	/* multiline comments. */
		else if (*json=='\"'){*into++=*json++;while (*json && *json!='\"'){if (*json=='\\') *into++=*json++;*into++=*json++;}*into++=*json++;} /* string literals, which are \" sensitive. */
   157cc:	e5c13000 	strb	r3, [r1]
   157d0:	e5d03001 	ldrb	r3, [r0, #1]
   157d4:	e2811001 	add	r1, r1, #1
   157d8:	e3530022 	cmp	r3, #34	; 0x22
   157dc:	13530000 	cmpne	r3, #0
   157e0:	e2800001 	add	r0, r0, #1
   157e4:	0affffd0 	beq	1572c <cJSON_Minify+0x3c>
   157e8:	e353005c 	cmp	r3, #92	; 0x5c
   157ec:	e1a02000 	mov	r2, r0
   157f0:	02802001 	addeq	r2, r0, #1
   157f4:	05c13000 	strbeq	r3, [r1]
   157f8:	e1a0c001 	mov	ip, r1
   157fc:	e5d23000 	ldrb	r3, [r2]
   15800:	0281c001 	addeq	ip, r1, #1
   15804:	e5cc3000 	strb	r3, [ip]
   15808:	e5d23001 	ldrb	r3, [r2, #1]
   1580c:	e28c1001 	add	r1, ip, #1
   15810:	e3530022 	cmp	r3, #34	; 0x22
   15814:	13530000 	cmpne	r3, #0
   15818:	e2820001 	add	r0, r2, #1
   1581c:	1afffff1 	bne	157e8 <cJSON_Minify+0xf8>
   15820:	eaffffc1 	b	1572c <cJSON_Minify+0x3c>

00015824 <rtmp_log_default>:
  "CRIT", "ERROR", "WARNING", "INFO",
  "DEBUG", "DEBUG2"
};

static void rtmp_log_default(int level, const char *format, va_list vl)
{
   15824:	e92d40f0 	push	{r4, r5, r6, r7, lr}
   15828:	e24ddb02 	sub	sp, sp, #2048	; 0x800
   1582c:	e24dd004 	sub	sp, sp, #4
	char str[MAX_PRINT_LEN]="";
   15830:	e3a0c000 	mov	ip, #0
  "CRIT", "ERROR", "WARNING", "INFO",
  "DEBUG", "DEBUG2"
};

static void rtmp_log_default(int level, const char *format, va_list vl)
{
   15834:	e1a05002 	mov	r5, r2
   15838:	e1a06001 	mov	r6, r1
	char str[MAX_PRINT_LEN]="";
   1583c:	e59f20f0 	ldr	r2, [pc, #240]	; 15934 <rtmp_log_default+0x110>
   15840:	e1a0100c 	mov	r1, ip
  "CRIT", "ERROR", "WARNING", "INFO",
  "DEBUG", "DEBUG2"
};

static void rtmp_log_default(int level, const char *format, va_list vl)
{
   15844:	e1a07000 	mov	r7, r0
	char str[MAX_PRINT_LEN]="";
   15848:	e28d0004 	add	r0, sp, #4
   1584c:	e58dc000 	str	ip, [sp]
   15850:	ebffbe1e 	bl	50d0 <memset@plt>

	vsnprintf(str, MAX_PRINT_LEN-1, format, vl);
   15854:	e1a03005 	mov	r3, r5
   15858:	e1a02006 	mov	r2, r6
   1585c:	e1a0000d 	mov	r0, sp
   15860:	e59f10d0 	ldr	r1, [pc, #208]	; 15938 <rtmp_log_default+0x114>
   15864:	ebffbf24 	bl	54fc <vsnprintf@plt>
   15868:	e59f30cc 	ldr	r3, [pc, #204]	; 1593c <rtmp_log_default+0x118>
   1586c:	e1a0400d 	mov	r4, sp

	/* Filter out 'no-name' */
	if ( RTMP_debuglevel<RTMP_LOGALL && strstr(str, "no-name" ) != NULL )
   15870:	e79f3003 	ldr	r3, [pc, r3]
   15874:	e5935000 	ldr	r5, [r3]
   15878:	e3550005 	cmp	r5, #5
   1587c:	8a000008 	bhi	158a4 <rtmp_log_default+0x80>
   15880:	e59f10b8 	ldr	r1, [pc, #184]	; 15940 <rtmp_log_default+0x11c>
   15884:	e1a0000d 	mov	r0, sp
   15888:	e08f1001 	add	r1, pc, r1
   1588c:	ebffbe39 	bl	5178 <strstr@plt>
   15890:	e3500000 	cmp	r0, #0
   15894:	0a000002 	beq	158a4 <rtmp_log_default+0x80>
		fprintf(fmsg, "%s: %s\n", levels[level], str);
#ifdef _DEBUG
		fflush(fmsg);
#endif
	}
}
   15898:	e28ddb02 	add	sp, sp, #2048	; 0x800
   1589c:	e28dd004 	add	sp, sp, #4
   158a0:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

	/* Filter out 'no-name' */
	if ( RTMP_debuglevel<RTMP_LOGALL && strstr(str, "no-name" ) != NULL )
		return;

	if ( !fmsg ) fmsg = stderr;
   158a4:	e59f3098 	ldr	r3, [pc, #152]	; 15944 <rtmp_log_default+0x120>
   158a8:	e08f3003 	add	r3, pc, r3
   158ac:	e5932000 	ldr	r2, [r3]
   158b0:	e3520000 	cmp	r2, #0
   158b4:	0a000013 	beq	15908 <rtmp_log_default+0xe4>

	if ( level <= RTMP_debuglevel ) {
   158b8:	e1550007 	cmp	r5, r7
   158bc:	3afffff5 	bcc	15898 <rtmp_log_default+0x74>
		if (neednl) {
   158c0:	e59f5080 	ldr	r5, [pc, #128]	; 15948 <rtmp_log_default+0x124>
   158c4:	e08f5005 	add	r5, pc, r5
   158c8:	e5953004 	ldr	r3, [r5, #4]
   158cc:	e3530000 	cmp	r3, #0
   158d0:	1a000011 	bne	1591c <rtmp_log_default+0xf8>
			putc('\n', fmsg);
			neednl = 0;
		}
		fprintf(fmsg, "%s: %s\n", levels[level], str);
   158d4:	e59f1070 	ldr	r1, [pc, #112]	; 1594c <rtmp_log_default+0x128>
   158d8:	e59f2070 	ldr	r2, [pc, #112]	; 15950 <rtmp_log_default+0x12c>
   158dc:	e08f1001 	add	r1, pc, r1
   158e0:	e5910000 	ldr	r0, [r1]
   158e4:	e59f1068 	ldr	r1, [pc, #104]	; 15954 <rtmp_log_default+0x130>
   158e8:	e08f2002 	add	r2, pc, r2
   158ec:	e1a03004 	mov	r3, r4
   158f0:	e7922107 	ldr	r2, [r2, r7, lsl #2]
   158f4:	e08f1001 	add	r1, pc, r1
   158f8:	ebffbf02 	bl	5508 <fprintf@plt>
#ifdef _DEBUG
		fflush(fmsg);
#endif
	}
}
   158fc:	e28ddb02 	add	sp, sp, #2048	; 0x800
   15900:	e28dd004 	add	sp, sp, #4
   15904:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
   15908:	e59f2048 	ldr	r2, [pc, #72]	; 15958 <rtmp_log_default+0x134>

	/* Filter out 'no-name' */
	if ( RTMP_debuglevel<RTMP_LOGALL && strstr(str, "no-name" ) != NULL )
		return;

	if ( !fmsg ) fmsg = stderr;
   1590c:	e79f2002 	ldr	r2, [pc, r2]
   15910:	e28220a8 	add	r2, r2, #168	; 0xa8
   15914:	e5832000 	str	r2, [r3]
   15918:	eaffffe6 	b	158b8 <rtmp_log_default+0x94>

	if ( level <= RTMP_debuglevel ) {
		if (neednl) {
			putc('\n', fmsg);
   1591c:	e3a0000a 	mov	r0, #10
   15920:	e5951000 	ldr	r1, [r5]
   15924:	ebffbefa 	bl	5514 <putc@plt>
			neednl = 0;
   15928:	e3a03000 	mov	r3, #0
   1592c:	e5853004 	str	r3, [r5, #4]
   15930:	eaffffe7 	b	158d4 <rtmp_log_default+0xb0>
   15934:	000007fc 	.word	0x000007fc
   15938:	000007ff 	.word	0x000007ff
   1593c:	0000e538 	.word	0x0000e538
   15940:	0000b3fc 	.word	0x0000b3fc
   15944:	00010f78 	.word	0x00010f78
   15948:	00010f5c 	.word	0x00010f5c
   1594c:	00010f44 	.word	0x00010f44
   15950:	0000e2e8 	.word	0x0000e2e8
   15954:	0000b398 	.word	0x0000b398
   15958:	0000e4a0 	.word	0x0000e4a0

0001595c <RTMP_LogSetOutput>:
	}
}

void RTMP_LogSetOutput(FILE *file)
{
	fmsg = file;
   1595c:	e59f3008 	ldr	r3, [pc, #8]	; 1596c <RTMP_LogSetOutput+0x10>
   15960:	e08f3003 	add	r3, pc, r3
   15964:	e5830000 	str	r0, [r3]
   15968:	e12fff1e 	bx	lr
   1596c:	00010ec0 	.word	0x00010ec0

00015970 <RTMP_LogSetLevel>:
}

void RTMP_LogSetLevel(RTMP_LogLevel level)
{
   15970:	e59f3008 	ldr	r3, [pc, #8]	; 15980 <RTMP_LogSetLevel+0x10>
	RTMP_debuglevel = level;
   15974:	e79f3003 	ldr	r3, [pc, r3]
   15978:	e5830000 	str	r0, [r3]
   1597c:	e12fff1e 	bx	lr
   15980:	0000e434 	.word	0x0000e434

00015984 <RTMP_LogSetCallback>:
}

void RTMP_LogSetCallback(RTMP_LogCallback *cbp)
{
	cb = cbp;
   15984:	e59f3008 	ldr	r3, [pc, #8]	; 15994 <RTMP_LogSetCallback+0x10>
   15988:	e08f3003 	add	r3, pc, r3
   1598c:	e5830000 	str	r0, [r3]
   15990:	e12fff1e 	bx	lr
   15994:	0000e680 	.word	0x0000e680

00015998 <RTMP_LogGetLevel>:
}

RTMP_LogLevel RTMP_LogGetLevel()
{
   15998:	e59f3008 	ldr	r3, [pc, #8]	; 159a8 <RTMP_LogGetLevel+0x10>
	return RTMP_debuglevel;
   1599c:	e79f3003 	ldr	r3, [pc, r3]
}
   159a0:	e5930000 	ldr	r0, [r3]
   159a4:	e12fff1e 	bx	lr
   159a8:	0000e40c 	.word	0x0000e40c

000159ac <RTMP_Log>:

void RTMP_Log(int level, const char *format, ...)
{
   159ac:	e92d000e 	push	{r1, r2, r3}
	va_list args;
	va_start(args, format);
	cb(level, format, args);
   159b0:	e59f3030 	ldr	r3, [pc, #48]	; 159e8 <RTMP_Log+0x3c>
{
	return RTMP_debuglevel;
}

void RTMP_Log(int level, const char *format, ...)
{
   159b4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
   159b8:	e24dd008 	sub	sp, sp, #8
	va_list args;
	va_start(args, format);
   159bc:	e28dc010 	add	ip, sp, #16
	cb(level, format, args);
   159c0:	e08f3003 	add	r3, pc, r3
   159c4:	e5933000 	ldr	r3, [r3]
   159c8:	e1a0200c 	mov	r2, ip
   159cc:	e59d100c 	ldr	r1, [sp, #12]
}

void RTMP_Log(int level, const char *format, ...)
{
	va_list args;
	va_start(args, format);
   159d0:	e58dc004 	str	ip, [sp, #4]
	cb(level, format, args);
   159d4:	e12fff33 	blx	r3
	va_end(args);
}
   159d8:	e28dd008 	add	sp, sp, #8
   159dc:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
   159e0:	e28dd00c 	add	sp, sp, #12
   159e4:	e12fff1e 	bx	lr
   159e8:	0000e648 	.word	0x0000e648

000159ec <RTMP_LogHex>:

static const char hexdig[] = "0123456789abcdef";

void RTMP_LogHex(int level, const uint8_t *data, unsigned long len)
{
   159ec:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   159f0:	e59f40dc 	ldr	r4, [pc, #220]	; 15ad4 <RTMP_LogHex+0xe8>
   159f4:	e24dd03c 	sub	sp, sp, #60	; 0x3c
	unsigned long i;
	char line[50], *ptr;

	if ( level > RTMP_debuglevel )
   159f8:	e79f4004 	ldr	r4, [pc, r4]
   159fc:	e5943000 	ldr	r3, [r4]
   15a00:	e1500003 	cmp	r0, r3
   15a04:	8a000027 	bhi	15aa8 <RTMP_LogHex+0xbc>
		return;

	ptr = line;

	for(i=0; i<len; i++) {
   15a08:	e3520000 	cmp	r2, #0
   15a0c:	0a000025 	beq	15aa8 <RTMP_LogHex+0xbc>
		*ptr++ = hexdig[0x0f & (data[i] >> 4)];
   15a10:	e59f60c0 	ldr	r6, [pc, #192]	; 15ad8 <RTMP_LogHex+0xec>
		*ptr++ = hexdig[0x0f & data[i]];
		if ((i & 0x0f) == 0x0f) {
			*ptr = '\0';
			ptr = line;
			RTMP_Log(level, "%s", line);
   15a14:	e59fa0c0 	ldr	sl, [pc, #192]	; 15adc <RTMP_LogHex+0xf0>
	if ( level > RTMP_debuglevel )
		return;

	ptr = line;

	for(i=0; i<len; i++) {
   15a18:	e28d9004 	add	r9, sp, #4
   15a1c:	e1a07002 	mov	r7, r2
   15a20:	e1a08000 	mov	r8, r0
   15a24:	e3a04000 	mov	r4, #0
		*ptr++ = hexdig[0x0f & (data[i] >> 4)];
   15a28:	e08f6006 	add	r6, pc, r6
		*ptr++ = hexdig[0x0f & data[i]];
		if ((i & 0x0f) == 0x0f) {
			*ptr = '\0';
			ptr = line;
			RTMP_Log(level, "%s", line);
   15a2c:	e08fa00a 	add	sl, pc, sl
   15a30:	e2415001 	sub	r5, r1, #1
	if ( level > RTMP_debuglevel )
		return;

	ptr = line;

	for(i=0; i<len; i++) {
   15a34:	e1a03009 	mov	r3, r9
		if ((i & 0x0f) == 0x0f) {
			*ptr = '\0';
			ptr = line;
			RTMP_Log(level, "%s", line);
		} else {
			*ptr++ = ' ';
   15a38:	e3a0b020 	mov	fp, #32
   15a3c:	ea000002 	b	15a4c <RTMP_LogHex+0x60>
	if ( level > RTMP_debuglevel )
		return;

	ptr = line;

	for(i=0; i<len; i++) {
   15a40:	e2844001 	add	r4, r4, #1
   15a44:	e1540007 	cmp	r4, r7
   15a48:	0a000014 	beq	15aa0 <RTMP_LogHex+0xb4>
		*ptr++ = hexdig[0x0f & (data[i] >> 4)];
   15a4c:	e5f51001 	ldrb	r1, [r5, #1]!
		*ptr++ = hexdig[0x0f & data[i]];
		if ((i & 0x0f) == 0x0f) {
   15a50:	e204200f 	and	r2, r4, #15

	ptr = line;

	for(i=0; i<len; i++) {
		*ptr++ = hexdig[0x0f & (data[i] >> 4)];
		*ptr++ = hexdig[0x0f & data[i]];
   15a54:	e201000f 	and	r0, r1, #15
		if ((i & 0x0f) == 0x0f) {
   15a58:	e352000f 	cmp	r2, #15

	ptr = line;

	for(i=0; i<len; i++) {
		*ptr++ = hexdig[0x0f & (data[i] >> 4)];
		*ptr++ = hexdig[0x0f & data[i]];
   15a5c:	e7d60000 	ldrb	r0, [r6, r0]
		return;

	ptr = line;

	for(i=0; i<len; i++) {
		*ptr++ = hexdig[0x0f & (data[i] >> 4)];
   15a60:	e7d61221 	ldrb	r1, [r6, r1, lsr #4]
		*ptr++ = hexdig[0x0f & data[i]];
   15a64:	e5c30001 	strb	r0, [r3, #1]
		return;

	ptr = line;

	for(i=0; i<len; i++) {
		*ptr++ = hexdig[0x0f & (data[i] >> 4)];
   15a68:	e5c31000 	strb	r1, [r3]
		if ((i & 0x0f) == 0x0f) {
			*ptr = '\0';
			ptr = line;
			RTMP_Log(level, "%s", line);
		} else {
			*ptr++ = ' ';
   15a6c:	15c3b002 	strbne	fp, [r3, #2]
   15a70:	12833003 	addne	r3, r3, #3
	ptr = line;

	for(i=0; i<len; i++) {
		*ptr++ = hexdig[0x0f & (data[i] >> 4)];
		*ptr++ = hexdig[0x0f & data[i]];
		if ((i & 0x0f) == 0x0f) {
   15a74:	1afffff1 	bne	15a40 <RTMP_LogHex+0x54>
			*ptr = '\0';
   15a78:	e3a0c000 	mov	ip, #0
   15a7c:	e5c3c002 	strb	ip, [r3, #2]
			ptr = line;
			RTMP_Log(level, "%s", line);
   15a80:	e1a00008 	mov	r0, r8
   15a84:	e1a0100a 	mov	r1, sl
   15a88:	e1a02009 	mov	r2, r9
	if ( level > RTMP_debuglevel )
		return;

	ptr = line;

	for(i=0; i<len; i++) {
   15a8c:	e2844001 	add	r4, r4, #1
		*ptr++ = hexdig[0x0f & (data[i] >> 4)];
		*ptr++ = hexdig[0x0f & data[i]];
		if ((i & 0x0f) == 0x0f) {
			*ptr = '\0';
			ptr = line;
			RTMP_Log(level, "%s", line);
   15a90:	ebffffc5 	bl	159ac <RTMP_Log>
	if ( level > RTMP_debuglevel )
		return;

	ptr = line;

	for(i=0; i<len; i++) {
   15a94:	e1540007 	cmp	r4, r7
		*ptr++ = hexdig[0x0f & (data[i] >> 4)];
		*ptr++ = hexdig[0x0f & data[i]];
		if ((i & 0x0f) == 0x0f) {
			*ptr = '\0';
			ptr = line;
   15a98:	e1a03009 	mov	r3, r9
	if ( level > RTMP_debuglevel )
		return;

	ptr = line;

	for(i=0; i<len; i++) {
   15a9c:	1affffea 	bne	15a4c <RTMP_LogHex+0x60>
			RTMP_Log(level, "%s", line);
		} else {
			*ptr++ = ' ';
		}
	}
	if (i & 0x0f) {
   15aa0:	e314000f 	tst	r4, #15
   15aa4:	1a000001 	bne	15ab0 <RTMP_LogHex+0xc4>
		*ptr = '\0';
		RTMP_Log(level, "%s", line);
	}
}
   15aa8:	e28dd03c 	add	sp, sp, #60	; 0x3c
   15aac:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
			*ptr++ = ' ';
		}
	}
	if (i & 0x0f) {
		*ptr = '\0';
		RTMP_Log(level, "%s", line);
   15ab0:	e59f1028 	ldr	r1, [pc, #40]	; 15ae0 <RTMP_LogHex+0xf4>
		} else {
			*ptr++ = ' ';
		}
	}
	if (i & 0x0f) {
		*ptr = '\0';
   15ab4:	e3a0c000 	mov	ip, #0
		RTMP_Log(level, "%s", line);
   15ab8:	e1a00008 	mov	r0, r8
   15abc:	e1a02009 	mov	r2, r9
   15ac0:	e08f1001 	add	r1, pc, r1
		} else {
			*ptr++ = ' ';
		}
	}
	if (i & 0x0f) {
		*ptr = '\0';
   15ac4:	e5c3c000 	strb	ip, [r3]
		RTMP_Log(level, "%s", line);
   15ac8:	ebffffb7 	bl	159ac <RTMP_Log>
	}
}
   15acc:	e28dd03c 	add	sp, sp, #60	; 0x3c
   15ad0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
   15ad4:	0000e3b0 	.word	0x0000e3b0
   15ad8:	0000bfc8 	.word	0x0000bfc8
   15adc:	000085e4 	.word	0x000085e4
   15ae0:	00008550 	.word	0x00008550

00015ae4 <RTMP_LogHexString>:
#define BP_GRAPH 60
#define BP_LEN	80
	char	line[BP_LEN];
	unsigned long i;

	if ( !data || level > RTMP_debuglevel )
   15ae4:	e3510000 	cmp	r1, #0
   15ae8:	012fff1e 	bxeq	lr
		RTMP_Log(level, "%s", line);
	}
}

void RTMP_LogHexString(int level, const uint8_t *data, unsigned long len)
{
   15aec:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15af0:	e59f5154 	ldr	r5, [pc, #340]	; 15c4c <RTMP_LogHexString+0x168>
   15af4:	e24dd05c 	sub	sp, sp, #92	; 0x5c
#define BP_GRAPH 60
#define BP_LEN	80
	char	line[BP_LEN];
	unsigned long i;

	if ( !data || level > RTMP_debuglevel )
   15af8:	e79f5005 	ldr	r5, [pc, r5]
   15afc:	e5956000 	ldr	r6, [r5]
   15b00:	e1500006 	cmp	r0, r6
   15b04:	8a00004c 	bhi	15c3c <RTMP_LogHexString+0x158>
		return;

	/* in case len is zero */
	line[0] = '\0';
   15b08:	e3a0c000 	mov	ip, #0

	for ( i = 0 ; i < len ; i++ ) {
   15b0c:	e3520000 	cmp	r2, #0
   15b10:	e1a09002 	mov	r9, r2
   15b14:	e58d0000 	str	r0, [sp]
   15b18:	e1a04001 	mov	r4, r1

	if ( !data || level > RTMP_debuglevel )
		return;

	/* in case len is zero */
	line[0] = '\0';
   15b1c:	e5cdc008 	strb	ip, [sp, #8]

	for ( i = 0 ; i < len ; i++ ) {
   15b20:	0a000047 	beq	15c44 <RTMP_LogHexString+0x160>
			memset( line, ' ', sizeof(line)-2 );
			line[sizeof(line)-2] = '\0';

			off = i % 0x0ffffU;

			line[2] = hexdig[0x0f & (off >> 12)];
   15b24:	e59f6124 	ldr	r6, [pc, #292]	; 15c50 <RTMP_LogHexString+0x16c>
	for ( i = 0 ; i < len ; i++ ) {
		int n = i % 16;
		unsigned off;

		if( !n ) {
			if( i ) RTMP_Log( level, "%s", line );
   15b28:	e59f3124 	ldr	r3, [pc, #292]	; 15c54 <RTMP_LogHexString+0x170>
			line[5] = hexdig[0x0f & off];
			line[6] = ':';
		}

		off = BP_OFFSET + n*3 + ((n >= 8)?1:0);
		line[off] = hexdig[0x0f & ( data[i] >> 4 )];
   15b2c:	e59f5124 	ldr	r5, [pc, #292]	; 15c58 <RTMP_LogHexString+0x174>
	for ( i = 0 ; i < len ; i++ ) {
		int n = i % 16;
		unsigned off;

		if( !n ) {
			if( i ) RTMP_Log( level, "%s", line );
   15b30:	e08f3003 	add	r3, pc, r3
			memset( line, ' ', sizeof(line)-2 );
			line[sizeof(line)-2] = '\0';

			off = i % 0x0ffffU;

			line[2] = hexdig[0x0f & (off >> 12)];
   15b34:	e08f6006 	add	r6, pc, r6
			line[5] = hexdig[0x0f & off];
			line[6] = ':';
		}

		off = BP_OFFSET + n*3 + ((n >= 8)?1:0);
		line[off] = hexdig[0x0f & ( data[i] >> 4 )];
   15b38:	e08f5005 	add	r5, pc, r5
		return;

	/* in case len is zero */
	line[0] = '\0';

	for ( i = 0 ; i < len ; i++ ) {
   15b3c:	e1a0b00c 	mov	fp, ip
   15b40:	e28d8008 	add	r8, sp, #8
		int n = i % 16;
		unsigned off;

		if( !n ) {
			if( i ) RTMP_Log( level, "%s", line );
   15b44:	e58d3004 	str	r3, [sp, #4]

	for ( i = 0 ; i < len ; i++ ) {
		int n = i % 16;
		unsigned off;

		if( !n ) {
   15b48:	e21b700f 	ands	r7, fp, #15
			if( i ) RTMP_Log( level, "%s", line );
   15b4c:	e89d0003 	ldm	sp, {r0, r1}
   15b50:	e1a02008 	mov	r2, r8

	for ( i = 0 ; i < len ; i++ ) {
		int n = i % 16;
		unsigned off;

		if( !n ) {
   15b54:	1a00001c 	bne	15bcc <RTMP_LogHexString+0xe8>
			if( i ) RTMP_Log( level, "%s", line );
   15b58:	e35b0000 	cmp	fp, #0
   15b5c:	0a000000 	beq	15b64 <RTMP_LogHexString+0x80>
   15b60:	ebffff91 	bl	159ac <RTMP_Log>
			memset( line, ' ', sizeof(line)-2 );
   15b64:	e3a01020 	mov	r1, #32
   15b68:	e3a0204e 	mov	r2, #78	; 0x4e
   15b6c:	e1a00008 	mov	r0, r8
   15b70:	ebffbd56 	bl	50d0 <memset@plt>
			line[sizeof(line)-2] = '\0';

			off = i % 0x0ffffU;
   15b74:	e59f20e0 	ldr	r2, [pc, #224]	; 15c5c <RTMP_LogHexString+0x178>
		unsigned off;

		if( !n ) {
			if( i ) RTMP_Log( level, "%s", line );
			memset( line, ' ', sizeof(line)-2 );
			line[sizeof(line)-2] = '\0';
   15b78:	e3a00000 	mov	r0, #0

			off = i % 0x0ffffU;
   15b7c:	e082329b 	umull	r3, r2, fp, r2
		unsigned off;

		if( !n ) {
			if( i ) RTMP_Log( level, "%s", line );
			memset( line, ' ', sizeof(line)-2 );
			line[sizeof(line)-2] = '\0';
   15b80:	e5cd0056 	strb	r0, [sp, #86]	; 0x56

			off = i % 0x0ffffU;
   15b84:	e1a027a2 	lsr	r2, r2, #15
   15b88:	e0622802 	rsb	r2, r2, r2, lsl #16
   15b8c:	e062200b 	rsb	r2, r2, fp

			line[2] = hexdig[0x0f & (off >> 12)];
			line[3] = hexdig[0x0f & (off >>  8)];
   15b90:	e1a01422 	lsr	r1, r2, #8
			line[4] = hexdig[0x0f & (off >>  4)];
   15b94:	e1a0e222 	lsr	lr, r2, #4
			line[sizeof(line)-2] = '\0';

			off = i % 0x0ffffU;

			line[2] = hexdig[0x0f & (off >> 12)];
			line[3] = hexdig[0x0f & (off >>  8)];
   15b98:	e201100f 	and	r1, r1, #15
   15b9c:	e7d61001 	ldrb	r1, [r6, r1]
			line[4] = hexdig[0x0f & (off >>  4)];
   15ba0:	e20ee00f 	and	lr, lr, #15
   15ba4:	e7d6e00e 	ldrb	lr, [r6, lr]
			line[sizeof(line)-2] = '\0';

			off = i % 0x0ffffU;

			line[2] = hexdig[0x0f & (off >> 12)];
			line[3] = hexdig[0x0f & (off >>  8)];
   15ba8:	e5cd100b 	strb	r1, [sp, #11]
			line[4] = hexdig[0x0f & (off >>  4)];
			line[5] = hexdig[0x0f & off];
   15bac:	e202100f 	and	r1, r2, #15
   15bb0:	e7d61001 	ldrb	r1, [r6, r1]
			memset( line, ' ', sizeof(line)-2 );
			line[sizeof(line)-2] = '\0';

			off = i % 0x0ffffU;

			line[2] = hexdig[0x0f & (off >> 12)];
   15bb4:	e7d62622 	ldrb	r2, [r6, r2, lsr #12]
			line[3] = hexdig[0x0f & (off >>  8)];
			line[4] = hexdig[0x0f & (off >>  4)];
   15bb8:	e5cde00c 	strb	lr, [sp, #12]
			line[5] = hexdig[0x0f & off];
			line[6] = ':';
   15bbc:	e3a0e03a 	mov	lr, #58	; 0x3a
			off = i % 0x0ffffU;

			line[2] = hexdig[0x0f & (off >> 12)];
			line[3] = hexdig[0x0f & (off >>  8)];
			line[4] = hexdig[0x0f & (off >>  4)];
			line[5] = hexdig[0x0f & off];
   15bc0:	e5cd100d 	strb	r1, [sp, #13]
			memset( line, ' ', sizeof(line)-2 );
			line[sizeof(line)-2] = '\0';

			off = i % 0x0ffffU;

			line[2] = hexdig[0x0f & (off >> 12)];
   15bc4:	e5cd200a 	strb	r2, [sp, #10]
			line[3] = hexdig[0x0f & (off >>  8)];
			line[4] = hexdig[0x0f & (off >>  4)];
			line[5] = hexdig[0x0f & off];
			line[6] = ':';
   15bc8:	e5cde00e 	strb	lr, [sp, #14]
		}

		off = BP_OFFSET + n*3 + ((n >= 8)?1:0);
   15bcc:	e0872087 	add	r2, r7, r7, lsl #1
		line[off] = hexdig[0x0f & ( data[i] >> 4 )];
   15bd0:	e4d4a001 	ldrb	sl, [r4], #1
			line[4] = hexdig[0x0f & (off >>  4)];
			line[5] = hexdig[0x0f & off];
			line[6] = ':';
		}

		off = BP_OFFSET + n*3 + ((n >= 8)?1:0);
   15bd4:	e2822009 	add	r2, r2, #9
		line[off] = hexdig[0x0f & ( data[i] >> 4 )];
   15bd8:	e28d3058 	add	r3, sp, #88	; 0x58
			line[4] = hexdig[0x0f & (off >>  4)];
			line[5] = hexdig[0x0f & off];
			line[6] = ':';
		}

		off = BP_OFFSET + n*3 + ((n >= 8)?1:0);
   15bdc:	e3570007 	cmp	r7, #7
   15be0:	c2822001 	addgt	r2, r2, #1
		line[off] = hexdig[0x0f & ( data[i] >> 4 )];
   15be4:	e0832002 	add	r2, r3, r2
   15be8:	e7d5022a 	ldrb	r0, [r5, sl, lsr #4]
		line[off+1] = hexdig[0x0f & data[i]];
   15bec:	e20ae00f 	and	lr, sl, #15
   15bf0:	e7d5e00e 	ldrb	lr, [r5, lr]
			line[5] = hexdig[0x0f & off];
			line[6] = ':';
		}

		off = BP_OFFSET + n*3 + ((n >= 8)?1:0);
		line[off] = hexdig[0x0f & ( data[i] >> 4 )];
   15bf4:	e5420050 	strb	r0, [r2, #-80]	; 0xffffffb0
		line[off+1] = hexdig[0x0f & data[i]];

		off = BP_GRAPH + n + ((n >= 8)?1:0);

		if ( isprint( data[i] )) {
   15bf8:	e1a0000a 	mov	r0, sl
			line[6] = ':';
		}

		off = BP_OFFSET + n*3 + ((n >= 8)?1:0);
		line[off] = hexdig[0x0f & ( data[i] >> 4 )];
		line[off+1] = hexdig[0x0f & data[i]];
   15bfc:	e542e04f 	strb	lr, [r2, #-79]	; 0xffffffb1

		off = BP_GRAPH + n + ((n >= 8)?1:0);

		if ( isprint( data[i] )) {
   15c00:	ebffbe46 	bl	5520 <isprint@plt>
			line[BP_GRAPH + n] = data[i];
   15c04:	e28d3058 	add	r3, sp, #88	; 0x58
   15c08:	e0832007 	add	r2, r3, r7
		} else {
			line[BP_GRAPH + n] = '.';
   15c0c:	e3a0e02e 	mov	lr, #46	; 0x2e
		return;

	/* in case len is zero */
	line[0] = '\0';

	for ( i = 0 ; i < len ; i++ ) {
   15c10:	e28bb001 	add	fp, fp, #1
		line[off] = hexdig[0x0f & ( data[i] >> 4 )];
		line[off+1] = hexdig[0x0f & data[i]];

		off = BP_GRAPH + n + ((n >= 8)?1:0);

		if ( isprint( data[i] )) {
   15c14:	e3500000 	cmp	r0, #0
			line[BP_GRAPH + n] = data[i];
   15c18:	1542a014 	strbne	sl, [r2, #-20]	; 0xffffffec
		} else {
			line[BP_GRAPH + n] = '.';
   15c1c:	0542e014 	strbeq	lr, [r2, #-20]	; 0xffffffec
		return;

	/* in case len is zero */
	line[0] = '\0';

	for ( i = 0 ; i < len ; i++ ) {
   15c20:	e15b0009 	cmp	fp, r9
   15c24:	1affffc7 	bne	15b48 <RTMP_LogHexString+0x64>
		} else {
			line[BP_GRAPH + n] = '.';
		}
	}

	RTMP_Log( level, "%s", line );
   15c28:	e59f1030 	ldr	r1, [pc, #48]	; 15c60 <RTMP_LogHexString+0x17c>
   15c2c:	e59d0000 	ldr	r0, [sp]
   15c30:	e1a02008 	mov	r2, r8
   15c34:	e08f1001 	add	r1, pc, r1
   15c38:	ebffff5b 	bl	159ac <RTMP_Log>
}
   15c3c:	e28dd05c 	add	sp, sp, #92	; 0x5c
   15c40:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
   15c44:	e28d8008 	add	r8, sp, #8
   15c48:	eafffff6 	b	15c28 <RTMP_LogHexString+0x144>
   15c4c:	0000e2b0 	.word	0x0000e2b0
   15c50:	0000bebc 	.word	0x0000bebc
   15c54:	000084e0 	.word	0x000084e0
   15c58:	0000beb8 	.word	0x0000beb8
   15c5c:	80008001 	.word	0x80008001
   15c60:	000083dc 	.word	0x000083dc

00015c64 <RTMP_LogPrintf>:

/* These should only be used by apps, never by the library itself */
void RTMP_LogPrintf(const char *format, ...)
{
   15c64:	e92d000f 	push	{r0, r1, r2, r3}
   15c68:	e92d4070 	push	{r4, r5, r6, lr}
   15c6c:	e24ddb02 	sub	sp, sp, #2048	; 0x800
   15c70:	e24dd008 	sub	sp, sp, #8
	char str[MAX_PRINT_LEN]="";
   15c74:	e3a03000 	mov	r3, #0
   15c78:	e1a01003 	mov	r1, r3
   15c7c:	e59f20ec 	ldr	r2, [pc, #236]	; 15d70 <RTMP_LogPrintf+0x10c>
   15c80:	e28d000c 	add	r0, sp, #12
   15c84:	e58d3008 	str	r3, [sp, #8]
   15c88:	ebffbd10 	bl	50d0 <memset@plt>
	int len;
	va_list args;
	va_start(args, format);
   15c8c:	e28dce81 	add	ip, sp, #2064	; 0x810
   15c90:	e28cc00c 	add	ip, ip, #12
	len = vsnprintf(str, MAX_PRINT_LEN-1, format, args);
   15c94:	e28d5008 	add	r5, sp, #8
   15c98:	e1a0300c 	mov	r3, ip
   15c9c:	e59d2818 	ldr	r2, [sp, #2072]	; 0x818
   15ca0:	e1a00005 	mov	r0, r5
   15ca4:	e59f10c8 	ldr	r1, [pc, #200]	; 15d74 <RTMP_LogPrintf+0x110>
void RTMP_LogPrintf(const char *format, ...)
{
	char str[MAX_PRINT_LEN]="";
	int len;
	va_list args;
	va_start(args, format);
   15ca8:	e58dc004 	str	ip, [sp, #4]
	len = vsnprintf(str, MAX_PRINT_LEN-1, format, args);
   15cac:	ebffbe12 	bl	54fc <vsnprintf@plt>
   15cb0:	e59f30c0 	ldr	r3, [pc, #192]	; 15d78 <RTMP_LogPrintf+0x114>
	va_end(args);

	if ( RTMP_debuglevel==RTMP_LOGCRIT )
   15cb4:	e79f3003 	ldr	r3, [pc, r3]
   15cb8:	e5933000 	ldr	r3, [r3]
   15cbc:	e3530000 	cmp	r3, #0
   15cc0:	0a000015 	beq	15d1c <RTMP_LogPrintf+0xb8>
		return;

	if ( !fmsg ) fmsg = stderr;
   15cc4:	e59f30b0 	ldr	r3, [pc, #176]	; 15d7c <RTMP_LogPrintf+0x118>
   15cc8:	e1a04000 	mov	r4, r0
   15ccc:	e08f3003 	add	r3, pc, r3
   15cd0:	e5931000 	ldr	r1, [r3]
   15cd4:	e3510000 	cmp	r1, #0
   15cd8:	0a00001e 	beq	15d58 <RTMP_LogPrintf+0xf4>

	if (neednl) {
   15cdc:	e59f609c 	ldr	r6, [pc, #156]	; 15d80 <RTMP_LogPrintf+0x11c>
   15ce0:	e08f6006 	add	r6, pc, r6
   15ce4:	e5963004 	ldr	r3, [r6, #4]
   15ce8:	e3530000 	cmp	r3, #0
   15cec:	1a00000f 	bne	15d30 <RTMP_LogPrintf+0xcc>
		neednl = 0;
	}

    if (len > MAX_PRINT_LEN-1)
          len = MAX_PRINT_LEN-1;
	fprintf(fmsg, "%s", str);
   15cf0:	e1a00005 	mov	r0, r5
   15cf4:	ebffbe0c 	bl	552c <fputs@plt>
   15cf8:	e59f3074 	ldr	r3, [pc, #116]	; 15d74 <RTMP_LogPrintf+0x110>
   15cfc:	e1540003 	cmp	r4, r3
   15d00:	a1a04003 	movge	r4, r3
    if (str[len-1] == '\n')
   15d04:	e28d3b02 	add	r3, sp, #2048	; 0x800
   15d08:	e2833008 	add	r3, r3, #8
   15d0c:	e0834004 	add	r4, r3, r4
   15d10:	e5543801 	ldrb	r3, [r4, #-2049]	; 0xfffff7ff
   15d14:	e353000a 	cmp	r3, #10
   15d18:	0a00000a 	beq	15d48 <RTMP_LogPrintf+0xe4>
		fflush(fmsg);
}
   15d1c:	e28ddb02 	add	sp, sp, #2048	; 0x800
   15d20:	e28dd008 	add	sp, sp, #8
   15d24:	e8bd4070 	pop	{r4, r5, r6, lr}
   15d28:	e28dd010 	add	sp, sp, #16
   15d2c:	e12fff1e 	bx	lr
		return;

	if ( !fmsg ) fmsg = stderr;

	if (neednl) {
		putc('\n', fmsg);
   15d30:	e3a0000a 	mov	r0, #10
   15d34:	ebffbdf6 	bl	5514 <putc@plt>
		neednl = 0;
   15d38:	e3a03000 	mov	r3, #0
   15d3c:	e5961000 	ldr	r1, [r6]
   15d40:	e5863004 	str	r3, [r6, #4]
   15d44:	eaffffe9 	b	15cf0 <RTMP_LogPrintf+0x8c>

    if (len > MAX_PRINT_LEN-1)
          len = MAX_PRINT_LEN-1;
	fprintf(fmsg, "%s", str);
    if (str[len-1] == '\n')
		fflush(fmsg);
   15d48:	e59f3034 	ldr	r3, [pc, #52]	; 15d84 <RTMP_LogPrintf+0x120>
   15d4c:	e79f0003 	ldr	r0, [pc, r3]
   15d50:	ebffbdf8 	bl	5538 <fflush@plt>
   15d54:	eafffff0 	b	15d1c <RTMP_LogPrintf+0xb8>
   15d58:	e59f2028 	ldr	r2, [pc, #40]	; 15d88 <RTMP_LogPrintf+0x124>
	va_end(args);

	if ( RTMP_debuglevel==RTMP_LOGCRIT )
		return;

	if ( !fmsg ) fmsg = stderr;
   15d5c:	e79f2002 	ldr	r2, [pc, r2]
   15d60:	e28220a8 	add	r2, r2, #168	; 0xa8
   15d64:	e1a01002 	mov	r1, r2
   15d68:	e5832000 	str	r2, [r3]
   15d6c:	eaffffda 	b	15cdc <RTMP_LogPrintf+0x78>
   15d70:	000007fc 	.word	0x000007fc
   15d74:	000007ff 	.word	0x000007ff
   15d78:	0000e0f4 	.word	0x0000e0f4
   15d7c:	00010b54 	.word	0x00010b54
   15d80:	00010b40 	.word	0x00010b40
   15d84:	00010ad4 	.word	0x00010ad4
   15d88:	0000e050 	.word	0x0000e050

00015d8c <RTMP_LogStatus>:
    if (str[len-1] == '\n')
		fflush(fmsg);
}

void RTMP_LogStatus(const char *format, ...)
{
   15d8c:	e92d000f 	push	{r0, r1, r2, r3}
   15d90:	e92d4030 	push	{r4, r5, lr}
   15d94:	e24ddb02 	sub	sp, sp, #2048	; 0x800
   15d98:	e24dd00c 	sub	sp, sp, #12
	char str[MAX_PRINT_LEN]="";
   15d9c:	e3a03000 	mov	r3, #0
   15da0:	e1a01003 	mov	r1, r3
   15da4:	e59f20a0 	ldr	r2, [pc, #160]	; 15e4c <RTMP_LogStatus+0xc0>
   15da8:	e28d000c 	add	r0, sp, #12
   15dac:	e58d3008 	str	r3, [sp, #8]
   15db0:	ebffbcc6 	bl	50d0 <memset@plt>
	va_list args;
	va_start(args, format);
   15db4:	e28dce81 	add	ip, sp, #2064	; 0x810
   15db8:	e28cc00c 	add	ip, ip, #12
	vsnprintf(str, MAX_PRINT_LEN-1, format, args);
   15dbc:	e28d5008 	add	r5, sp, #8
   15dc0:	e1a0300c 	mov	r3, ip
   15dc4:	e59d2818 	ldr	r2, [sp, #2072]	; 0x818
   15dc8:	e1a00005 	mov	r0, r5
   15dcc:	e59f107c 	ldr	r1, [pc, #124]	; 15e50 <RTMP_LogStatus+0xc4>

void RTMP_LogStatus(const char *format, ...)
{
	char str[MAX_PRINT_LEN]="";
	va_list args;
	va_start(args, format);
   15dd0:	e58dc004 	str	ip, [sp, #4]
	vsnprintf(str, MAX_PRINT_LEN-1, format, args);
   15dd4:	ebffbdc8 	bl	54fc <vsnprintf@plt>
   15dd8:	e59f3074 	ldr	r3, [pc, #116]	; 15e54 <RTMP_LogStatus+0xc8>
	va_end(args);

	if ( RTMP_debuglevel==RTMP_LOGCRIT )
   15ddc:	e79f3003 	ldr	r3, [pc, r3]
   15de0:	e5933000 	ldr	r3, [r3]
   15de4:	e3530000 	cmp	r3, #0
   15de8:	0a00000c 	beq	15e20 <RTMP_LogStatus+0x94>
		return;

	if ( !fmsg ) fmsg = stderr;
   15dec:	e59f3064 	ldr	r3, [pc, #100]	; 15e58 <RTMP_LogStatus+0xcc>
   15df0:	e08f3003 	add	r3, pc, r3
   15df4:	e5931000 	ldr	r1, [r3]
   15df8:	e3510000 	cmp	r1, #0
   15dfc:	0a00000c 	beq	15e34 <RTMP_LogStatus+0xa8>

	fprintf(fmsg, "%s", str);
	fflush(fmsg);
   15e00:	e59f4054 	ldr	r4, [pc, #84]	; 15e5c <RTMP_LogStatus+0xd0>
	if ( RTMP_debuglevel==RTMP_LOGCRIT )
		return;

	if ( !fmsg ) fmsg = stderr;

	fprintf(fmsg, "%s", str);
   15e04:	e1a00005 	mov	r0, r5
	fflush(fmsg);
   15e08:	e08f4004 	add	r4, pc, r4
	if ( RTMP_debuglevel==RTMP_LOGCRIT )
		return;

	if ( !fmsg ) fmsg = stderr;

	fprintf(fmsg, "%s", str);
   15e0c:	ebffbdc6 	bl	552c <fputs@plt>
	fflush(fmsg);
   15e10:	e5940000 	ldr	r0, [r4]
   15e14:	ebffbdc7 	bl	5538 <fflush@plt>
	neednl = 1;
   15e18:	e3a03001 	mov	r3, #1
   15e1c:	e5843004 	str	r3, [r4, #4]
}
   15e20:	e28ddb02 	add	sp, sp, #2048	; 0x800
   15e24:	e28dd00c 	add	sp, sp, #12
   15e28:	e8bd4030 	pop	{r4, r5, lr}
   15e2c:	e28dd010 	add	sp, sp, #16
   15e30:	e12fff1e 	bx	lr
   15e34:	e59f2024 	ldr	r2, [pc, #36]	; 15e60 <RTMP_LogStatus+0xd4>
	va_end(args);

	if ( RTMP_debuglevel==RTMP_LOGCRIT )
		return;

	if ( !fmsg ) fmsg = stderr;
   15e38:	e79f2002 	ldr	r2, [pc, r2]
   15e3c:	e28220a8 	add	r2, r2, #168	; 0xa8
   15e40:	e1a01002 	mov	r1, r2
   15e44:	e5832000 	str	r2, [r3]
   15e48:	eaffffec 	b	15e00 <RTMP_LogStatus+0x74>
   15e4c:	000007fc 	.word	0x000007fc
   15e50:	000007ff 	.word	0x000007ff
   15e54:	0000dfcc 	.word	0x0000dfcc
   15e58:	00010a30 	.word	0x00010a30
   15e5c:	00010a18 	.word	0x00010a18
   15e60:	0000df74 	.word	0x0000df74

00015e64 <AMF_DecodeInt16>:
unsigned short
AMF_DecodeInt16(const char *data)
{
  unsigned char *c = (unsigned char *) data;
  unsigned short val;
  val = (c[0] << 8) | c[1];
   15e64:	e5d03000 	ldrb	r3, [r0]
   15e68:	e5d00001 	ldrb	r0, [r0, #1]
  return val;
}
   15e6c:	e1800403 	orr	r0, r0, r3, lsl #8
   15e70:	e12fff1e 	bx	lr

00015e74 <AMF_DecodeInt24>:
unsigned int
AMF_DecodeInt24(const char *data)
{
  unsigned char *c = (unsigned char *) data;
  unsigned int val;
  val = (c[0] << 16) | (c[1] << 8) | c[2];
   15e74:	e5d03001 	ldrb	r3, [r0, #1]
   15e78:	e5d02000 	ldrb	r2, [r0]
   15e7c:	e1a03403 	lsl	r3, r3, #8
   15e80:	e5d00002 	ldrb	r0, [r0, #2]
   15e84:	e1833802 	orr	r3, r3, r2, lsl #16
  return val;
}
   15e88:	e1830000 	orr	r0, r3, r0
   15e8c:	e12fff1e 	bx	lr

00015e90 <AMF_DecodeInt32>:
unsigned int
AMF_DecodeInt32(const char *data)
{
  unsigned char *c = (unsigned char *)data;
  unsigned int val;
  val = (c[0] << 24) | (c[1] << 16) | (c[2] << 8) | c[3];
   15e90:	e5d02001 	ldrb	r2, [r0, #1]
   15e94:	e5d03000 	ldrb	r3, [r0]
   15e98:	e5d01003 	ldrb	r1, [r0, #3]
   15e9c:	e1a02802 	lsl	r2, r2, #16
   15ea0:	e1823c03 	orr	r3, r2, r3, lsl #24
   15ea4:	e5d00002 	ldrb	r0, [r0, #2]
   15ea8:	e1833001 	orr	r3, r3, r1
  return val;
}
   15eac:	e1830400 	orr	r0, r3, r0, lsl #8
   15eb0:	e12fff1e 	bx	lr

00015eb4 <AMF_DecodeString>:

void
AMF_DecodeString(const char *data, AVal *bv)
{
   15eb4:	e92d4038 	push	{r3, r4, r5, lr}
   15eb8:	e1a04001 	mov	r4, r1
   15ebc:	e1a05000 	mov	r5, r0
  bv->av_len = AMF_DecodeInt16(data);
   15ec0:	ebffffe7 	bl	15e64 <AMF_DecodeInt16>
  bv->av_val = (bv->av_len > 0) ? (char *)data + 2 : NULL;
   15ec4:	e3500000 	cmp	r0, #0
}

void
AMF_DecodeString(const char *data, AVal *bv)
{
  bv->av_len = AMF_DecodeInt16(data);
   15ec8:	e5840004 	str	r0, [r4, #4]
  bv->av_val = (bv->av_len > 0) ? (char *)data + 2 : NULL;
   15ecc:	12850002 	addne	r0, r5, #2
   15ed0:	e5840000 	str	r0, [r4]
   15ed4:	e8bd8038 	pop	{r3, r4, r5, pc}

00015ed8 <AMF_DecodeLongString>:
}

void
AMF_DecodeLongString(const char *data, AVal *bv)
{
   15ed8:	e92d4038 	push	{r3, r4, r5, lr}
   15edc:	e1a05001 	mov	r5, r1
   15ee0:	e1a04000 	mov	r4, r0
  bv->av_len = AMF_DecodeInt32(data);
   15ee4:	ebffffe9 	bl	15e90 <AMF_DecodeInt32>
  bv->av_val = (bv->av_len > 0) ? (char *)data + 4 : NULL;
   15ee8:	e3500000 	cmp	r0, #0
   15eec:	c2843004 	addgt	r3, r4, #4
   15ef0:	d3a03000 	movle	r3, #0
}

void
AMF_DecodeLongString(const char *data, AVal *bv)
{
  bv->av_len = AMF_DecodeInt32(data);
   15ef4:	e5850004 	str	r0, [r5, #4]
  bv->av_val = (bv->av_len > 0) ? (char *)data + 4 : NULL;
   15ef8:	e5853000 	str	r3, [r5]
   15efc:	e8bd8038 	pop	{r3, r4, r5, pc}

00015f00 <AMF_DecodeNumber>:
}

double
AMF_DecodeNumber(const char *data)
{
   15f00:	e92d4070 	push	{r4, r5, r6, lr}
   15f04:	e24dd008 	sub	sp, sp, #8
  memcpy(&dVal, data, 8);
#elif __BYTE_ORDER == __LITTLE_ENDIAN
  unsigned char *ci, *co;
  ci = (unsigned char *)data;
  co = (unsigned char *)&dVal;
  co[0] = ci[7];
   15f08:	e5d06007 	ldrb	r6, [r0, #7]
  co[1] = ci[6];
   15f0c:	e5d05006 	ldrb	r5, [r0, #6]
  co[2] = ci[5];
   15f10:	e5d04005 	ldrb	r4, [r0, #5]
  co[3] = ci[4];
   15f14:	e5d0e004 	ldrb	lr, [r0, #4]
  co[4] = ci[3];
   15f18:	e5d0c003 	ldrb	ip, [r0, #3]
  co[5] = ci[2];
   15f1c:	e5d01002 	ldrb	r1, [r0, #2]
  co[6] = ci[1];
   15f20:	e5d02001 	ldrb	r2, [r0, #1]
  co[7] = ci[0];
   15f24:	e5d03000 	ldrb	r3, [r0]
  memcpy(&dVal, data, 8);
#elif __BYTE_ORDER == __LITTLE_ENDIAN
  unsigned char *ci, *co;
  ci = (unsigned char *)data;
  co = (unsigned char *)&dVal;
  co[0] = ci[7];
   15f28:	e5cd6000 	strb	r6, [sp]
  co[1] = ci[6];
   15f2c:	e5cd5001 	strb	r5, [sp, #1]
  co[2] = ci[5];
   15f30:	e5cd4002 	strb	r4, [sp, #2]
  co[3] = ci[4];
   15f34:	e5cde003 	strb	lr, [sp, #3]
  co[4] = ci[3];
   15f38:	e5cdc004 	strb	ip, [sp, #4]
  co[5] = ci[2];
   15f3c:	e5cd1005 	strb	r1, [sp, #5]
  co[6] = ci[1];
   15f40:	e5cd2006 	strb	r2, [sp, #6]
  co[7] = ci[0];
   15f44:	e5cd3007 	strb	r3, [sp, #7]
  co[6] = ci[2];
  co[7] = ci[3];
#endif
#endif
  return dVal;
}
   15f48:	e1cd00d0 	ldrd	r0, [sp]
   15f4c:	e28dd008 	add	sp, sp, #8
   15f50:	e8bd8070 	pop	{r4, r5, r6, pc}

00015f54 <AMF_DecodeBoolean>:

int
AMF_DecodeBoolean(const char *data)
{
  return *data != 0;
   15f54:	e5d00000 	ldrb	r0, [r0]
}
   15f58:	e2900000 	adds	r0, r0, #0
   15f5c:	13a00001 	movne	r0, #1
   15f60:	e12fff1e 	bx	lr

00015f64 <AMF_EncodeInt16>:

char *
AMF_EncodeInt16(char *output, char *outend, short nVal)
{
   15f64:	e1a03000 	mov	r3, r0
  if (output+2 > outend)
   15f68:	e2800002 	add	r0, r0, #2
   15f6c:	e1500001 	cmp	r0, r1
    return NULL;

  output[1] = nVal & 0xff;
  output[0] = nVal >> 8;
   15f70:	91a01442 	asrls	r1, r2, #8
AMF_EncodeInt16(char *output, char *outend, short nVal)
{
  if (output+2 > outend)
    return NULL;

  output[1] = nVal & 0xff;
   15f74:	95c32001 	strbls	r2, [r3, #1]
  output[0] = nVal >> 8;
   15f78:	95c31000 	strbls	r1, [r3]

char *
AMF_EncodeInt16(char *output, char *outend, short nVal)
{
  if (output+2 > outend)
    return NULL;
   15f7c:	83a00000 	movhi	r0, #0

  output[1] = nVal & 0xff;
  output[0] = nVal >> 8;
  return output+2;
}
   15f80:	e12fff1e 	bx	lr

00015f84 <AMF_EncodeInt24>:

char *
AMF_EncodeInt24(char *output, char *outend, int nVal)
{
   15f84:	e1a03000 	mov	r3, r0
  if (output+3 > outend)
   15f88:	e2800003 	add	r0, r0, #3
   15f8c:	e1500001 	cmp	r0, r1
    return NULL;

  output[2] = nVal & 0xff;
  output[1] = nVal >> 8;
   15f90:	91a0c442 	asrls	ip, r2, #8
  output[0] = nVal >> 16;
   15f94:	91a01842 	asrls	r1, r2, #16
AMF_EncodeInt24(char *output, char *outend, int nVal)
{
  if (output+3 > outend)
    return NULL;

  output[2] = nVal & 0xff;
   15f98:	95c32002 	strbls	r2, [r3, #2]
  output[1] = nVal >> 8;
   15f9c:	95c3c001 	strbls	ip, [r3, #1]
  output[0] = nVal >> 16;
   15fa0:	95c31000 	strbls	r1, [r3]

char *
AMF_EncodeInt24(char *output, char *outend, int nVal)
{
  if (output+3 > outend)
    return NULL;
   15fa4:	83a00000 	movhi	r0, #0

  output[2] = nVal & 0xff;
  output[1] = nVal >> 8;
  output[0] = nVal >> 16;
  return output+3;
}
   15fa8:	e12fff1e 	bx	lr

00015fac <AMF_EncodeInt32>:

char *
AMF_EncodeInt32(char *output, char *outend, int nVal)
{
   15fac:	e1a03000 	mov	r3, r0
  if (output+4 > outend)
   15fb0:	e2800004 	add	r0, r0, #4
   15fb4:	e1500001 	cmp	r0, r1
   15fb8:	8a000008 	bhi	15fe0 <AMF_EncodeInt32+0x34>
  return output+3;
}

char *
AMF_EncodeInt32(char *output, char *outend, int nVal)
{
   15fbc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  if (output+4 > outend)
    return NULL;

  output[3] = nVal & 0xff;
  output[2] = nVal >> 8;
  output[1] = nVal >> 16;
   15fc0:	e1a0c842 	asr	ip, r2, #16
{
  if (output+4 > outend)
    return NULL;

  output[3] = nVal & 0xff;
  output[2] = nVal >> 8;
   15fc4:	e1a0e442 	asr	lr, r2, #8
  output[1] = nVal >> 16;
  output[0] = nVal >> 24;
   15fc8:	e1a01c42 	asr	r1, r2, #24
AMF_EncodeInt32(char *output, char *outend, int nVal)
{
  if (output+4 > outend)
    return NULL;

  output[3] = nVal & 0xff;
   15fcc:	e5c32003 	strb	r2, [r3, #3]
  output[2] = nVal >> 8;
   15fd0:	e5c3e002 	strb	lr, [r3, #2]
  output[1] = nVal >> 16;
   15fd4:	e5c3c001 	strb	ip, [r3, #1]
  output[0] = nVal >> 24;
   15fd8:	e5c31000 	strb	r1, [r3]
  return output+4;
   15fdc:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

char *
AMF_EncodeInt32(char *output, char *outend, int nVal)
{
  if (output+4 > outend)
    return NULL;
   15fe0:	e3a00000 	mov	r0, #0
   15fe4:	e12fff1e 	bx	lr

00015fe8 <AMF_EncodeString>:
}

char *
AMF_EncodeString(char *output, char *outend, const AVal *bv)
{
  if ((bv->av_len < 65536 && output + 1 + 2 + bv->av_len > outend) ||
   15fe8:	e5923004 	ldr	r3, [r2, #4]
  return output+4;
}

char *
AMF_EncodeString(char *output, char *outend, const AVal *bv)
{
   15fec:	e92d4010 	push	{r4, lr}
  if ((bv->av_len < 65536 && output + 1 + 2 + bv->av_len > outend) ||
   15ff0:	e3530801 	cmp	r3, #65536	; 0x10000
  return output+4;
}

char *
AMF_EncodeString(char *output, char *outend, const AVal *bv)
{
   15ff4:	e1a04002 	mov	r4, r2
  if ((bv->av_len < 65536 && output + 1 + 2 + bv->av_len > outend) ||
   15ff8:	aa000014 	bge	16050 <AMF_EncodeString+0x68>
   15ffc:	e283c003 	add	ip, r3, #3
   16000:	e080c00c 	add	ip, r0, ip
   16004:	e151000c 	cmp	r1, ip
   16008:	3a00001b 	bcc	1607c <AMF_EncodeString+0x94>
	output + 1 + 4 + bv->av_len > outend)
   1600c:	e2833005 	add	r3, r3, #5
   16010:	e0803003 	add	r3, r0, r3
}

char *
AMF_EncodeString(char *output, char *outend, const AVal *bv)
{
  if ((bv->av_len < 65536 && output + 1 + 2 + bv->av_len > outend) ||
   16014:	e1510003 	cmp	r1, r3
   16018:	3a000017 	bcc	1607c <AMF_EncodeString+0x94>
	output + 1 + 4 + bv->av_len > outend)
    return NULL;

  if (bv->av_len < 65536)
    {
      *output++ = AMF_STRING;
   1601c:	e3a03002 	mov	r3, #2
   16020:	e5c03000 	strb	r3, [r0]

      output = AMF_EncodeInt16(output, outend, bv->av_len);
   16024:	e2800001 	add	r0, r0, #1
   16028:	e1d420f4 	ldrsh	r2, [r4, #4]
   1602c:	ebffffcc 	bl	15f64 <AMF_EncodeInt16>
   16030:	e1a03000 	mov	r3, r0
    {
      *output++ = AMF_LONG_STRING;

      output = AMF_EncodeInt32(output, outend, bv->av_len);
    }
  memcpy(output, bv->av_val, bv->av_len);
   16034:	e1a00003 	mov	r0, r3
   16038:	e8940006 	ldm	r4, {r1, r2}
   1603c:	ebffbc62 	bl	51cc <memcpy@plt>
   16040:	e1a03000 	mov	r3, r0
  output += bv->av_len;
   16044:	e5940004 	ldr	r0, [r4, #4]
   16048:	e0830000 	add	r0, r3, r0

  return output;
   1604c:	e8bd8010 	pop	{r4, pc}

char *
AMF_EncodeString(char *output, char *outend, const AVal *bv)
{
  if ((bv->av_len < 65536 && output + 1 + 2 + bv->av_len > outend) ||
	output + 1 + 4 + bv->av_len > outend)
   16050:	e2833005 	add	r3, r3, #5
   16054:	e0803003 	add	r3, r0, r3
}

char *
AMF_EncodeString(char *output, char *outend, const AVal *bv)
{
  if ((bv->av_len < 65536 && output + 1 + 2 + bv->av_len > outend) ||
   16058:	e1510003 	cmp	r1, r3
   1605c:	3a000006 	bcc	1607c <AMF_EncodeString+0x94>

      output = AMF_EncodeInt16(output, outend, bv->av_len);
    }
  else
    {
      *output++ = AMF_LONG_STRING;
   16060:	e3a0300c 	mov	r3, #12
   16064:	e5c03000 	strb	r3, [r0]

      output = AMF_EncodeInt32(output, outend, bv->av_len);
   16068:	e2800001 	add	r0, r0, #1
   1606c:	e5942004 	ldr	r2, [r4, #4]
   16070:	ebffffcd 	bl	15fac <AMF_EncodeInt32>
   16074:	e1a03000 	mov	r3, r0
   16078:	eaffffed 	b	16034 <AMF_EncodeString+0x4c>
char *
AMF_EncodeString(char *output, char *outend, const AVal *bv)
{
  if ((bv->av_len < 65536 && output + 1 + 2 + bv->av_len > outend) ||
	output + 1 + 4 + bv->av_len > outend)
    return NULL;
   1607c:	e3a00000 	mov	r0, #0
   16080:	e8bd8010 	pop	{r4, pc}

00016084 <AMF_EncodeNumber>:
  return output;
}

char *
AMF_EncodeNumber(char *output, char *outend, double dVal)
{
   16084:	e1a0c000 	mov	ip, r0
  if (output+1+8 > outend)
   16088:	e2800009 	add	r0, r0, #9
  return output;
}

char *
AMF_EncodeNumber(char *output, char *outend, double dVal)
{
   1608c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  if (output+1+8 > outend)
   16090:	e1500001 	cmp	r0, r1
  return output;
}

char *
AMF_EncodeNumber(char *output, char *outend, double dVal)
{
   16094:	e24dd008 	sub	sp, sp, #8
   16098:	e1cd20f0 	strd	r2, [sp]
  if (output+1+8 > outend)
   1609c:	8a000013 	bhi	160f0 <AMF_EncodeNumber+0x6c>
    return NULL;

  *output++ = AMF_NUMBER;	/* type: Number */
   160a0:	e3a08000 	mov	r8, #0
#elif __BYTE_ORDER == __LITTLE_ENDIAN
  {
    unsigned char *ci, *co;
    ci = (unsigned char *)&dVal;
    co = (unsigned char *)output;
    co[0] = ci[7];
   160a4:	e5dd7007 	ldrb	r7, [sp, #7]
    co[1] = ci[6];
   160a8:	e5dd6006 	ldrb	r6, [sp, #6]
    co[2] = ci[5];
   160ac:	e5dd5005 	ldrb	r5, [sp, #5]
    co[3] = ci[4];
   160b0:	e5dd4004 	ldrb	r4, [sp, #4]
    co[4] = ci[3];
   160b4:	e5dde003 	ldrb	lr, [sp, #3]
    co[5] = ci[2];
   160b8:	e5dd1002 	ldrb	r1, [sp, #2]
    co[6] = ci[1];
   160bc:	e5dd2001 	ldrb	r2, [sp, #1]
    co[7] = ci[0];
   160c0:	e5dd3000 	ldrb	r3, [sp]
AMF_EncodeNumber(char *output, char *outend, double dVal)
{
  if (output+1+8 > outend)
    return NULL;

  *output++ = AMF_NUMBER;	/* type: Number */
   160c4:	e5cc8000 	strb	r8, [ip]
#elif __BYTE_ORDER == __LITTLE_ENDIAN
  {
    unsigned char *ci, *co;
    ci = (unsigned char *)&dVal;
    co = (unsigned char *)output;
    co[0] = ci[7];
   160c8:	e5cc7001 	strb	r7, [ip, #1]
    co[1] = ci[6];
   160cc:	e5cc6002 	strb	r6, [ip, #2]
    co[2] = ci[5];
   160d0:	e5cc5003 	strb	r5, [ip, #3]
    co[3] = ci[4];
   160d4:	e5cc4004 	strb	r4, [ip, #4]
    co[4] = ci[3];
   160d8:	e5cce005 	strb	lr, [ip, #5]
    co[5] = ci[2];
   160dc:	e5cc1006 	strb	r1, [ip, #6]
    co[6] = ci[1];
   160e0:	e5cc2007 	strb	r2, [ip, #7]
    co[7] = ci[0];
   160e4:	e5cc3008 	strb	r3, [ip, #8]
  }
#endif
#endif

  return output+8;
}
   160e8:	e28dd008 	add	sp, sp, #8
   160ec:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

char *
AMF_EncodeNumber(char *output, char *outend, double dVal)
{
  if (output+1+8 > outend)
    return NULL;
   160f0:	e3a00000 	mov	r0, #0
  }
#endif
#endif

  return output+8;
}
   160f4:	e28dd008 	add	sp, sp, #8
   160f8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

000160fc <AMF_EncodeBoolean>:

char *
AMF_EncodeBoolean(char *output, char *outend, int bVal)
{
  if (output+2 > outend)
   160fc:	e2803002 	add	r3, r0, #2
   16100:	e1530001 	cmp	r3, r1
   16104:	8a000006 	bhi	16124 <AMF_EncodeBoolean+0x28>
    return NULL;

  *output++ = AMF_BOOLEAN;

  *output++ = bVal ? 0x01 : 0x00;
   16108:	e2922000 	adds	r2, r2, #0
   1610c:	13a02001 	movne	r2, #1
AMF_EncodeBoolean(char *output, char *outend, int bVal)
{
  if (output+2 > outend)
    return NULL;

  *output++ = AMF_BOOLEAN;
   16110:	e3a01001 	mov	r1, #1

  *output++ = bVal ? 0x01 : 0x00;
   16114:	e5c02001 	strb	r2, [r0, #1]
AMF_EncodeBoolean(char *output, char *outend, int bVal)
{
  if (output+2 > outend)
    return NULL;

  *output++ = AMF_BOOLEAN;
   16118:	e5c01000 	strb	r1, [r0]

  *output++ = bVal ? 0x01 : 0x00;

  return output;
}
   1611c:	e1a00003 	mov	r0, r3
   16120:	e12fff1e 	bx	lr

char *
AMF_EncodeBoolean(char *output, char *outend, int bVal)
{
  if (output+2 > outend)
    return NULL;
   16124:	e3a03000 	mov	r3, #0
  *output++ = AMF_BOOLEAN;

  *output++ = bVal ? 0x01 : 0x00;

  return output;
}
   16128:	e1a00003 	mov	r0, r3
   1612c:	e12fff1e 	bx	lr

00016130 <AMF_EncodeNamedString>:

char *
AMF_EncodeNamedString(char *output, char *outend, const AVal *strName, const AVal *strValue)
{
   16130:	e92d4070 	push	{r4, r5, r6, lr}
   16134:	e1a04002 	mov	r4, r2
  if (output+2+strName->av_len > outend)
   16138:	e5922004 	ldr	r2, [r2, #4]
   1613c:	e282e002 	add	lr, r2, #2
   16140:	e080e00e 	add	lr, r0, lr
   16144:	e151000e 	cmp	r1, lr
   16148:	3a00000d 	bcc	16184 <AMF_EncodeNamedString+0x54>
    return NULL;
  output = AMF_EncodeInt16(output, outend, strName->av_len);
   1614c:	e1a02802 	lsl	r2, r2, #16
   16150:	e1a02842 	asr	r2, r2, #16
   16154:	e1a06003 	mov	r6, r3
   16158:	e1a05001 	mov	r5, r1
   1615c:	ebffff80 	bl	15f64 <AMF_EncodeInt16>

  memcpy(output, strName->av_val, strName->av_len);
   16160:	e8940006 	ldm	r4, {r1, r2}
   16164:	ebffbc18 	bl	51cc <memcpy@plt>
  output += strName->av_len;

  return AMF_EncodeString(output, outend, strValue);
   16168:	e1a01005 	mov	r1, r5
   1616c:	e1a02006 	mov	r2, r6
{
  if (output+2+strName->av_len > outend)
    return NULL;
  output = AMF_EncodeInt16(output, outend, strName->av_len);

  memcpy(output, strName->av_val, strName->av_len);
   16170:	e1a03000 	mov	r3, r0
  output += strName->av_len;
   16174:	e5940004 	ldr	r0, [r4, #4]

  return AMF_EncodeString(output, outend, strValue);
}
   16178:	e8bd4070 	pop	{r4, r5, r6, lr}
  output = AMF_EncodeInt16(output, outend, strName->av_len);

  memcpy(output, strName->av_val, strName->av_len);
  output += strName->av_len;

  return AMF_EncodeString(output, outend, strValue);
   1617c:	e0830000 	add	r0, r3, r0
   16180:	eaffff98 	b	15fe8 <AMF_EncodeString>
}
   16184:	e3a00000 	mov	r0, #0
   16188:	e8bd8070 	pop	{r4, r5, r6, pc}

0001618c <AMF_EncodeNamedNumber>:

char *
AMF_EncodeNamedNumber(char *output, char *outend, const AVal *strName, double dVal)
{
  if (output+2+strName->av_len > outend)
   1618c:	e592c004 	ldr	ip, [r2, #4]
  return AMF_EncodeString(output, outend, strValue);
}

char *
AMF_EncodeNamedNumber(char *output, char *outend, const AVal *strName, double dVal)
{
   16190:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  if (output+2+strName->av_len > outend)
   16194:	e28ce002 	add	lr, ip, #2
   16198:	e080e00e 	add	lr, r0, lr
   1619c:	e151000e 	cmp	r1, lr
  return AMF_EncodeString(output, outend, strValue);
}

char *
AMF_EncodeNamedNumber(char *output, char *outend, const AVal *strName, double dVal)
{
   161a0:	e1cd61d8 	ldrd	r6, [sp, #24]
  if (output+2+strName->av_len > outend)
   161a4:	3a00000e 	bcc	161e4 <AMF_EncodeNamedNumber+0x58>
   161a8:	e1a04002 	mov	r4, r2
    return NULL;
  output = AMF_EncodeInt16(output, outend, strName->av_len);
   161ac:	e1a0280c 	lsl	r2, ip, #16
   161b0:	e1a02842 	asr	r2, r2, #16
   161b4:	e1a05001 	mov	r5, r1
   161b8:	ebffff69 	bl	15f64 <AMF_EncodeInt16>

  memcpy(output, strName->av_val, strName->av_len);
   161bc:	e8940006 	ldm	r4, {r1, r2}
   161c0:	ebffbc01 	bl	51cc <memcpy@plt>
  output += strName->av_len;

  return AMF_EncodeNumber(output, outend, dVal);
   161c4:	e1a01005 	mov	r1, r5
   161c8:	e1a02006 	mov	r2, r6
{
  if (output+2+strName->av_len > outend)
    return NULL;
  output = AMF_EncodeInt16(output, outend, strName->av_len);

  memcpy(output, strName->av_val, strName->av_len);
   161cc:	e1a03000 	mov	r3, r0
  output += strName->av_len;
   161d0:	e5940004 	ldr	r0, [r4, #4]

  return AMF_EncodeNumber(output, outend, dVal);
   161d4:	e0830000 	add	r0, r3, r0
   161d8:	e1a03007 	mov	r3, r7
}
   161dc:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
  output = AMF_EncodeInt16(output, outend, strName->av_len);

  memcpy(output, strName->av_val, strName->av_len);
  output += strName->av_len;

  return AMF_EncodeNumber(output, outend, dVal);
   161e0:	eaffffa7 	b	16084 <AMF_EncodeNumber>
}
   161e4:	e3a00000 	mov	r0, #0
   161e8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

000161ec <AMF_EncodeNamedBoolean>:

char *
AMF_EncodeNamedBoolean(char *output, char *outend, const AVal *strName, int bVal)
{
   161ec:	e92d4070 	push	{r4, r5, r6, lr}
   161f0:	e1a04002 	mov	r4, r2
  if (output+2+strName->av_len > outend)
   161f4:	e5922004 	ldr	r2, [r2, #4]
   161f8:	e282e002 	add	lr, r2, #2
   161fc:	e080e00e 	add	lr, r0, lr
   16200:	e151000e 	cmp	r1, lr
   16204:	3a00000d 	bcc	16240 <AMF_EncodeNamedBoolean+0x54>
    return NULL;
  output = AMF_EncodeInt16(output, outend, strName->av_len);
   16208:	e1a02802 	lsl	r2, r2, #16
   1620c:	e1a02842 	asr	r2, r2, #16
   16210:	e1a06003 	mov	r6, r3
   16214:	e1a05001 	mov	r5, r1
   16218:	ebffff51 	bl	15f64 <AMF_EncodeInt16>

  memcpy(output, strName->av_val, strName->av_len);
   1621c:	e8940006 	ldm	r4, {r1, r2}
   16220:	ebffbbe9 	bl	51cc <memcpy@plt>
  output += strName->av_len;

  return AMF_EncodeBoolean(output, outend, bVal);
   16224:	e1a01005 	mov	r1, r5
   16228:	e1a02006 	mov	r2, r6
{
  if (output+2+strName->av_len > outend)
    return NULL;
  output = AMF_EncodeInt16(output, outend, strName->av_len);

  memcpy(output, strName->av_val, strName->av_len);
   1622c:	e1a03000 	mov	r3, r0
  output += strName->av_len;
   16230:	e5940004 	ldr	r0, [r4, #4]

  return AMF_EncodeBoolean(output, outend, bVal);
}
   16234:	e8bd4070 	pop	{r4, r5, r6, lr}
  output = AMF_EncodeInt16(output, outend, strName->av_len);

  memcpy(output, strName->av_val, strName->av_len);
  output += strName->av_len;

  return AMF_EncodeBoolean(output, outend, bVal);
   16238:	e0830000 	add	r0, r3, r0
   1623c:	eaffffae 	b	160fc <AMF_EncodeBoolean>
}
   16240:	e3a00000 	mov	r0, #0
   16244:	e8bd8070 	pop	{r4, r5, r6, pc}

00016248 <AMFProp_GetName>:

void
AMFProp_GetName(AMFObjectProperty *prop, AVal *name)
{
   16248:	e1a03001 	mov	r3, r1
  *name = prop->p_name;
   1624c:	e8900003 	ldm	r0, {r0, r1}
   16250:	e8830003 	stm	r3, {r0, r1}
   16254:	e12fff1e 	bx	lr

00016258 <AMFProp_SetName>:
}

void
AMFProp_SetName(AMFObjectProperty *prop, AVal *name)
{
   16258:	e1a03000 	mov	r3, r0
  prop->p_name = *name;
   1625c:	e8910003 	ldm	r1, {r0, r1}
   16260:	e8830003 	stm	r3, {r0, r1}
   16264:	e12fff1e 	bx	lr

00016268 <AMFProp_GetType>:

AMFDataType
AMFProp_GetType(AMFObjectProperty *prop)
{
  return prop->p_type;
}
   16268:	e5900008 	ldr	r0, [r0, #8]
   1626c:	e12fff1e 	bx	lr

00016270 <AMFProp_GetNumber>:

double
AMFProp_GetNumber(AMFObjectProperty *prop)
{
  return prop->p_vu.p_number;
}
   16270:	e1c001d0 	ldrd	r0, [r0, #16]
   16274:	e12fff1e 	bx	lr

00016278 <AMFProp_GetBoolean>:

int
AMFProp_GetBoolean(AMFObjectProperty *prop)
{
   16278:	e92d4008 	push	{r3, lr}
  return prop->p_vu.p_number != 0;
   1627c:	e3a02000 	mov	r2, #0
   16280:	e1c001d0 	ldrd	r0, [r0, #16]
   16284:	e3a03000 	mov	r3, #0
   16288:	eb001854 	bl	1c3e0 <__aeabi_dcmpeq>
}
   1628c:	e16f0f10 	clz	r0, r0
   16290:	e1a002a0 	lsr	r0, r0, #5
   16294:	e8bd8008 	pop	{r3, pc}

00016298 <AMFProp_GetString>:

void
AMFProp_GetString(AMFObjectProperty *prop, AVal *str)
{
  *str = prop->p_vu.p_aval;
   16298:	e2800010 	add	r0, r0, #16
  return prop->p_vu.p_number != 0;
}

void
AMFProp_GetString(AMFObjectProperty *prop, AVal *str)
{
   1629c:	e1a03001 	mov	r3, r1
  *str = prop->p_vu.p_aval;
   162a0:	e8900003 	ldm	r0, {r0, r1}
   162a4:	e8830003 	stm	r3, {r0, r1}
   162a8:	e12fff1e 	bx	lr

000162ac <AMFProp_GetObject>:
}

void
AMFProp_GetObject(AMFObjectProperty *prop, AMFObject *obj)
{
  *obj = prop->p_vu.p_object;
   162ac:	e2800010 	add	r0, r0, #16
  *str = prop->p_vu.p_aval;
}

void
AMFProp_GetObject(AMFObjectProperty *prop, AMFObject *obj)
{
   162b0:	e1a03001 	mov	r3, r1
  *obj = prop->p_vu.p_object;
   162b4:	e8900003 	ldm	r0, {r0, r1}
   162b8:	e8830003 	stm	r3, {r0, r1}
   162bc:	e12fff1e 	bx	lr

000162c0 <AMFProp_IsValid>:
}

int
AMFProp_IsValid(AMFObjectProperty *prop)
{
  return prop->p_type != AMF_INVALID;
   162c0:	e5900008 	ldr	r0, [r0, #8]
}
   162c4:	e25000ff 	subs	r0, r0, #255	; 0xff
   162c8:	13a00001 	movne	r0, #1
   162cc:	e12fff1e 	bx	lr

000162d0 <AMF3ReadInteger>:
  int i = 0;
  int32_t val = 0;

  while (i <= 2)
    {				/* handle first 3 bytes */
      if (data[i] & 0x80)
   162d0:	e5d03000 	ldrb	r3, [r0]
   162d4:	e3130080 	tst	r3, #128	; 0x80
   162d8:	0a000011 	beq	16324 <AMF3ReadInteger+0x54>
	{			/* byte used */
	  val <<= 7;		/* shift up */
	  val |= (data[i] & 0x7f);	/* add bits */
   162dc:	e203c07f 	and	ip, r3, #127	; 0x7f
  int i = 0;
  int32_t val = 0;

  while (i <= 2)
    {				/* handle first 3 bytes */
      if (data[i] & 0x80)
   162e0:	e5d03001 	ldrb	r3, [r0, #1]
   162e4:	e3130080 	tst	r3, #128	; 0x80
   162e8:	0a000013 	beq	1633c <AMF3ReadInteger+0x6c>
	{			/* byte used */
	  val <<= 7;		/* shift up */
	  val |= (data[i] & 0x7f);	/* add bits */
   162ec:	e203207f 	and	r2, r3, #127	; 0x7f
  int i = 0;
  int32_t val = 0;

  while (i <= 2)
    {				/* handle first 3 bytes */
      if (data[i] & 0x80)
   162f0:	e5d03002 	ldrb	r3, [r0, #2]
	{			/* byte used */
	  val <<= 7;		/* shift up */
	  val |= (data[i] & 0x7f);	/* add bits */
   162f4:	e182c38c 	orr	ip, r2, ip, lsl #7
  int i = 0;
  int32_t val = 0;

  while (i <= 2)
    {				/* handle first 3 bytes */
      if (data[i] & 0x80)
   162f8:	e3130080 	tst	r3, #128	; 0x80
   162fc:	0a000010 	beq	16344 <AMF3ReadInteger+0x74>
    }

  if (i > 2)
    {				/* use 4th byte, all 8bits */
      val <<= 8;
      val |= data[3];
   16300:	e5d02003 	ldrb	r2, [r0, #3]
  while (i <= 2)
    {				/* handle first 3 bytes */
      if (data[i] & 0x80)
	{			/* byte used */
	  val <<= 7;		/* shift up */
	  val |= (data[i] & 0x7f);	/* add bits */
   16304:	e203307f 	and	r3, r3, #127	; 0x7f
   16308:	e183338c 	orr	r3, r3, ip, lsl #7
    }

  if (i > 2)
    {				/* use 4th byte, all 8bits */
      val <<= 8;
      val |= data[3];
   1630c:	e1823403 	orr	r3, r2, r3, lsl #8

      /* range check */
      if (val > AMF3_INTEGER_MAX)
   16310:	e373021f 	cmn	r3, #-268435455	; 0xf0000001
	val -= (1 << 29);
   16314:	c283320e 	addgt	r3, r3, #-536870912	; 0xe0000000
      val |= data[i];
    }

  *valp = val;

  return i > 2 ? 4 : i + 1;
   16318:	e3a00004 	mov	r0, #4
    {				/* use 7bits of last unparsed byte (0xxxxxxx) */
      val <<= 7;
      val |= data[i];
    }

  *valp = val;
   1631c:	e5813000 	str	r3, [r1]

  return i > 2 ? 4 : i + 1;
}
   16320:	e12fff1e 	bx	lr

int
AMF3ReadInteger(const char *data, int32_t *valp)
{
  int i = 0;
  int32_t val = 0;
   16324:	e3a0c000 	mov	ip, #0
#define AMF3_INTEGER_MIN	-268435456

int
AMF3ReadInteger(const char *data, int32_t *valp)
{
  int i = 0;
   16328:	e1a0000c 	mov	r0, ip
	val -= (1 << 29);
    }
  else
    {				/* use 7bits of last unparsed byte (0xxxxxxx) */
      val <<= 7;
      val |= data[i];
   1632c:	e183338c 	orr	r3, r3, ip, lsl #7
    }

  *valp = val;
   16330:	e5813000 	str	r3, [r1]

  return i > 2 ? 4 : i + 1;
   16334:	e2800001 	add	r0, r0, #1
   16338:	e12fff1e 	bx	lr
    {				/* handle first 3 bytes */
      if (data[i] & 0x80)
	{			/* byte used */
	  val <<= 7;		/* shift up */
	  val |= (data[i] & 0x7f);	/* add bits */
	  i++;
   1633c:	e3a00001 	mov	r0, #1
   16340:	eafffff9 	b	1632c <AMF3ReadInteger+0x5c>
   16344:	e3a00002 	mov	r0, #2
   16348:	eafffff7 	b	1632c <AMF3ReadInteger+0x5c>

0001634c <AMF3ReadString>:
  return i > 2 ? 4 : i + 1;
}

int
AMF3ReadString(const char *data, AVal *str)
{
   1634c:	e92d4070 	push	{r4, r5, r6, lr}
  int32_t ref = 0;
   16350:	e3a03000 	mov	r3, #0
  return i > 2 ? 4 : i + 1;
}

int
AMF3ReadString(const char *data, AVal *str)
{
   16354:	e24dd008 	sub	sp, sp, #8
  int32_t ref = 0;
  int len;
  assert(str != 0);
   16358:	e2516000 	subs	r6, r1, #0
  return i > 2 ? 4 : i + 1;
}

int
AMF3ReadString(const char *data, AVal *str)
{
   1635c:	e1a05000 	mov	r5, r0
  int32_t ref = 0;
   16360:	e58d3004 	str	r3, [sp, #4]
  int len;
  assert(str != 0);
   16364:	0a000018 	beq	163cc <AMF3ReadString+0x80>

  len = AMF3ReadInteger(data, &ref);
   16368:	e1a00005 	mov	r0, r5
   1636c:	e28d1004 	add	r1, sp, #4
   16370:	ebffffd6 	bl	162d0 <AMF3ReadInteger>
  data += len;

  if ((ref & 0x1) == 0)
   16374:	e59d3004 	ldr	r3, [sp, #4]
   16378:	e3130001 	tst	r3, #1
{
  int32_t ref = 0;
  int len;
  assert(str != 0);

  len = AMF3ReadInteger(data, &ref);
   1637c:	e1a04000 	mov	r4, r0
  data += len;
   16380:	e0855000 	add	r5, r5, r0

  if ((ref & 0x1) == 0)
   16384:	0a000005 	beq	163a0 <AMF3ReadString+0x54>
	  __FUNCTION__, refIndex);
      return len;
    }
  else
    {
      uint32_t nSize = (ref >> 1);
   16388:	e1a030c3 	asr	r3, r3, #1

      str->av_val = (char *)data;
      str->av_len = nSize;

      return len + nSize;
   1638c:	e0800003 	add	r0, r0, r3
  else
    {
      uint32_t nSize = (ref >> 1);

      str->av_val = (char *)data;
      str->av_len = nSize;
   16390:	e5863004 	str	r3, [r6, #4]
    }
  else
    {
      uint32_t nSize = (ref >> 1);

      str->av_val = (char *)data;
   16394:	e5865000 	str	r5, [r6]
      str->av_len = nSize;

      return len + nSize;
    }
  return len;
}
   16398:	e28dd008 	add	sp, sp, #8
   1639c:	e8bd8070 	pop	{r4, r5, r6, pc}
  data += len;

  if ((ref & 0x1) == 0)
    {				/* reference: 0xxx */
      uint32_t refIndex = (ref >> 1);
      RTMP_Log(RTMP_LOGDEBUG,
   163a0:	e59f2048 	ldr	r2, [pc, #72]	; 163f0 <AMF3ReadString+0xa4>
   163a4:	e59f1048 	ldr	r1, [pc, #72]	; 163f4 <AMF3ReadString+0xa8>
   163a8:	e08f2002 	add	r2, pc, r2
   163ac:	e1a030c3 	asr	r3, r3, #1
   163b0:	e2822010 	add	r2, r2, #16
   163b4:	e3a00004 	mov	r0, #4
   163b8:	e08f1001 	add	r1, pc, r1
   163bc:	ebfffd7a 	bl	159ac <RTMP_Log>
	  "%s, string reference, index: %d, not supported, ignoring!",
	  __FUNCTION__, refIndex);
      return len;
   163c0:	e1a00004 	mov	r0, r4
      str->av_len = nSize;

      return len + nSize;
    }
  return len;
}
   163c4:	e28dd008 	add	sp, sp, #8
   163c8:	e8bd8070 	pop	{r4, r5, r6, pc}
int
AMF3ReadString(const char *data, AVal *str)
{
  int32_t ref = 0;
  int len;
  assert(str != 0);
   163cc:	e59f0024 	ldr	r0, [pc, #36]	; 163f8 <AMF3ReadString+0xac>
   163d0:	e59f2024 	ldr	r2, [pc, #36]	; 163fc <AMF3ReadString+0xb0>
   163d4:	e59f3024 	ldr	r3, [pc, #36]	; 16400 <AMF3ReadString+0xb4>
   163d8:	e08f0000 	add	r0, pc, r0
   163dc:	e3a01e1d 	mov	r1, #464	; 0x1d0
   163e0:	e08f2002 	add	r2, pc, r2
   163e4:	e08f3003 	add	r3, pc, r3
   163e8:	ebffbb08 	bl	5010 <__assert2@plt>
   163ec:	eaffffdd 	b	16368 <AMF3ReadString+0x1c>
   163f0:	0000b660 	.word	0x0000b660
   163f4:	0000a920 	.word	0x0000a920
   163f8:	0000a8ec 	.word	0x0000a8ec
   163fc:	0000b628 	.word	0x0000b628
   16400:	0000a8e8 	.word	0x0000a8e8

00016404 <AMF_EncodeArray>:
char *
AMF_EncodeArray(AMFObject *obj, char *pBuffer, char *pBufEnd)
{
  int i;

  if (pBuffer+4 >= pBufEnd)
   16404:	e2813004 	add	r3, r1, #4
   16408:	e1520003 	cmp	r2, r3
   1640c:	9a000022 	bls	1649c <AMF_EncodeArray+0x98>
  return pBuffer;
}

char *
AMF_EncodeArray(AMFObject *obj, char *pBuffer, char *pBufEnd)
{
   16410:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  int i;

  if (pBuffer+4 >= pBufEnd)
    return NULL;

  *pBuffer++ = AMF_STRICT_ARRAY;
   16414:	e3a0300a 	mov	r3, #10
   16418:	e1a05000 	mov	r5, r0
   1641c:	e1a08002 	mov	r8, r2
   16420:	e5c13000 	strb	r3, [r1]

  pBuffer = AMF_EncodeInt32(pBuffer, pBufEnd, obj->o_num);
   16424:	e2810001 	add	r0, r1, #1
   16428:	e5952000 	ldr	r2, [r5]
   1642c:	e1a01008 	mov	r1, r8
   16430:	ebfffedd 	bl	15fac <AMF_EncodeInt32>

  for (i = 0; i < obj->o_num; i++)
   16434:	e5953000 	ldr	r3, [r5]
   16438:	e3530000 	cmp	r3, #0
  if (pBuffer+4 >= pBufEnd)
    return NULL;

  *pBuffer++ = AMF_STRICT_ARRAY;

  pBuffer = AMF_EncodeInt32(pBuffer, pBufEnd, obj->o_num);
   1643c:	e1a07000 	mov	r7, r0

  for (i = 0; i < obj->o_num; i++)
   16440:	da000017 	ble	164a4 <AMF_EncodeArray+0xa0>
   16444:	e3a04000 	mov	r4, #0
   16448:	ea000004 	b	16460 <AMF_EncodeArray+0x5c>
   1644c:	e5957000 	ldr	r7, [r5]
   16450:	e2844001 	add	r4, r4, #1
   16454:	e1570004 	cmp	r7, r4
   16458:	e1a07006 	mov	r7, r6
   1645c:	da00000c 	ble	16494 <AMF_EncodeArray+0x90>
    {
      char *res = AMFProp_Encode(&obj->o_props[i], pBuffer, pBufEnd);
   16460:	e5950004 	ldr	r0, [r5, #4]
   16464:	e1a01007 	mov	r1, r7
   16468:	e0800284 	add	r0, r0, r4, lsl #5
   1646c:	e1a02008 	mov	r2, r8
   16470:	eb00000e 	bl	164b0 <AMFProp_Encode>
      if (res == NULL)
   16474:	e2506000 	subs	r6, r0, #0
   16478:	1afffff3 	bne	1644c <AMF_EncodeArray+0x48>
	{
	  RTMP_Log(RTMP_LOGERROR, "AMF_Encode - failed to encode property in index %d",
   1647c:	e59f1028 	ldr	r1, [pc, #40]	; 164ac <AMF_EncodeArray+0xa8>
   16480:	e1a02004 	mov	r2, r4
   16484:	e3a00001 	mov	r0, #1
   16488:	e08f1001 	add	r1, pc, r1
   1648c:	e1a06007 	mov	r6, r7
   16490:	ebfffd45 	bl	159ac <RTMP_Log>
  //if (pBuffer + 3 >= pBufEnd)
  //  return NULL;			/* no room for the end marker */

  //pBuffer = AMF_EncodeInt24(pBuffer, pBufEnd, AMF_OBJECT_END);

  return pBuffer;
   16494:	e1a00006 	mov	r0, r6
   16498:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
AMF_EncodeArray(AMFObject *obj, char *pBuffer, char *pBufEnd)
{
  int i;

  if (pBuffer+4 >= pBufEnd)
    return NULL;
   1649c:	e3a00000 	mov	r0, #0
   164a0:	e12fff1e 	bx	lr

  *pBuffer++ = AMF_STRICT_ARRAY;

  pBuffer = AMF_EncodeInt32(pBuffer, pBufEnd, obj->o_num);
   164a4:	e1a06000 	mov	r6, r0
   164a8:	eafffff9 	b	16494 <AMF_EncodeArray+0x90>
   164ac:	0000a88c 	.word	0x0000a88c

000164b0 <AMFProp_Encode>:
}

char *
AMFProp_Encode(AMFObjectProperty *prop, char *pBuffer, char *pBufEnd)
{
  if (prop->p_type == AMF_INVALID)
   164b0:	e5903008 	ldr	r3, [r0, #8]
  return prop->p_type != AMF_INVALID;
}

char *
AMFProp_Encode(AMFObjectProperty *prop, char *pBuffer, char *pBufEnd)
{
   164b4:	e92d4070 	push	{r4, r5, r6, lr}
  if (prop->p_type == AMF_INVALID)
   164b8:	e35300ff 	cmp	r3, #255	; 0xff
  return prop->p_type != AMF_INVALID;
}

char *
AMFProp_Encode(AMFObjectProperty *prop, char *pBuffer, char *pBufEnd)
{
   164bc:	e1a04000 	mov	r4, r0
  if (prop->p_type == AMF_INVALID)
   164c0:	0a00001f 	beq	16544 <AMFProp_Encode+0x94>
    return NULL;

  if (prop->p_type != AMF_NULL && pBuffer + prop->p_name.av_len + 2 + 1 >= pBufEnd)
   164c4:	e3530005 	cmp	r3, #5
   164c8:	e1a05001 	mov	r5, r1
   164cc:	e1a06002 	mov	r6, r2
   164d0:	0a00004c 	beq	16608 <AMFProp_Encode+0x158>
   164d4:	e5901004 	ldr	r1, [r0, #4]
   164d8:	e2812003 	add	r2, r1, #3
   164dc:	e0852002 	add	r2, r5, r2
   164e0:	e1560002 	cmp	r6, r2
   164e4:	9a000016 	bls	16544 <AMFProp_Encode+0x94>
    return NULL;

  if (prop->p_type != AMF_NULL && prop->p_name.av_len)
   164e8:	e3510000 	cmp	r1, #0
   164ec:	1a000016 	bne	1654c <AMFProp_Encode+0x9c>
      *pBuffer++ = prop->p_name.av_len & 0xff;
      memcpy(pBuffer, prop->p_name.av_val, prop->p_name.av_len);
      pBuffer += prop->p_name.av_len;
    }

  switch (prop->p_type)
   164f0:	e353000a 	cmp	r3, #10
   164f4:	908ff103 	addls	pc, pc, r3, lsl #2
   164f8:	ea00000a 	b	16528 <AMFProp_Encode+0x78>
   164fc:	ea00001e 	b	1657c <AMFProp_Encode+0xcc>
   16500:	ea000022 	b	16590 <AMFProp_Encode+0xe0>
   16504:	ea00002b 	b	165b8 <AMFProp_Encode+0x108>
   16508:	ea00002f 	b	165cc <AMFProp_Encode+0x11c>
   1650c:	ea000005 	b	16528 <AMFProp_Encode+0x78>
   16510:	ea00003c 	b	16608 <AMFProp_Encode+0x158>
   16514:	ea000003 	b	16528 <AMFProp_Encode+0x78>
   16518:	ea000002 	b	16528 <AMFProp_Encode+0x78>
   1651c:	ea00002f 	b	165e0 <AMFProp_Encode+0x130>
   16520:	ea000000 	b	16528 <AMFProp_Encode+0x78>
   16524:	ea000032 	b	165f4 <AMFProp_Encode+0x144>
    case AMF_STRICT_ARRAY:
      pBuffer = AMF_EncodeArray(&prop->p_vu.p_object, pBuffer, pBufEnd);
      break;

    default:
      RTMP_Log(RTMP_LOGERROR, "%s, invalid type. %d", __FUNCTION__, prop->p_type);
   16528:	e59f20f0 	ldr	r2, [pc, #240]	; 16620 <AMFProp_Encode+0x170>
   1652c:	e59f10f0 	ldr	r1, [pc, #240]	; 16624 <AMFProp_Encode+0x174>
   16530:	e08f2002 	add	r2, pc, r2
   16534:	e2822020 	add	r2, r2, #32
   16538:	e3a00001 	mov	r0, #1
   1653c:	e08f1001 	add	r1, pc, r1
   16540:	ebfffd19 	bl	159ac <RTMP_Log>
      pBuffer = NULL;
   16544:	e3a00000 	mov	r0, #0
    };

  return pBuffer;
}
   16548:	e8bd8070 	pop	{r4, r5, r6, pc}
  if (prop->p_type != AMF_NULL && pBuffer + prop->p_name.av_len + 2 + 1 >= pBufEnd)
    return NULL;

  if (prop->p_type != AMF_NULL && prop->p_name.av_len)
    {
      *pBuffer++ = prop->p_name.av_len >> 8;
   1654c:	e1a0c005 	mov	ip, r5
   16550:	e1a01441 	asr	r1, r1, #8
   16554:	e4cc1002 	strb	r1, [ip], #2
      *pBuffer++ = prop->p_name.av_len & 0xff;
   16558:	e5903004 	ldr	r3, [r0, #4]
   1655c:	e5c53001 	strb	r3, [r5, #1]
      memcpy(pBuffer, prop->p_name.av_val, prop->p_name.av_len);
   16560:	e1a0000c 	mov	r0, ip
   16564:	e8940006 	ldm	r4, {r1, r2}
   16568:	ebffbb17 	bl	51cc <memcpy@plt>
      pBuffer += prop->p_name.av_len;
   1656c:	e5945004 	ldr	r5, [r4, #4]
   16570:	e5943008 	ldr	r3, [r4, #8]
   16574:	e0805005 	add	r5, r0, r5
   16578:	eaffffdc 	b	164f0 <AMFProp_Encode+0x40>
    }

  switch (prop->p_type)
    {
    case AMF_NUMBER:
      pBuffer = AMF_EncodeNumber(pBuffer, pBufEnd, prop->p_vu.p_number);
   1657c:	e1a00005 	mov	r0, r5
   16580:	e1a01006 	mov	r1, r6
   16584:	e1c421d0 	ldrd	r2, [r4, #16]
      RTMP_Log(RTMP_LOGERROR, "%s, invalid type. %d", __FUNCTION__, prop->p_type);
      pBuffer = NULL;
    };

  return pBuffer;
}
   16588:	e8bd4070 	pop	{r4, r5, r6, lr}
    }

  switch (prop->p_type)
    {
    case AMF_NUMBER:
      pBuffer = AMF_EncodeNumber(pBuffer, pBufEnd, prop->p_vu.p_number);
   1658c:	eafffebc 	b	16084 <AMF_EncodeNumber>
      break;

    case AMF_BOOLEAN:
      pBuffer = AMF_EncodeBoolean(pBuffer, pBufEnd, prop->p_vu.p_number != 0);
   16590:	e1c401d0 	ldrd	r0, [r4, #16]
   16594:	e3a02000 	mov	r2, #0
   16598:	e3a03000 	mov	r3, #0
   1659c:	eb00178f 	bl	1c3e0 <__aeabi_dcmpeq>
   165a0:	e1a01006 	mov	r1, r6
   165a4:	e16f2f10 	clz	r2, r0
   165a8:	e1a00005 	mov	r0, r5
   165ac:	e1a022a2 	lsr	r2, r2, #5
      RTMP_Log(RTMP_LOGERROR, "%s, invalid type. %d", __FUNCTION__, prop->p_type);
      pBuffer = NULL;
    };

  return pBuffer;
}
   165b0:	e8bd4070 	pop	{r4, r5, r6, lr}
    case AMF_NUMBER:
      pBuffer = AMF_EncodeNumber(pBuffer, pBufEnd, prop->p_vu.p_number);
      break;

    case AMF_BOOLEAN:
      pBuffer = AMF_EncodeBoolean(pBuffer, pBufEnd, prop->p_vu.p_number != 0);
   165b4:	eafffed0 	b	160fc <AMF_EncodeBoolean>
      break;

    case AMF_STRING:
      pBuffer = AMF_EncodeString(pBuffer, pBufEnd, &prop->p_vu.p_aval);
   165b8:	e1a00005 	mov	r0, r5
   165bc:	e1a01006 	mov	r1, r6
   165c0:	e2842010 	add	r2, r4, #16
      RTMP_Log(RTMP_LOGERROR, "%s, invalid type. %d", __FUNCTION__, prop->p_type);
      pBuffer = NULL;
    };

  return pBuffer;
}
   165c4:	e8bd4070 	pop	{r4, r5, r6, lr}
    case AMF_BOOLEAN:
      pBuffer = AMF_EncodeBoolean(pBuffer, pBufEnd, prop->p_vu.p_number != 0);
      break;

    case AMF_STRING:
      pBuffer = AMF_EncodeString(pBuffer, pBufEnd, &prop->p_vu.p_aval);
   165c8:	eafffe86 	b	15fe8 <AMF_EncodeString>
        return NULL;
      *pBuffer++ = AMF_NULL;
      break;

    case AMF_OBJECT:
      pBuffer = AMF_Encode(&prop->p_vu.p_object, pBuffer, pBufEnd);
   165cc:	e2840010 	add	r0, r4, #16
   165d0:	e1a01005 	mov	r1, r5
   165d4:	e1a02006 	mov	r2, r6
      RTMP_Log(RTMP_LOGERROR, "%s, invalid type. %d", __FUNCTION__, prop->p_type);
      pBuffer = NULL;
    };

  return pBuffer;
}
   165d8:	e8bd4070 	pop	{r4, r5, r6, lr}
        return NULL;
      *pBuffer++ = AMF_NULL;
      break;

    case AMF_OBJECT:
      pBuffer = AMF_Encode(&prop->p_vu.p_object, pBuffer, pBufEnd);
   165dc:	ea000011 	b	16628 <AMF_Encode>
      break;

    case AMF_ECMA_ARRAY:
      pBuffer = AMF_EncodeEcmaArray(&prop->p_vu.p_object, pBuffer, pBufEnd);
   165e0:	e2840010 	add	r0, r4, #16
   165e4:	e1a01005 	mov	r1, r5
   165e8:	e1a02006 	mov	r2, r6
      RTMP_Log(RTMP_LOGERROR, "%s, invalid type. %d", __FUNCTION__, prop->p_type);
      pBuffer = NULL;
    };

  return pBuffer;
}
   165ec:	e8bd4070 	pop	{r4, r5, r6, lr}
    case AMF_OBJECT:
      pBuffer = AMF_Encode(&prop->p_vu.p_object, pBuffer, pBufEnd);
      break;

    case AMF_ECMA_ARRAY:
      pBuffer = AMF_EncodeEcmaArray(&prop->p_vu.p_object, pBuffer, pBufEnd);
   165f0:	ea00003b 	b	166e4 <AMF_EncodeEcmaArray>
      break;

    case AMF_STRICT_ARRAY:
      pBuffer = AMF_EncodeArray(&prop->p_vu.p_object, pBuffer, pBufEnd);
   165f4:	e2840010 	add	r0, r4, #16
   165f8:	e1a01005 	mov	r1, r5
   165fc:	e1a02006 	mov	r2, r6
      RTMP_Log(RTMP_LOGERROR, "%s, invalid type. %d", __FUNCTION__, prop->p_type);
      pBuffer = NULL;
    };

  return pBuffer;
}
   16600:	e8bd4070 	pop	{r4, r5, r6, lr}
    case AMF_ECMA_ARRAY:
      pBuffer = AMF_EncodeEcmaArray(&prop->p_vu.p_object, pBuffer, pBufEnd);
      break;

    case AMF_STRICT_ARRAY:
      pBuffer = AMF_EncodeArray(&prop->p_vu.p_object, pBuffer, pBufEnd);
   16604:	eaffff7e 	b	16404 <AMF_EncodeArray>
    case AMF_STRING:
      pBuffer = AMF_EncodeString(pBuffer, pBufEnd, &prop->p_vu.p_aval);
      break;

    case AMF_NULL:
      if (pBuffer+1 >= pBufEnd)
   16608:	e2850001 	add	r0, r5, #1
   1660c:	e1560000 	cmp	r6, r0
   16610:	9affffcb 	bls	16544 <AMFProp_Encode+0x94>
        return NULL;
      *pBuffer++ = AMF_NULL;
   16614:	e3a03005 	mov	r3, #5
   16618:	e5c53000 	strb	r3, [r5]
      break;
   1661c:	e8bd8070 	pop	{r4, r5, r6, pc}
   16620:	0000b4d8 	.word	0x0000b4d8
   16624:	0000a80c 	.word	0x0000a80c

00016628 <AMF_Encode>:
char *
AMF_Encode(AMFObject *obj, char *pBuffer, char *pBufEnd)
{
  int i;

  if (pBuffer+4 >= pBufEnd)
   16628:	e2813004 	add	r3, r1, #4
   1662c:	e1520003 	cmp	r2, r3
   16630:	9a000026 	bls	166d0 <AMF_Encode+0xa8>
    return NULL;

  *pBuffer++ = AMF_OBJECT;
   16634:	e3a03003 	mov	r3, #3

/* AMFObject */

char *
AMF_Encode(AMFObject *obj, char *pBuffer, char *pBufEnd)
{
   16638:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  int i;

  if (pBuffer+4 >= pBufEnd)
    return NULL;

  *pBuffer++ = AMF_OBJECT;
   1663c:	e5c13000 	strb	r3, [r1]

  for (i = 0; i < obj->o_num; i++)
   16640:	e5903000 	ldr	r3, [r0]
   16644:	e1a06000 	mov	r6, r0
   16648:	e3530000 	cmp	r3, #0
   1664c:	e1a08002 	mov	r8, r2
  int i;

  if (pBuffer+4 >= pBufEnd)
    return NULL;

  *pBuffer++ = AMF_OBJECT;
   16650:	e2815001 	add	r5, r1, #1

  for (i = 0; i < obj->o_num; i++)
   16654:	da00001f 	ble	166d8 <AMF_Encode+0xb0>
   16658:	e3a04000 	mov	r4, #0
   1665c:	ea000004 	b	16674 <AMF_Encode+0x4c>
   16660:	e5963000 	ldr	r3, [r6]
   16664:	e2844001 	add	r4, r4, #1
   16668:	e1530004 	cmp	r3, r4
   1666c:	e1a05007 	mov	r5, r7
   16670:	da00000c 	ble	166a8 <AMF_Encode+0x80>
    {
      char *res = AMFProp_Encode(&obj->o_props[i], pBuffer, pBufEnd);
   16674:	e5960004 	ldr	r0, [r6, #4]
   16678:	e1a01005 	mov	r1, r5
   1667c:	e0800284 	add	r0, r0, r4, lsl #5
   16680:	e1a02008 	mov	r2, r8
   16684:	ebffff89 	bl	164b0 <AMFProp_Encode>
      if (res == NULL)
   16688:	e2507000 	subs	r7, r0, #0
   1668c:	1afffff3 	bne	16660 <AMF_Encode+0x38>
	{
	  RTMP_Log(RTMP_LOGERROR, "AMF_Encode - failed to encode property in index %d",
   16690:	e59f1048 	ldr	r1, [pc, #72]	; 166e0 <AMF_Encode+0xb8>
   16694:	e1a02004 	mov	r2, r4
   16698:	e3a00001 	mov	r0, #1
   1669c:	e08f1001 	add	r1, pc, r1
   166a0:	e1a07005 	mov	r7, r5
   166a4:	ebfffcc0 	bl	159ac <RTMP_Log>
	{
	  pBuffer = res;
	}
    }

  if (pBuffer + 3 >= pBufEnd)
   166a8:	e2873003 	add	r3, r7, #3
   166ac:	e1580003 	cmp	r8, r3
   166b0:	9a000004 	bls	166c8 <AMF_Encode+0xa0>
    return NULL;			/* no room for the end marker */

  pBuffer = AMF_EncodeInt24(pBuffer, pBufEnd, AMF_OBJECT_END);
   166b4:	e1a00007 	mov	r0, r7
   166b8:	e1a01008 	mov	r1, r8
   166bc:	e3a02009 	mov	r2, #9

  return pBuffer;
}
   166c0:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
    }

  if (pBuffer + 3 >= pBufEnd)
    return NULL;			/* no room for the end marker */

  pBuffer = AMF_EncodeInt24(pBuffer, pBufEnd, AMF_OBJECT_END);
   166c4:	eafffe2e 	b	15f84 <AMF_EncodeInt24>

  return pBuffer;
}
   166c8:	e3a00000 	mov	r0, #0
   166cc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
   166d0:	e3a00000 	mov	r0, #0
   166d4:	e12fff1e 	bx	lr
  int i;

  if (pBuffer+4 >= pBufEnd)
    return NULL;

  *pBuffer++ = AMF_OBJECT;
   166d8:	e1a07005 	mov	r7, r5
   166dc:	eafffff1 	b	166a8 <AMF_Encode+0x80>
   166e0:	0000a678 	.word	0x0000a678

000166e4 <AMF_EncodeEcmaArray>:
char *
AMF_EncodeEcmaArray(AMFObject *obj, char *pBuffer, char *pBufEnd)
{
  int i;

  if (pBuffer+4 >= pBufEnd)
   166e4:	e2813004 	add	r3, r1, #4
   166e8:	e1520003 	cmp	r2, r3
   166ec:	9a000028 	bls	16794 <AMF_EncodeEcmaArray+0xb0>
  return pBuffer;
}

char *
AMF_EncodeEcmaArray(AMFObject *obj, char *pBuffer, char *pBufEnd)
{
   166f0:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  int i;

  if (pBuffer+4 >= pBufEnd)
    return NULL;

  *pBuffer++ = AMF_ECMA_ARRAY;
   166f4:	e3a03008 	mov	r3, #8
   166f8:	e1a05000 	mov	r5, r0
   166fc:	e1a08002 	mov	r8, r2
   16700:	e5c13000 	strb	r3, [r1]

  pBuffer = AMF_EncodeInt32(pBuffer, pBufEnd, obj->o_num);
   16704:	e2810001 	add	r0, r1, #1
   16708:	e5952000 	ldr	r2, [r5]
   1670c:	e1a01008 	mov	r1, r8
   16710:	ebfffe25 	bl	15fac <AMF_EncodeInt32>

  for (i = 0; i < obj->o_num; i++)
   16714:	e5953000 	ldr	r3, [r5]
   16718:	e3530000 	cmp	r3, #0
  if (pBuffer+4 >= pBufEnd)
    return NULL;

  *pBuffer++ = AMF_ECMA_ARRAY;

  pBuffer = AMF_EncodeInt32(pBuffer, pBufEnd, obj->o_num);
   1671c:	e1a07000 	mov	r7, r0

  for (i = 0; i < obj->o_num; i++)
   16720:	da00001f 	ble	167a4 <AMF_EncodeEcmaArray+0xc0>
   16724:	e3a04000 	mov	r4, #0
   16728:	ea000004 	b	16740 <AMF_EncodeEcmaArray+0x5c>
   1672c:	e5957000 	ldr	r7, [r5]
   16730:	e2844001 	add	r4, r4, #1
   16734:	e1570004 	cmp	r7, r4
   16738:	e1a07006 	mov	r7, r6
   1673c:	da00000c 	ble	16774 <AMF_EncodeEcmaArray+0x90>
    {
      char *res = AMFProp_Encode(&obj->o_props[i], pBuffer, pBufEnd);
   16740:	e5950004 	ldr	r0, [r5, #4]
   16744:	e1a01007 	mov	r1, r7
   16748:	e0800284 	add	r0, r0, r4, lsl #5
   1674c:	e1a02008 	mov	r2, r8
   16750:	ebffff56 	bl	164b0 <AMFProp_Encode>
      if (res == NULL)
   16754:	e2506000 	subs	r6, r0, #0
   16758:	1afffff3 	bne	1672c <AMF_EncodeEcmaArray+0x48>
	{
	  RTMP_Log(RTMP_LOGERROR, "AMF_Encode - failed to encode property in index %d",
   1675c:	e59f1048 	ldr	r1, [pc, #72]	; 167ac <AMF_EncodeEcmaArray+0xc8>
   16760:	e1a02004 	mov	r2, r4
   16764:	e3a00001 	mov	r0, #1
   16768:	e08f1001 	add	r1, pc, r1
   1676c:	e1a06007 	mov	r6, r7
   16770:	ebfffc8d 	bl	159ac <RTMP_Log>
	{
	  pBuffer = res;
	}
    }

  if (pBuffer + 3 >= pBufEnd)
   16774:	e2863003 	add	r3, r6, #3
   16778:	e1580003 	cmp	r8, r3
   1677c:	9a000006 	bls	1679c <AMF_EncodeEcmaArray+0xb8>
    return NULL;			/* no room for the end marker */

  pBuffer = AMF_EncodeInt24(pBuffer, pBufEnd, AMF_OBJECT_END);
   16780:	e1a00006 	mov	r0, r6
   16784:	e1a01008 	mov	r1, r8
   16788:	e3a02009 	mov	r2, #9

  return pBuffer;
}
   1678c:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
    }

  if (pBuffer + 3 >= pBufEnd)
    return NULL;			/* no room for the end marker */

  pBuffer = AMF_EncodeInt24(pBuffer, pBufEnd, AMF_OBJECT_END);
   16790:	eafffdfb 	b	15f84 <AMF_EncodeInt24>

  return pBuffer;
}
   16794:	e3a00000 	mov	r0, #0
   16798:	e12fff1e 	bx	lr
   1679c:	e3a00000 	mov	r0, #0
   167a0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  if (pBuffer+4 >= pBufEnd)
    return NULL;

  *pBuffer++ = AMF_ECMA_ARRAY;

  pBuffer = AMF_EncodeInt32(pBuffer, pBufEnd, obj->o_num);
   167a4:	e1a06000 	mov	r6, r0
   167a8:	eafffff1 	b	16774 <AMF_EncodeEcmaArray+0x90>
   167ac:	0000a5ac 	.word	0x0000a5ac

000167b0 <AMF_AddProp>:
  return nOriginalSize - nSize;
}

void
AMF_AddProp(AMFObject *obj, const AMFObjectProperty *prop)
{
   167b0:	e92d4038 	push	{r3, r4, r5, lr}
  if (!(obj->o_num & 0x0f))
   167b4:	e5903000 	ldr	r3, [r0]
  return nOriginalSize - nSize;
}

void
AMF_AddProp(AMFObject *obj, const AMFObjectProperty *prop)
{
   167b8:	e1a04000 	mov	r4, r0
  if (!(obj->o_num & 0x0f))
   167bc:	e313000f 	tst	r3, #15
  return nOriginalSize - nSize;
}

void
AMF_AddProp(AMFObject *obj, const AMFObjectProperty *prop)
{
   167c0:	e1a05001 	mov	r5, r1
  if (!(obj->o_num & 0x0f))
   167c4:	0a000007 	beq	167e8 <AMF_AddProp+0x38>
   167c8:	e5901004 	ldr	r1, [r0, #4]
    obj->o_props =
      realloc(obj->o_props, (obj->o_num + 16) * sizeof(AMFObjectProperty));
  memcpy(&obj->o_props[obj->o_num++], prop, sizeof(AMFObjectProperty));
   167cc:	e2832001 	add	r2, r3, #1
   167d0:	e0810283 	add	r0, r1, r3, lsl #5
   167d4:	e5842000 	str	r2, [r4]
   167d8:	e1a01005 	mov	r1, r5
   167dc:	e3a02020 	mov	r2, #32
}
   167e0:	e8bd4038 	pop	{r3, r4, r5, lr}
AMF_AddProp(AMFObject *obj, const AMFObjectProperty *prop)
{
  if (!(obj->o_num & 0x0f))
    obj->o_props =
      realloc(obj->o_props, (obj->o_num + 16) * sizeof(AMFObjectProperty));
  memcpy(&obj->o_props[obj->o_num++], prop, sizeof(AMFObjectProperty));
   167e4:	eaffba78 	b	51cc <memcpy@plt>
void
AMF_AddProp(AMFObject *obj, const AMFObjectProperty *prop)
{
  if (!(obj->o_num & 0x0f))
    obj->o_props =
      realloc(obj->o_props, (obj->o_num + 16) * sizeof(AMFObjectProperty));
   167e8:	e2831010 	add	r1, r3, #16
   167ec:	e1a01281 	lsl	r1, r1, #5
   167f0:	e5900004 	ldr	r0, [r0, #4]
   167f4:	ebffbb22 	bl	5484 <realloc@plt>
   167f8:	e5943000 	ldr	r3, [r4]

void
AMF_AddProp(AMFObject *obj, const AMFObjectProperty *prop)
{
  if (!(obj->o_num & 0x0f))
    obj->o_props =
   167fc:	e1a01000 	mov	r1, r0
   16800:	e5840004 	str	r0, [r4, #4]
   16804:	eafffff0 	b	167cc <AMF_AddProp+0x1c>

00016808 <AMF_CountProp>:

int
AMF_CountProp(AMFObject *obj)
{
  return obj->o_num;
}
   16808:	e5900000 	ldr	r0, [r0]
   1680c:	e12fff1e 	bx	lr

00016810 <AMF_GetProp>:

AMFObjectProperty *
AMF_GetProp(AMFObject *obj, const AVal *name, int nIndex)
{
  if (nIndex >= 0)
   16810:	e3520000 	cmp	r2, #0
  return obj->o_num;
}

AMFObjectProperty *
AMF_GetProp(AMFObject *obj, const AVal *name, int nIndex)
{
   16814:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
  if (nIndex >= 0)
   16818:	ba00000b 	blt	1684c <AMF_GetProp+0x3c>
    {
      if (nIndex < obj->o_num)
   1681c:	e5903000 	ldr	r3, [r0]
   16820:	e1520003 	cmp	r2, r3
   16824:	ba000004 	blt	1683c <AMF_GetProp+0x2c>
	  if (AVMATCH(&obj->o_props[n].p_name, name))
	    return &obj->o_props[n];
	}
    }

  return (AMFObjectProperty *)&AMFProp_Invalid;
   16828:	e59f60a8 	ldr	r6, [pc, #168]	; 168d8 <AMF_GetProp+0xc8>
   1682c:	e08f6006 	add	r6, pc, r6
   16830:	e2866030 	add	r6, r6, #48	; 0x30
}
   16834:	e1a00006 	mov	r0, r6
   16838:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
AMF_GetProp(AMFObject *obj, const AVal *name, int nIndex)
{
  if (nIndex >= 0)
    {
      if (nIndex < obj->o_num)
	return &obj->o_props[nIndex];
   1683c:	e5903004 	ldr	r3, [r0, #4]
   16840:	e0836282 	add	r6, r3, r2, lsl #5
	    return &obj->o_props[n];
	}
    }

  return (AMFObjectProperty *)&AMFProp_Invalid;
}
   16844:	e1a00006 	mov	r0, r6
   16848:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
	return &obj->o_props[nIndex];
    }
  else
    {
      int n;
      for (n = 0; n < obj->o_num; n++)
   1684c:	e5908000 	ldr	r8, [r0]
	  if (AVMATCH(&obj->o_props[n].p_name, name))
	    return &obj->o_props[n];
	}
    }

  return (AMFObjectProperty *)&AMFProp_Invalid;
   16850:	e59f6084 	ldr	r6, [pc, #132]	; 168dc <AMF_GetProp+0xcc>
	return &obj->o_props[nIndex];
    }
  else
    {
      int n;
      for (n = 0; n < obj->o_num; n++)
   16854:	e3580000 	cmp	r8, #0
	  if (AVMATCH(&obj->o_props[n].p_name, name))
	    return &obj->o_props[n];
	}
    }

  return (AMFObjectProperty *)&AMFProp_Invalid;
   16858:	e08f6006 	add	r6, pc, r6
   1685c:	e2866030 	add	r6, r6, #48	; 0x30
	return &obj->o_props[nIndex];
    }
  else
    {
      int n;
      for (n = 0; n < obj->o_num; n++)
   16860:	dafffff3 	ble	16834 <AMF_GetProp+0x24>
   16864:	e590a004 	ldr	sl, [r0, #4]
   16868:	e1a09001 	mov	r9, r1
   1686c:	e5917004 	ldr	r7, [r1, #4]
   16870:	e1a0400a 	mov	r4, sl
   16874:	e3a05000 	mov	r5, #0
   16878:	ea000003 	b	1688c <AMF_GetProp+0x7c>
   1687c:	e2855001 	add	r5, r5, #1
   16880:	e1550008 	cmp	r5, r8
   16884:	e2844020 	add	r4, r4, #32
   16888:	0a00000d 	beq	168c4 <AMF_GetProp+0xb4>
	{
	  if (AVMATCH(&obj->o_props[n].p_name, name))
   1688c:	e5943004 	ldr	r3, [r4, #4]
   16890:	e1a06004 	mov	r6, r4
   16894:	e1530007 	cmp	r3, r7
   16898:	1afffff7 	bne	1687c <AMF_GetProp+0x6c>
   1689c:	e79a0285 	ldr	r0, [sl, r5, lsl #5]
   168a0:	e5991000 	ldr	r1, [r9]
   168a4:	e1a02007 	mov	r2, r7
   168a8:	ebffba4a 	bl	51d8 <memcmp@plt>
   168ac:	e3500000 	cmp	r0, #0
   168b0:	0affffdf 	beq	16834 <AMF_GetProp+0x24>
	return &obj->o_props[nIndex];
    }
  else
    {
      int n;
      for (n = 0; n < obj->o_num; n++)
   168b4:	e2855001 	add	r5, r5, #1
   168b8:	e1550008 	cmp	r5, r8
   168bc:	e2844020 	add	r4, r4, #32
   168c0:	1afffff1 	bne	1688c <AMF_GetProp+0x7c>
	  if (AVMATCH(&obj->o_props[n].p_name, name))
	    return &obj->o_props[n];
	}
    }

  return (AMFObjectProperty *)&AMFProp_Invalid;
   168c4:	e59f6014 	ldr	r6, [pc, #20]	; 168e0 <AMF_GetProp+0xd0>
   168c8:	e08f6006 	add	r6, pc, r6
   168cc:	e2866030 	add	r6, r6, #48	; 0x30
}
   168d0:	e1a00006 	mov	r0, r6
   168d4:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
   168d8:	0000b1dc 	.word	0x0000b1dc
   168dc:	0000b1b0 	.word	0x0000b1b0
   168e0:	0000b140 	.word	0x0000b140

000168e4 <AMF_Dump>:

void
AMF_Dump(AMFObject *obj)
{
  int n;
  RTMP_Log(RTMP_LOGDEBUG, "(object begin)");
   168e4:	e59f1050 	ldr	r1, [pc, #80]	; 1693c <AMF_Dump+0x58>
  return (AMFObjectProperty *)&AMFProp_Invalid;
}

void
AMF_Dump(AMFObject *obj)
{
   168e8:	e92d4038 	push	{r3, r4, r5, lr}
  int n;
  RTMP_Log(RTMP_LOGDEBUG, "(object begin)");
   168ec:	e08f1001 	add	r1, pc, r1
  return (AMFObjectProperty *)&AMFProp_Invalid;
}

void
AMF_Dump(AMFObject *obj)
{
   168f0:	e1a05000 	mov	r5, r0
  int n;
  RTMP_Log(RTMP_LOGDEBUG, "(object begin)");
   168f4:	e3a00004 	mov	r0, #4
   168f8:	ebfffc2b 	bl	159ac <RTMP_Log>
  for (n = 0; n < obj->o_num; n++)
   168fc:	e5953000 	ldr	r3, [r5]
   16900:	e3530000 	cmp	r3, #0
   16904:	c3a04000 	movgt	r4, #0
   16908:	da000006 	ble	16928 <AMF_Dump+0x44>
    {
      AMFProp_Dump(&obj->o_props[n]);
   1690c:	e5950004 	ldr	r0, [r5, #4]
   16910:	e0800284 	add	r0, r0, r4, lsl #5
   16914:	eb00000a 	bl	16944 <AMFProp_Dump>
void
AMF_Dump(AMFObject *obj)
{
  int n;
  RTMP_Log(RTMP_LOGDEBUG, "(object begin)");
  for (n = 0; n < obj->o_num; n++)
   16918:	e5953000 	ldr	r3, [r5]
   1691c:	e2844001 	add	r4, r4, #1
   16920:	e1530004 	cmp	r3, r4
   16924:	cafffff8 	bgt	1690c <AMF_Dump+0x28>
    {
      AMFProp_Dump(&obj->o_props[n]);
    }
  RTMP_Log(RTMP_LOGDEBUG, "(object end)");
   16928:	e59f1010 	ldr	r1, [pc, #16]	; 16940 <AMF_Dump+0x5c>
   1692c:	e3a00004 	mov	r0, #4
   16930:	e08f1001 	add	r1, pc, r1
}
   16934:	e8bd4038 	pop	{r3, r4, r5, lr}
  RTMP_Log(RTMP_LOGDEBUG, "(object begin)");
  for (n = 0; n < obj->o_num; n++)
    {
      AMFProp_Dump(&obj->o_props[n]);
    }
  RTMP_Log(RTMP_LOGDEBUG, "(object end)");
   16938:	eafffc1b 	b	159ac <RTMP_Log>
   1693c:	0000a474 	.word	0x0000a474
   16940:	0000a440 	.word	0x0000a440

00016944 <AMFProp_Dump>:
{
  char strRes[256];
  char str[256];
  AVal name;

  if (prop->p_type == AMF_INVALID)
   16944:	e5903008 	ldr	r3, [r0, #8]
  return nOriginalSize - nSize;
}

void
AMFProp_Dump(AMFObjectProperty *prop)
{
   16948:	e92d4030 	push	{r4, r5, lr}
  char strRes[256];
  char str[256];
  AVal name;

  if (prop->p_type == AMF_INVALID)
   1694c:	e35300ff 	cmp	r3, #255	; 0xff
  return nOriginalSize - nSize;
}

void
AMFProp_Dump(AMFObjectProperty *prop)
{
   16950:	e24ddf85 	sub	sp, sp, #532	; 0x214
   16954:	e1a04000 	mov	r4, r0
  char strRes[256];
  char str[256];
  AVal name;

  if (prop->p_type == AMF_INVALID)
   16958:	0a000064 	beq	16af0 <AMFProp_Dump+0x1ac>
    {
      RTMP_Log(RTMP_LOGDEBUG, "Property: INVALID");
      return;
    }

  if (prop->p_type == AMF_NULL)
   1695c:	e3530005 	cmp	r3, #5
   16960:	0a000068 	beq	16b08 <AMFProp_Dump+0x1c4>
    {
      RTMP_Log(RTMP_LOGDEBUG, "Property: NULL");
      return;
    }

  if (prop->p_name.av_len)
   16964:	e5903004 	ldr	r3, [r0, #4]
   16968:	e3530000 	cmp	r3, #0
   1696c:	1a00001f 	bne	169f0 <AMFProp_Dump+0xac>
    {
      name = prop->p_name;
    }
  else
    {
      name.av_val = "no-name.";
   16970:	e59f2218 	ldr	r2, [pc, #536]	; 16b90 <AMFProp_Dump+0x24c>
      name.av_len = sizeof("no-name.") - 1;
   16974:	e3a03008 	mov	r3, #8
    {
      name = prop->p_name;
    }
  else
    {
      name.av_val = "no-name.";
   16978:	e08f2002 	add	r2, pc, r2
      name.av_len = sizeof("no-name.") - 1;
    }
  if (name.av_len > 18)
    name.av_len = 18;

  snprintf(strRes, 255, "Name: %18.*s, ", name.av_len, name.av_val);
   1697c:	e58d2000 	str	r2, [sp]
   16980:	e59f220c 	ldr	r2, [pc, #524]	; 16b94 <AMFProp_Dump+0x250>
   16984:	e28d5010 	add	r5, sp, #16
   16988:	e1a00005 	mov	r0, r5
   1698c:	e3a010ff 	mov	r1, #255	; 0xff
   16990:	e08f2002 	add	r2, pc, r2
   16994:	ebffb9d0 	bl	50dc <snprintf@plt>

  if (prop->p_type == AMF_OBJECT)
   16998:	e5943008 	ldr	r3, [r4, #8]
   1699c:	e3530003 	cmp	r3, #3
   169a0:	0a00005e 	beq	16b20 <AMFProp_Dump+0x1dc>
    {
      RTMP_Log(RTMP_LOGDEBUG, "Property: <%sOBJECT>", strRes);
      AMF_Dump(&prop->p_vu.p_object);
      return;
    }
  else if (prop->p_type == AMF_ECMA_ARRAY)
   169a4:	e3530008 	cmp	r3, #8
   169a8:	0a000065 	beq	16b44 <AMFProp_Dump+0x200>
    {
      RTMP_Log(RTMP_LOGDEBUG, "Property: <%sECMA_ARRAY>", strRes);
      AMF_Dump(&prop->p_vu.p_object);
      return;
    }
  else if (prop->p_type == AMF_STRICT_ARRAY)
   169ac:	e353000a 	cmp	r3, #10
   169b0:	0a00006b 	beq	16b64 <AMFProp_Dump+0x220>
      RTMP_Log(RTMP_LOGDEBUG, "Property: <%sSTRICT_ARRAY>", strRes);
      AMF_Dump(&prop->p_vu.p_object);
      return;
    }

  switch (prop->p_type)
   169b4:	e353000b 	cmp	r3, #11
   169b8:	908ff103 	addls	pc, pc, r3, lsl #2
   169bc:	ea000043 	b	16ad0 <AMFProp_Dump+0x18c>
   169c0:	ea000039 	b	16aac <AMFProp_Dump+0x168>
   169c4:	ea000029 	b	16a70 <AMFProp_Dump+0x12c>
   169c8:	ea00001e 	b	16a48 <AMFProp_Dump+0x104>
   169cc:	ea00003f 	b	16ad0 <AMFProp_Dump+0x18c>
   169d0:	ea00003e 	b	16ad0 <AMFProp_Dump+0x18c>
   169d4:	ea00003d 	b	16ad0 <AMFProp_Dump+0x18c>
   169d8:	ea00003c 	b	16ad0 <AMFProp_Dump+0x18c>
   169dc:	ea00003b 	b	16ad0 <AMFProp_Dump+0x18c>
   169e0:	ea00003a 	b	16ad0 <AMFProp_Dump+0x18c>
   169e4:	ea000039 	b	16ad0 <AMFProp_Dump+0x18c>
   169e8:	ea000038 	b	16ad0 <AMFProp_Dump+0x18c>
   169ec:	ea000003 	b	16a00 <AMFProp_Dump+0xbc>
    {
      name.av_val = "no-name.";
      name.av_len = sizeof("no-name.") - 1;
    }
  if (name.av_len > 18)
    name.av_len = 18;
   169f0:	e3530012 	cmp	r3, #18
   169f4:	a3a03012 	movge	r3, #18
      return;
    }

  if (prop->p_name.av_len)
    {
      name = prop->p_name;
   169f8:	e5902000 	ldr	r2, [r0]
   169fc:	eaffffde 	b	1697c <AMFProp_Dump+0x38>
    case AMF_STRING:
      snprintf(str, 255, "STRING:\t%.*s", prop->p_vu.p_aval.av_len,
	       prop->p_vu.p_aval.av_val);
      break;
    case AMF_DATE:
      snprintf(str, 255, "DATE:\ttimestamp: %.2f, UTC offset: %d",
   16a00:	e1c401d0 	ldrd	r0, [r4, #16]
   16a04:	e59f218c 	ldr	r2, [pc, #396]	; 16b98 <AMFProp_Dump+0x254>
   16a08:	e1d431f8 	ldrsh	r3, [r4, #24]
   16a0c:	e28d4e11 	add	r4, sp, #272	; 0x110
   16a10:	e1cd00f0 	strd	r0, [sp]
   16a14:	e58d3008 	str	r3, [sp, #8]
   16a18:	e1a00004 	mov	r0, r4
   16a1c:	e3a010ff 	mov	r1, #255	; 0xff
   16a20:	e08f2002 	add	r2, pc, r2
   16a24:	ebffb9ac 	bl	50dc <snprintf@plt>
      break;
    default:
      snprintf(str, 255, "INVALID TYPE 0x%02x", (unsigned char)prop->p_type);
    }

  RTMP_Log(RTMP_LOGDEBUG, "Property: <%s%s>", strRes, str);
   16a28:	e59f116c 	ldr	r1, [pc, #364]	; 16b9c <AMFProp_Dump+0x258>
   16a2c:	e1a02005 	mov	r2, r5
   16a30:	e1a03004 	mov	r3, r4
   16a34:	e3a00004 	mov	r0, #4
   16a38:	e08f1001 	add	r1, pc, r1
   16a3c:	ebfffbda 	bl	159ac <RTMP_Log>
}
   16a40:	e28ddf85 	add	sp, sp, #532	; 0x214
   16a44:	e8bd8030 	pop	{r4, r5, pc}
    case AMF_BOOLEAN:
      snprintf(str, 255, "BOOLEAN:\t%s",
	       prop->p_vu.p_number != 0.0 ? "TRUE" : "FALSE");
      break;
    case AMF_STRING:
      snprintf(str, 255, "STRING:\t%.*s", prop->p_vu.p_aval.av_len,
   16a48:	e5942010 	ldr	r2, [r4, #16]
   16a4c:	e5943014 	ldr	r3, [r4, #20]
   16a50:	e58d2000 	str	r2, [sp]
   16a54:	e59f2144 	ldr	r2, [pc, #324]	; 16ba0 <AMFProp_Dump+0x25c>
   16a58:	e28d4e11 	add	r4, sp, #272	; 0x110
   16a5c:	e1a00004 	mov	r0, r4
   16a60:	e3a010ff 	mov	r1, #255	; 0xff
   16a64:	e08f2002 	add	r2, pc, r2
   16a68:	ebffb99b 	bl	50dc <snprintf@plt>
	       prop->p_vu.p_aval.av_val);
      break;
   16a6c:	eaffffed 	b	16a28 <AMFProp_Dump+0xe4>
    {
    case AMF_NUMBER:
      snprintf(str, 255, "NUMBER:\t%.2f", prop->p_vu.p_number);
      break;
    case AMF_BOOLEAN:
      snprintf(str, 255, "BOOLEAN:\t%s",
   16a70:	e3a03000 	mov	r3, #0
   16a74:	e1c401d0 	ldrd	r0, [r4, #16]
   16a78:	e3a02000 	mov	r2, #0
   16a7c:	eb001657 	bl	1c3e0 <__aeabi_dcmpeq>
   16a80:	e59f311c 	ldr	r3, [pc, #284]	; 16ba4 <AMFProp_Dump+0x260>
   16a84:	e08f3003 	add	r3, pc, r3
   16a88:	e3500000 	cmp	r0, #0
   16a8c:	0a00003c 	beq	16b84 <AMFProp_Dump+0x240>
   16a90:	e59f2110 	ldr	r2, [pc, #272]	; 16ba8 <AMFProp_Dump+0x264>
   16a94:	e28d4e11 	add	r4, sp, #272	; 0x110
   16a98:	e1a00004 	mov	r0, r4
   16a9c:	e3a010ff 	mov	r1, #255	; 0xff
   16aa0:	e08f2002 	add	r2, pc, r2
   16aa4:	ebffb98c 	bl	50dc <snprintf@plt>
	       prop->p_vu.p_number != 0.0 ? "TRUE" : "FALSE");
      break;
   16aa8:	eaffffde 	b	16a28 <AMFProp_Dump+0xe4>
    }

  switch (prop->p_type)
    {
    case AMF_NUMBER:
      snprintf(str, 255, "NUMBER:\t%.2f", prop->p_vu.p_number);
   16aac:	e1c421d0 	ldrd	r2, [r4, #16]
   16ab0:	e28d4e11 	add	r4, sp, #272	; 0x110
   16ab4:	e1cd20f0 	strd	r2, [sp]
   16ab8:	e59f20ec 	ldr	r2, [pc, #236]	; 16bac <AMFProp_Dump+0x268>
   16abc:	e1a00004 	mov	r0, r4
   16ac0:	e3a010ff 	mov	r1, #255	; 0xff
   16ac4:	e08f2002 	add	r2, pc, r2
   16ac8:	ebffb983 	bl	50dc <snprintf@plt>
      break;
   16acc:	eaffffd5 	b	16a28 <AMFProp_Dump+0xe4>
    case AMF_DATE:
      snprintf(str, 255, "DATE:\ttimestamp: %.2f, UTC offset: %d",
	       prop->p_vu.p_number, prop->p_UTCoffset);
      break;
    default:
      snprintf(str, 255, "INVALID TYPE 0x%02x", (unsigned char)prop->p_type);
   16ad0:	e59f20d8 	ldr	r2, [pc, #216]	; 16bb0 <AMFProp_Dump+0x26c>
   16ad4:	e28d4e11 	add	r4, sp, #272	; 0x110
   16ad8:	e20330ff 	and	r3, r3, #255	; 0xff
   16adc:	e1a00004 	mov	r0, r4
   16ae0:	e3a010ff 	mov	r1, #255	; 0xff
   16ae4:	e08f2002 	add	r2, pc, r2
   16ae8:	ebffb97b 	bl	50dc <snprintf@plt>
   16aec:	eaffffcd 	b	16a28 <AMFProp_Dump+0xe4>
  char str[256];
  AVal name;

  if (prop->p_type == AMF_INVALID)
    {
      RTMP_Log(RTMP_LOGDEBUG, "Property: INVALID");
   16af0:	e59f10bc 	ldr	r1, [pc, #188]	; 16bb4 <AMFProp_Dump+0x270>
   16af4:	e3a00004 	mov	r0, #4
   16af8:	e08f1001 	add	r1, pc, r1
   16afc:	ebfffbaa 	bl	159ac <RTMP_Log>
    default:
      snprintf(str, 255, "INVALID TYPE 0x%02x", (unsigned char)prop->p_type);
    }

  RTMP_Log(RTMP_LOGDEBUG, "Property: <%s%s>", strRes, str);
}
   16b00:	e28ddf85 	add	sp, sp, #532	; 0x214
   16b04:	e8bd8030 	pop	{r4, r5, pc}
      return;
    }

  if (prop->p_type == AMF_NULL)
    {
      RTMP_Log(RTMP_LOGDEBUG, "Property: NULL");
   16b08:	e59f10a8 	ldr	r1, [pc, #168]	; 16bb8 <AMFProp_Dump+0x274>
   16b0c:	e3a00004 	mov	r0, #4
   16b10:	e08f1001 	add	r1, pc, r1
   16b14:	ebfffba4 	bl	159ac <RTMP_Log>
    default:
      snprintf(str, 255, "INVALID TYPE 0x%02x", (unsigned char)prop->p_type);
    }

  RTMP_Log(RTMP_LOGDEBUG, "Property: <%s%s>", strRes, str);
}
   16b18:	e28ddf85 	add	sp, sp, #532	; 0x214
   16b1c:	e8bd8030 	pop	{r4, r5, pc}

  snprintf(strRes, 255, "Name: %18.*s, ", name.av_len, name.av_val);

  if (prop->p_type == AMF_OBJECT)
    {
      RTMP_Log(RTMP_LOGDEBUG, "Property: <%sOBJECT>", strRes);
   16b20:	e59f1094 	ldr	r1, [pc, #148]	; 16bbc <AMFProp_Dump+0x278>
   16b24:	e1a02005 	mov	r2, r5
   16b28:	e08f1001 	add	r1, pc, r1
   16b2c:	e3a00004 	mov	r0, #4
   16b30:	ebfffb9d 	bl	159ac <RTMP_Log>
      AMF_Dump(&prop->p_vu.p_object);
   16b34:	e2840010 	add	r0, r4, #16
   16b38:	ebffff69 	bl	168e4 <AMF_Dump>
    default:
      snprintf(str, 255, "INVALID TYPE 0x%02x", (unsigned char)prop->p_type);
    }

  RTMP_Log(RTMP_LOGDEBUG, "Property: <%s%s>", strRes, str);
}
   16b3c:	e28ddf85 	add	sp, sp, #532	; 0x214
   16b40:	e8bd8030 	pop	{r4, r5, pc}
      AMF_Dump(&prop->p_vu.p_object);
      return;
    }
  else if (prop->p_type == AMF_ECMA_ARRAY)
    {
      RTMP_Log(RTMP_LOGDEBUG, "Property: <%sECMA_ARRAY>", strRes);
   16b44:	e59f1074 	ldr	r1, [pc, #116]	; 16bc0 <AMFProp_Dump+0x27c>
   16b48:	e1a02005 	mov	r2, r5
   16b4c:	e3a00004 	mov	r0, #4
   16b50:	e08f1001 	add	r1, pc, r1
   16b54:	ebfffb94 	bl	159ac <RTMP_Log>
      AMF_Dump(&prop->p_vu.p_object);
   16b58:	e2840010 	add	r0, r4, #16
   16b5c:	ebffff60 	bl	168e4 <AMF_Dump>
      return;
   16b60:	eaffffb6 	b	16a40 <AMFProp_Dump+0xfc>
    }
  else if (prop->p_type == AMF_STRICT_ARRAY)
    {
      RTMP_Log(RTMP_LOGDEBUG, "Property: <%sSTRICT_ARRAY>", strRes);
   16b64:	e59f1058 	ldr	r1, [pc, #88]	; 16bc4 <AMFProp_Dump+0x280>
   16b68:	e1a02005 	mov	r2, r5
   16b6c:	e3a00004 	mov	r0, #4
   16b70:	e08f1001 	add	r1, pc, r1
   16b74:	ebfffb8c 	bl	159ac <RTMP_Log>
      AMF_Dump(&prop->p_vu.p_object);
   16b78:	e2840010 	add	r0, r4, #16
   16b7c:	ebffff58 	bl	168e4 <AMF_Dump>
      return;
   16b80:	eaffffae 	b	16a40 <AMFProp_Dump+0xfc>
    {
    case AMF_NUMBER:
      snprintf(str, 255, "NUMBER:\t%.2f", prop->p_vu.p_number);
      break;
    case AMF_BOOLEAN:
      snprintf(str, 255, "BOOLEAN:\t%s",
   16b84:	e59f303c 	ldr	r3, [pc, #60]	; 16bc8 <AMFProp_Dump+0x284>
   16b88:	e08f3003 	add	r3, pc, r3
   16b8c:	eaffffbf 	b	16a90 <AMFProp_Dump+0x14c>
   16b90:	0000a408 	.word	0x0000a408
   16b94:	0000a420 	.word	0x0000a420
   16b98:	0000a41c 	.word	0x0000a41c
   16b9c:	0000a42c 	.word	0x0000a42c
   16ba0:	0000a3c8 	.word	0x0000a3c8
   16ba4:	00007574 	.word	0x00007574
   16ba8:	0000a380 	.word	0x0000a380
   16bac:	0000a34c 	.word	0x0000a34c
   16bb0:	00007548 	.word	0x00007548
   16bb4:	0000a294 	.word	0x0000a294
   16bb8:	0000a290 	.word	0x0000a290
   16bbc:	0000a298 	.word	0x0000a298
   16bc0:	0000a288 	.word	0x0000a288
   16bc4:	0000a284 	.word	0x0000a284
   16bc8:	00007468 	.word	0x00007468

00016bcc <AMF_Reset>:
  RTMP_Log(RTMP_LOGDEBUG, "(object end)");
}

void
AMF_Reset(AMFObject *obj)
{
   16bcc:	e92d4038 	push	{r3, r4, r5, lr}
  int n;
  for (n = 0; n < obj->o_num; n++)
   16bd0:	e5903000 	ldr	r3, [r0]
  RTMP_Log(RTMP_LOGDEBUG, "(object end)");
}

void
AMF_Reset(AMFObject *obj)
{
   16bd4:	e1a05000 	mov	r5, r0
  int n;
  for (n = 0; n < obj->o_num; n++)
   16bd8:	e3530000 	cmp	r3, #0
   16bdc:	c3a04000 	movgt	r4, #0
   16be0:	da000006 	ble	16c00 <AMF_Reset+0x34>
    {
      AMFProp_Reset(&obj->o_props[n]);
   16be4:	e5950004 	ldr	r0, [r5, #4]
   16be8:	e0800284 	add	r0, r0, r4, lsl #5
   16bec:	eb000009 	bl	16c18 <AMFProp_Reset>

void
AMF_Reset(AMFObject *obj)
{
  int n;
  for (n = 0; n < obj->o_num; n++)
   16bf0:	e5953000 	ldr	r3, [r5]
   16bf4:	e2844001 	add	r4, r4, #1
   16bf8:	e1530004 	cmp	r3, r4
   16bfc:	cafffff8 	bgt	16be4 <AMF_Reset+0x18>
    {
      AMFProp_Reset(&obj->o_props[n]);
    }
  free(obj->o_props);
   16c00:	e5950004 	ldr	r0, [r5, #4]
   16c04:	ebffb8fe 	bl	5004 <free@plt>
  obj->o_props = NULL;
   16c08:	e3a03000 	mov	r3, #0
   16c0c:	e5853004 	str	r3, [r5, #4]
  obj->o_num = 0;
   16c10:	e5853000 	str	r3, [r5]
   16c14:	e8bd8038 	pop	{r3, r4, r5, pc}

00016c18 <AMFProp_Reset>:
}

void
AMFProp_Reset(AMFObjectProperty *prop)
{
  if (prop->p_type == AMF_OBJECT || prop->p_type == AMF_ECMA_ARRAY ||
   16c18:	e5902008 	ldr	r2, [r0, #8]
  RTMP_Log(RTMP_LOGDEBUG, "Property: <%s%s>", strRes, str);
}

void
AMFProp_Reset(AMFObjectProperty *prop)
{
   16c1c:	e92d4010 	push	{r4, lr}
  if (prop->p_type == AMF_OBJECT || prop->p_type == AMF_ECMA_ARRAY ||
   16c20:	e3c23002 	bic	r3, r2, #2
   16c24:	e3520003 	cmp	r2, #3
   16c28:	13530008 	cmpne	r3, #8
   16c2c:	13a03000 	movne	r3, #0
  RTMP_Log(RTMP_LOGDEBUG, "Property: <%s%s>", strRes, str);
}

void
AMFProp_Reset(AMFObjectProperty *prop)
{
   16c30:	e1a04000 	mov	r4, r0
  if (prop->p_type == AMF_OBJECT || prop->p_type == AMF_ECMA_ARRAY ||
   16c34:	03a03001 	moveq	r3, #1
      prop->p_type == AMF_STRICT_ARRAY)
    AMF_Reset(&prop->p_vu.p_object);
  else
    {
      prop->p_vu.p_aval.av_len = 0;
   16c38:	15803014 	strne	r3, [r0, #20]
      prop->p_vu.p_aval.av_val = NULL;
   16c3c:	15803010 	strne	r3, [r0, #16]
}

void
AMFProp_Reset(AMFObjectProperty *prop)
{
  if (prop->p_type == AMF_OBJECT || prop->p_type == AMF_ECMA_ARRAY ||
   16c40:	0a000002 	beq	16c50 <AMFProp_Reset+0x38>
  else
    {
      prop->p_vu.p_aval.av_len = 0;
      prop->p_vu.p_aval.av_val = NULL;
    }
  prop->p_type = AMF_INVALID;
   16c44:	e3a030ff 	mov	r3, #255	; 0xff
   16c48:	e5843008 	str	r3, [r4, #8]
   16c4c:	e8bd8010 	pop	{r4, pc}
void
AMFProp_Reset(AMFObjectProperty *prop)
{
  if (prop->p_type == AMF_OBJECT || prop->p_type == AMF_ECMA_ARRAY ||
      prop->p_type == AMF_STRICT_ARRAY)
    AMF_Reset(&prop->p_vu.p_object);
   16c50:	e2800010 	add	r0, r0, #16
   16c54:	ebffffdc 	bl	16bcc <AMF_Reset>
   16c58:	eafffff9 	b	16c44 <AMFProp_Reset+0x2c>

00016c5c <AMF3CD_AddProp>:

/* AMF3ClassDefinition */

void
AMF3CD_AddProp(AMF3ClassDef *cd, AVal *prop)
{
   16c5c:	e92d4038 	push	{r3, r4, r5, lr}
  if (!(cd->cd_num & 0x0f))
   16c60:	e590300c 	ldr	r3, [r0, #12]

/* AMF3ClassDefinition */

void
AMF3CD_AddProp(AMF3ClassDef *cd, AVal *prop)
{
   16c64:	e1a04000 	mov	r4, r0
  if (!(cd->cd_num & 0x0f))
   16c68:	e313000f 	tst	r3, #15

/* AMF3ClassDefinition */

void
AMF3CD_AddProp(AMF3ClassDef *cd, AVal *prop)
{
   16c6c:	e1a05001 	mov	r5, r1
  if (!(cd->cd_num & 0x0f))
   16c70:	0a000006 	beq	16c90 <AMF3CD_AddProp+0x34>
   16c74:	e5902010 	ldr	r2, [r0, #16]
    cd->cd_props = realloc(cd->cd_props, (cd->cd_num + 16) * sizeof(AVal));
  cd->cd_props[cd->cd_num++] = *prop;
   16c78:	e8950003 	ldm	r5, {r0, r1}
   16c7c:	e0822183 	add	r2, r2, r3, lsl #3
   16c80:	e2833001 	add	r3, r3, #1
   16c84:	e584300c 	str	r3, [r4, #12]
   16c88:	e8820003 	stm	r2, {r0, r1}
   16c8c:	e8bd8038 	pop	{r3, r4, r5, pc}

void
AMF3CD_AddProp(AMF3ClassDef *cd, AVal *prop)
{
  if (!(cd->cd_num & 0x0f))
    cd->cd_props = realloc(cd->cd_props, (cd->cd_num + 16) * sizeof(AVal));
   16c90:	e2831010 	add	r1, r3, #16
   16c94:	e1a01181 	lsl	r1, r1, #3
   16c98:	e5900010 	ldr	r0, [r0, #16]
   16c9c:	ebffb9f8 	bl	5484 <realloc@plt>
   16ca0:	e594300c 	ldr	r3, [r4, #12]
   16ca4:	e1a02000 	mov	r2, r0
   16ca8:	e5840010 	str	r0, [r4, #16]
   16cac:	eafffff1 	b	16c78 <AMF3CD_AddProp+0x1c>

00016cb0 <AMF3CD_GetProp>:
}

AVal *
AMF3CD_GetProp(AMF3ClassDef *cd, int nIndex)
{
  if (nIndex >= cd->cd_num)
   16cb0:	e590300c 	ldr	r3, [r0, #12]
   16cb4:	e1530001 	cmp	r3, r1
   16cb8:	da000002 	ble	16cc8 <AMF3CD_GetProp+0x18>
    return (AVal *)&AV_empty;
  return &cd->cd_props[nIndex];
   16cbc:	e5903010 	ldr	r3, [r0, #16]
   16cc0:	e0830181 	add	r0, r3, r1, lsl #3
   16cc4:	e12fff1e 	bx	lr

AVal *
AMF3CD_GetProp(AMF3ClassDef *cd, int nIndex)
{
  if (nIndex >= cd->cd_num)
    return (AVal *)&AV_empty;
   16cc8:	e59f0008 	ldr	r0, [pc, #8]	; 16cd8 <AMF3CD_GetProp+0x28>
   16ccc:	e08f0000 	add	r0, pc, r0
   16cd0:	e2800050 	add	r0, r0, #80	; 0x50
  return &cd->cd_props[nIndex];
}
   16cd4:	e12fff1e 	bx	lr
   16cd8:	0000ad3c 	.word	0x0000ad3c

00016cdc <AMF3_Decode>:
  return nOriginalSize - nSize;
}

int
AMF3_Decode(AMFObject *obj, const char *pBuffer, int nSize, int bAMFData)
{
   16cdc:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int32_t ref;
  int len;

  obj->o_num = 0;
  obj->o_props = NULL;
  if (bAMFData)
   16ce0:	e3530000 	cmp	r3, #0
  return nOriginalSize - nSize;
}

int
AMF3_Decode(AMFObject *obj, const char *pBuffer, int nSize, int bAMFData)
{
   16ce4:	e24dd054 	sub	sp, sp, #84	; 0x54
  int nOriginalSize = nSize;
  int32_t ref;
  int len;

  obj->o_num = 0;
   16ce8:	e3a03000 	mov	r3, #0
  return nOriginalSize - nSize;
}

int
AMF3_Decode(AMFObject *obj, const char *pBuffer, int nSize, int bAMFData)
{
   16cec:	e1a08000 	mov	r8, r0
   16cf0:	e1a04001 	mov	r4, r1
   16cf4:	e58d2008 	str	r2, [sp, #8]
  int nOriginalSize = nSize;
  int32_t ref;
  int len;

  obj->o_num = 0;
   16cf8:	e5803000 	str	r3, [r0]
  obj->o_props = NULL;
   16cfc:	e5803004 	str	r3, [r0, #4]
  if (bAMFData)
   16d00:	0a00004a 	beq	16e30 <AMF3_Decode+0x154>
    {
      if (*pBuffer != AMF3_OBJECT)
   16d04:	e5d13000 	ldrb	r3, [r1]
   16d08:	e353000a 	cmp	r3, #10
   16d0c:	0a000003 	beq	16d20 <AMF3_Decode+0x44>
	RTMP_Log(RTMP_LOGERROR,
   16d10:	e59f1304 	ldr	r1, [pc, #772]	; 1701c <AMF3_Decode+0x340>
   16d14:	e3a00001 	mov	r0, #1
   16d18:	e08f1001 	add	r1, pc, r1
   16d1c:	ebfffb22 	bl	159ac <RTMP_Log>
	    "AMF3 Object encapsulated in AMF stream does not start with AMF3_OBJECT!");
      pBuffer++;
      nSize--;
   16d20:	e59d3008 	ldr	r3, [sp, #8]
  if (bAMFData)
    {
      if (*pBuffer != AMF3_OBJECT)
	RTMP_Log(RTMP_LOGERROR,
	    "AMF3 Object encapsulated in AMF stream does not start with AMF3_OBJECT!");
      pBuffer++;
   16d24:	e2844001 	add	r4, r4, #1
      nSize--;
   16d28:	e2435001 	sub	r5, r3, #1
    }

  ref = 0;
   16d2c:	e28d1050 	add	r1, sp, #80	; 0x50
   16d30:	e3a07000 	mov	r7, #0
  len = AMF3ReadInteger(pBuffer, &ref);
   16d34:	e1a00004 	mov	r0, r4
	    "AMF3 Object encapsulated in AMF stream does not start with AMF3_OBJECT!");
      pBuffer++;
      nSize--;
    }

  ref = 0;
   16d38:	e5217040 	str	r7, [r1, #-64]!	; 0xffffffc0
  len = AMF3ReadInteger(pBuffer, &ref);
   16d3c:	ebfffd63 	bl	162d0 <AMF3ReadInteger>
  pBuffer += len;
  nSize -= len;

  if ((ref & 1) == 0)
   16d40:	e59d2010 	ldr	r2, [sp, #16]
   16d44:	e3120001 	tst	r2, #1
      nSize--;
    }

  ref = 0;
  len = AMF3ReadInteger(pBuffer, &ref);
  pBuffer += len;
   16d48:	e0844000 	add	r4, r4, r0
  nSize -= len;
   16d4c:	e0605005 	rsb	r5, r0, r5

  if ((ref & 1) == 0)
   16d50:	0a0000a0 	beq	16fd8 <AMF3_Decode+0x2fc>

      AMF3ClassDef cd = { {0, 0}
      };
      AMFObjectProperty prop;

      if ((classRef & 0x1) == 0)
   16d54:	e3120002 	tst	r2, #2
    }
  else				/* object instance */
    {
      int32_t classRef = (ref >> 1);

      AMF3ClassDef cd = { {0, 0}
   16d58:	e58d701c 	str	r7, [sp, #28]
   16d5c:	e58d7020 	str	r7, [sp, #32]
   16d60:	e58d7024 	str	r7, [sp, #36]	; 0x24
   16d64:	e58d7028 	str	r7, [sp, #40]	; 0x28
   16d68:	e58d702c 	str	r7, [sp, #44]	; 0x2c
      };
      AMFObjectProperty prop;

      if ((classRef & 0x1) == 0)
   16d6c:	1a000031 	bne	16e38 <AMF3_Decode+0x15c>
	{			/* class reference */
	  uint32_t classIndex = (classRef >> 1);
	  RTMP_Log(RTMP_LOGDEBUG, "Class reference: %d", classIndex);
   16d70:	e59f12a8 	ldr	r1, [pc, #680]	; 17020 <AMF3_Decode+0x344>
   16d74:	e1a02142 	asr	r2, r2, #2
   16d78:	e3a00004 	mov	r0, #4
   16d7c:	e08f1001 	add	r1, pc, r1
   16d80:	ebfffb09 	bl	159ac <RTMP_Log>
	    }
	}

      /* add as referencable object */

      if (cd.cd_externalizable)
   16d84:	e5dd7024 	ldrb	r7, [sp, #36]	; 0x24
   16d88:	e3570000 	cmp	r7, #0
   16d8c:	1a00005b 	bne	16f00 <AMF3_Decode+0x224>
	  AMF_AddProp(obj, &prop);
	}
      else
	{
	  int nRes, i;
	  for (i = 0; i < cd.cd_num; i++)	/* non-dynamic */
   16d90:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
   16d94:	e3530000 	cmp	r3, #0
   16d98:	da00007b 	ble	16f8c <AMF3_Decode+0x2b0>
	    {
	      nRes = AMF3Prop_Decode(&prop, pBuffer, nSize, FALSE);
	      if (nRes == -1)
		RTMP_Log(RTMP_LOGDEBUG, "%s, failed to decode AMF3 property!",
   16d9c:	e59f3280 	ldr	r3, [pc, #640]	; 17024 <AMF3_Decode+0x348>
   16da0:	e59fa280 	ldr	sl, [pc, #640]	; 17028 <AMF3_Decode+0x34c>
   16da4:	e08f3003 	add	r3, pc, r3
   16da8:	e2833058 	add	r3, r3, #88	; 0x58
   16dac:	e08fa00a 	add	sl, pc, sl
   16db0:	e58d300c 	str	r3, [sp, #12]
   16db4:	e28d901c 	add	r9, sp, #28
   16db8:	e28d6030 	add	r6, sp, #48	; 0x30
   16dbc:	ea00000e 	b	16dfc <AMF3_Decode+0x120>
		    __FUNCTION__);

	      AMFProp_SetName(&prop, AMF3CD_GetProp(&cd, i));
   16dc0:	e1a01007 	mov	r1, r7
   16dc4:	e1a00009 	mov	r0, r9
   16dc8:	ebffffb8 	bl	16cb0 <AMF3CD_GetProp>
	  AMF_AddProp(obj, &prop);
	}
      else
	{
	  int nRes, i;
	  for (i = 0; i < cd.cd_num; i++)	/* non-dynamic */
   16dcc:	e2877001 	add	r7, r7, #1
		    __FUNCTION__);

	      AMFProp_SetName(&prop, AMF3CD_GetProp(&cd, i));
	      AMF_AddProp(obj, &prop);

	      pBuffer += nRes;
   16dd0:	e084400b 	add	r4, r4, fp
	      nSize -= nRes;
   16dd4:	e06b5005 	rsb	r5, fp, r5
	      nRes = AMF3Prop_Decode(&prop, pBuffer, nSize, FALSE);
	      if (nRes == -1)
		RTMP_Log(RTMP_LOGDEBUG, "%s, failed to decode AMF3 property!",
		    __FUNCTION__);

	      AMFProp_SetName(&prop, AMF3CD_GetProp(&cd, i));
   16dd8:	e1a01000 	mov	r1, r0
   16ddc:	e1a00006 	mov	r0, r6
   16de0:	ebfffd1c 	bl	16258 <AMFProp_SetName>
	      AMF_AddProp(obj, &prop);
   16de4:	e1a00008 	mov	r0, r8
   16de8:	e1a01006 	mov	r1, r6
   16dec:	ebfffe6f 	bl	167b0 <AMF_AddProp>
	  AMF_AddProp(obj, &prop);
	}
      else
	{
	  int nRes, i;
	  for (i = 0; i < cd.cd_num; i++)	/* non-dynamic */
   16df0:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
   16df4:	e1520007 	cmp	r2, r7
   16df8:	da000063 	ble	16f8c <AMF3_Decode+0x2b0>
	    {
	      nRes = AMF3Prop_Decode(&prop, pBuffer, nSize, FALSE);
   16dfc:	e1a00006 	mov	r0, r6
   16e00:	e1a01004 	mov	r1, r4
   16e04:	e1a02005 	mov	r2, r5
   16e08:	e3a03000 	mov	r3, #0
   16e0c:	eb00008e 	bl	1704c <AMF3Prop_Decode>
	      if (nRes == -1)
   16e10:	e3700001 	cmn	r0, #1
      else
	{
	  int nRes, i;
	  for (i = 0; i < cd.cd_num; i++)	/* non-dynamic */
	    {
	      nRes = AMF3Prop_Decode(&prop, pBuffer, nSize, FALSE);
   16e14:	e1a0b000 	mov	fp, r0
	      if (nRes == -1)
   16e18:	1affffe8 	bne	16dc0 <AMF3_Decode+0xe4>
		RTMP_Log(RTMP_LOGDEBUG, "%s, failed to decode AMF3 property!",
   16e1c:	e3a00004 	mov	r0, #4
   16e20:	e1a0100a 	mov	r1, sl
   16e24:	e59d200c 	ldr	r2, [sp, #12]
   16e28:	ebfffadf 	bl	159ac <RTMP_Log>
   16e2c:	eaffffe3 	b	16dc0 <AMF3_Decode+0xe4>
   16e30:	e59d5008 	ldr	r5, [sp, #8]
   16e34:	eaffffbc 	b	16d2c <AMF3_Decode+0x50>
	  uint32_t classIndex = (classRef >> 1);
	  RTMP_Log(RTMP_LOGDEBUG, "Class reference: %d", classIndex);
	}
      else
	{
	  int32_t classExtRef = (classRef >> 1);
   16e38:	e1a0c142 	asr	ip, r2, #2
	  int i;

	  cd.cd_externalizable = (classExtRef & 0x1) == 1;
	  cd.cd_dynamic = ((classExtRef >> 1) & 0x1) == 1;
   16e3c:	e1a031c2 	asr	r3, r2, #3

	  cd.cd_num = classExtRef >> 2;

	  /* class name */

	  len = AMF3ReadString(pBuffer, &cd.cd_name);
   16e40:	e28d901c 	add	r9, sp, #28
      else
	{
	  int32_t classExtRef = (classRef >> 1);
	  int i;

	  cd.cd_externalizable = (classExtRef & 0x1) == 1;
   16e44:	e20cc001 	and	ip, ip, #1
	  cd.cd_dynamic = ((classExtRef >> 1) & 0x1) == 1;
   16e48:	e2033001 	and	r3, r3, #1

	  cd.cd_num = classExtRef >> 2;
   16e4c:	e1a02242 	asr	r2, r2, #4

	  /* class name */

	  len = AMF3ReadString(pBuffer, &cd.cd_name);
   16e50:	e1a01009 	mov	r1, r9
   16e54:	e1a00004 	mov	r0, r4
      else
	{
	  int32_t classExtRef = (classRef >> 1);
	  int i;

	  cd.cd_externalizable = (classExtRef & 0x1) == 1;
   16e58:	e5cdc024 	strb	ip, [sp, #36]	; 0x24
	  cd.cd_dynamic = ((classExtRef >> 1) & 0x1) == 1;
   16e5c:	e5cd3025 	strb	r3, [sp, #37]	; 0x25

	  cd.cd_num = classExtRef >> 2;
   16e60:	e58d2028 	str	r2, [sp, #40]	; 0x28

	  /* class name */

	  len = AMF3ReadString(pBuffer, &cd.cd_name);
   16e64:	ebfffd38 	bl	1634c <AMF3ReadString>
	  nSize -= len;
	  pBuffer += len;

	  /*std::string str = className; */

	  RTMP_Log(RTMP_LOGDEBUG,
   16e68:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
   16e6c:	e5dd3024 	ldrb	r3, [sp, #36]	; 0x24
   16e70:	e59d201c 	ldr	r2, [sp, #28]

	  cd.cd_num = classExtRef >> 2;

	  /* class name */

	  len = AMF3ReadString(pBuffer, &cd.cd_name);
   16e74:	e1a0c000 	mov	ip, r0
	  nSize -= len;
	  pBuffer += len;

	  /*std::string str = className; */

	  RTMP_Log(RTMP_LOGDEBUG,
   16e78:	e5dd0025 	ldrb	r0, [sp, #37]	; 0x25
	  cd.cd_num = classExtRef >> 2;

	  /* class name */

	  len = AMF3ReadString(pBuffer, &cd.cd_name);
	  nSize -= len;
   16e7c:	e06c5005 	rsb	r5, ip, r5
	  pBuffer += len;

	  /*std::string str = className; */

	  RTMP_Log(RTMP_LOGDEBUG,
   16e80:	e88d0003 	stm	sp, {r0, r1}
   16e84:	e59f11a0 	ldr	r1, [pc, #416]	; 1702c <AMF3_Decode+0x350>
   16e88:	e3a00004 	mov	r0, #4
   16e8c:	e08f1001 	add	r1, pc, r1

	  /* class name */

	  len = AMF3ReadString(pBuffer, &cd.cd_name);
	  nSize -= len;
	  pBuffer += len;
   16e90:	e084400c 	add	r4, r4, ip

	  /*std::string str = className; */

	  RTMP_Log(RTMP_LOGDEBUG,
   16e94:	ebfffac4 	bl	159ac <RTMP_Log>
	      "Class name: %s, externalizable: %d, dynamic: %d, classMembers: %d",
	      cd.cd_name.av_val, cd.cd_externalizable, cd.cd_dynamic,
	      cd.cd_num);

	  for (i = 0; i < cd.cd_num; i++)
   16e98:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
   16e9c:	e3530000 	cmp	r3, #0
   16ea0:	da000036 	ble	16f80 <AMF3_Decode+0x2a4>
	    {
	      AVal memberName;
	      len = AMF3ReadString(pBuffer, &memberName);
	      RTMP_Log(RTMP_LOGDEBUG, "Member: %s", memberName.av_val);
   16ea4:	e59fb184 	ldr	fp, [pc, #388]	; 17030 <AMF3_Decode+0x354>
   16ea8:	e28d6030 	add	r6, sp, #48	; 0x30
   16eac:	e08fb00b 	add	fp, pc, fp
	      cd.cd_num);

	  for (i = 0; i < cd.cd_num; i++)
	    {
	      AVal memberName;
	      len = AMF3ReadString(pBuffer, &memberName);
   16eb0:	e1a00004 	mov	r0, r4
   16eb4:	e1a01006 	mov	r1, r6
   16eb8:	ebfffd23 	bl	1634c <AMF3ReadString>
	      RTMP_Log(RTMP_LOGDEBUG, "Member: %s", memberName.av_val);
   16ebc:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
   16ec0:	e1a0100b 	mov	r1, fp
	  RTMP_Log(RTMP_LOGDEBUG,
	      "Class name: %s, externalizable: %d, dynamic: %d, classMembers: %d",
	      cd.cd_name.av_val, cd.cd_externalizable, cd.cd_dynamic,
	      cd.cd_num);

	  for (i = 0; i < cd.cd_num; i++)
   16ec4:	e2877001 	add	r7, r7, #1
	    {
	      AVal memberName;
	      len = AMF3ReadString(pBuffer, &memberName);
   16ec8:	e1a0a000 	mov	sl, r0
	      RTMP_Log(RTMP_LOGDEBUG, "Member: %s", memberName.av_val);
   16ecc:	e3a00004 	mov	r0, #4
   16ed0:	ebfffab5 	bl	159ac <RTMP_Log>
	      AMF3CD_AddProp(&cd, &memberName);
   16ed4:	e1a00009 	mov	r0, r9
   16ed8:	e1a01006 	mov	r1, r6
   16edc:	ebffff5e 	bl	16c5c <AMF3CD_AddProp>
	  RTMP_Log(RTMP_LOGDEBUG,
	      "Class name: %s, externalizable: %d, dynamic: %d, classMembers: %d",
	      cd.cd_name.av_val, cd.cd_externalizable, cd.cd_dynamic,
	      cd.cd_num);

	  for (i = 0; i < cd.cd_num; i++)
   16ee0:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
	    {
	      AVal memberName;
	      len = AMF3ReadString(pBuffer, &memberName);
	      RTMP_Log(RTMP_LOGDEBUG, "Member: %s", memberName.av_val);
	      AMF3CD_AddProp(&cd, &memberName);
	      nSize -= len;
   16ee4:	e06a5005 	rsb	r5, sl, r5
	  RTMP_Log(RTMP_LOGDEBUG,
	      "Class name: %s, externalizable: %d, dynamic: %d, classMembers: %d",
	      cd.cd_name.av_val, cd.cd_externalizable, cd.cd_dynamic,
	      cd.cd_num);

	  for (i = 0; i < cd.cd_num; i++)
   16ee8:	e1520007 	cmp	r2, r7
	      AVal memberName;
	      len = AMF3ReadString(pBuffer, &memberName);
	      RTMP_Log(RTMP_LOGDEBUG, "Member: %s", memberName.av_val);
	      AMF3CD_AddProp(&cd, &memberName);
	      nSize -= len;
	      pBuffer += len;
   16eec:	e084400a 	add	r4, r4, sl
	  RTMP_Log(RTMP_LOGDEBUG,
	      "Class name: %s, externalizable: %d, dynamic: %d, classMembers: %d",
	      cd.cd_name.av_val, cd.cd_externalizable, cd.cd_dynamic,
	      cd.cd_num);

	  for (i = 0; i < cd.cd_num; i++)
   16ef0:	caffffee 	bgt	16eb0 <AMF3_Decode+0x1d4>
	    }
	}

      /* add as referencable object */

      if (cd.cd_externalizable)
   16ef4:	e5dd7024 	ldrb	r7, [sp, #36]	; 0x24
   16ef8:	e3570000 	cmp	r7, #0
   16efc:	0affffa3 	beq	16d90 <AMF3_Decode+0xb4>
	{
	  int nRes;
	  AVal name = AVC("DEFAULT_ATTRIBUTE");
   16f00:	e59f312c 	ldr	r3, [pc, #300]	; 17034 <AMF3_Decode+0x358>
   16f04:	e28d7014 	add	r7, sp, #20
   16f08:	e08f3003 	add	r3, pc, r3
   16f0c:	e8930003 	ldm	r3, {r0, r1}

	  RTMP_Log(RTMP_LOGDEBUG, "Externalizable, TODO check");

	  nRes = AMF3Prop_Decode(&prop, pBuffer, nSize, FALSE);
   16f10:	e28d6030 	add	r6, sp, #48	; 0x30
      /* add as referencable object */

      if (cd.cd_externalizable)
	{
	  int nRes;
	  AVal name = AVC("DEFAULT_ATTRIBUTE");
   16f14:	e8870003 	stm	r7, {r0, r1}

	  RTMP_Log(RTMP_LOGDEBUG, "Externalizable, TODO check");
   16f18:	e59f1118 	ldr	r1, [pc, #280]	; 17038 <AMF3_Decode+0x35c>
   16f1c:	e3a00004 	mov	r0, #4
   16f20:	e08f1001 	add	r1, pc, r1
   16f24:	ebfffaa0 	bl	159ac <RTMP_Log>

	  nRes = AMF3Prop_Decode(&prop, pBuffer, nSize, FALSE);
   16f28:	e1a02005 	mov	r2, r5
   16f2c:	e1a01004 	mov	r1, r4
   16f30:	e1a00006 	mov	r0, r6
   16f34:	e3a03000 	mov	r3, #0
   16f38:	eb000043 	bl	1704c <AMF3Prop_Decode>
	  if (nRes == -1)
   16f3c:	e3700001 	cmn	r0, #1
	    RTMP_Log(RTMP_LOGDEBUG, "%s, failed to decode AMF3 property!",
		__FUNCTION__);
	  else
	    {
	      nSize -= nRes;
   16f40:	10605005 	rsbne	r5, r0, r5
	  AVal name = AVC("DEFAULT_ATTRIBUTE");

	  RTMP_Log(RTMP_LOGDEBUG, "Externalizable, TODO check");

	  nRes = AMF3Prop_Decode(&prop, pBuffer, nSize, FALSE);
	  if (nRes == -1)
   16f44:	0a00002c 	beq	16ffc <AMF3_Decode+0x320>
	    {
	      nSize -= nRes;
	      pBuffer += nRes;
	    }

	  AMFProp_SetName(&prop, &name);
   16f48:	e1a01007 	mov	r1, r7
   16f4c:	e1a00006 	mov	r0, r6
   16f50:	ebfffcc0 	bl	16258 <AMFProp_SetName>
	  AMF_AddProp(obj, &prop);
   16f54:	e1a00008 	mov	r0, r8
   16f58:	e1a01006 	mov	r1, r6
   16f5c:	ebfffe13 	bl	167b0 <AMF_AddProp>
		  len = prop.p_name.av_len;
		}
	      while (len > 0);
	    }
	}
      RTMP_Log(RTMP_LOGDEBUG, "class object!");
   16f60:	e59f10d4 	ldr	r1, [pc, #212]	; 1703c <AMF3_Decode+0x360>
   16f64:	e3a00004 	mov	r0, #4
   16f68:	e08f1001 	add	r1, pc, r1
   16f6c:	ebfffa8e 	bl	159ac <RTMP_Log>
    }
  return nOriginalSize - nSize;
   16f70:	e59d3008 	ldr	r3, [sp, #8]
   16f74:	e0650003 	rsb	r0, r5, r3
}
   16f78:	e28dd054 	add	sp, sp, #84	; 0x54
   16f7c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
	    }
	}

      /* add as referencable object */

      if (cd.cd_externalizable)
   16f80:	e5dd3024 	ldrb	r3, [sp, #36]	; 0x24
   16f84:	e3530000 	cmp	r3, #0
   16f88:	1affffdc 	bne	16f00 <AMF3_Decode+0x224>
	      AMF_AddProp(obj, &prop);

	      pBuffer += nRes;
	      nSize -= nRes;
	    }
	  if (cd.cd_dynamic)
   16f8c:	e5dd3025 	ldrb	r3, [sp, #37]	; 0x25
   16f90:	e3530000 	cmp	r3, #0
   16f94:	0afffff1 	beq	16f60 <AMF3_Decode+0x284>
   16f98:	e28d6030 	add	r6, sp, #48	; 0x30
	    {
	      int len = 0;

	      do
		{
		  nRes = AMF3Prop_Decode(&prop, pBuffer, nSize, TRUE);
   16f9c:	e1a01004 	mov	r1, r4
   16fa0:	e1a02005 	mov	r2, r5
   16fa4:	e3a03001 	mov	r3, #1
   16fa8:	e1a00006 	mov	r0, r6
   16fac:	eb000026 	bl	1704c <AMF3Prop_Decode>
		  AMF_AddProp(obj, &prop);
   16fb0:	e1a01006 	mov	r1, r6
	    {
	      int len = 0;

	      do
		{
		  nRes = AMF3Prop_Decode(&prop, pBuffer, nSize, TRUE);
   16fb4:	e1a07000 	mov	r7, r0
		  AMF_AddProp(obj, &prop);
   16fb8:	e1a00008 	mov	r0, r8
   16fbc:	ebfffdfb 	bl	167b0 <AMF_AddProp>
		  pBuffer += nRes;
		  nSize -= nRes;

		  len = prop.p_name.av_len;
		}
	      while (len > 0);
   16fc0:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
	      do
		{
		  nRes = AMF3Prop_Decode(&prop, pBuffer, nSize, TRUE);
		  AMF_AddProp(obj, &prop);

		  pBuffer += nRes;
   16fc4:	e0844007 	add	r4, r4, r7
		  nSize -= nRes;

		  len = prop.p_name.av_len;
		}
	      while (len > 0);
   16fc8:	e3530000 	cmp	r3, #0
		{
		  nRes = AMF3Prop_Decode(&prop, pBuffer, nSize, TRUE);
		  AMF_AddProp(obj, &prop);

		  pBuffer += nRes;
		  nSize -= nRes;
   16fcc:	e0675005 	rsb	r5, r7, r5

		  len = prop.p_name.av_len;
		}
	      while (len > 0);
   16fd0:	cafffff1 	bgt	16f9c <AMF3_Decode+0x2c0>
   16fd4:	eaffffe1 	b	16f60 <AMF3_Decode+0x284>

  if ((ref & 1) == 0)
    {				/* object reference, 0xxx */
      uint32_t objectIndex = (ref >> 1);

      RTMP_Log(RTMP_LOGDEBUG, "Object reference, index: %d", objectIndex);
   16fd8:	e59f1060 	ldr	r1, [pc, #96]	; 17040 <AMF3_Decode+0x364>
   16fdc:	e1a020c2 	asr	r2, r2, #1
   16fe0:	e3a00004 	mov	r0, #4
   16fe4:	e08f1001 	add	r1, pc, r1
   16fe8:	ebfffa6f 	bl	159ac <RTMP_Log>
	      while (len > 0);
	    }
	}
      RTMP_Log(RTMP_LOGDEBUG, "class object!");
    }
  return nOriginalSize - nSize;
   16fec:	e59d3008 	ldr	r3, [sp, #8]
   16ff0:	e0650003 	rsb	r0, r5, r3
}
   16ff4:	e28dd054 	add	sp, sp, #84	; 0x54
   16ff8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

	  RTMP_Log(RTMP_LOGDEBUG, "Externalizable, TODO check");

	  nRes = AMF3Prop_Decode(&prop, pBuffer, nSize, FALSE);
	  if (nRes == -1)
	    RTMP_Log(RTMP_LOGDEBUG, "%s, failed to decode AMF3 property!",
   16ffc:	e59f2040 	ldr	r2, [pc, #64]	; 17044 <AMF3_Decode+0x368>
   17000:	e59f1040 	ldr	r1, [pc, #64]	; 17048 <AMF3_Decode+0x36c>
   17004:	e08f2002 	add	r2, pc, r2
   17008:	e3a00004 	mov	r0, #4
   1700c:	e2822058 	add	r2, r2, #88	; 0x58
   17010:	e08f1001 	add	r1, pc, r1
   17014:	ebfffa64 	bl	159ac <RTMP_Log>
   17018:	eaffffca 	b	16f48 <AMF3_Decode+0x26c>
   1701c:	0000a160 	.word	0x0000a160
   17020:	0000a160 	.word	0x0000a160
   17024:	0000ac64 	.word	0x0000ac64
   17028:	0000a1b0 	.word	0x0000a1b0
   1702c:	0000a064 	.word	0x0000a064
   17030:	0000a088 	.word	0x0000a088
   17034:	0000d104 	.word	0x0000d104
   17038:	0000a020 	.word	0x0000a020
   1703c:	0000a018 	.word	0x0000a018
   17040:	00009edc 	.word	0x00009edc
   17044:	0000aa04 	.word	0x0000aa04
   17048:	00009f4c 	.word	0x00009f4c

0001704c <AMF3Prop_Decode>:
}

int
AMF3Prop_Decode(AMFObjectProperty *prop, const char *pBuffer, int nSize,
		int bDecodeName)
{
   1704c:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
  AMF3DataType type;

  prop->p_name.av_len = 0;
  prop->p_name.av_val = NULL;

  if (nSize == 0 || !pBuffer)
   17050:	e3510000 	cmp	r1, #0
   17054:	13520000 	cmpne	r2, #0
}

int
AMF3Prop_Decode(AMFObjectProperty *prop, const char *pBuffer, int nSize,
		int bDecodeName)
{
   17058:	e1a04000 	mov	r4, r0
  int nOriginalSize = nSize;
  AMF3DataType type;

  prop->p_name.av_len = 0;
   1705c:	e3a00000 	mov	r0, #0
}

int
AMF3Prop_Decode(AMFObjectProperty *prop, const char *pBuffer, int nSize,
		int bDecodeName)
{
   17060:	e24dd014 	sub	sp, sp, #20
  int nOriginalSize = nSize;
  AMF3DataType type;

  prop->p_name.av_len = 0;
   17064:	e5840004 	str	r0, [r4, #4]
  prop->p_name.av_val = NULL;
   17068:	e5840000 	str	r0, [r4]

  if (nSize == 0 || !pBuffer)
   1706c:	0a00007e 	beq	1726c <AMF3Prop_Decode+0x220>
      RTMP_Log(RTMP_LOGDEBUG, "empty buffer/no buffer pointer!");
      return -1;
    }

  /* decode name */
  if (bDecodeName)
   17070:	e3530000 	cmp	r3, #0
   17074:	e1a05002 	mov	r5, r2
   17078:	e1a06001 	mov	r6, r1
   1707c:	01a08002 	moveq	r8, r2
   17080:	1a000011 	bne	170cc <AMF3Prop_Decode+0x80>

  /* decode */
  type = *pBuffer++;
  nSize--;

  switch (type)
   17084:	e5d63000 	ldrb	r3, [r6]
      pBuffer += nRes;
      nSize -= nRes;
    }

  /* decode */
  type = *pBuffer++;
   17088:	e2869001 	add	r9, r6, #1
  nSize--;
   1708c:	e2487001 	sub	r7, r8, #1

  switch (type)
   17090:	e353000b 	cmp	r3, #11
   17094:	908ff103 	addls	pc, pc, r3, lsl #2
   17098:	ea000061 	b	17224 <AMF3Prop_Decode+0x1d8>
   1709c:	ea000024 	b	17134 <AMF3Prop_Decode+0xe8>
   170a0:	ea000023 	b	17134 <AMF3Prop_Decode+0xe8>
   170a4:	ea000052 	b	171f4 <AMF3Prop_Decode+0x1a8>
   170a8:	ea000057 	b	1720c <AMF3Prop_Decode+0x1c0>
   170ac:	ea000023 	b	17140 <AMF3Prop_Decode+0xf4>
   170b0:	ea00002e 	b	17170 <AMF3Prop_Decode+0x124>
   170b4:	ea000036 	b	17194 <AMF3Prop_Decode+0x148>
   170b8:	ea000035 	b	17194 <AMF3Prop_Decode+0x148>
   170bc:	ea00003b 	b	171b0 <AMF3Prop_Decode+0x164>
   170c0:	ea000057 	b	17224 <AMF3Prop_Decode+0x1d8>
   170c4:	ea00000d 	b	17100 <AMF3Prop_Decode+0xb4>
   170c8:	ea000031 	b	17194 <AMF3Prop_Decode+0x148>

  /* decode name */
  if (bDecodeName)
    {
      AVal name;
      int nRes = AMF3ReadString(pBuffer, &name);
   170cc:	e28d7008 	add	r7, sp, #8
   170d0:	e1a01007 	mov	r1, r7
   170d4:	e1a00006 	mov	r0, r6
   170d8:	ebfffc9b 	bl	1634c <AMF3ReadString>

      if (name.av_len <= 0)
   170dc:	e59d300c 	ldr	r3, [sp, #12]
   170e0:	e3530000 	cmp	r3, #0

  /* decode name */
  if (bDecodeName)
    {
      AVal name;
      int nRes = AMF3ReadString(pBuffer, &name);
   170e4:	e1a08000 	mov	r8, r0

      if (name.av_len <= 0)
   170e8:	da00000f 	ble	1712c <AMF3Prop_Decode+0xe0>
	return nRes;

      prop->p_name = name;
   170ec:	e8970003 	ldm	r7, {r0, r1}
      pBuffer += nRes;
   170f0:	e0866008 	add	r6, r6, r8
      int nRes = AMF3ReadString(pBuffer, &name);

      if (name.av_len <= 0)
	return nRes;

      prop->p_name = name;
   170f4:	e8840003 	stm	r4, {r0, r1}
      pBuffer += nRes;
      nSize -= nRes;
   170f8:	e0688005 	rsb	r8, r8, r5
   170fc:	eaffffe0 	b	17084 <AMF3Prop_Decode+0x38>
	  }
	break;
      }
    case AMF3_OBJECT:
      {
	int nRes = AMF3_Decode(&prop->p_vu.p_object, pBuffer, nSize, TRUE);
   17100:	e1a01009 	mov	r1, r9
   17104:	e2840010 	add	r0, r4, #16
   17108:	e1a02007 	mov	r2, r7
   1710c:	e3a03001 	mov	r3, #1
   17110:	ebfffef1 	bl	16cdc <AMF3_Decode>
	if (nRes == -1)
   17114:	e3700001 	cmn	r0, #1
   17118:	0a00004a 	beq	17248 <AMF3Prop_Decode+0x1fc>
	  return -1;
	nSize -= nRes;
	prop->p_type = AMF_OBJECT;
   1711c:	e3a03003 	mov	r3, #3
    case AMF3_OBJECT:
      {
	int nRes = AMF3_Decode(&prop->p_vu.p_object, pBuffer, nSize, TRUE);
	if (nRes == -1)
	  return -1;
	nSize -= nRes;
   17120:	e0607007 	rsb	r7, r0, r7
	prop->p_type = AMF_OBJECT;
   17124:	e5843008 	str	r3, [r4, #8]
      RTMP_Log(RTMP_LOGDEBUG, "%s - AMF3 unknown/unsupported datatype 0x%02x, @%p",
	  __FUNCTION__, (unsigned char)(*pBuffer), pBuffer);
      return -1;
    }

  return nOriginalSize - nSize;
   17128:	e0670005 	rsb	r0, r7, r5
}
   1712c:	e28dd014 	add	sp, sp, #20
   17130:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}

  switch (type)
    {
    case AMF3_UNDEFINED:
    case AMF3_NULL:
      prop->p_type = AMF_NULL;
   17134:	e3a03005 	mov	r3, #5
   17138:	e5843008 	str	r3, [r4, #8]
      break;
   1713c:	eafffff9 	b	17128 <AMF3Prop_Decode+0xdc>
      prop->p_type = AMF_BOOLEAN;
      prop->p_vu.p_number = 1.0;
      break;
    case AMF3_INTEGER:
      {
	int32_t res = 0;
   17140:	e28d1010 	add	r1, sp, #16
   17144:	e3a06000 	mov	r6, #0
   17148:	e5216008 	str	r6, [r1, #-8]!
	int len = AMF3ReadInteger(pBuffer, &res);
   1714c:	e1a00009 	mov	r0, r9
   17150:	ebfffc5e 	bl	162d0 <AMF3ReadInteger>
   17154:	e1a08000 	mov	r8, r0
	prop->p_vu.p_number = (double)res;
   17158:	e59d0008 	ldr	r0, [sp, #8]
   1715c:	eb00131a 	bl	1bdcc <__aeabi_i2d>
	prop->p_type = AMF_NUMBER;
	nSize -= len;
   17160:	e0687007 	rsb	r7, r8, r7
    case AMF3_INTEGER:
      {
	int32_t res = 0;
	int len = AMF3ReadInteger(pBuffer, &res);
	prop->p_vu.p_number = (double)res;
	prop->p_type = AMF_NUMBER;
   17164:	e5846008 	str	r6, [r4, #8]
      break;
    case AMF3_INTEGER:
      {
	int32_t res = 0;
	int len = AMF3ReadInteger(pBuffer, &res);
	prop->p_vu.p_number = (double)res;
   17168:	e1c401f0 	strd	r0, [r4, #16]
   1716c:	eaffffed 	b	17128 <AMF3Prop_Decode+0xdc>
	prop->p_type = AMF_NUMBER;
	nSize -= len;
	break;
      }
    case AMF3_DOUBLE:
      if (nSize < 8)
   17170:	e3570007 	cmp	r7, #7
   17174:	da000033 	ble	17248 <AMF3Prop_Decode+0x1fc>
	return -1;
      prop->p_vu.p_number = AMF_DecodeNumber(pBuffer);
   17178:	e1a00009 	mov	r0, r9
   1717c:	ebfffb5f 	bl	15f00 <AMF_DecodeNumber>
      prop->p_type = AMF_NUMBER;
   17180:	e3a03000 	mov	r3, #0
      nSize -= 8;
   17184:	e2487009 	sub	r7, r8, #9
      }
    case AMF3_DOUBLE:
      if (nSize < 8)
	return -1;
      prop->p_vu.p_number = AMF_DecodeNumber(pBuffer);
      prop->p_type = AMF_NUMBER;
   17188:	e5843008 	str	r3, [r4, #8]
	break;
      }
    case AMF3_DOUBLE:
      if (nSize < 8)
	return -1;
      prop->p_vu.p_number = AMF_DecodeNumber(pBuffer);
   1718c:	e1c401f0 	strd	r0, [r4, #16]
      prop->p_type = AMF_NUMBER;
      nSize -= 8;
      break;
   17190:	eaffffe4 	b	17128 <AMF3Prop_Decode+0xdc>
    case AMF3_STRING:
    case AMF3_XML_DOC:
    case AMF3_XML:
      {
	int len = AMF3ReadString(pBuffer, &prop->p_vu.p_aval);
   17194:	e1a00009 	mov	r0, r9
   17198:	e2841010 	add	r1, r4, #16
   1719c:	ebfffc6a 	bl	1634c <AMF3ReadString>
	prop->p_type = AMF_STRING;
   171a0:	e3a03002 	mov	r3, #2
   171a4:	e5843008 	str	r3, [r4, #8]
	nSize -= len;
   171a8:	e0607007 	rsb	r7, r0, r7
	break;
   171ac:	eaffffdd 	b	17128 <AMF3Prop_Decode+0xdc>
      }
    case AMF3_DATE:
      {
	int32_t res = 0;
   171b0:	e28d1010 	add	r1, sp, #16
   171b4:	e3a06000 	mov	r6, #0
   171b8:	e5216008 	str	r6, [r1, #-8]!
	int len = AMF3ReadInteger(pBuffer, &res);
   171bc:	e1a00009 	mov	r0, r9
   171c0:	ebfffc42 	bl	162d0 <AMF3ReadInteger>

	nSize -= len;
	pBuffer += len;

	if ((res & 0x1) == 0)
   171c4:	e59d2008 	ldr	r2, [sp, #8]
   171c8:	e3120001 	tst	r2, #1
    case AMF3_DATE:
      {
	int32_t res = 0;
	int len = AMF3ReadInteger(pBuffer, &res);

	nSize -= len;
   171cc:	e0607007 	rsb	r7, r0, r7
	pBuffer += len;

	if ((res & 0x1) == 0)
   171d0:	0a00001f 	beq	17254 <AMF3Prop_Decode+0x208>
	    uint32_t nIndex = (res >> 1);
	    RTMP_Log(RTMP_LOGDEBUG, "AMF3_DATE reference: %d, not supported!", nIndex);
	  }
	else
	  {
	    if (nSize < 8)
   171d4:	e3570007 	cmp	r7, #7
   171d8:	da00001a 	ble	17248 <AMF3Prop_Decode+0x1fc>
	      return -1;

	    prop->p_vu.p_number = AMF_DecodeNumber(pBuffer);
   171dc:	e0890000 	add	r0, r9, r0
   171e0:	ebfffb46 	bl	15f00 <AMF_DecodeNumber>
	    nSize -= 8;
   171e4:	e2477008 	sub	r7, r7, #8
	    prop->p_type = AMF_NUMBER;
   171e8:	e5846008 	str	r6, [r4, #8]
	else
	  {
	    if (nSize < 8)
	      return -1;

	    prop->p_vu.p_number = AMF_DecodeNumber(pBuffer);
   171ec:	e1c401f0 	strd	r0, [r4, #16]
   171f0:	eaffffcc 	b	17128 <AMF3Prop_Decode+0xdc>
    case AMF3_UNDEFINED:
    case AMF3_NULL:
      prop->p_type = AMF_NULL;
      break;
    case AMF3_FALSE:
      prop->p_type = AMF_BOOLEAN;
   171f4:	e3a01001 	mov	r1, #1
      prop->p_vu.p_number = 0.0;
   171f8:	e3a02000 	mov	r2, #0
   171fc:	e3a03000 	mov	r3, #0
    case AMF3_UNDEFINED:
    case AMF3_NULL:
      prop->p_type = AMF_NULL;
      break;
    case AMF3_FALSE:
      prop->p_type = AMF_BOOLEAN;
   17200:	e5841008 	str	r1, [r4, #8]
      prop->p_vu.p_number = 0.0;
   17204:	e1c421f0 	strd	r2, [r4, #16]
      break;
   17208:	eaffffc6 	b	17128 <AMF3Prop_Decode+0xdc>
    case AMF3_TRUE:
      prop->p_type = AMF_BOOLEAN;
      prop->p_vu.p_number = 1.0;
   1720c:	e59f3070 	ldr	r3, [pc, #112]	; 17284 <AMF3Prop_Decode+0x238>
    case AMF3_FALSE:
      prop->p_type = AMF_BOOLEAN;
      prop->p_vu.p_number = 0.0;
      break;
    case AMF3_TRUE:
      prop->p_type = AMF_BOOLEAN;
   17210:	e3a01001 	mov	r1, #1
      prop->p_vu.p_number = 1.0;
   17214:	e3a02000 	mov	r2, #0
    case AMF3_FALSE:
      prop->p_type = AMF_BOOLEAN;
      prop->p_vu.p_number = 0.0;
      break;
    case AMF3_TRUE:
      prop->p_type = AMF_BOOLEAN;
   17218:	e5841008 	str	r1, [r4, #8]
      prop->p_vu.p_number = 1.0;
   1721c:	e1c421f0 	strd	r2, [r4, #16]
      break;
   17220:	eaffffc0 	b	17128 <AMF3Prop_Decode+0xdc>
	break;
      }
    case AMF3_ARRAY:
    case AMF3_BYTE_ARRAY:
    default:
      RTMP_Log(RTMP_LOGDEBUG, "%s - AMF3 unknown/unsupported datatype 0x%02x, @%p",
   17224:	e59f205c 	ldr	r2, [pc, #92]	; 17288 <AMF3Prop_Decode+0x23c>
   17228:	e59f105c 	ldr	r1, [pc, #92]	; 1728c <AMF3Prop_Decode+0x240>
   1722c:	e08f2002 	add	r2, pc, r2
   17230:	e5d63001 	ldrb	r3, [r6, #1]
   17234:	e2822064 	add	r2, r2, #100	; 0x64
   17238:	e58d9000 	str	r9, [sp]
   1723c:	e3a00004 	mov	r0, #4
   17240:	e08f1001 	add	r1, pc, r1
   17244:	ebfff9d8 	bl	159ac <RTMP_Log>
	  __FUNCTION__, (unsigned char)(*pBuffer), pBuffer);
      return -1;
   17248:	e3e00000 	mvn	r0, #0
    }

  return nOriginalSize - nSize;
}
   1724c:	e28dd014 	add	sp, sp, #20
   17250:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
	pBuffer += len;

	if ((res & 0x1) == 0)
	  {			/* reference */
	    uint32_t nIndex = (res >> 1);
	    RTMP_Log(RTMP_LOGDEBUG, "AMF3_DATE reference: %d, not supported!", nIndex);
   17254:	e59f1034 	ldr	r1, [pc, #52]	; 17290 <AMF3Prop_Decode+0x244>
   17258:	e1a020c2 	asr	r2, r2, #1
   1725c:	e3a00004 	mov	r0, #4
   17260:	e08f1001 	add	r1, pc, r1
   17264:	ebfff9d0 	bl	159ac <RTMP_Log>
   17268:	eaffffae 	b	17128 <AMF3Prop_Decode+0xdc>
  prop->p_name.av_len = 0;
  prop->p_name.av_val = NULL;

  if (nSize == 0 || !pBuffer)
    {
      RTMP_Log(RTMP_LOGDEBUG, "empty buffer/no buffer pointer!");
   1726c:	e59f1020 	ldr	r1, [pc, #32]	; 17294 <AMF3Prop_Decode+0x248>
   17270:	e3a00004 	mov	r0, #4
   17274:	e08f1001 	add	r1, pc, r1
   17278:	ebfff9cb 	bl	159ac <RTMP_Log>
      return -1;
   1727c:	e3e00000 	mvn	r0, #0
   17280:	eaffffa9 	b	1712c <AMF3Prop_Decode+0xe0>
   17284:	3ff00000 	.word	0x3ff00000
   17288:	0000a7dc 	.word	0x0000a7dc
   1728c:	00009d98 	.word	0x00009d98
   17290:	00009d50 	.word	0x00009d50
   17294:	00009d1c 	.word	0x00009d1c

00017298 <AMFProp_Decode>:
}

int
AMFProp_Decode(AMFObjectProperty *prop, const char *pBuffer, int nSize,
	       int bDecodeName)
{
   17298:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
  int nRes;

  prop->p_name.av_len = 0;
  prop->p_name.av_val = NULL;

  if (nSize == 0 || !pBuffer)
   1729c:	e3510000 	cmp	r1, #0
   172a0:	13520000 	cmpne	r2, #0
}

int
AMFProp_Decode(AMFObjectProperty *prop, const char *pBuffer, int nSize,
	       int bDecodeName)
{
   172a4:	e1a05000 	mov	r5, r0
  int nOriginalSize = nSize;
  int nRes;

  prop->p_name.av_len = 0;
   172a8:	e3a00000 	mov	r0, #0
}

int
AMFProp_Decode(AMFObjectProperty *prop, const char *pBuffer, int nSize,
	       int bDecodeName)
{
   172ac:	e24dd00c 	sub	sp, sp, #12
  int nOriginalSize = nSize;
  int nRes;

  prop->p_name.av_len = 0;
   172b0:	e5850004 	str	r0, [r5, #4]
  prop->p_name.av_val = NULL;
   172b4:	e5850000 	str	r0, [r5]

  if (nSize == 0 || !pBuffer)
   172b8:	0a0000c2 	beq	175c8 <AMFProp_Decode+0x330>
    {
      RTMP_Log(RTMP_LOGDEBUG, "%s: Empty buffer/no buffer pointer!", __FUNCTION__);
      return -1;
    }

  if (bDecodeName && nSize < 4)
   172bc:	e2933000 	adds	r3, r3, #0
   172c0:	13a03001 	movne	r3, #1
   172c4:	e1a04002 	mov	r4, r2
   172c8:	e3520003 	cmp	r2, #3
   172cc:	c3a02000 	movgt	r2, #0
   172d0:	d2032001 	andle	r2, r3, #1
   172d4:	e3520000 	cmp	r2, #0
   172d8:	1a0000c3 	bne	175ec <AMFProp_Decode+0x354>
	  "%s: Not enough data for decoding with name, less than 4 bytes!",
	  __FUNCTION__);
      return -1;
    }

  if (bDecodeName)
   172dc:	e3530000 	cmp	r3, #0
   172e0:	e1a06001 	mov	r6, r1
   172e4:	01a07004 	moveq	r7, r4
   172e8:	1a000018 	bne	17350 <AMFProp_Decode+0xb8>
      return -1;
    }

  nSize--;

  prop->p_type = *pBuffer++;
   172ec:	e5d63000 	ldrb	r3, [r6]
   172f0:	e5853008 	str	r3, [r5, #8]
  if (nSize == 0)
    {
      return -1;
    }

  nSize--;
   172f4:	e2478001 	sub	r8, r7, #1

  prop->p_type = *pBuffer++;
   172f8:	e2869001 	add	r9, r6, #1
  switch (prop->p_type)
   172fc:	e3530011 	cmp	r3, #17
   17300:	908ff103 	addls	pc, pc, r3, lsl #2
   17304:	ea0000a5 	b	175a0 <AMFProp_Decode+0x308>
   17308:	ea000067 	b	174ac <AMFProp_Decode+0x214>
   1730c:	ea00006d 	b	174c8 <AMFProp_Decode+0x230>
   17310:	ea000074 	b	174e8 <AMFProp_Decode+0x250>
   17314:	ea000080 	b	1751c <AMFProp_Decode+0x284>
   17318:	ea000088 	b	17540 <AMFProp_Decode+0x2a8>
   1731c:	ea00008d 	b	17558 <AMFProp_Decode+0x2c0>
   17320:	ea00008c 	b	17558 <AMFProp_Decode+0x2c0>
   17324:	ea00008e 	b	17564 <AMFProp_Decode+0x2cc>
   17328:	ea000093 	b	1757c <AMFProp_Decode+0x2e4>
   1732c:	ea000016 	b	1738c <AMFProp_Decode+0xf4>
   17330:	ea000018 	b	17398 <AMFProp_Decode+0x100>
   17334:	ea000027 	b	173d8 <AMFProp_Decode+0x140>
   17338:	ea000034 	b	17410 <AMFProp_Decode+0x178>
   1733c:	ea000085 	b	17558 <AMFProp_Decode+0x2c0>
   17340:	ea000042 	b	17450 <AMFProp_Decode+0x1b8>
   17344:	ea000031 	b	17410 <AMFProp_Decode+0x178>
   17348:	ea000046 	b	17468 <AMFProp_Decode+0x1d0>
   1734c:	ea00004b 	b	17480 <AMFProp_Decode+0x1e8>
      return -1;
    }

  if (bDecodeName)
    {
      unsigned short nNameSize = AMF_DecodeInt16(pBuffer);
   17350:	e1a00001 	mov	r0, r1
   17354:	ebfffac2 	bl	15e64 <AMF_DecodeInt16>
      if (nNameSize > nSize - 2)
   17358:	e2443001 	sub	r3, r4, #1
   1735c:	e1530000 	cmp	r3, r0
      return -1;
    }

  if (bDecodeName)
    {
      unsigned short nNameSize = AMF_DecodeInt16(pBuffer);
   17360:	e1a08000 	mov	r8, r0
      if (nNameSize > nSize - 2)
   17364:	da0000a9 	ble	17610 <AMFProp_Decode+0x378>
	      __FUNCTION__, nNameSize, nSize);
	  return -1;
	}

      AMF_DecodeString(pBuffer, &prop->p_name);
      nSize -= 2 + nNameSize;
   17368:	e3e07001 	mvn	r7, #1
	      "%s: Name size out of range: namesize (%d) > len (%d) - 2",
	      __FUNCTION__, nNameSize, nSize);
	  return -1;
	}

      AMF_DecodeString(pBuffer, &prop->p_name);
   1736c:	e1a00006 	mov	r0, r6
      nSize -= 2 + nNameSize;
   17370:	e0687007 	rsb	r7, r8, r7
	      "%s: Name size out of range: namesize (%d) > len (%d) - 2",
	      __FUNCTION__, nNameSize, nSize);
	  return -1;
	}

      AMF_DecodeString(pBuffer, &prop->p_name);
   17374:	e1a01005 	mov	r1, r5
   17378:	ebfffacd 	bl	15eb4 <AMF_DecodeString>
      nSize -= 2 + nNameSize;
      pBuffer += 2 + nNameSize;
   1737c:	e2888002 	add	r8, r8, #2
    }

  if (nSize == 0)
   17380:	e0977004 	adds	r7, r7, r4
	  return -1;
	}

      AMF_DecodeString(pBuffer, &prop->p_name);
      nSize -= 2 + nNameSize;
      pBuffer += 2 + nNameSize;
   17384:	e0866008 	add	r6, r6, r8
    }

  if (nSize == 0)
   17388:	1affffd7 	bne	172ec <AMFProp_Decode+0x54>
	nSize -= nRes;
	break;
      }
    case AMF_OBJECT_END:
      {
	return -1;
   1738c:	e3e00000 	mvn	r0, #0
	  prop->p_type, pBuffer - 1);
      return -1;
    }

  return nOriginalSize - nSize;
}
   17390:	e28dd00c 	add	sp, sp, #12
   17394:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
	return -1;
	break;
      }
    case AMF_STRICT_ARRAY:
      {
	unsigned int nArrayLen = AMF_DecodeInt32(pBuffer);
   17398:	e1a00009 	mov	r0, r9
   1739c:	ebfffabb 	bl	15e90 <AMF_DecodeInt32>
	nSize -= 4;
   173a0:	e2477005 	sub	r7, r7, #5

	nRes = AMF_DecodeArray(&prop->p_vu.p_object, pBuffer + 4, nSize,
   173a4:	e3a0c000 	mov	ip, #0
   173a8:	e2861005 	add	r1, r6, #5
   173ac:	e1a02007 	mov	r2, r7
   173b0:	e58dc000 	str	ip, [sp]
	return -1;
	break;
      }
    case AMF_STRICT_ARRAY:
      {
	unsigned int nArrayLen = AMF_DecodeInt32(pBuffer);
   173b4:	e1a03000 	mov	r3, r0
	nSize -= 4;

	nRes = AMF_DecodeArray(&prop->p_vu.p_object, pBuffer + 4, nSize,
   173b8:	e2850010 	add	r0, r5, #16
   173bc:	eb0000ab 	bl	17670 <AMF_DecodeArray>
				   nArrayLen, FALSE);
	if (nRes == -1)
   173c0:	e3700001 	cmn	r0, #1
   173c4:	0afffff0 	beq	1738c <AMFProp_Decode+0xf4>
	  return -1;
	nSize -= nRes;
   173c8:	e0608007 	rsb	r8, r0, r7
      RTMP_Log(RTMP_LOGDEBUG, "%s - unknown datatype 0x%02x, @%p", __FUNCTION__,
	  prop->p_type, pBuffer - 1);
      return -1;
    }

  return nOriginalSize - nSize;
   173cc:	e0680004 	rsb	r0, r8, r4
}
   173d0:	e28dd00c 	add	sp, sp, #12
   173d4:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
	nSize -= nRes;
	break;
      }
    case AMF_DATE:
      {
	RTMP_Log(RTMP_LOGDEBUG, "AMF_DATE");
   173d8:	e59f125c 	ldr	r1, [pc, #604]	; 1763c <AMFProp_Decode+0x3a4>
   173dc:	e3a00004 	mov	r0, #4
   173e0:	e08f1001 	add	r1, pc, r1
   173e4:	ebfff970 	bl	159ac <RTMP_Log>

	if (nSize < 10)
   173e8:	e3580009 	cmp	r8, #9
   173ec:	daffffe6 	ble	1738c <AMFProp_Decode+0xf4>
	  return -1;

	prop->p_vu.p_number = AMF_DecodeNumber(pBuffer);
   173f0:	e1a00009 	mov	r0, r9
   173f4:	ebfffac1 	bl	15f00 <AMF_DecodeNumber>
	prop->p_UTCoffset = AMF_DecodeInt16(pBuffer + 8);

	nSize -= 10;
   173f8:	e247800b 	sub	r8, r7, #11
	RTMP_Log(RTMP_LOGDEBUG, "AMF_DATE");

	if (nSize < 10)
	  return -1;

	prop->p_vu.p_number = AMF_DecodeNumber(pBuffer);
   173fc:	e1c501f0 	strd	r0, [r5, #16]
	prop->p_UTCoffset = AMF_DecodeInt16(pBuffer + 8);
   17400:	e2860009 	add	r0, r6, #9
   17404:	ebfffa96 	bl	15e64 <AMF_DecodeInt16>
   17408:	e1c501b8 	strh	r0, [r5, #24]

	nSize -= 10;
	break;
   1740c:	eaffffee 	b	173cc <AMFProp_Decode+0x134>
      }
    case AMF_LONG_STRING:
    case AMF_XML_DOC:
      {
	unsigned int nStringSize = AMF_DecodeInt32(pBuffer);
   17410:	e1a00009 	mov	r0, r9
   17414:	ebfffa9d 	bl	15e90 <AMF_DecodeInt32>
	if (nSize < (long)nStringSize + 4)
   17418:	e2803003 	add	r3, r0, #3
   1741c:	e1580003 	cmp	r8, r3
	break;
      }
    case AMF_LONG_STRING:
    case AMF_XML_DOC:
      {
	unsigned int nStringSize = AMF_DecodeInt32(pBuffer);
   17420:	e1a06000 	mov	r6, r0
	if (nSize < (long)nStringSize + 4)
   17424:	daffffd8 	ble	1738c <AMFProp_Decode+0xf4>
	  return -1;
	AMF_DecodeLongString(pBuffer, &prop->p_vu.p_aval);
   17428:	e1a00009 	mov	r0, r9
   1742c:	e2851010 	add	r1, r5, #16
   17430:	ebfffaa8 	bl	15ed8 <AMF_DecodeLongString>
	nSize -= (4 + nStringSize);
	if (prop->p_type == AMF_LONG_STRING)
   17434:	e5953008 	ldr	r3, [r5, #8]
   17438:	e2488004 	sub	r8, r8, #4
   1743c:	e353000c 	cmp	r3, #12
	  prop->p_type = AMF_STRING;
   17440:	03a03002 	moveq	r3, #2
      {
	unsigned int nStringSize = AMF_DecodeInt32(pBuffer);
	if (nSize < (long)nStringSize + 4)
	  return -1;
	AMF_DecodeLongString(pBuffer, &prop->p_vu.p_aval);
	nSize -= (4 + nStringSize);
   17444:	e0668008 	rsb	r8, r6, r8
	if (prop->p_type == AMF_LONG_STRING)
	  prop->p_type = AMF_STRING;
   17448:	05853008 	streq	r3, [r5, #8]
   1744c:	eaffffde 	b	173cc <AMFProp_Decode+0x134>
	break;
      }
    case AMF_RECORDSET:
      {
	RTMP_Log(RTMP_LOGERROR, "AMF_RECORDSET reserved!");
   17450:	e59f11e8 	ldr	r1, [pc, #488]	; 17640 <AMFProp_Decode+0x3a8>
   17454:	e3a00001 	mov	r0, #1
   17458:	e08f1001 	add	r1, pc, r1
   1745c:	ebfff952 	bl	159ac <RTMP_Log>
	return -1;
   17460:	e3e00000 	mvn	r0, #0
   17464:	eaffffc9 	b	17390 <AMFProp_Decode+0xf8>
	break;
      }
    case AMF_TYPED_OBJECT:
      {
	RTMP_Log(RTMP_LOGERROR, "AMF_TYPED_OBJECT not supported!");
   17468:	e59f11d4 	ldr	r1, [pc, #468]	; 17644 <AMFProp_Decode+0x3ac>
   1746c:	e3a00001 	mov	r0, #1
   17470:	e08f1001 	add	r1, pc, r1
   17474:	ebfff94c 	bl	159ac <RTMP_Log>
	return -1;
   17478:	e3e00000 	mvn	r0, #0
   1747c:	eaffffc3 	b	17390 <AMFProp_Decode+0xf8>
	break;
      }
    case AMF_AVMPLUS:
      {
	int nRes = AMF3_Decode(&prop->p_vu.p_object, pBuffer, nSize, TRUE);
   17480:	e1a01009 	mov	r1, r9
   17484:	e2850010 	add	r0, r5, #16
   17488:	e1a02008 	mov	r2, r8
   1748c:	e3a03001 	mov	r3, #1
   17490:	ebfffe11 	bl	16cdc <AMF3_Decode>
	if (nRes == -1)
   17494:	e3700001 	cmn	r0, #1
   17498:	0affffbb 	beq	1738c <AMFProp_Decode+0xf4>
	  return -1;
	nSize -= nRes;
	prop->p_type = AMF_OBJECT;
   1749c:	e3a03003 	mov	r3, #3
    case AMF_AVMPLUS:
      {
	int nRes = AMF3_Decode(&prop->p_vu.p_object, pBuffer, nSize, TRUE);
	if (nRes == -1)
	  return -1;
	nSize -= nRes;
   174a0:	e0608008 	rsb	r8, r0, r8
	prop->p_type = AMF_OBJECT;
   174a4:	e5853008 	str	r3, [r5, #8]
	break;
   174a8:	eaffffc7 	b	173cc <AMFProp_Decode+0x134>

  prop->p_type = *pBuffer++;
  switch (prop->p_type)
    {
    case AMF_NUMBER:
      if (nSize < 8)
   174ac:	e3580007 	cmp	r8, #7
   174b0:	daffffb5 	ble	1738c <AMFProp_Decode+0xf4>
	return -1;
      prop->p_vu.p_number = AMF_DecodeNumber(pBuffer);
   174b4:	e1a00009 	mov	r0, r9
   174b8:	ebfffa90 	bl	15f00 <AMF_DecodeNumber>
      nSize -= 8;
   174bc:	e2478009 	sub	r8, r7, #9
  switch (prop->p_type)
    {
    case AMF_NUMBER:
      if (nSize < 8)
	return -1;
      prop->p_vu.p_number = AMF_DecodeNumber(pBuffer);
   174c0:	e1c501f0 	strd	r0, [r5, #16]
      nSize -= 8;
      break;
   174c4:	eaffffc0 	b	173cc <AMFProp_Decode+0x134>
    case AMF_BOOLEAN:
      if (nSize < 1)
   174c8:	e3580000 	cmp	r8, #0
   174cc:	daffffae 	ble	1738c <AMFProp_Decode+0xf4>
	return -1;
      prop->p_vu.p_number = (double)AMF_DecodeBoolean(pBuffer);
   174d0:	e1a00009 	mov	r0, r9
   174d4:	ebfffa9e 	bl	15f54 <AMF_DecodeBoolean>
   174d8:	eb00123b 	bl	1bdcc <__aeabi_i2d>
      nSize--;
   174dc:	e2478002 	sub	r8, r7, #2
      nSize -= 8;
      break;
    case AMF_BOOLEAN:
      if (nSize < 1)
	return -1;
      prop->p_vu.p_number = (double)AMF_DecodeBoolean(pBuffer);
   174e0:	e1c501f0 	strd	r0, [r5, #16]
      nSize--;
      break;
   174e4:	eaffffb8 	b	173cc <AMFProp_Decode+0x134>
    case AMF_STRING:
      {
	unsigned short nStringSize = AMF_DecodeInt16(pBuffer);
   174e8:	e1a00009 	mov	r0, r9
   174ec:	ebfffa5c 	bl	15e64 <AMF_DecodeInt16>

	if (nSize < (long)nStringSize + 2)
   174f0:	e2803001 	add	r3, r0, #1
   174f4:	e1580003 	cmp	r8, r3
      prop->p_vu.p_number = (double)AMF_DecodeBoolean(pBuffer);
      nSize--;
      break;
    case AMF_STRING:
      {
	unsigned short nStringSize = AMF_DecodeInt16(pBuffer);
   174f8:	e1a06000 	mov	r6, r0

	if (nSize < (long)nStringSize + 2)
   174fc:	daffffa2 	ble	1738c <AMFProp_Decode+0xf4>
	  return -1;
	AMF_DecodeString(pBuffer, &prop->p_vu.p_aval);
   17500:	e1a00009 	mov	r0, r9
   17504:	e2851010 	add	r1, r5, #16
   17508:	ebfffa69 	bl	15eb4 <AMF_DecodeString>
	nSize -= (2 + nStringSize);
   1750c:	e3e03001 	mvn	r3, #1
   17510:	e0663003 	rsb	r3, r6, r3
   17514:	e0888003 	add	r8, r8, r3
	break;
   17518:	eaffffab 	b	173cc <AMFProp_Decode+0x134>
      }
    case AMF_OBJECT:
      {
	int nRes = AMF_Decode(&prop->p_vu.p_object, pBuffer, nSize, TRUE);
   1751c:	e2850010 	add	r0, r5, #16
   17520:	e1a01009 	mov	r1, r9
   17524:	e1a02008 	mov	r2, r8
   17528:	e3a03001 	mov	r3, #1
   1752c:	eb000076 	bl	1770c <AMF_Decode>
	if (nRes == -1)
   17530:	e3700001 	cmn	r0, #1
   17534:	0affff94 	beq	1738c <AMFProp_Decode+0xf4>
	  return -1;
	nSize -= nRes;
   17538:	e0608008 	rsb	r8, r0, r8
	break;
   1753c:	eaffffa2 	b	173cc <AMFProp_Decode+0x134>
      }
    case AMF_MOVIECLIP:
      {
	RTMP_Log(RTMP_LOGERROR, "AMF_MOVIECLIP reserved!");
   17540:	e59f1100 	ldr	r1, [pc, #256]	; 17648 <AMFProp_Decode+0x3b0>
   17544:	e3a00001 	mov	r0, #1
   17548:	e08f1001 	add	r1, pc, r1
   1754c:	ebfff916 	bl	159ac <RTMP_Log>
	return -1;
   17550:	e3e00000 	mvn	r0, #0
   17554:	eaffff8d 	b	17390 <AMFProp_Decode+0xf8>
	break;
      }
    case AMF_NULL:
    case AMF_UNDEFINED:
    case AMF_UNSUPPORTED:
      prop->p_type = AMF_NULL;
   17558:	e3a03005 	mov	r3, #5
   1755c:	e5853008 	str	r3, [r5, #8]
      break;
   17560:	eaffff99 	b	173cc <AMFProp_Decode+0x134>
    case AMF_REFERENCE:
      {
	RTMP_Log(RTMP_LOGERROR, "AMF_REFERENCE not supported!");
   17564:	e59f10e0 	ldr	r1, [pc, #224]	; 1764c <AMFProp_Decode+0x3b4>
   17568:	e3a00001 	mov	r0, #1
   1756c:	e08f1001 	add	r1, pc, r1
   17570:	ebfff90d 	bl	159ac <RTMP_Log>
	return -1;
   17574:	e3e00000 	mvn	r0, #0
   17578:	eaffff84 	b	17390 <AMFProp_Decode+0xf8>
	break;
      }
    case AMF_ECMA_ARRAY:
      {
	nSize -= 4;
   1757c:	e2477005 	sub	r7, r7, #5

	/* next comes the rest, mixed array has a final 0x000009 mark and names, so its an object */
	nRes = AMF_Decode(&prop->p_vu.p_object, pBuffer + 4, nSize, TRUE);
   17580:	e2850010 	add	r0, r5, #16
   17584:	e2861005 	add	r1, r6, #5
   17588:	e1a02007 	mov	r2, r7
   1758c:	e3a03001 	mov	r3, #1
   17590:	eb00005d 	bl	1770c <AMF_Decode>
	if (nRes == -1)
   17594:	e3700001 	cmn	r0, #1
   17598:	1affff8a 	bne	173c8 <AMFProp_Decode+0x130>
   1759c:	eaffff7a 	b	1738c <AMFProp_Decode+0xf4>
	nSize -= nRes;
	prop->p_type = AMF_OBJECT;
	break;
      }
    default:
      RTMP_Log(RTMP_LOGDEBUG, "%s - unknown datatype 0x%02x, @%p", __FUNCTION__,
   175a0:	e59f20a8 	ldr	r2, [pc, #168]	; 17650 <AMFProp_Decode+0x3b8>
   175a4:	e59f10a8 	ldr	r1, [pc, #168]	; 17654 <AMFProp_Decode+0x3bc>
   175a8:	e08f2002 	add	r2, pc, r2
   175ac:	e3a00004 	mov	r0, #4
   175b0:	e58d6000 	str	r6, [sp]
   175b4:	e2822074 	add	r2, r2, #116	; 0x74
   175b8:	e08f1001 	add	r1, pc, r1
   175bc:	ebfff8fa 	bl	159ac <RTMP_Log>
	  prop->p_type, pBuffer - 1);
      return -1;
   175c0:	e3e00000 	mvn	r0, #0
   175c4:	eaffff71 	b	17390 <AMFProp_Decode+0xf8>
  prop->p_name.av_len = 0;
  prop->p_name.av_val = NULL;

  if (nSize == 0 || !pBuffer)
    {
      RTMP_Log(RTMP_LOGDEBUG, "%s: Empty buffer/no buffer pointer!", __FUNCTION__);
   175c8:	e59f2088 	ldr	r2, [pc, #136]	; 17658 <AMFProp_Decode+0x3c0>
   175cc:	e59f1088 	ldr	r1, [pc, #136]	; 1765c <AMFProp_Decode+0x3c4>
   175d0:	e08f2002 	add	r2, pc, r2
   175d4:	e3a00004 	mov	r0, #4
   175d8:	e2822074 	add	r2, r2, #116	; 0x74
   175dc:	e08f1001 	add	r1, pc, r1
   175e0:	ebfff8f1 	bl	159ac <RTMP_Log>
      return -1;
   175e4:	e3e00000 	mvn	r0, #0
   175e8:	eaffff68 	b	17390 <AMFProp_Decode+0xf8>
    }

  if (bDecodeName && nSize < 4)
    {				/* at least name (length + at least 1 byte) and 1 byte of data */
      RTMP_Log(RTMP_LOGDEBUG,
   175ec:	e59f206c 	ldr	r2, [pc, #108]	; 17660 <AMFProp_Decode+0x3c8>
   175f0:	e59f106c 	ldr	r1, [pc, #108]	; 17664 <AMFProp_Decode+0x3cc>
   175f4:	e08f2002 	add	r2, pc, r2
   175f8:	e3a00004 	mov	r0, #4
   175fc:	e2822074 	add	r2, r2, #116	; 0x74
   17600:	e08f1001 	add	r1, pc, r1
   17604:	ebfff8e8 	bl	159ac <RTMP_Log>
	  "%s: Not enough data for decoding with name, less than 4 bytes!",
	  __FUNCTION__);
      return -1;
   17608:	e3e00000 	mvn	r0, #0
   1760c:	eaffff5f 	b	17390 <AMFProp_Decode+0xf8>
  if (bDecodeName)
    {
      unsigned short nNameSize = AMF_DecodeInt16(pBuffer);
      if (nNameSize > nSize - 2)
	{
	  RTMP_Log(RTMP_LOGDEBUG,
   17610:	e59f2050 	ldr	r2, [pc, #80]	; 17668 <AMFProp_Decode+0x3d0>
   17614:	e59f1050 	ldr	r1, [pc, #80]	; 1766c <AMFProp_Decode+0x3d4>
   17618:	e08f2002 	add	r2, pc, r2
   1761c:	e1a03000 	mov	r3, r0
   17620:	e58d4000 	str	r4, [sp]
   17624:	e3a00004 	mov	r0, #4
   17628:	e2822074 	add	r2, r2, #116	; 0x74
   1762c:	e08f1001 	add	r1, pc, r1
   17630:	ebfff8dd 	bl	159ac <RTMP_Log>
	      "%s: Name size out of range: namesize (%d) > len (%d) - 2",
	      __FUNCTION__, nNameSize, nSize);
	  return -1;
   17634:	e3e00000 	mvn	r0, #0
   17638:	eaffff54 	b	17390 <AMFProp_Decode+0xf8>
   1763c:	00009d04 	.word	0x00009d04
   17640:	00009c98 	.word	0x00009c98
   17644:	00009c98 	.word	0x00009c98
   17648:	00009b64 	.word	0x00009b64
   1764c:	00009b58 	.word	0x00009b58
   17650:	0000a460 	.word	0x0000a460
   17654:	00009b70 	.word	0x00009b70
   17658:	0000a438 	.word	0x0000a438
   1765c:	00009a30 	.word	0x00009a30
   17660:	0000a414 	.word	0x0000a414
   17664:	00009a30 	.word	0x00009a30
   17668:	0000a3f0 	.word	0x0000a3f0
   1766c:	00009a44 	.word	0x00009a44

00017670 <AMF_DecodeArray>:
}

int
AMF_DecodeArray(AMFObject *obj, const char *pBuffer, int nSize,
		int nArrayLen, int bDecodeName)
{
   17670:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int nOriginalSize = nSize;
  int bError = FALSE;

  obj->o_num = 0;
   17674:	e3a0a000 	mov	sl, #0
}

int
AMF_DecodeArray(AMFObject *obj, const char *pBuffer, int nSize,
		int nArrayLen, int bDecodeName)
{
   17678:	e24dd024 	sub	sp, sp, #36	; 0x24
  int nOriginalSize = nSize;
  int bError = FALSE;

  obj->o_num = 0;
  obj->o_props = NULL;
  while (nArrayLen > 0)
   1767c:	e2534000 	subs	r4, r3, #0
}

int
AMF_DecodeArray(AMFObject *obj, const char *pBuffer, int nSize,
		int nArrayLen, int bDecodeName)
{
   17680:	e1a08000 	mov	r8, r0
  int nOriginalSize = nSize;
  int bError = FALSE;

  obj->o_num = 0;
   17684:	e580a000 	str	sl, [r0]
  obj->o_props = NULL;
   17688:	e580a004 	str	sl, [r0, #4]
}

int
AMF_DecodeArray(AMFObject *obj, const char *pBuffer, int nSize,
		int nArrayLen, int bDecodeName)
{
   1768c:	e59d9048 	ldr	r9, [sp, #72]	; 0x48
  int nOriginalSize = nSize;
  int bError = FALSE;

  obj->o_num = 0;
  obj->o_props = NULL;
  while (nArrayLen > 0)
   17690:	da000019 	ble	176fc <AMF_DecodeArray+0x8c>
   17694:	e1a06001 	mov	r6, r1
   17698:	e1a0b002 	mov	fp, r2
   1769c:	e1a05002 	mov	r5, r2
   176a0:	e1a0700d 	mov	r7, sp
    {
      AMFObjectProperty prop;
      int nRes;
      nArrayLen--;

      nRes = AMFProp_Decode(&prop, pBuffer, nSize, bDecodeName);
   176a4:	e1a01006 	mov	r1, r6
   176a8:	e1a03009 	mov	r3, r9
   176ac:	e1a00007 	mov	r0, r7
   176b0:	e1a02005 	mov	r2, r5
   176b4:	ebfffef7 	bl	17298 <AMFProp_Decode>
  obj->o_props = NULL;
  while (nArrayLen > 0)
    {
      AMFObjectProperty prop;
      int nRes;
      nArrayLen--;
   176b8:	e2444001 	sub	r4, r4, #1
	bError = TRUE;
      else
	{
	  nSize -= nRes;
	  pBuffer += nRes;
	  AMF_AddProp(obj, &prop);
   176bc:	e1a01007 	mov	r1, r7
      AMFObjectProperty prop;
      int nRes;
      nArrayLen--;

      nRes = AMFProp_Decode(&prop, pBuffer, nSize, bDecodeName);
      if (nRes == -1)
   176c0:	e3700001 	cmn	r0, #1
    {
      AMFObjectProperty prop;
      int nRes;
      nArrayLen--;

      nRes = AMFProp_Decode(&prop, pBuffer, nSize, bDecodeName);
   176c4:	e1a03000 	mov	r3, r0
      if (nRes == -1)
	bError = TRUE;
   176c8:	03a0a001 	moveq	sl, #1
      else
	{
	  nSize -= nRes;
	  pBuffer += nRes;
	  AMF_AddProp(obj, &prop);
   176cc:	e1a00008 	mov	r0, r8
      AMFObjectProperty prop;
      int nRes;
      nArrayLen--;

      nRes = AMFProp_Decode(&prop, pBuffer, nSize, bDecodeName);
      if (nRes == -1)
   176d0:	0a000002 	beq	176e0 <AMF_DecodeArray+0x70>
	bError = TRUE;
      else
	{
	  nSize -= nRes;
   176d4:	e0635005 	rsb	r5, r3, r5
	  pBuffer += nRes;
   176d8:	e0866003 	add	r6, r6, r3
	  AMF_AddProp(obj, &prop);
   176dc:	ebfffc33 	bl	167b0 <AMF_AddProp>
  int nOriginalSize = nSize;
  int bError = FALSE;

  obj->o_num = 0;
  obj->o_props = NULL;
  while (nArrayLen > 0)
   176e0:	e3540000 	cmp	r4, #0
   176e4:	1affffee 	bne	176a4 <AMF_DecodeArray+0x34>
	  nSize -= nRes;
	  pBuffer += nRes;
	  AMF_AddProp(obj, &prop);
	}
    }
  if (bError)
   176e8:	e35a0000 	cmp	sl, #0
   176ec:	1a000004 	bne	17704 <AMF_DecodeArray+0x94>
   176f0:	e065000b 	rsb	r0, r5, fp
    return -1;

  return nOriginalSize - nSize;
}
   176f4:	e28dd024 	add	sp, sp, #36	; 0x24
   176f8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  int nOriginalSize = nSize;
  int bError = FALSE;

  obj->o_num = 0;
  obj->o_props = NULL;
  while (nArrayLen > 0)
   176fc:	e1a0000a 	mov	r0, sl
	}
    }
  if (bError)
    return -1;

  return nOriginalSize - nSize;
   17700:	eafffffb 	b	176f4 <AMF_DecodeArray+0x84>
	  pBuffer += nRes;
	  AMF_AddProp(obj, &prop);
	}
    }
  if (bError)
    return -1;
   17704:	e3e00000 	mvn	r0, #0
   17708:	eafffff9 	b	176f4 <AMF_DecodeArray+0x84>

0001770c <AMF_Decode>:
  return nOriginalSize - nSize;
}

int
AMF_Decode(AMFObject *obj, const char *pBuffer, int nSize, int bDecodeName)
{
   1770c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int nOriginalSize = nSize;
  int bError = FALSE;		/* if there is an error while decoding - try to at least find the end mark AMF_OBJECT_END */

  obj->o_num = 0;
   17710:	e3a06000 	mov	r6, #0
  obj->o_props = NULL;
  while (nSize > 0)
   17714:	e2529000 	subs	r9, r2, #0
  return nOriginalSize - nSize;
}

int
AMF_Decode(AMFObject *obj, const char *pBuffer, int nSize, int bDecodeName)
{
   17718:	e24dd024 	sub	sp, sp, #36	; 0x24
   1771c:	e1a08000 	mov	r8, r0
  int nOriginalSize = nSize;
  int bError = FALSE;		/* if there is an error while decoding - try to at least find the end mark AMF_OBJECT_END */

  obj->o_num = 0;
   17720:	e5806000 	str	r6, [r0]
  obj->o_props = NULL;
   17724:	e5806004 	str	r6, [r0, #4]
  while (nSize > 0)
   17728:	da00002f 	ble	177ec <AMF_Decode+0xe0>
	  break;
	}

      if (bError)
	{
	  RTMP_Log(RTMP_LOGERROR,
   1772c:	e59fa0c8 	ldr	sl, [pc, #200]	; 177fc <AMF_Decode+0xf0>
   17730:	e1a05001 	mov	r5, r1
   17734:	e1a07003 	mov	r7, r3
   17738:	e08fa00a 	add	sl, pc, sl
  int nOriginalSize = nSize;
  int bError = FALSE;		/* if there is an error while decoding - try to at least find the end mark AMF_OBJECT_END */

  obj->o_num = 0;
  obj->o_props = NULL;
  while (nSize > 0)
   1773c:	e1a04009 	mov	r4, r9
	  nSize--;
	  pBuffer++;
	  continue;
	}

      nRes = AMFProp_Decode(&prop, pBuffer, nSize, bDecodeName);
   17740:	e1a0b00d 	mov	fp, sp
   17744:	ea000007 	b	17768 <AMF_Decode+0x5c>
	{
	  RTMP_Log(RTMP_LOGERROR,
	      "DECODING ERROR, IGNORING BYTES UNTIL NEXT KNOWN PATTERN!");
	  nSize--;
	  pBuffer++;
	  continue;
   17748:	e3a06001 	mov	r6, #1
	  break;
	}

      if (bError)
	{
	  RTMP_Log(RTMP_LOGERROR,
   1774c:	e1a00006 	mov	r0, r6
   17750:	e1a0100a 	mov	r1, sl
	      "DECODING ERROR, IGNORING BYTES UNTIL NEXT KNOWN PATTERN!");
	  nSize--;
   17754:	e2444001 	sub	r4, r4, #1
	  pBuffer++;
   17758:	e2855001 	add	r5, r5, #1
	  break;
	}

      if (bError)
	{
	  RTMP_Log(RTMP_LOGERROR,
   1775c:	ebfff892 	bl	159ac <RTMP_Log>
  int nOriginalSize = nSize;
  int bError = FALSE;		/* if there is an error while decoding - try to at least find the end mark AMF_OBJECT_END */

  obj->o_num = 0;
  obj->o_props = NULL;
  while (nSize > 0)
   17760:	e3540000 	cmp	r4, #0
   17764:	da000013 	ble	177b8 <AMF_Decode+0xac>
    {
      AMFObjectProperty prop;
      int nRes;

      if (nSize >=3 && AMF_DecodeInt24(pBuffer) == AMF_OBJECT_END)
   17768:	e3540002 	cmp	r4, #2
   1776c:	ca000016 	bgt	177cc <AMF_Decode+0xc0>
	  nSize -= 3;
	  bError = FALSE;
	  break;
	}

      if (bError)
   17770:	e3560000 	cmp	r6, #0
	  nSize--;
	  pBuffer++;
	  continue;
	}

      nRes = AMFProp_Decode(&prop, pBuffer, nSize, bDecodeName);
   17774:	e1a02004 	mov	r2, r4
   17778:	e1a01005 	mov	r1, r5
   1777c:	e1a03007 	mov	r3, r7
   17780:	e1a0000b 	mov	r0, fp
	  nSize -= 3;
	  bError = FALSE;
	  break;
	}

      if (bError)
   17784:	1affffef 	bne	17748 <AMF_Decode+0x3c>
	  nSize--;
	  pBuffer++;
	  continue;
	}

      nRes = AMFProp_Decode(&prop, pBuffer, nSize, bDecodeName);
   17788:	ebfffec2 	bl	17298 <AMFProp_Decode>
	bError = TRUE;
      else
	{
	  nSize -= nRes;
	  pBuffer += nRes;
	  AMF_AddProp(obj, &prop);
   1778c:	e1a0100b 	mov	r1, fp
	  pBuffer++;
	  continue;
	}

      nRes = AMFProp_Decode(&prop, pBuffer, nSize, bDecodeName);
      if (nRes == -1)
   17790:	e3700001 	cmn	r0, #1
	  nSize--;
	  pBuffer++;
	  continue;
	}

      nRes = AMFProp_Decode(&prop, pBuffer, nSize, bDecodeName);
   17794:	e1a03000 	mov	r3, r0
      if (nRes == -1)
	bError = TRUE;
   17798:	03a06001 	moveq	r6, #1
      else
	{
	  nSize -= nRes;
	  pBuffer += nRes;
	  AMF_AddProp(obj, &prop);
   1779c:	e1a00008 	mov	r0, r8
	  pBuffer++;
	  continue;
	}

      nRes = AMFProp_Decode(&prop, pBuffer, nSize, bDecodeName);
      if (nRes == -1)
   177a0:	0affffee 	beq	17760 <AMF_Decode+0x54>
	bError = TRUE;
      else
	{
	  nSize -= nRes;
   177a4:	e0634004 	rsb	r4, r3, r4
	  pBuffer += nRes;
   177a8:	e0855003 	add	r5, r5, r3
	  AMF_AddProp(obj, &prop);
   177ac:	ebfffbff 	bl	167b0 <AMF_AddProp>
  int nOriginalSize = nSize;
  int bError = FALSE;		/* if there is an error while decoding - try to at least find the end mark AMF_OBJECT_END */

  obj->o_num = 0;
  obj->o_props = NULL;
  while (nSize > 0)
   177b0:	e3540000 	cmp	r4, #0
   177b4:	caffffeb 	bgt	17768 <AMF_Decode+0x5c>
	  pBuffer += nRes;
	  AMF_AddProp(obj, &prop);
	}
    }

  if (bError)
   177b8:	e3560000 	cmp	r6, #0
   177bc:	1a00000c 	bne	177f4 <AMF_Decode+0xe8>
   177c0:	e0640009 	rsb	r0, r4, r9
    return -1;

  return nOriginalSize - nSize;
}
   177c4:	e28dd024 	add	sp, sp, #36	; 0x24
   177c8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  while (nSize > 0)
    {
      AMFObjectProperty prop;
      int nRes;

      if (nSize >=3 && AMF_DecodeInt24(pBuffer) == AMF_OBJECT_END)
   177cc:	e1a00005 	mov	r0, r5
   177d0:	ebfff9a7 	bl	15e74 <AMF_DecodeInt24>
   177d4:	e3500009 	cmp	r0, #9
   177d8:	1affffe4 	bne	17770 <AMF_Decode+0x64>
	{
	  nSize -= 3;
   177dc:	e2444003 	sub	r4, r4, #3
   177e0:	e0640009 	rsb	r0, r4, r9

  if (bError)
    return -1;

  return nOriginalSize - nSize;
}
   177e4:	e28dd024 	add	sp, sp, #36	; 0x24
   177e8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  int nOriginalSize = nSize;
  int bError = FALSE;		/* if there is an error while decoding - try to at least find the end mark AMF_OBJECT_END */

  obj->o_num = 0;
  obj->o_props = NULL;
  while (nSize > 0)
   177ec:	e1a00006 	mov	r0, r6
    }

  if (bError)
    return -1;

  return nOriginalSize - nSize;
   177f0:	eafffff3 	b	177c4 <AMF_Decode+0xb8>
	  AMF_AddProp(obj, &prop);
	}
    }

  if (bError)
    return -1;
   177f4:	e3e00000 	mvn	r0, #0
   177f8:	eafffff1 	b	177c4 <AMF_Decode+0xb8>
   177fc:	00009a14 	.word	0x00009a14

00017800 <swfcrunch.part.0>:
  int zlib;
  int size;
};

static size_t
swfcrunch(void *ptr, size_t size, size_t nmemb, void *stream)
   17800:	e92d40f0 	push	{r4, r5, r6, r7, lr}
   17804:	e1a06000 	mov	r6, r0
   17808:	e24dd901 	sub	sp, sp, #16384	; 0x4000
   1780c:	e24dd004 	sub	sp, sp, #4
   17810:	e1a04000 	mov	r4, r0
   17814:	e4960004 	ldr	r0, [r6], #4
   17818:	e1a0500d 	mov	r5, sp
      unsigned char out[CHUNK];
      i->zs->next_in = (unsigned char *)p;
      i->zs->avail_in = len;
      do
	{
	  i->zs->avail_out = CHUNK;
   1781c:	e3a07901 	mov	r7, #16384	; 0x4000
	  i->zs->next_out = out;
	  inflate(i->zs, Z_NO_FLUSH);
   17820:	e3a01000 	mov	r1, #0
      unsigned char out[CHUNK];
      i->zs->next_in = (unsigned char *)p;
      i->zs->avail_in = len;
      do
	{
	  i->zs->avail_out = CHUNK;
   17824:	e5807010 	str	r7, [r0, #16]
	  i->zs->next_out = out;
   17828:	e580500c 	str	r5, [r0, #12]
	  inflate(i->zs, Z_NO_FLUSH);
   1782c:	ebffb744 	bl	5544 <inflate@plt>
	  len = CHUNK - i->zs->avail_out;
   17830:	e5942000 	ldr	r2, [r4]
	  i->size += len;
   17834:	e59430f8 	ldr	r3, [r4, #248]	; 0xf8
      do
	{
	  i->zs->avail_out = CHUNK;
	  i->zs->next_out = out;
	  inflate(i->zs, Z_NO_FLUSH);
	  len = CHUNK - i->zs->avail_out;
   17838:	e5922010 	ldr	r2, [r2, #16]
	  i->size += len;
	  HMAC_crunch(i->ctx, out, len);
   1783c:	e1a00006 	mov	r0, r6
      do
	{
	  i->zs->avail_out = CHUNK;
	  i->zs->next_out = out;
	  inflate(i->zs, Z_NO_FLUSH);
	  len = CHUNK - i->zs->avail_out;
   17840:	e2622901 	rsb	r2, r2, #16384	; 0x4000
	  i->size += len;
   17844:	e0833002 	add	r3, r3, r2
   17848:	e58430f8 	str	r3, [r4, #248]	; 0xf8
	  HMAC_crunch(i->ctx, out, len);
   1784c:	e1a01005 	mov	r1, r5
   17850:	ebffb615 	bl	50ac <sha2_hmac_update@plt>
	}
      while (i->zs->avail_out == 0);
   17854:	e5940000 	ldr	r0, [r4]
   17858:	e5903010 	ldr	r3, [r0, #16]
   1785c:	e3530000 	cmp	r3, #0
   17860:	0affffee 	beq	17820 <swfcrunch.part.0+0x20>
    {
      i->size += len;
      HMAC_crunch(i->ctx, (unsigned char *)p, len);
    }
  return size * nmemb;
}
   17864:	e28dd901 	add	sp, sp, #16384	; 0x4000
   17868:	e28dd004 	add	sp, sp, #4
   1786c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

00017870 <swfcrunch>:
  int size;
};

static size_t
swfcrunch(void *ptr, size_t size, size_t nmemb, void *stream)
{
   17870:	e92d4070 	push	{r4, r5, r6, lr}
   17874:	e1a04003 	mov	r4, r3
  struct info *i = stream;
  char *p = ptr;
  size_t len = size * nmemb;
   17878:	e0060192 	mul	r6, r2, r1

  if (i->first)
   1787c:	e59330f0 	ldr	r3, [r3, #240]	; 0xf0
  int size;
};

static size_t
swfcrunch(void *ptr, size_t size, size_t nmemb, void *stream)
{
   17880:	e1a05000 	mov	r5, r0
  struct info *i = stream;
  char *p = ptr;
  size_t len = size * nmemb;

  if (i->first)
   17884:	e3530000 	cmp	r3, #0
static size_t
swfcrunch(void *ptr, size_t size, size_t nmemb, void *stream)
{
  struct info *i = stream;
  char *p = ptr;
  size_t len = size * nmemb;
   17888:	01a02006 	moveq	r2, r6

  if (i->first)
   1788c:	0a000012 	beq	178dc <swfcrunch+0x6c>
    {
      i->first = 0;
      /* compressed? */
      if (!strncmp(p, "CWS", 3))
   17890:	e59f108c 	ldr	r1, [pc, #140]	; 17924 <swfcrunch+0xb4>
  char *p = ptr;
  size_t len = size * nmemb;

  if (i->first)
    {
      i->first = 0;
   17894:	e3a03000 	mov	r3, #0
   17898:	e58430f0 	str	r3, [r4, #240]	; 0xf0
      /* compressed? */
      if (!strncmp(p, "CWS", 3))
   1789c:	e3a02003 	mov	r2, #3
   178a0:	e08f1001 	add	r1, pc, r1
   178a4:	ebffb6c3 	bl	53b8 <strncmp@plt>
	{
	  *p = 'F';
	  i->zlib = 1;
	}
      HMAC_crunch(i->ctx, (unsigned char *)p, 8);
   178a8:	e1a01005 	mov	r1, r5

  if (i->first)
    {
      i->first = 0;
      /* compressed? */
      if (!strncmp(p, "CWS", 3))
   178ac:	e3500000 	cmp	r0, #0
	{
	  *p = 'F';
   178b0:	03a02046 	moveq	r2, #70	; 0x46
	  i->zlib = 1;
   178b4:	03a03001 	moveq	r3, #1
    {
      i->first = 0;
      /* compressed? */
      if (!strncmp(p, "CWS", 3))
	{
	  *p = 'F';
   178b8:	05c52000 	strbeq	r2, [r5]
	  i->zlib = 1;
	}
      HMAC_crunch(i->ctx, (unsigned char *)p, 8);
   178bc:	e2840004 	add	r0, r4, #4
      i->first = 0;
      /* compressed? */
      if (!strncmp(p, "CWS", 3))
	{
	  *p = 'F';
	  i->zlib = 1;
   178c0:	058430f4 	streq	r3, [r4, #244]	; 0xf4
	}
      HMAC_crunch(i->ctx, (unsigned char *)p, 8);
   178c4:	e3a02008 	mov	r2, #8
   178c8:	ebffb5f7 	bl	50ac <sha2_hmac_update@plt>
      p += 8;
      len -= 8;
      i->size = 8;
   178cc:	e3a03008 	mov	r3, #8
	{
	  *p = 'F';
	  i->zlib = 1;
	}
      HMAC_crunch(i->ctx, (unsigned char *)p, 8);
      p += 8;
   178d0:	e0855003 	add	r5, r5, r3
      len -= 8;
   178d4:	e2462008 	sub	r2, r6, #8
      i->size = 8;
   178d8:	e58430f8 	str	r3, [r4, #248]	; 0xf8
    }

  if (i->zlib)
   178dc:	e59430f4 	ldr	r3, [r4, #244]	; 0xf4
   178e0:	e3530000 	cmp	r3, #0
   178e4:	0a000006 	beq	17904 <swfcrunch+0x94>
    {
      unsigned char out[CHUNK];
      i->zs->next_in = (unsigned char *)p;
   178e8:	e5943000 	ldr	r3, [r4]
   178ec:	e1a00004 	mov	r0, r4
   178f0:	e5835000 	str	r5, [r3]
      i->zs->avail_in = len;
   178f4:	e5832004 	str	r2, [r3, #4]
   178f8:	ebffffc0 	bl	17800 <swfcrunch.part.0>
    {
      i->size += len;
      HMAC_crunch(i->ctx, (unsigned char *)p, len);
    }
  return size * nmemb;
}
   178fc:	e1a00006 	mov	r0, r6
   17900:	e8bd8070 	pop	{r4, r5, r6, pc}
	}
      while (i->zs->avail_out == 0);
    }
  else
    {
      i->size += len;
   17904:	e59430f8 	ldr	r3, [r4, #248]	; 0xf8
      HMAC_crunch(i->ctx, (unsigned char *)p, len);
   17908:	e2840004 	add	r0, r4, #4
	}
      while (i->zs->avail_out == 0);
    }
  else
    {
      i->size += len;
   1790c:	e0833002 	add	r3, r3, r2
      HMAC_crunch(i->ctx, (unsigned char *)p, len);
   17910:	e1a01005 	mov	r1, r5
	}
      while (i->zs->avail_out == 0);
    }
  else
    {
      i->size += len;
   17914:	e58430f8 	str	r3, [r4, #248]	; 0xf8
      HMAC_crunch(i->ctx, (unsigned char *)p, len);
   17918:	ebffb5e3 	bl	50ac <sha2_hmac_update@plt>
    }
  return size * nmemb;
}
   1791c:	e1a00006 	mov	r0, r6
   17920:	e8bd8070 	pop	{r4, r5, r6, pc}
   17924:	000098fc 	.word	0x000098fc

00017928 <HTTP_get>:

#define	AGENT	"Mozilla/5.0"

HTTPResult
HTTP_get(struct HTTP_ctx *http, const char *url, HTTP_read_callback *cb)
{
   17928:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1792c:	e24ddc41 	sub	sp, sp, #16640	; 0x4100
   17930:	e24dd07c 	sub	sp, sp, #124	; 0x7c
	int hlen, flen = 0;
	int rc, i;
	int len_known;
	HTTPResult ret = HTTPRES_OK;
	struct sockaddr_in sa;
	RTMPSockBuf sb = {0};
   17934:	e28d5f5e 	add	r5, sp, #376	; 0x178

#define	AGENT	"Mozilla/5.0"

HTTPResult
HTTP_get(struct HTTP_ctx *http, const char *url, HTTP_read_callback *cb)
{
   17938:	e1a07000 	mov	r7, r0
   1793c:	e1a04001 	mov	r4, r1
   17940:	e1a09002 	mov	r9, r2
	int hlen, flen = 0;
	int rc, i;
	int len_known;
	HTTPResult ret = HTTPRES_OK;
	struct sockaddr_in sa;
	RTMPSockBuf sb = {0};
   17944:	e3a01000 	mov	r1, #0
   17948:	e59f2610 	ldr	r2, [pc, #1552]	; 17f60 <HTTP_get+0x638>
   1794c:	e2450014 	sub	r0, r5, #20
   17950:	ebffb5de 	bl	50d0 <memset@plt>
	
	http->status = -1;
	
	/* we only handle http here */
	if (strncasecmp(url, "http", 4))
   17954:	e59f1608 	ldr	r1, [pc, #1544]	; 17f64 <HTTP_get+0x63c>
	int len_known;
	HTTPResult ret = HTTPRES_OK;
	struct sockaddr_in sa;
	RTMPSockBuf sb = {0};
	
	http->status = -1;
   17958:	e3e03000 	mvn	r3, #0
   1795c:	e5873008 	str	r3, [r7, #8]
	
	/* we only handle http here */
	if (strncasecmp(url, "http", 4))
   17960:	e1a00004 	mov	r0, r4
   17964:	e08f1001 	add	r1, pc, r1
   17968:	e3a02004 	mov	r2, #4
   1796c:	ebffb694 	bl	53c4 <strncasecmp@plt>

#define	AGENT	"Mozilla/5.0"

HTTPResult
HTTP_get(struct HTTP_ctx *http, const char *url, HTTP_read_callback *cb)
{
   17970:	e59f65f0 	ldr	r6, [pc, #1520]	; 17f68 <HTTP_get+0x640>
   17974:	e08f6006 	add	r6, pc, r6
	RTMPSockBuf sb = {0};
	
	http->status = -1;
	
	/* we only handle http here */
	if (strncasecmp(url, "http", 4))
   17978:	e3500000 	cmp	r0, #0
   1797c:	0a000003 	beq	17990 <HTTP_get+0x68>
		return HTTPRES_BAD_REQUEST;
   17980:	e3a00003 	mov	r0, #3
		ret = HTTPRES_LOST_CONNECTION;
	
leave:
	RTMPSockBuf_Close(&sb);
	return ret;
}
   17984:	e28ddc41 	add	sp, sp, #16640	; 0x4100
   17988:	e28dd07c 	add	sp, sp, #124	; 0x7c
   1798c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
	
	/* we only handle http here */
	if (strncasecmp(url, "http", 4))
		return HTTPRES_BAD_REQUEST;
	
	if (url[4] == 's')
   17990:	e5d43004 	ldrb	r3, [r4, #4]
   17994:	e3530073 	cmp	r3, #115	; 0x73
	char *host, *path;
	char *p1, *p2;
	char hbuf[256];
	int port = 80;
#ifdef CRYPTO
	int ssl = 0;
   17998:	11a08000 	movne	r8, r0
HTTP_get(struct HTTP_ctx *http, const char *url, HTTP_read_callback *cb)
{
	char *host, *path;
	char *p1, *p2;
	char hbuf[256];
	int port = 80;
   1799c:	13a0a050 	movne	sl, #80	; 0x50
	
	/* we only handle http here */
	if (strncasecmp(url, "http", 4))
		return HTTPRES_BAD_REQUEST;
	
	if (url[4] == 's')
   179a0:	0a000040 	beq	17aa8 <HTTP_get+0x180>
#else
		return HTTPRES_BAD_REQUEST;
#endif
	}
	
	p1 = strchr(url + 4, ':');
   179a4:	e2840004 	add	r0, r4, #4
   179a8:	e3a0103a 	mov	r1, #58	; 0x3a
   179ac:	ebffb5cd 	bl	50e8 <strchr@plt>
	if (!p1 || strncmp(p1, "://", 3))
   179b0:	e250b000 	subs	fp, r0, #0
   179b4:	0afffff1 	beq	17980 <HTTP_get+0x58>
   179b8:	e59f15ac 	ldr	r1, [pc, #1452]	; 17f6c <HTTP_get+0x644>
   179bc:	e3a02003 	mov	r2, #3
   179c0:	e08f1001 	add	r1, pc, r1
   179c4:	ebffb67b 	bl	53b8 <strncmp@plt>
   179c8:	e2503000 	subs	r3, r0, #0
   179cc:	1affffeb 	bne	17980 <HTTP_get+0x58>
		return HTTPRES_BAD_REQUEST;
	
	host = p1 + 3;
   179d0:	e28b2003 	add	r2, fp, #3
	path = strchr(host, '/');
   179d4:	e1a00002 	mov	r0, r2
   179d8:	e3a0102f 	mov	r1, #47	; 0x2f
   179dc:	e58d301c 	str	r3, [sp, #28]
   179e0:	e58d2014 	str	r2, [sp, #20]
   179e4:	ebffb5bf 	bl	50e8 <strchr@plt>
	hlen = path - host;
   179e8:	e59d2014 	ldr	r2, [sp, #20]
	strncpy(hbuf, host, hlen);
   179ec:	e28d3078 	add	r3, sp, #120	; 0x78
   179f0:	e58d3018 	str	r3, [sp, #24]
   179f4:	e28d3064 	add	r3, sp, #100	; 0x64
   179f8:	e1a01002 	mov	r1, r2
   179fc:	e58d3014 	str	r3, [sp, #20]
	if (!p1 || strncmp(p1, "://", 3))
		return HTTPRES_BAD_REQUEST;
	
	host = p1 + 3;
	path = strchr(host, '/');
	hlen = path - host;
   17a00:	e062b000 	rsb	fp, r2, r0
	p1 = strchr(url + 4, ':');
	if (!p1 || strncmp(p1, "://", 3))
		return HTTPRES_BAD_REQUEST;
	
	host = p1 + 3;
	path = strchr(host, '/');
   17a04:	e58d0020 	str	r0, [sp, #32]
	hlen = path - host;
	strncpy(hbuf, host, hlen);
   17a08:	e1a0200b 	mov	r2, fp
   17a0c:	e1a00003 	mov	r0, r3
   17a10:	ebffb5db 	bl	5184 <strncpy@plt>
	hbuf[hlen] = '\0';
   17a14:	e085c00b 	add	ip, r5, fp
   17a18:	e59d301c 	ldr	r3, [sp, #28]
	host = hbuf;
	p1 = strrchr(host, ':');
   17a1c:	e59d0014 	ldr	r0, [sp, #20]
   17a20:	e3a0103a 	mov	r1, #58	; 0x3a
	
	host = p1 + 3;
	path = strchr(host, '/');
	hlen = path - host;
	strncpy(hbuf, host, hlen);
	hbuf[hlen] = '\0';
   17a24:	e54c3114 	strb	r3, [ip, #-276]	; 0xfffffeec
	host = hbuf;
	p1 = strrchr(host, ':');
   17a28:	ebffb677 	bl	540c <strrchr@plt>
	if (p1)
   17a2c:	e3500000 	cmp	r0, #0
   17a30:	0a000003 	beq	17a44 <HTTP_get+0x11c>
	{
		*p1++ = '\0';
   17a34:	e59d301c 	ldr	r3, [sp, #28]
   17a38:	e4c03001 	strb	r3, [r0], #1
		port = atoi(p1);
   17a3c:	ebffb5b2 	bl	510c <atoi@plt>
   17a40:	e1a0a000 	mov	sl, r0
	
	struct addrinfo hints, *res, *aip;
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	char SERVICE[10] = { '\0' };
	sprintf(SERVICE, "%s", port);
   17a44:	e59db018 	ldr	fp, [sp, #24]
   17a48:	e1a0200a 	mov	r2, sl
   17a4c:	e24b3040 	sub	r3, fp, #64	; 0x40
   17a50:	e1a0a003 	mov	sl, r3
   17a54:	e1a00003 	mov	r0, r3
	}
	
	struct addrinfo hints, *res, *aip;
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	char SERVICE[10] = { '\0' };
   17a58:	e2451f4e 	sub	r1, r5, #312	; 0x138
		*p1++ = '\0';
		port = atoi(p1);
	}
	
	struct addrinfo hints, *res, *aip;
	hints.ai_family = AF_UNSPEC;
   17a5c:	e3a03000 	mov	r3, #0
	hints.ai_socktype = SOCK_STREAM;
	char SERVICE[10] = { '\0' };
   17a60:	e1c130b0 	strh	r3, [r1]
	sprintf(SERVICE, "%s", port);
   17a64:	e59f1504 	ldr	r1, [pc, #1284]	; 17f70 <HTTP_get+0x648>
		port = atoi(p1);
	}
	
	struct addrinfo hints, *res, *aip;
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
   17a68:	e3a0c001 	mov	ip, #1
	char SERVICE[10] = { '\0' };
	sprintf(SERVICE, "%s", port);
   17a6c:	e08f1001 	add	r1, pc, r1
		*p1++ = '\0';
		port = atoi(p1);
	}
	
	struct addrinfo hints, *res, *aip;
	hints.ai_family = AF_UNSPEC;
   17a70:	e5053130 	str	r3, [r5, #-304]	; 0xfffffed0
	hints.ai_socktype = SOCK_STREAM;
	char SERVICE[10] = { '\0' };
   17a74:	e5053140 	str	r3, [r5, #-320]	; 0xfffffec0
   17a78:	e505313c 	str	r3, [r5, #-316]	; 0xfffffec4
		port = atoi(p1);
	}
	
	struct addrinfo hints, *res, *aip;
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
   17a7c:	e505c12c 	str	ip, [r5, #-300]	; 0xfffffed4
	char SERVICE[10] = { '\0' };
	sprintf(SERVICE, "%s", port);
   17a80:	ebffb5b9 	bl	516c <sprintf@plt>
	
	int error = getaddrinfo(host, SERVICE, &hints, &res);
   17a84:	e59d0014 	ldr	r0, [sp, #20]
   17a88:	e1a0100a 	mov	r1, sl
   17a8c:	e24b2034 	sub	r2, fp, #52	; 0x34
   17a90:	e24b304c 	sub	r3, fp, #76	; 0x4c
   17a94:	ebffb65f 	bl	5418 <getaddrinfo@plt>
	if (error != 0)
   17a98:	e3500000 	cmp	r0, #0
   17a9c:	0a00000c 	beq	17ad4 <HTTP_get+0x1ac>
	{
		return HTTPRES_LOST_CONNECTION;
   17aa0:	e3a00006 	mov	r0, #6
   17aa4:	eaffffb6 	b	17984 <HTTP_get+0x5c>
	if (url[4] == 's')
	{
#ifdef CRYPTO
		ssl = 1;
		port = 443;
		if (!RTMP_TLS_ctx)
   17aa8:	e59f34c4 	ldr	r3, [pc, #1220]	; 17f74 <HTTP_get+0x64c>
   17aac:	e7963003 	ldr	r3, [r6, r3]
   17ab0:	e5933000 	ldr	r3, [r3]
   17ab4:	e3530000 	cmp	r3, #0
	
	if (url[4] == 's')
	{
#ifdef CRYPTO
		ssl = 1;
		port = 443;
   17ab8:	159fa4b8 	ldrne	sl, [pc, #1208]	; 17f78 <HTTP_get+0x650>
		return HTTPRES_BAD_REQUEST;
	
	if (url[4] == 's')
	{
#ifdef CRYPTO
		ssl = 1;
   17abc:	13a08001 	movne	r8, #1
		port = 443;
		if (!RTMP_TLS_ctx)
   17ac0:	1affffb7 	bne	179a4 <HTTP_get+0x7c>
			RTMP_TLS_Init();
   17ac4:	ebffc346 	bl	87e4 <RTMP_TLS_Init>
		return HTTPRES_BAD_REQUEST;
	
	if (url[4] == 's')
	{
#ifdef CRYPTO
		ssl = 1;
   17ac8:	e3a08001 	mov	r8, #1
		port = 443;
   17acc:	e59fa4a4 	ldr	sl, [pc, #1188]	; 17f78 <HTTP_get+0x650>
   17ad0:	eaffffb3 	b	179a4 <HTTP_get+0x7c>
	{
		return HTTPRES_LOST_CONNECTION;
	}
	
	int sockfd = -1;
	for (aip = res; aip != NULL; aip = aip->ai_next)
   17ad4:	e515a14c 	ldr	sl, [r5, #-332]	; 0xfffffeb4
   17ad8:	e35a0000 	cmp	sl, #0
   17adc:	1a00000a 	bne	17b0c <HTTP_get+0x1e4>
   17ae0:	eaffffee 	b	17aa0 <HTTP_get+0x178>
					break;
			}
		}
		else
		{
			if (connect(sockfd, aip->ai_addr, aip->ai_addrlen) >= 0)
   17ae4:	e59a1018 	ldr	r1, [sl, #24]
   17ae8:	e59a2010 	ldr	r2, [sl, #16]
   17aec:	ebffb64f 	bl	5430 <connect@plt>
   17af0:	e3500000 	cmp	r0, #0
   17af4:	aa00000b 	bge	17b28 <HTTP_get+0x200>
			{
				break;
			}
		}
		
		close(sockfd);
   17af8:	e1a0000b 	mov	r0, fp
   17afc:	ebffb63f 	bl	5400 <close@plt>
	{
		return HTTPRES_LOST_CONNECTION;
	}
	
	int sockfd = -1;
	for (aip = res; aip != NULL; aip = aip->ai_next)
   17b00:	e59aa01c 	ldr	sl, [sl, #28]
   17b04:	e35a0000 	cmp	sl, #0
   17b08:	0affffe4 	beq	17aa0 <HTTP_get+0x178>
	{
		sockfd = socket(aip->ai_family, aip->ai_socktype, aip->ai_protocol);
   17b0c:	e99a0007 	ldmib	sl, {r0, r1, r2}
   17b10:	ebffb649 	bl	543c <socket@plt>
		
		if (sockfd < 0)
   17b14:	e250b000 	subs	fp, r0, #0
   17b18:	aafffff1 	bge	17ae4 <HTTP_get+0x1bc>
		{
			switch (errno)
   17b1c:	ebffb61f 	bl	53a0 <__errno@plt>
   17b20:	e5903000 	ldr	r3, [r0]
   17b24:	eafffff3 	b	17af8 <HTTP_get+0x1d0>
	if (sb.sb_socket == -1)
		return HTTPRES_LOST_CONNECTION;

	sprintf(sb.sb_buf,
			"GET %s HTTP/1.0\r\nUser-Agent: %s\r\nHost: %s\r\nReferer: %.*s\r\n",
			path, AGENT, host, (int)(path - url + 1), url);
   17b28:	e59d2020 	ldr	r2, [sp, #32]
	
	sb.sb_socket = sockfd;
	if (sb.sb_socket == -1)
		return HTTPRES_LOST_CONNECTION;

	sprintf(sb.sb_buf,
   17b2c:	e59d1014 	ldr	r1, [sp, #20]
			"GET %s HTTP/1.0\r\nUser-Agent: %s\r\nHost: %s\r\nReferer: %.*s\r\n",
			path, AGENT, host, (int)(path - url + 1), url);
   17b30:	e0643002 	rsb	r3, r4, r2
	
	sb.sb_socket = sockfd;
	if (sb.sb_socket == -1)
		return HTTPRES_LOST_CONNECTION;

	sprintf(sb.sb_buf,
   17b34:	e2833001 	add	r3, r3, #1
   17b38:	e88d001a 	stm	sp, {r1, r3, r4}
   17b3c:	e59f1438 	ldr	r1, [pc, #1080]	; 17f7c <HTTP_get+0x654>
   17b40:	e59f3438 	ldr	r3, [pc, #1080]	; 17f80 <HTTP_get+0x658>
		
		close(sockfd);
		sockfd = -1;
	}
	
	sb.sb_socket = sockfd;
   17b44:	e1a0a005 	mov	sl, r5
	if (sb.sb_socket == -1)
		return HTTPRES_LOST_CONNECTION;

	sprintf(sb.sb_buf,
   17b48:	e08f3003 	add	r3, pc, r3
   17b4c:	e2450008 	sub	r0, r5, #8
   17b50:	e08f1001 	add	r1, pc, r1
		
		close(sockfd);
		sockfd = -1;
	}
	
	sb.sb_socket = sockfd;
   17b54:	e52ab014 	str	fp, [sl, #-20]!	; 0xffffffec
	if (sb.sb_socket == -1)
		return HTTPRES_LOST_CONNECTION;

	sprintf(sb.sb_buf,
   17b58:	ebffb583 	bl	516c <sprintf@plt>
			"GET %s HTTP/1.0\r\nUser-Agent: %s\r\nHost: %s\r\nReferer: %.*s\r\n",
			path, AGENT, host, (int)(path - url + 1), url);
	if (http->date[0])
   17b5c:	e5972000 	ldr	r2, [r7]
   17b60:	e5d23000 	ldrb	r3, [r2]
   17b64:	e3530000 	cmp	r3, #0
   17b68:	1a000059 	bne	17cd4 <HTTP_get+0x3ac>
		i += sprintf(sb.sb_buf + i, "If-Modified-Since: %s\r\n", http->date);
	i += sprintf(sb.sb_buf + i, "\r\n");
   17b6c:	e59d4024 	ldr	r4, [sp, #36]	; 0x24
   17b70:	e59f140c 	ldr	r1, [pc, #1036]	; 17f84 <HTTP_get+0x65c>
   17b74:	e08a0004 	add	r0, sl, r4
   17b78:	e280000c 	add	r0, r0, #12
   17b7c:	e08f1001 	add	r1, pc, r1
   17b80:	e3a02003 	mov	r2, #3
   17b84:	ebffb590 	bl	51cc <memcpy@plt>
	

#ifdef CRYPTO
	if (ssl)
   17b88:	e3580000 	cmp	r8, #0
	sprintf(sb.sb_buf,
			"GET %s HTTP/1.0\r\nUser-Agent: %s\r\nHost: %s\r\nReferer: %.*s\r\n",
			path, AGENT, host, (int)(path - url + 1), url);
	if (http->date[0])
		i += sprintf(sb.sb_buf + i, "If-Modified-Since: %s\r\n", http->date);
	i += sprintf(sb.sb_buf + i, "\r\n");
   17b8c:	e284b002 	add	fp, r4, #2
   17b90:	028d4dc5 	addeq	r4, sp, #12608	; 0x3140
   17b94:	02844038 	addeq	r4, r4, #56	; 0x38
	

#ifdef CRYPTO
	if (ssl)
   17b98:	0a000027 	beq	17c3c <HTTP_get+0x314>
#ifdef NO_SSL
		RTMP_Log(RTMP_LOGERROR, "%s, No SSL/TLS support", __FUNCTION__);
		ret = HTTPRES_BAD_REQUEST;
		goto leave;
#else
		TLS_client(RTMP_TLS_ctx, sb.sb_ssl);
   17b9c:	e3a00e17 	mov	r0, #368	; 0x170
   17ba0:	ebffb51d 	bl	501c <malloc@plt>
   17ba4:	e28d4dc5 	add	r4, sp, #12608	; 0x3140
   17ba8:	e2844038 	add	r4, r4, #56	; 0x38
   17bac:	e5840ffc 	str	r0, [r4, #4092]	; 0xffc
   17bb0:	ebffb5d9 	bl	531c <ssl_init@plt>
   17bb4:	e5940ffc 	ldr	r0, [r4, #4092]	; 0xffc
   17bb8:	e3a01000 	mov	r1, #0
   17bbc:	ebffb5d9 	bl	5328 <ssl_set_endpoint@plt>
   17bc0:	e5940ffc 	ldr	r0, [r4, #4092]	; 0xffc
   17bc4:	e3a01000 	mov	r1, #0
   17bc8:	ebffb5d9 	bl	5334 <ssl_set_authmode@plt>
   17bcc:	e59f33a0 	ldr	r3, [pc, #928]	; 17f74 <HTTP_get+0x64c>
   17bd0:	e59f23b0 	ldr	r2, [pc, #944]	; 17f88 <HTTP_get+0x660>
   17bd4:	e7968003 	ldr	r8, [r6, r3]
   17bd8:	e7961002 	ldr	r1, [r6, r2]
   17bdc:	e5940ffc 	ldr	r0, [r4, #4092]	; 0xffc
   17be0:	e5982000 	ldr	r2, [r8]
   17be4:	ebffb5d5 	bl	5340 <ssl_set_rng@plt>
   17be8:	e59f339c 	ldr	r3, [pc, #924]	; 17f8c <HTTP_get+0x664>
   17bec:	e5940ffc 	ldr	r0, [r4, #4092]	; 0xffc
   17bf0:	e7961003 	ldr	r1, [r6, r3]
   17bf4:	ebffb5d4 	bl	534c <ssl_set_ciphersuites@plt>
   17bf8:	e5981000 	ldr	r1, [r8]
   17bfc:	e5940ffc 	ldr	r0, [r4, #4092]	; 0xffc
   17c00:	e2811a09 	add	r1, r1, #36864	; 0x9000
   17c04:	e2811010 	add	r1, r1, #16
   17c08:	ebffb5d2 	bl	5358 <ssl_set_session@plt>
		TLS_setfd(sb.sb_ssl, sb.sb_socket);
   17c0c:	e59f237c 	ldr	r2, [pc, #892]	; 17f90 <HTTP_get+0x668>
   17c10:	e59f337c 	ldr	r3, [pc, #892]	; 17f94 <HTTP_get+0x66c>
   17c14:	e7961002 	ldr	r1, [r6, r2]
   17c18:	e5940ffc 	ldr	r0, [r4, #4092]	; 0xffc
   17c1c:	e7963003 	ldr	r3, [r6, r3]
   17c20:	e1a0200a 	mov	r2, sl
   17c24:	e58da000 	str	sl, [sp]
   17c28:	ebffb5d3 	bl	537c <ssl_set_bio@plt>
		if (TLS_connect(sb.sb_ssl) < 0)
   17c2c:	e5940ffc 	ldr	r0, [r4, #4092]	; 0xffc
   17c30:	ebffb5d4 	bl	5388 <ssl_handshake@plt>
   17c34:	e3500000 	cmp	r0, #0
   17c38:	ba0000b4 	blt	17f10 <HTTP_get+0x5e8>
	  goto leave;
		}
#endif
	}
#endif
	RTMPSockBuf_Send(&sb, sb.sb_buf, i);
   17c3c:	e1a0200b 	mov	r2, fp
   17c40:	e2451008 	sub	r1, r5, #8
   17c44:	e1a0000a 	mov	r0, sl
   17c48:	ebffc8f7 	bl	a02c <RTMPSockBuf_Send>
	
	/* set timeout */
#define HTTP_TIMEOUT	5
	{
		SET_RCVTIMEO(tv, HTTP_TIMEOUT);
		if (setsockopt
   17c4c:	e59d3018 	ldr	r3, [sp, #24]
   17c50:	e3a02008 	mov	r2, #8
	RTMPSockBuf_Send(&sb, sb.sb_buf, i);
	
	/* set timeout */
#define HTTP_TIMEOUT	5
	{
		SET_RCVTIMEO(tv, HTTP_TIMEOUT);
   17c54:	e3a0c000 	mov	ip, #0
   17c58:	e3a06005 	mov	r6, #5
		if (setsockopt
   17c5c:	e5150014 	ldr	r0, [r5, #-20]	; 0xffffffec
   17c60:	e2433048 	sub	r3, r3, #72	; 0x48
   17c64:	e58d2000 	str	r2, [sp]
   17c68:	e3a01001 	mov	r1, #1
   17c6c:	e3a02014 	mov	r2, #20
	RTMPSockBuf_Send(&sb, sb.sb_buf, i);
	
	/* set timeout */
#define HTTP_TIMEOUT	5
	{
		SET_RCVTIMEO(tv, HTTP_TIMEOUT);
   17c70:	e5056148 	str	r6, [r5, #-328]	; 0xfffffeb8
   17c74:	e505c144 	str	ip, [r5, #-324]	; 0xfffffebc
		if (setsockopt
   17c78:	ebffb5f8 	bl	5460 <setsockopt@plt>
   17c7c:	e3500000 	cmp	r0, #0
   17c80:	1a00001c 	bne	17cf8 <HTTP_get+0x3d0>
			RTMP_Log(RTMP_LOGERROR, "%s, Setting socket timeout to %ds failed!",
					 __FUNCTION__, HTTP_TIMEOUT);
		}
	}
	
	sb.sb_size = 0;
   17c84:	e3a03000 	mov	r3, #0
	sb.sb_timedout = FALSE;
	if (RTMPSockBuf_Fill(&sb) < 1)
   17c88:	e1a0000a 	mov	r0, sl
			RTMP_Log(RTMP_LOGERROR, "%s, Setting socket timeout to %ds failed!",
					 __FUNCTION__, HTTP_TIMEOUT);
		}
	}
	
	sb.sb_size = 0;
   17c8c:	e5053010 	str	r3, [r5, #-16]
	sb.sb_timedout = FALSE;
   17c90:	e5843ff8 	str	r3, [r4, #4088]	; 0xff8
	if (RTMPSockBuf_Fill(&sb) < 1)
   17c94:	ebffc832 	bl	9d64 <RTMPSockBuf_Fill>
   17c98:	e3500000 	cmp	r0, #0
   17c9c:	da000012 	ble	17cec <HTTP_get+0x3c4>
	{
		ret = HTTPRES_LOST_CONNECTION;
		goto leave;
	}
	if (strncmp(sb.sb_buf, "HTTP/1", 6))
   17ca0:	e59f12f0 	ldr	r1, [pc, #752]	; 17f98 <HTTP_get+0x670>
   17ca4:	e2450008 	sub	r0, r5, #8
   17ca8:	e08f1001 	add	r1, pc, r1
   17cac:	e3a02006 	mov	r2, #6
   17cb0:	ebffb5c0 	bl	53b8 <strncmp@plt>
   17cb4:	e2504000 	subs	r4, r0, #0
   17cb8:	0a000016 	beq	17d18 <HTTP_get+0x3f0>
	{
		ret = HTTPRES_BAD_REQUEST;
   17cbc:	e3a03003 	mov	r3, #3
   17cc0:	e58d3014 	str	r3, [sp, #20]
	
	if (flen > 0)
		ret = HTTPRES_LOST_CONNECTION;
	
leave:
	RTMPSockBuf_Close(&sb);
   17cc4:	e1a0000a 	mov	r0, sl
   17cc8:	ebffc914 	bl	a120 <RTMPSockBuf_Close>
	return ret;
   17ccc:	e59d0014 	ldr	r0, [sp, #20]
   17cd0:	eaffff2b 	b	17984 <HTTP_get+0x5c>

	sprintf(sb.sb_buf,
			"GET %s HTTP/1.0\r\nUser-Agent: %s\r\nHost: %s\r\nReferer: %.*s\r\n",
			path, AGENT, host, (int)(path - url + 1), url);
	if (http->date[0])
		i += sprintf(sb.sb_buf + i, "If-Modified-Since: %s\r\n", http->date);
   17cd4:	e59f12c0 	ldr	r1, [pc, #704]	; 17f9c <HTTP_get+0x674>
   17cd8:	e28a000c 	add	r0, sl, #12
   17cdc:	e08f1001 	add	r1, pc, r1
   17ce0:	ebffb521 	bl	516c <sprintf@plt>
   17ce4:	e58d0024 	str	r0, [sp, #36]	; 0x24
   17ce8:	eaffff9f 	b	17b6c <HTTP_get+0x244>
	
	sb.sb_size = 0;
	sb.sb_timedout = FALSE;
	if (RTMPSockBuf_Fill(&sb) < 1)
	{
		ret = HTTPRES_LOST_CONNECTION;
   17cec:	e3a03006 	mov	r3, #6
   17cf0:	e58d3014 	str	r3, [sp, #20]
   17cf4:	eafffff2 	b	17cc4 <HTTP_get+0x39c>
	{
		SET_RCVTIMEO(tv, HTTP_TIMEOUT);
		if (setsockopt
			(sb.sb_socket, SOL_SOCKET, SO_RCVTIMEO, (char *)&tv, sizeof(tv)))
		{
			RTMP_Log(RTMP_LOGERROR, "%s, Setting socket timeout to %ds failed!",
   17cf8:	e59f12a0 	ldr	r1, [pc, #672]	; 17fa0 <HTTP_get+0x678>
   17cfc:	e59f22a0 	ldr	r2, [pc, #672]	; 17fa4 <HTTP_get+0x67c>
   17d00:	e1a03006 	mov	r3, r6
   17d04:	e3a00001 	mov	r0, #1
   17d08:	e08f1001 	add	r1, pc, r1
   17d0c:	e08f2002 	add	r2, pc, r2
   17d10:	ebfff725 	bl	159ac <RTMP_Log>
   17d14:	eaffffda 	b	17c84 <HTTP_get+0x35c>
	{
		ret = HTTPRES_BAD_REQUEST;
		goto leave;
	}
	
	p1 = strchr(sb.sb_buf, ' ');
   17d18:	e3a01020 	mov	r1, #32
   17d1c:	e28a000c 	add	r0, sl, #12
   17d20:	ebffb4f0 	bl	50e8 <strchr@plt>
	rc = atoi(p1 + 1);
   17d24:	e2800001 	add	r0, r0, #1
   17d28:	ebffb4f7 	bl	510c <atoi@plt>
	http->status = rc;
	
	if (rc >= 300)
   17d2c:	e3500f4b 	cmp	r0, #300	; 0x12c
		goto leave;
	}
	
	p1 = strchr(sb.sb_buf, ' ');
	rc = atoi(p1 + 1);
	http->status = rc;
   17d30:	e5870008 	str	r0, [r7, #8]
	
	if (rc >= 300)
   17d34:	ba000073 	blt	17f08 <HTTP_get+0x5e0>
	{
		if (rc == 304)
   17d38:	e3500e13 	cmp	r0, #304	; 0x130
   17d3c:	0a000084 	beq	17f54 <HTTP_get+0x62c>
		{
	  ret = HTTPRES_OK_NOT_MODIFIED;
	  goto leave;
		}
		else if (rc == 404)
   17d40:	e3500f65 	cmp	r0, #404	; 0x194
   17d44:	0a00007f 	beq	17f48 <HTTP_get+0x620>
			ret = HTTPRES_NOT_FOUND;
		else if (rc >= 500)
   17d48:	e3500f7d 	cmp	r0, #500	; 0x1f4
			ret = HTTPRES_SERVER_ERROR;
   17d4c:	a3a03004 	movge	r3, #4
   17d50:	a58d3014 	strge	r3, [sp, #20]
	  ret = HTTPRES_OK_NOT_MODIFIED;
	  goto leave;
		}
		else if (rc == 404)
			ret = HTTPRES_NOT_FOUND;
		else if (rc >= 500)
   17d54:	aa000003 	bge	17d68 <HTTP_get+0x440>
			ret = HTTPRES_SERVER_ERROR;
		else if (rc >= 400)
			ret = HTTPRES_BAD_REQUEST;
		else
			ret = HTTPRES_REDIRECTED;
   17d58:	e3500e19 	cmp	r0, #400	; 0x190
   17d5c:	a3a03003 	movge	r3, #3
   17d60:	b3a03005 	movlt	r3, #5
   17d64:	e58d3014 	str	r3, [sp, #20]
	}
	
	p1 = memchr(sb.sb_buf, '\n', sb.sb_size);
   17d68:	e5158010 	ldr	r8, [r5, #-16]
   17d6c:	e28a600c 	add	r6, sl, #12
   17d70:	e1a02008 	mov	r2, r8
   17d74:	e1a00006 	mov	r0, r6
   17d78:	e3a0100a 	mov	r1, #10
   17d7c:	ebffb5ba 	bl	546c <memchr@plt>
	if (!p1)
   17d80:	e3500000 	cmp	r0, #0
   17d84:	0affffcc 	beq	17cbc <HTTP_get+0x394>
	  sb.sb_start += 2;
	  sb.sb_size -= 2;
	  break;
		}
		else
			if (!strncasecmp
   17d88:	e59f3218 	ldr	r3, [pc, #536]	; 17fa8 <HTTP_get+0x680>
	if (!p1)
	{
		ret = HTTPRES_BAD_REQUEST;
		goto leave;
	}
	sb.sb_start = p1 + 1;
   17d8c:	e2804001 	add	r4, r0, #1
	  sb.sb_start += 2;
	  sb.sb_size -= 2;
	  break;
		}
		else
			if (!strncasecmp
   17d90:	e08f3003 	add	r3, pc, r3
   17d94:	e58d3018 	str	r3, [sp, #24]
				(sb.sb_start, "Content-Length: ", sizeof("Content-Length: ") - 1))
			{
				flen = atoi(sb.sb_start + sizeof("Content-Length: ") - 1);
			}
			else
				if (!strncasecmp
   17d98:	e59f320c 	ldr	r3, [pc, #524]	; 17fac <HTTP_get+0x684>
	{
		ret = HTTPRES_BAD_REQUEST;
		goto leave;
	}
	sb.sb_start = p1 + 1;
	sb.sb_size -= sb.sb_start - sb.sb_buf;
   17d9c:	e0642006 	rsb	r2, r4, r6
   17da0:	e088b002 	add	fp, r8, r2
				(sb.sb_start, "Content-Length: ", sizeof("Content-Length: ") - 1))
			{
				flen = atoi(sb.sb_start + sizeof("Content-Length: ") - 1);
			}
			else
				if (!strncasecmp
   17da4:	e08f3003 	add	r3, pc, r3
	{
		ret = HTTPRES_BAD_REQUEST;
		goto leave;
	}
	sb.sb_start = p1 + 1;
	sb.sb_size -= sb.sb_start - sb.sb_buf;
   17da8:	e505b010 	str	fp, [r5, #-16]
	if (!p1)
	{
		ret = HTTPRES_BAD_REQUEST;
		goto leave;
	}
	sb.sb_start = p1 + 1;
   17dac:	e505400c 	str	r4, [r5, #-12]
	char hbuf[256];
	int port = 80;
#ifdef CRYPTO
	int ssl = 0;
#endif
	int hlen, flen = 0;
   17db0:	e3a08000 	mov	r8, #0
				(sb.sb_start, "Content-Length: ", sizeof("Content-Length: ") - 1))
			{
				flen = atoi(sb.sb_start + sizeof("Content-Length: ") - 1);
			}
			else
				if (!strncasecmp
   17db4:	e58d301c 	str	r3, [sp, #28]
		goto leave;
	}
	sb.sb_start = p1 + 1;
	sb.sb_size -= sb.sb_start - sb.sb_buf;
	
	while ((p2 = memchr(sb.sb_start, '\r', sb.sb_size)))
   17db8:	ea00000a 	b	17de8 <HTTP_get+0x4c0>
				(sb.sb_start, "Content-Length: ", sizeof("Content-Length: ") - 1))
			{
				flen = atoi(sb.sb_start + sizeof("Content-Length: ") - 1);
			}
			else
				if (!strncasecmp
   17dbc:	ebffb580 	bl	53c4 <strncasecmp@plt>
   17dc0:	e3500000 	cmp	r0, #0
   17dc4:	0a00001f 	beq	17e48 <HTTP_get+0x520>
	    (sb.sb_start, "Last-Modified: ", sizeof("Last-Modified: ") - 1))
				{
					*p2 = '\0';
					strcpy(http->date, sb.sb_start + sizeof("Last-Modified: ") - 1);
				}
		p2 += 2;
   17dc8:	e2863002 	add	r3, r6, #2
		sb.sb_size -= p2 - sb.sb_start;
   17dcc:	e0634004 	rsb	r4, r3, r4
   17dd0:	e08bb004 	add	fp, fp, r4
		sb.sb_start = p2;
		if (sb.sb_size < 1)
   17dd4:	e35b0000 	cmp	fp, #0
   17dd8:	e1a04003 	mov	r4, r3
				{
					*p2 = '\0';
					strcpy(http->date, sb.sb_start + sizeof("Last-Modified: ") - 1);
				}
		p2 += 2;
		sb.sb_size -= p2 - sb.sb_start;
   17ddc:	e505b010 	str	fp, [r5, #-16]
		sb.sb_start = p2;
   17de0:	e505300c 	str	r3, [r5, #-12]
		if (sb.sb_size < 1)
   17de4:	da00001f 	ble	17e68 <HTTP_get+0x540>
		goto leave;
	}
	sb.sb_start = p1 + 1;
	sb.sb_size -= sb.sb_start - sb.sb_buf;
	
	while ((p2 = memchr(sb.sb_start, '\r', sb.sb_size)))
   17de8:	e3a0100d 	mov	r1, #13
   17dec:	e1a0200b 	mov	r2, fp
   17df0:	e1a00004 	mov	r0, r4
   17df4:	ebffb59c 	bl	546c <memchr@plt>
	  sb.sb_start += 2;
	  sb.sb_size -= 2;
	  break;
		}
		else
			if (!strncasecmp
   17df8:	e59d1018 	ldr	r1, [sp, #24]
   17dfc:	e3a02010 	mov	r2, #16
		goto leave;
	}
	sb.sb_start = p1 + 1;
	sb.sb_size -= sb.sb_start - sb.sb_buf;
	
	while ((p2 = memchr(sb.sb_start, '\r', sb.sb_size)))
   17e00:	e2506000 	subs	r6, r0, #0
	  sb.sb_start += 2;
	  sb.sb_size -= 2;
	  break;
		}
		else
			if (!strncasecmp
   17e04:	e1a00004 	mov	r0, r4
		goto leave;
	}
	sb.sb_start = p1 + 1;
	sb.sb_size -= sb.sb_start - sb.sb_buf;
	
	while ((p2 = memchr(sb.sb_start, '\r', sb.sb_size)))
   17e08:	0a000021 	beq	17e94 <HTTP_get+0x56c>
	{
		if (*sb.sb_start == '\r')
   17e0c:	e5d43000 	ldrb	r3, [r4]
   17e10:	e353000d 	cmp	r3, #13
   17e14:	0a00001a 	beq	17e84 <HTTP_get+0x55c>
	  sb.sb_start += 2;
	  sb.sb_size -= 2;
	  break;
		}
		else
			if (!strncasecmp
   17e18:	ebffb569 	bl	53c4 <strncasecmp@plt>
				(sb.sb_start, "Content-Length: ", sizeof("Content-Length: ") - 1))
			{
				flen = atoi(sb.sb_start + sizeof("Content-Length: ") - 1);
			}
			else
				if (!strncasecmp
   17e1c:	e59d101c 	ldr	r1, [sp, #28]
   17e20:	e3a0200f 	mov	r2, #15
	  sb.sb_start += 2;
	  sb.sb_size -= 2;
	  break;
		}
		else
			if (!strncasecmp
   17e24:	e3500000 	cmp	r0, #0
				(sb.sb_start, "Content-Length: ", sizeof("Content-Length: ") - 1))
			{
				flen = atoi(sb.sb_start + sizeof("Content-Length: ") - 1);
			}
			else
				if (!strncasecmp
   17e28:	e1a00004 	mov	r0, r4
	  sb.sb_start += 2;
	  sb.sb_size -= 2;
	  break;
		}
		else
			if (!strncasecmp
   17e2c:	1affffe2 	bne	17dbc <HTTP_get+0x494>
				(sb.sb_start, "Content-Length: ", sizeof("Content-Length: ") - 1))
			{
				flen = atoi(sb.sb_start + sizeof("Content-Length: ") - 1);
   17e30:	e2840010 	add	r0, r4, #16
   17e34:	ebffb4b4 	bl	510c <atoi@plt>
   17e38:	e515b010 	ldr	fp, [r5, #-16]
   17e3c:	e515400c 	ldr	r4, [r5, #-12]
   17e40:	e1a08000 	mov	r8, r0
   17e44:	eaffffdf 	b	17dc8 <HTTP_get+0x4a0>
			}
			else
				if (!strncasecmp
	    (sb.sb_start, "Last-Modified: ", sizeof("Last-Modified: ") - 1))
				{
					*p2 = '\0';
   17e48:	e5c60000 	strb	r0, [r6]
					strcpy(http->date, sb.sb_start + sizeof("Last-Modified: ") - 1);
   17e4c:	e515100c 	ldr	r1, [r5, #-12]
   17e50:	e5970000 	ldr	r0, [r7]
   17e54:	e281100f 	add	r1, r1, #15
   17e58:	ebffb4e7 	bl	51fc <strcpy@plt>
   17e5c:	e515b010 	ldr	fp, [r5, #-16]
   17e60:	e515400c 	ldr	r4, [r5, #-12]
   17e64:	eaffffd7 	b	17dc8 <HTTP_get+0x4a0>
		p2 += 2;
		sb.sb_size -= p2 - sb.sb_start;
		sb.sb_start = p2;
		if (sb.sb_size < 1)
		{
	  if (RTMPSockBuf_Fill(&sb) < 1)
   17e68:	e1a0000a 	mov	r0, sl
   17e6c:	ebffc7bc 	bl	9d64 <RTMPSockBuf_Fill>
   17e70:	e3500000 	cmp	r0, #0
   17e74:	daffff9c 	ble	17cec <HTTP_get+0x3c4>
   17e78:	e515400c 	ldr	r4, [r5, #-12]
   17e7c:	e515b010 	ldr	fp, [r5, #-16]
   17e80:	eaffffd8 	b	17de8 <HTTP_get+0x4c0>
	
	while ((p2 = memchr(sb.sb_start, '\r', sb.sb_size)))
	{
		if (*sb.sb_start == '\r')
		{
	  sb.sb_start += 2;
   17e84:	e2843002 	add	r3, r4, #2
	  sb.sb_size -= 2;
   17e88:	e24bc002 	sub	ip, fp, #2
	
	while ((p2 = memchr(sb.sb_start, '\r', sb.sb_size)))
	{
		if (*sb.sb_start == '\r')
		{
	  sb.sb_start += 2;
   17e8c:	e505300c 	str	r3, [r5, #-12]
	  sb.sb_size -= 2;
   17e90:	e505c010 	str	ip, [r5, #-16]
   17e94:	e5152010 	ldr	r2, [r5, #-16]
		  goto leave;
	  }
		}
	}
	
	len_known = flen > 0;
   17e98:	e3580000 	cmp	r8, #0
   17e9c:	d3a06000 	movle	r6, #0
   17ea0:	c3a06001 	movgt	r6, #1
	while ((!len_known || flen > 0) &&
   17ea4:	e3520000 	cmp	r2, #0
	{
		cb(sb.sb_start, 1, sb.sb_size, http->data);
		if (len_known)
			flen -= sb.sb_size;
		http->size += sb.sb_size;
		sb.sb_size = 0;
   17ea8:	e3a0b000 	mov	fp, #0
	  }
		}
	}
	
	len_known = flen > 0;
	while ((!len_known || flen > 0) &&
   17eac:	da00000f 	ble	17ef0 <HTTP_get+0x5c8>
		   (sb.sb_size > 0 || RTMPSockBuf_Fill(&sb) > 0))
	{
		cb(sb.sb_start, 1, sb.sb_size, http->data);
   17eb0:	e3a01001 	mov	r1, #1
   17eb4:	e597300c 	ldr	r3, [r7, #12]
   17eb8:	e515000c 	ldr	r0, [r5, #-12]
   17ebc:	e12fff39 	blx	r9
		if (len_known)
			flen -= sb.sb_size;
   17ec0:	e5152010 	ldr	r2, [r5, #-16]
	len_known = flen > 0;
	while ((!len_known || flen > 0) &&
		   (sb.sb_size > 0 || RTMPSockBuf_Fill(&sb) > 0))
	{
		cb(sb.sb_start, 1, sb.sb_size, http->data);
		if (len_known)
   17ec4:	e3560000 	cmp	r6, #0
			flen -= sb.sb_size;
   17ec8:	10628008 	rsbne	r8, r2, r8
	  }
		}
	}
	
	len_known = flen > 0;
	while ((!len_known || flen > 0) &&
   17ecc:	e3580000 	cmp	r8, #0
		   (sb.sb_size > 0 || RTMPSockBuf_Fill(&sb) > 0))
	{
		cb(sb.sb_start, 1, sb.sb_size, http->data);
		if (len_known)
			flen -= sb.sb_size;
		http->size += sb.sb_size;
   17ed0:	e5973004 	ldr	r3, [r7, #4]
	  }
		}
	}
	
	len_known = flen > 0;
	while ((!len_known || flen > 0) &&
   17ed4:	d3a01000 	movle	r1, #0
   17ed8:	c3a01001 	movgt	r1, #1
		   (sb.sb_size > 0 || RTMPSockBuf_Fill(&sb) > 0))
	{
		cb(sb.sb_start, 1, sb.sb_size, http->data);
		if (len_known)
			flen -= sb.sb_size;
		http->size += sb.sb_size;
   17edc:	e0833002 	add	r3, r3, r2
		sb.sb_size = 0;
   17ee0:	e505b010 	str	fp, [r5, #-16]
		   (sb.sb_size > 0 || RTMPSockBuf_Fill(&sb) > 0))
	{
		cb(sb.sb_start, 1, sb.sb_size, http->data);
		if (len_known)
			flen -= sb.sb_size;
		http->size += sb.sb_size;
   17ee4:	e5873004 	str	r3, [r7, #4]
	  }
		}
	}
	
	len_known = flen > 0;
	while ((!len_known || flen > 0) &&
   17ee8:	e1510006 	cmp	r1, r6
   17eec:	3affff74 	bcc	17cc4 <HTTP_get+0x39c>
		   (sb.sb_size > 0 || RTMPSockBuf_Fill(&sb) > 0))
   17ef0:	e1a0000a 	mov	r0, sl
   17ef4:	ebffc79a 	bl	9d64 <RTMPSockBuf_Fill>
   17ef8:	e3500000 	cmp	r0, #0
   17efc:	da00000c 	ble	17f34 <HTTP_get+0x60c>
   17f00:	e5152010 	ldr	r2, [r5, #-16]
   17f04:	eaffffe9 	b	17eb0 <HTTP_get+0x588>
	int ssl = 0;
#endif
	int hlen, flen = 0;
	int rc, i;
	int len_known;
	HTTPResult ret = HTTPRES_OK;
   17f08:	e58d4014 	str	r4, [sp, #20]
   17f0c:	eaffff95 	b	17d68 <HTTP_get+0x440>
#else
		TLS_client(RTMP_TLS_ctx, sb.sb_ssl);
		TLS_setfd(sb.sb_ssl, sb.sb_socket);
		if (TLS_connect(sb.sb_ssl) < 0)
		{
	  RTMP_Log(RTMP_LOGERROR, "%s, TLS_Connect failed", __FUNCTION__);
   17f10:	e59f1098 	ldr	r1, [pc, #152]	; 17fb0 <HTTP_get+0x688>
   17f14:	e59f2098 	ldr	r2, [pc, #152]	; 17fb4 <HTTP_get+0x68c>
   17f18:	e3a00001 	mov	r0, #1
   17f1c:	e08f1001 	add	r1, pc, r1
   17f20:	e08f2002 	add	r2, pc, r2
   17f24:	ebfff6a0 	bl	159ac <RTMP_Log>
	  ret = HTTPRES_LOST_CONNECTION;
   17f28:	e3a03006 	mov	r3, #6
   17f2c:	e58d3014 	str	r3, [sp, #20]
	  goto leave;
   17f30:	eaffff63 	b	17cc4 <HTTP_get+0x39c>
		http->size += sb.sb_size;
		sb.sb_size = 0;
	}
	
	if (flen > 0)
		ret = HTTPRES_LOST_CONNECTION;
   17f34:	e3580000 	cmp	r8, #0
   17f38:	e59d3014 	ldr	r3, [sp, #20]
   17f3c:	c3a03006 	movgt	r3, #6
   17f40:	e58d3014 	str	r3, [sp, #20]
   17f44:	eaffff5e 	b	17cc4 <HTTP_get+0x39c>
		{
	  ret = HTTPRES_OK_NOT_MODIFIED;
	  goto leave;
		}
		else if (rc == 404)
			ret = HTTPRES_NOT_FOUND;
   17f48:	e3a03002 	mov	r3, #2
   17f4c:	e58d3014 	str	r3, [sp, #20]
   17f50:	eaffff84 	b	17d68 <HTTP_get+0x440>
	
	if (rc >= 300)
	{
		if (rc == 304)
		{
	  ret = HTTPRES_OK_NOT_MODIFIED;
   17f54:	e3a03001 	mov	r3, #1
   17f58:	e58d3014 	str	r3, [sp, #20]
   17f5c:	eaffff58 	b	17cc4 <HTTP_get+0x39c>
   17f60:	00004014 	.word	0x00004014
   17f64:	0000983c 	.word	0x0000983c
   17f68:	0000c444 	.word	0x0000c444
   17f6c:	00006b70 	.word	0x00006b70
   17f70:	000065a4 	.word	0x000065a4
   17f74:	ffffffb4 	.word	0xffffffb4
   17f78:	000001bb 	.word	0x000001bb
   17f7c:	00007138 	.word	0x00007138
   17f80:	00007134 	.word	0x00007134
   17f84:	00007148 	.word	0x00007148
   17f88:	ffffffb0 	.word	0xffffffb0
   17f8c:	ffffffd8 	.word	0xffffffd8
   17f90:	ffffffdc 	.word	0xffffffdc
   17f94:	ffffffe0 	.word	0xffffffe0
   17f98:	00007090 	.word	0x00007090
   17f9c:	000094cc 	.word	0x000094cc
   17fa0:	00006fec 	.word	0x00006fec
   17fa4:	00009d84 	.word	0x00009d84
   17fa8:	00006fb0 	.word	0x00006fb0
   17fac:	0000941c 	.word	0x0000941c
   17fb0:	00006bbc 	.word	0x00006bbc
   17fb4:	00009b70 	.word	0x00009b70

00017fb8 <RTMP_HashSWF>:
#define HEX2BIN(a)      (((a)&0x40)?((a)&0xf)+9:((a)&0xf))

int
RTMP_HashSWF(const char *url, unsigned int *size, unsigned char *hash,
	     int age)
{
   17fb8:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   17fbc:	e24ddc12 	sub	sp, sp, #4608	; 0x1200
   17fc0:	e24dd00c 	sub	sp, sp, #12
  char *path, date[64], cctim[64];
  long pos = 0;
  time_t ctim = -1, cnow;
  int i, got = 0, ret = 0;
  unsigned int hlen;
  struct info in = { 0 };
   17fc4:	e28d4f82 	add	r4, sp, #520	; 0x208
#define HEX2BIN(a)      (((a)&0x40)?((a)&0xf)+9:((a)&0xf))

int
RTMP_HashSWF(const char *url, unsigned int *size, unsigned char *hash,
	     int age)
{
   17fc8:	e58d101c 	str	r1, [sp, #28]
   17fcc:	e58d2018 	str	r2, [sp, #24]
  char *path, date[64], cctim[64];
  long pos = 0;
  time_t ctim = -1, cnow;
  int i, got = 0, ret = 0;
  unsigned int hlen;
  struct info in = { 0 };
   17fd0:	e3a01000 	mov	r1, #0
   17fd4:	e3a020fc 	mov	r2, #252	; 0xfc
#define HEX2BIN(a)      (((a)&0x40)?((a)&0xf)+9:((a)&0xf))

int
RTMP_HashSWF(const char *url, unsigned int *size, unsigned char *hash,
	     int age)
{
   17fd8:	e58d3030 	str	r3, [sp, #48]	; 0x30
   17fdc:	e1a07000 	mov	r7, r0
  int i, got = 0, ret = 0;
  unsigned int hlen;
  struct info in = { 0 };
  struct HTTP_ctx http = { 0 };
  HTTPResult httpres;
  z_stream zs = { 0 };
   17fe0:	e28d30c8 	add	r3, sp, #200	; 0xc8
  char *path, date[64], cctim[64];
  long pos = 0;
  time_t ctim = -1, cnow;
  int i, got = 0, ret = 0;
  unsigned int hlen;
  struct info in = { 0 };
   17fe4:	e24400fc 	sub	r0, r4, #252	; 0xfc
  struct HTTP_ctx http = { 0 };
  HTTPResult httpres;
  z_stream zs = { 0 };
   17fe8:	e1a05003 	mov	r5, r3
   17fec:	e58d302c 	str	r3, [sp, #44]	; 0x2c
  char *path, date[64], cctim[64];
  long pos = 0;
  time_t ctim = -1, cnow;
  int i, got = 0, ret = 0;
  unsigned int hlen;
  struct info in = { 0 };
   17ff0:	ebffb436 	bl	50d0 <memset@plt>
#define DIRSEP	"\\"

#else /* !_WIN32 */
  hpre.av_val = "";
  hpre.av_len = 0;
  home.av_val = getenv("HOME");
   17ff4:	e59f0b70 	ldr	r0, [pc, #2928]	; 18b6c <RTMP_HashSWF+0xbb4>
  long pos = 0;
  time_t ctim = -1, cnow;
  int i, got = 0, ret = 0;
  unsigned int hlen;
  struct info in = { 0 };
  struct HTTP_ctx http = { 0 };
   17ff8:	e3a03000 	mov	r3, #0
#define DIRSEP	"\\"

#else /* !_WIN32 */
  hpre.av_val = "";
  hpre.av_len = 0;
  home.av_val = getenv("HOME");
   17ffc:	e08f0000 	add	r0, pc, r0
  int i, got = 0, ret = 0;
  unsigned int hlen;
  struct info in = { 0 };
  struct HTTP_ctx http = { 0 };
  HTTPResult httpres;
  z_stream zs = { 0 };
   18000:	e5853000 	str	r3, [r5]
  long pos = 0;
  time_t ctim = -1, cnow;
  int i, got = 0, ret = 0;
  unsigned int hlen;
  struct info in = { 0 };
  struct HTTP_ctx http = { 0 };
   18004:	e50431b0 	str	r3, [r4, #-432]	; 0xfffffe50
   18008:	e50431ac 	str	r3, [r4, #-428]	; 0xfffffe54
   1800c:	e50431a8 	str	r3, [r4, #-424]	; 0xfffffe58
   18010:	e50431a4 	str	r3, [r4, #-420]	; 0xfffffe5c
  HTTPResult httpres;
  z_stream zs = { 0 };
   18014:	e5043174 	str	r3, [r4, #-372]	; 0xfffffe8c
   18018:	e5043170 	str	r3, [r4, #-368]	; 0xfffffe90
   1801c:	e504316c 	str	r3, [r4, #-364]	; 0xfffffe94
   18020:	e5043168 	str	r3, [r4, #-360]	; 0xfffffe98
   18024:	e5043164 	str	r3, [r4, #-356]	; 0xfffffe9c
   18028:	e5043160 	str	r3, [r4, #-352]	; 0xfffffea0
   1802c:	e504315c 	str	r3, [r4, #-348]	; 0xfffffea4
   18030:	e5043158 	str	r3, [r4, #-344]	; 0xfffffea8
   18034:	e5043154 	str	r3, [r4, #-340]	; 0xfffffeac
   18038:	e5043150 	str	r3, [r4, #-336]	; 0xfffffeb0
   1803c:	e504314c 	str	r3, [r4, #-332]	; 0xfffffeb4
   18040:	e5043148 	str	r3, [r4, #-328]	; 0xfffffeb8
   18044:	e5043144 	str	r3, [r4, #-324]	; 0xfffffebc
  AVal home, hpre;

  date[0] = '\0';
   18048:	e544313c 	strb	r3, [r4, #-316]	; 0xfffffec4
#define DIRSEP	"\\"

#else /* !_WIN32 */
  hpre.av_val = "";
  hpre.av_len = 0;
  home.av_val = getenv("HOME");
   1804c:	ebffb53f 	bl	5550 <getenv@plt>
#define DIRSEP	"/"
#endif
  if (!home.av_val)
   18050:	e2505000 	subs	r5, r0, #0
   18054:	0a000228 	beq	188fc <RTMP_HashSWF+0x944>
   18058:	ebffb428 	bl	5100 <strlen@plt>
   1805c:	e280000a 	add	r0, r0, #10
   * hash: SWF hash in hex
   *
   * These fields must be present in this order. All fields
   * besides URL are fixed size.
   */
  path = malloc(hpre.av_len + home.av_len + sizeof(DIRSEP ".swfinfo"));
   18060:	ebffb3ed 	bl	501c <malloc@plt>
  sprintf(path, "%s%s" DIRSEP ".swfinfo", hpre.av_val, home.av_val);
   18064:	e59f1b04 	ldr	r1, [pc, #2820]	; 18b70 <RTMP_HashSWF+0xbb8>
   18068:	e59f2b04 	ldr	r2, [pc, #2820]	; 18b74 <RTMP_HashSWF+0xbbc>
   1806c:	e1a03005 	mov	r3, r5
   18070:	e08f1001 	add	r1, pc, r1
   18074:	e08f2002 	add	r2, pc, r2
   * hash: SWF hash in hex
   *
   * These fields must be present in this order. All fields
   * besides URL are fixed size.
   */
  path = malloc(hpre.av_len + home.av_len + sizeof(DIRSEP ".swfinfo"));
   18078:	e1a06000 	mov	r6, r0
   1807c:	e58d0024 	str	r0, [sp, #36]	; 0x24
  sprintf(path, "%s%s" DIRSEP ".swfinfo", hpre.av_val, home.av_val);
   18080:	ebffb439 	bl	516c <sprintf@plt>

  f = fopen(path, "r+");
   18084:	e59f1aec 	ldr	r1, [pc, #2796]	; 18b78 <RTMP_HashSWF+0xbc0>
   18088:	e1a00006 	mov	r0, r6
   1808c:	e08f1001 	add	r1, pc, r1
   18090:	ebffb531 	bl	555c <fopen@plt>
  while (f)
   18094:	e2506000 	subs	r6, r0, #0
   18098:	0a0000ab 	beq	1834c <RTMP_HashSWF+0x394>
    {
      char buf[4096], *file, *p;

      file = strchr(url, '/');
   1809c:	e1a00007 	mov	r0, r7
   180a0:	e3a0102f 	mov	r1, #47	; 0x2f
   180a4:	ebffb40f 	bl	50e8 <strchr@plt>
      if (!file)
   180a8:	e3500000 	cmp	r0, #0
   180ac:	0a0000ed 	beq	18468 <RTMP_HashSWF+0x4b0>
	break;
      file += 2;
      file = strchr(file, '/');
   180b0:	e2800002 	add	r0, r0, #2
   180b4:	e3a0102f 	mov	r1, #47	; 0x2f
   180b8:	ebffb40a 	bl	50e8 <strchr@plt>
      if (!file)
   180bc:	e250b000 	subs	fp, r0, #0
   180c0:	0a0000e8 	beq	18468 <RTMP_HashSWF+0x4b0>
	break;
      file++;
   180c4:	e28b8001 	add	r8, fp, #1
      hlen = file - url;
      p = strrchr(file, '/');
   180c8:	e1a00008 	mov	r0, r8
   180cc:	e3a0102f 	mov	r1, #47	; 0x2f
   180d0:	ebffb4cd 	bl	540c <strrchr@plt>
	{
	  char *r1;

	  got = 0;

	  if (strncmp(buf, "url: ", 5))
   180d4:	e59f9aa0 	ldr	r9, [pc, #2720]	; 18b7c <RTMP_HashSWF+0xbc4>
      file += 2;
      file = strchr(file, '/');
      if (!file)
	break;
      file++;
      hlen = file - url;
   180d8:	e0678008 	rsb	r8, r7, r8
	{
	  char *r1;

	  got = 0;

	  if (strncmp(buf, "url: ", 5))
   180dc:	e08f9009 	add	r9, pc, r9
	    continue;
	  if (strncmp(buf + 5, url, hlen))
   180e0:	e284a005 	add	sl, r4, #5
      if (!file)
	break;
      file++;
      hlen = file - url;
      p = strrchr(file, '/');
      if (p)
   180e4:	e3500000 	cmp	r0, #0
   180e8:	11a0b000 	movne	fp, r0
   180ec:	e58db020 	str	fp, [sp, #32]
	file = p;
      else
	file--;

      while (fgets(buf, sizeof(buf), f))
   180f0:	e3a01a01 	mov	r1, #4096	; 0x1000
   180f4:	e1a02006 	mov	r2, r6
   180f8:	e1a00004 	mov	r0, r4
   180fc:	ebffb519 	bl	5568 <fgets@plt>
	{
	  char *r1;

	  got = 0;

	  if (strncmp(buf, "url: ", 5))
   18100:	e1a01009 	mov	r1, r9
   18104:	e3a02005 	mov	r2, #5
      if (p)
	file = p;
      else
	file--;

      while (fgets(buf, sizeof(buf), f))
   18108:	e3500000 	cmp	r0, #0
	{
	  char *r1;

	  got = 0;

	  if (strncmp(buf, "url: ", 5))
   1810c:	e1a00004 	mov	r0, r4
      if (p)
	file = p;
      else
	file--;

      while (fgets(buf, sizeof(buf), f))
   18110:	0a0000d4 	beq	18468 <RTMP_HashSWF+0x4b0>
	{
	  char *r1;

	  got = 0;

	  if (strncmp(buf, "url: ", 5))
   18114:	ebffb4a7 	bl	53b8 <strncmp@plt>
	    continue;
	  if (strncmp(buf + 5, url, hlen))
   18118:	e1a02008 	mov	r2, r8
   1811c:	e1a01007 	mov	r1, r7
	{
	  char *r1;

	  got = 0;

	  if (strncmp(buf, "url: ", 5))
   18120:	e3500000 	cmp	r0, #0
	    continue;
	  if (strncmp(buf + 5, url, hlen))
   18124:	e1a0000a 	mov	r0, sl
	{
	  char *r1;

	  got = 0;

	  if (strncmp(buf, "url: ", 5))
   18128:	1afffff0 	bne	180f0 <RTMP_HashSWF+0x138>
	    continue;
	  if (strncmp(buf + 5, url, hlen))
   1812c:	ebffb4a1 	bl	53b8 <strncmp@plt>
	    continue;
	  r1 = strrchr(buf, '/');
   18130:	e3a0102f 	mov	r1, #47	; 0x2f

	  got = 0;

	  if (strncmp(buf, "url: ", 5))
	    continue;
	  if (strncmp(buf + 5, url, hlen))
   18134:	e2505000 	subs	r5, r0, #0
	    continue;
	  r1 = strrchr(buf, '/');
   18138:	e1a00004 	mov	r0, r4

	  got = 0;

	  if (strncmp(buf, "url: ", 5))
	    continue;
	  if (strncmp(buf + 5, url, hlen))
   1813c:	1affffeb 	bne	180f0 <RTMP_HashSWF+0x138>
	    continue;
	  r1 = strrchr(buf, '/');
   18140:	ebffb4b1 	bl	540c <strrchr@plt>
   18144:	e1a0b000 	mov	fp, r0
	  i = strlen(r1);
   18148:	ebffb3ec 	bl	5100 <strlen@plt>
	  r1[--i] = '\0';
	  if (strncmp(r1, file, i))
   1814c:	e59d1020 	ldr	r1, [sp, #32]
	    continue;
	  if (strncmp(buf + 5, url, hlen))
	    continue;
	  r1 = strrchr(buf, '/');
	  i = strlen(r1);
	  r1[--i] = '\0';
   18150:	e2402001 	sub	r2, r0, #1
   18154:	e7cb5002 	strb	r5, [fp, r2]
	  if (strncmp(r1, file, i))
   18158:	e1a0000b 	mov	r0, fp
   1815c:	ebffb495 	bl	53b8 <strncmp@plt>
   18160:	e3500000 	cmp	r0, #0
   18164:	1affffe1 	bne	180f0 <RTMP_HashSWF+0x138>
   18168:	e1a05000 	mov	r5, r0
	    continue;
	  pos = ftell(f);
   1816c:	e1a00006 	mov	r0, r6
   18170:	ebffb4ff 	bl	5574 <ftell@plt>
		  int l = strlen((char *)in) - 1;
		  for (i = 0; i < l; i += 2)
		    *ptr++ = (HEX2BIN(in[i]) << 4) | HEX2BIN(in[i + 1]);
		  got++;
		}
	      else if (!strncmp(buf, "date: ", 6))
   18174:	e59f2a04 	ldr	r2, [pc, #2564]	; 18b80 <RTMP_HashSWF+0xbc8>
	      if (!strncmp(buf, "size: ", 6))
		{
		  *size = strtol(buf + 6, NULL, 16);
		  got++;
		}
	      else if (!strncmp(buf, "hash: ", 6))
   18178:	e59f3a04 	ldr	r3, [pc, #2564]	; 18b84 <RTMP_HashSWF+0xbcc>
		  int l = strlen((char *)in) - 1;
		  for (i = 0; i < l; i += 2)
		    *ptr++ = (HEX2BIN(in[i]) << 4) | HEX2BIN(in[i + 1]);
		  got++;
		}
	      else if (!strncmp(buf, "date: ", 6))
   1817c:	e08f2002 	add	r2, pc, r2
   18180:	e58d2020 	str	r2, [sp, #32]
		{
		  buf[strlen(buf) - 1] = '\0';
		  strncpy(date, buf + 6, sizeof(date));
		  got++;
		}
	      else if (!strncmp(buf, "ctim: ", 6))
   18184:	e59f29fc 	ldr	r2, [pc, #2556]	; 18b88 <RTMP_HashSWF+0xbd0>
	  if (strncmp(r1, file, i))
	    continue;
	  pos = ftell(f);
	  while (got < 4 && fgets(buf, sizeof(buf), f))
	    {
	      if (!strncmp(buf, "size: ", 6))
   18188:	e59fb9fc 	ldr	fp, [pc, #2556]	; 18b8c <RTMP_HashSWF+0xbd4>
		{
		  buf[strlen(buf) - 1] = '\0';
		  strncpy(date, buf + 6, sizeof(date));
		  got++;
		}
	      else if (!strncmp(buf, "ctim: ", 6))
   1818c:	e08f2002 	add	r2, pc, r2
   18190:	e58d2028 	str	r2, [sp, #40]	; 0x28
		{
		  buf[strlen(buf) - 1] = '\0';
		  ctim = make_unix_time(buf + 6);
		  got++;
		}
	      else if (!strncmp(buf, "url: ", 5))
   18194:	e59f29f4 	ldr	r2, [pc, #2548]	; 18b90 <RTMP_HashSWF+0xbd8>
	      if (!strncmp(buf, "size: ", 6))
		{
		  *size = strtol(buf + 6, NULL, 16);
		  got++;
		}
	      else if (!strncmp(buf, "hash: ", 6))
   18198:	e08f3003 	add	r3, pc, r3
		{
		  buf[strlen(buf) - 1] = '\0';
		  ctim = make_unix_time(buf + 6);
		  got++;
		}
	      else if (!strncmp(buf, "url: ", 5))
   1819c:	e08f2002 	add	r2, pc, r2
   181a0:	e58d2034 	str	r2, [sp, #52]	; 0x34
    }
  if (time.tm_year > 100)
    time.tm_year -= ysub;

  for (i = 0; i < 12; i++)
    if (!strncasecmp(month, monthtab[i], 3))
   181a4:	e59f29e8 	ldr	r2, [pc, #2536]	; 18b94 <RTMP_HashSWF+0xbdc>
	     int age)
{
  FILE *f = NULL;
  char *path, date[64], cctim[64];
  long pos = 0;
  time_t ctim = -1, cnow;
   181a8:	e3e08000 	mvn	r8, #0
    }
  if (time.tm_year > 100)
    time.tm_year -= ysub;

  for (i = 0; i < 12; i++)
    if (!strncasecmp(month, monthtab[i], 3))
   181ac:	e08f2002 	add	r2, pc, r2
	  if (strncmp(r1, file, i))
	    continue;
	  pos = ftell(f);
	  while (got < 4 && fgets(buf, sizeof(buf), f))
	    {
	      if (!strncmp(buf, "size: ", 6))
   181b0:	e08fb00b 	add	fp, pc, fp
   181b4:	e1a09003 	mov	r9, r3
    }
  if (time.tm_year > 100)
    time.tm_year -= ysub;

  for (i = 0; i < 12; i++)
    if (!strncasecmp(month, monthtab[i], 3))
   181b8:	e58d2040 	str	r2, [sp, #64]	; 0x40
   181bc:	e58d7044 	str	r7, [sp, #68]	; 0x44
	  r1 = strrchr(buf, '/');
	  i = strlen(r1);
	  r1[--i] = '\0';
	  if (strncmp(r1, file, i))
	    continue;
	  pos = ftell(f);
   181c0:	e58d0038 	str	r0, [sp, #56]	; 0x38
	  while (got < 4 && fgets(buf, sizeof(buf), f))
   181c4:	e1a00004 	mov	r0, r4
   181c8:	e3a01a01 	mov	r1, #4096	; 0x1000
   181cc:	e1a02006 	mov	r2, r6
   181d0:	ebffb4e4 	bl	5568 <fgets@plt>
   181d4:	e3500000 	cmp	r0, #0
   181d8:	0a000028 	beq	18280 <RTMP_HashSWF+0x2c8>
	    {
	      if (!strncmp(buf, "size: ", 6))
   181dc:	e1a0100b 	mov	r1, fp
   181e0:	e1a00004 	mov	r0, r4
   181e4:	e3a02006 	mov	r2, #6
   181e8:	ebffb472 	bl	53b8 <strncmp@plt>
   181ec:	e2501000 	subs	r1, r0, #0
   181f0:	0a00004e 	beq	18330 <RTMP_HashSWF+0x378>
		{
		  *size = strtol(buf + 6, NULL, 16);
		  got++;
		}
	      else if (!strncmp(buf, "hash: ", 6))
   181f4:	e1a00004 	mov	r0, r4
   181f8:	e1a01009 	mov	r1, r9
   181fc:	e3a02006 	mov	r2, #6
   18200:	ebffb46c 	bl	53b8 <strncmp@plt>
   18204:	e3500000 	cmp	r0, #0
   18208:	1a000035 	bne	182e4 <RTMP_HashSWF+0x32c>
		{
		  unsigned char *ptr = hash, *in = (unsigned char *)buf + 6;
		  int l = strlen((char *)in) - 1;
   1820c:	e2840006 	add	r0, r4, #6
   18210:	ebffb3ba 	bl	5100 <strlen@plt>
   18214:	e2403001 	sub	r3, r0, #1
		  for (i = 0; i < l; i += 2)
   18218:	e3530000 	cmp	r3, #0
   1821c:	da000014 	ble	18274 <RTMP_HashSWF+0x2bc>
   18220:	e59d3018 	ldr	r3, [sp, #24]
   18224:	e2400002 	sub	r0, r0, #2
   18228:	e08300a0 	add	r0, r3, r0, lsr #1
   1822c:	e1a01004 	mov	r1, r4
   18230:	e243c001 	sub	ip, r3, #1
		    *ptr++ = (HEX2BIN(in[i]) << 4) | HEX2BIN(in[i + 1]);
   18234:	e5d12006 	ldrb	r2, [r1, #6]
   18238:	e5d17007 	ldrb	r7, [r1, #7]
   1823c:	e202300f 	and	r3, r2, #15
   18240:	e3120040 	tst	r2, #64	; 0x40
   18244:	e2833009 	add	r3, r3, #9
   18248:	11a02203 	lslne	r2, r3, #4
   1824c:	01a02202 	lsleq	r2, r2, #4
   18250:	e207e00f 	and	lr, r7, #15
   18254:	e3170040 	tst	r7, #64	; 0x40
   18258:	e28e3009 	add	r3, lr, #9
   1825c:	01a0300e 	moveq	r3, lr
   18260:	e1823003 	orr	r3, r2, r3
   18264:	e5ec3001 	strb	r3, [ip, #1]!
		}
	      else if (!strncmp(buf, "hash: ", 6))
		{
		  unsigned char *ptr = hash, *in = (unsigned char *)buf + 6;
		  int l = strlen((char *)in) - 1;
		  for (i = 0; i < l; i += 2)
   18268:	e15c0000 	cmp	ip, r0
   1826c:	e2811002 	add	r1, r1, #2
   18270:	1affffef 	bne	18234 <RTMP_HashSWF+0x27c>
		}
	      else if (!strncmp(buf, "ctim: ", 6))
		{
		  buf[strlen(buf) - 1] = '\0';
		  ctim = make_unix_time(buf + 6);
		  got++;
   18274:	e2855001 	add	r5, r5, #1
	  i = strlen(r1);
	  r1[--i] = '\0';
	  if (strncmp(r1, file, i))
	    continue;
	  pos = ftell(f);
	  while (got < 4 && fgets(buf, sizeof(buf), f))
   18278:	e3550003 	cmp	r5, #3
   1827c:	daffffd0 	ble	181c4 <RTMP_HashSWF+0x20c>
	  break;
	}
      break;
    }

  cnow = time(NULL);
   18280:	e3a00000 	mov	r0, #0
   18284:	e59d7044 	ldr	r7, [sp, #68]	; 0x44
   18288:	ebffb3d5 	bl	51e4 <time@plt>
  /* If we got a cache time, see if it's young enough to use directly */
  if (age && ctim > 0)
   1828c:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
   18290:	e3510000 	cmp	r1, #0
   18294:	13580000 	cmpne	r8, #0
	  break;
	}
      break;
    }

  cnow = time(NULL);
   18298:	e50401a0 	str	r0, [r4, #-416]	; 0xfffffe60
  /* If we got a cache time, see if it's young enough to use directly */
  if (age && ctim > 0)
   1829c:	da00002e 	ble	1835c <RTMP_HashSWF+0x3a4>
    {
      ctim = cnow - ctim;
      ctim /= 3600 * 24;	/* seconds to days */
   182a0:	e59f38f0 	ldr	r3, [pc, #2288]	; 18b98 <RTMP_HashSWF+0xbe0>

  cnow = time(NULL);
  /* If we got a cache time, see if it's young enough to use directly */
  if (age && ctim > 0)
    {
      ctim = cnow - ctim;
   182a4:	e0688000 	rsb	r8, r8, r0
      ctim /= 3600 * 24;	/* seconds to days */
   182a8:	e0c32398 	smull	r2, r3, r8, r3
   182ac:	e1a02fc8 	asr	r2, r8, #31
   182b0:	e0838008 	add	r8, r3, r8
   182b4:	e0628848 	rsb	r8, r2, r8, asr #16
      if (ctim < age)		/* ok, it's new enough */
   182b8:	e1510008 	cmp	r1, r8
   182bc:	da000026 	ble	1835c <RTMP_HashSWF+0x3a4>
	  fprintf(f, "\n");
	}
    }
  HMAC_close(in.ctx);
out:
  free(path);
   182c0:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
   182c4:	ebffb34e 	bl	5004 <free@plt>
{
  FILE *f = NULL;
  char *path, date[64], cctim[64];
  long pos = 0;
  time_t ctim = -1, cnow;
  int i, got = 0, ret = 0;
   182c8:	e3a04000 	mov	r4, #0
    }
  HMAC_close(in.ctx);
out:
  free(path);
  if (f)
    fclose(f);
   182cc:	e1a00006 	mov	r0, r6
   182d0:	ebffb4aa 	bl	5580 <fclose@plt>
  return ret;
}
   182d4:	e1a00004 	mov	r0, r4
   182d8:	e28ddc12 	add	sp, sp, #4608	; 0x1200
   182dc:	e28dd00c 	add	sp, sp, #12
   182e0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
		  int l = strlen((char *)in) - 1;
		  for (i = 0; i < l; i += 2)
		    *ptr++ = (HEX2BIN(in[i]) << 4) | HEX2BIN(in[i + 1]);
		  got++;
		}
	      else if (!strncmp(buf, "date: ", 6))
   182e4:	e1a00004 	mov	r0, r4
   182e8:	e59d1020 	ldr	r1, [sp, #32]
   182ec:	e3a02006 	mov	r2, #6
   182f0:	ebffb430 	bl	53b8 <strncmp@plt>
   182f4:	e2507000 	subs	r7, r0, #0
		{
		  buf[strlen(buf) - 1] = '\0';
   182f8:	e1a00004 	mov	r0, r4
		  int l = strlen((char *)in) - 1;
		  for (i = 0; i < l; i += 2)
		    *ptr++ = (HEX2BIN(in[i]) << 4) | HEX2BIN(in[i + 1]);
		  got++;
		}
	      else if (!strncmp(buf, "date: ", 6))
   182fc:	0a000050 	beq	18444 <RTMP_HashSWF+0x48c>
		{
		  buf[strlen(buf) - 1] = '\0';
		  strncpy(date, buf + 6, sizeof(date));
		  got++;
		}
	      else if (!strncmp(buf, "ctim: ", 6))
   18300:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
   18304:	e3a02006 	mov	r2, #6
   18308:	ebffb42a 	bl	53b8 <strncmp@plt>
   1830c:	e2507000 	subs	r7, r0, #0
		{
		  buf[strlen(buf) - 1] = '\0';
   18310:	e1a00004 	mov	r0, r4
		{
		  buf[strlen(buf) - 1] = '\0';
		  strncpy(date, buf + 6, sizeof(date));
		  got++;
		}
	      else if (!strncmp(buf, "ctim: ", 6))
   18314:	0a000059 	beq	18480 <RTMP_HashSWF+0x4c8>
		{
		  buf[strlen(buf) - 1] = '\0';
		  ctim = make_unix_time(buf + 6);
		  got++;
		}
	      else if (!strncmp(buf, "url: ", 5))
   18318:	e59d1034 	ldr	r1, [sp, #52]	; 0x34
   1831c:	e3a02005 	mov	r2, #5
   18320:	ebffb424 	bl	53b8 <strncmp@plt>
   18324:	e3500000 	cmp	r0, #0
   18328:	1affffd2 	bne	18278 <RTMP_HashSWF+0x2c0>
   1832c:	eaffffd3 	b	18280 <RTMP_HashSWF+0x2c8>
	  pos = ftell(f);
	  while (got < 4 && fgets(buf, sizeof(buf), f))
	    {
	      if (!strncmp(buf, "size: ", 6))
		{
		  *size = strtol(buf + 6, NULL, 16);
   18330:	e2840006 	add	r0, r4, #6
   18334:	e3a02010 	mov	r2, #16
   18338:	ebffb3eb 	bl	52ec <strtol@plt>
   1833c:	e59d301c 	ldr	r3, [sp, #28]
		  got++;
   18340:	e2855001 	add	r5, r5, #1
	  pos = ftell(f);
	  while (got < 4 && fgets(buf, sizeof(buf), f))
	    {
	      if (!strncmp(buf, "size: ", 6))
		{
		  *size = strtol(buf + 6, NULL, 16);
   18344:	e5830000 	str	r0, [r3]
   18348:	eaffffca 	b	18278 <RTMP_HashSWF+0x2c0>
	  break;
	}
      break;
    }

  cnow = time(NULL);
   1834c:	ebffb3a4 	bl	51e4 <time@plt>
{
  FILE *f = NULL;
  char *path, date[64], cctim[64];
  long pos = 0;
  time_t ctim = -1, cnow;
  int i, got = 0, ret = 0;
   18350:	e1a05006 	mov	r5, r6
RTMP_HashSWF(const char *url, unsigned int *size, unsigned char *hash,
	     int age)
{
  FILE *f = NULL;
  char *path, date[64], cctim[64];
  long pos = 0;
   18354:	e58d6038 	str	r6, [sp, #56]	; 0x38
	  break;
	}
      break;
    }

  cnow = time(NULL);
   18358:	e50401a0 	str	r0, [r4, #-416]	; 0xfffffe60
	goto out;
    }

  in.first = 1;
  HMAC_setup(in.ctx, "Genuine Adobe Flash Player 001", 30);
  inflateInit(&zs);
   1835c:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
      if (ctim < age)		/* ok, it's new enough */
	goto out;
    }

  in.first = 1;
  HMAC_setup(in.ctx, "Genuine Adobe Flash Player 001", 30);
   18360:	e59f1834 	ldr	r1, [pc, #2100]	; 18b9c <RTMP_HashSWF+0xbe4>
   18364:	e28d9f52 	add	r9, sp, #328	; 0x148
      ctim /= 3600 * 24;	/* seconds to days */
      if (ctim < age)		/* ok, it's new enough */
	goto out;
    }

  in.first = 1;
   18368:	e3a0c001 	mov	ip, #1
  HMAC_setup(in.ctx, "Genuine Adobe Flash Player 001", 30);
  inflateInit(&zs);
   1836c:	e2438034 	sub	r8, r3, #52	; 0x34
      if (ctim < age)		/* ok, it's new enough */
	goto out;
    }

  in.first = 1;
  HMAC_setup(in.ctx, "Genuine Adobe Flash Player 001", 30);
   18370:	e2490038 	sub	r0, r9, #56	; 0x38
   18374:	e3a03000 	mov	r3, #0
   18378:	e08f1001 	add	r1, pc, r1
   1837c:	e3a0201e 	mov	r2, #30
      ctim /= 3600 * 24;	/* seconds to days */
      if (ctim < age)		/* ok, it's new enough */
	goto out;
    }

  in.first = 1;
   18380:	e504c00c 	str	ip, [r4, #-12]
   18384:	e58dc028 	str	ip, [sp, #40]	; 0x28
  HMAC_setup(in.ctx, "Genuine Adobe Flash Player 001", 30);
   18388:	ebffb344 	bl	50a0 <sha2_hmac_starts@plt>
  inflateInit(&zs);
   1838c:	e59f180c 	ldr	r1, [pc, #2060]	; 18ba0 <RTMP_HashSWF+0xbe8>
   18390:	e3a02038 	mov	r2, #56	; 0x38
   18394:	e08f1001 	add	r1, pc, r1
   18398:	e1a00008 	mov	r0, r8
   1839c:	ebffb47a 	bl	558c <inflateInit_@plt>
  in.zs = &zs;

  http.date = date;
  http.data = &in;

  httpres = HTTP_get(&http, url, swfcrunch);
   183a0:	e59f27fc 	ldr	r2, [pc, #2044]	; 18ba4 <RTMP_HashSWF+0xbec>
   183a4:	e28db088 	add	fp, sp, #136	; 0x88
      if (ctim < age)		/* ok, it's new enough */
	goto out;
    }

  in.first = 1;
  HMAC_setup(in.ctx, "Genuine Adobe Flash Player 001", 30);
   183a8:	e249303c 	sub	r3, r9, #60	; 0x3c
  in.zs = &zs;

  http.date = date;
  http.data = &in;

  httpres = HTTP_get(&http, url, swfcrunch);
   183ac:	e1a01007 	mov	r1, r7
   183b0:	e08f2002 	add	r2, pc, r2
  in.first = 1;
  HMAC_setup(in.ctx, "Genuine Adobe Flash Player 001", 30);
  inflateInit(&zs);
  in.zs = &zs;

  http.date = date;
   183b4:	e28da0cc 	add	sl, sp, #204	; 0xcc
  http.data = &in;

  httpres = HTTP_get(&http, url, swfcrunch);
   183b8:	e24b0030 	sub	r0, fp, #48	; 0x30
  HMAC_setup(in.ctx, "Genuine Adobe Flash Player 001", 30);
  inflateInit(&zs);
  in.zs = &zs;

  http.date = date;
  http.data = &in;
   183bc:	e50431a4 	str	r3, [r4, #-420]	; 0xfffffe5c
    }

  in.first = 1;
  HMAC_setup(in.ctx, "Genuine Adobe Flash Player 001", 30);
  inflateInit(&zs);
  in.zs = &zs;
   183c0:	e50480fc 	str	r8, [r4, #-252]	; 0xffffff04

  http.date = date;
   183c4:	e504a1b0 	str	sl, [r4, #-432]	; 0xfffffe50
  http.data = &in;

  httpres = HTTP_get(&http, url, swfcrunch);
   183c8:	ebfffd56 	bl	17928 <HTTP_get>
   183cc:	e58d0020 	str	r0, [sp, #32]

  inflateEnd(&zs);
   183d0:	e1a00008 	mov	r0, r8
   183d4:	ebffb46f 	bl	5598 <inflateEnd@plt>

  if (httpres != HTTPRES_OK && httpres != HTTPRES_OK_NOT_MODIFIED)
   183d8:	e59d3020 	ldr	r3, [sp, #32]
   183dc:	e59dc028 	ldr	ip, [sp, #40]	; 0x28
   183e0:	e3530001 	cmp	r3, #1
   183e4:	9a0000e5 	bls	18780 <RTMP_HashSWF+0x7c8>
    {
      ret = -1;
      if (httpres == HTTPRES_LOST_CONNECTION)
   183e8:	e3530006 	cmp	r3, #6
   183ec:	0a0001d4 	beq	18b44 <RTMP_HashSWF+0xb8c>
	RTMP_Log(RTMP_LOGERROR, "%s: connection lost while downloading swfurl %s",
	    __FUNCTION__, url);
      else if (httpres == HTTPRES_NOT_FOUND)
   183f0:	e3530002 	cmp	r3, #2
   183f4:	0a000147 	beq	18918 <RTMP_HashSWF+0x960>
	RTMP_Log(RTMP_LOGERROR, "%s: swfurl %s not found", __FUNCTION__, url);
      else
	RTMP_Log(RTMP_LOGERROR, "%s: couldn't contact swfurl %s (HTTP error %d)",
   183f8:	e59f27a8 	ldr	r2, [pc, #1960]	; 18ba8 <RTMP_HashSWF+0xbf0>
   183fc:	e59f17a8 	ldr	r1, [pc, #1960]	; 18bac <RTMP_HashSWF+0xbf4>
   18400:	e51431a8 	ldr	r3, [r4, #-424]	; 0xfffffe58
   18404:	e08f2002 	add	r2, pc, r2
   18408:	e58d3000 	str	r3, [sp]
   1840c:	e1a0000c 	mov	r0, ip
   18410:	e1a03007 	mov	r3, r7
   18414:	e282200c 	add	r2, r2, #12
   18418:	e08f1001 	add	r1, pc, r1
   1841c:	ebfff562 	bl	159ac <RTMP_Log>

  inflateEnd(&zs);

  if (httpres != HTTPRES_OK && httpres != HTTPRES_OK_NOT_MODIFIED)
    {
      ret = -1;
   18420:	e3e04000 	mvn	r4, #0
	  fprintf(f, "\n");
	}
    }
  HMAC_close(in.ctx);
out:
  free(path);
   18424:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
   18428:	ebffb2f5 	bl	5004 <free@plt>
  if (f)
   1842c:	e3560000 	cmp	r6, #0
   18430:	1affffa5 	bne	182cc <RTMP_HashSWF+0x314>
    fclose(f);
  return ret;
}
   18434:	e1a00004 	mov	r0, r4
   18438:	e28ddc12 	add	sp, sp, #4608	; 0x1200
   1843c:	e28dd00c 	add	sp, sp, #12
   18440:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
		    *ptr++ = (HEX2BIN(in[i]) << 4) | HEX2BIN(in[i + 1]);
		  got++;
		}
	      else if (!strncmp(buf, "date: ", 6))
		{
		  buf[strlen(buf) - 1] = '\0';
   18444:	ebffb32d 	bl	5100 <strlen@plt>
		  strncpy(date, buf + 6, sizeof(date));
   18448:	e2841006 	add	r1, r4, #6
   1844c:	e3a02040 	mov	r2, #64	; 0x40
		  got++;
   18450:	e2855001 	add	r5, r5, #1
		    *ptr++ = (HEX2BIN(in[i]) << 4) | HEX2BIN(in[i + 1]);
		  got++;
		}
	      else if (!strncmp(buf, "date: ", 6))
		{
		  buf[strlen(buf) - 1] = '\0';
   18454:	e0843000 	add	r3, r4, r0
		  strncpy(date, buf + 6, sizeof(date));
   18458:	e28d00cc 	add	r0, sp, #204	; 0xcc
		    *ptr++ = (HEX2BIN(in[i]) << 4) | HEX2BIN(in[i + 1]);
		  got++;
		}
	      else if (!strncmp(buf, "date: ", 6))
		{
		  buf[strlen(buf) - 1] = '\0';
   1845c:	e5437001 	strb	r7, [r3, #-1]
		  strncpy(date, buf + 6, sizeof(date));
   18460:	ebffb347 	bl	5184 <strncpy@plt>
   18464:	eaffff83 	b	18278 <RTMP_HashSWF+0x2c0>
	  break;
	}
      break;
    }

  cnow = time(NULL);
   18468:	e3a00000 	mov	r0, #0
   1846c:	ebffb35c 	bl	51e4 <time@plt>
   18470:	e3a05000 	mov	r5, #0
   18474:	e58d5038 	str	r5, [sp, #56]	; 0x38
   18478:	e50401a0 	str	r0, [r4, #-416]	; 0xfffffe60
   1847c:	eaffffb6 	b	1835c <RTMP_HashSWF+0x3a4>
		  strncpy(date, buf + 6, sizeof(date));
		  got++;
		}
	      else if (!strncmp(buf, "ctim: ", 6))
		{
		  buf[strlen(buf) - 1] = '\0';
   18480:	ebffb31e 	bl	5100 <strlen@plt>
   18484:	e0840000 	add	r0, r4, r0
   18488:	e5407001 	strb	r7, [r0, #-1]
  int i, ysub = 1900, fmt = 0;
  char *month;
  char *n;
  time_t res;

  if (s[3] != ' ')
   1848c:	e5d41009 	ldrb	r1, [r4, #9]
   18490:	e3510020 	cmp	r1, #32
   18494:	0a000166 	beq	18a34 <RTMP_HashSWF+0xa7c>
    {
      fmt = 1;
      if (s[3] != ',')
	ysub = 0;
    }
  for (n = s; *n; ++n)
   18498:	e5d48006 	ldrb	r8, [r4, #6]

  if (s[3] != ' ')
    {
      fmt = 1;
      if (s[3] != ',')
	ysub = 0;
   1849c:	e351002c 	cmp	r1, #44	; 0x2c
   184a0:	e59f3708 	ldr	r3, [pc, #1800]	; 18bb0 <RTMP_HashSWF+0xbf8>
    }
  for (n = s; *n; ++n)
   184a4:	e2840006 	add	r0, r4, #6

  if (s[3] != ' ')
    {
      fmt = 1;
      if (s[3] != ',')
	ysub = 0;
   184a8:	13a03000 	movne	r3, #0
    }
  for (n = s; *n; ++n)
   184ac:	e3580000 	cmp	r8, #0

  if (s[3] != ' ')
    {
      fmt = 1;
      if (s[3] != ',')
	ysub = 0;
   184b0:	e58d3048 	str	r3, [sp, #72]	; 0x48
    }
  for (n = s; *n; ++n)
   184b4:	e50401b8 	str	r0, [r4, #-440]	; 0xfffffe48
   184b8:	0a000120 	beq	18940 <RTMP_HashSWF+0x988>
   184bc:	e3a07001 	mov	r7, #1
   184c0:	e2842006 	add	r2, r4, #6
    if (*n == '-' || *n == ':')
      *n = ' ';
   184c4:	e3a01020 	mov	r1, #32
      fmt = 1;
      if (s[3] != ',')
	ysub = 0;
    }
  for (n = s; *n; ++n)
    if (*n == '-' || *n == ':')
   184c8:	e358002d 	cmp	r8, #45	; 0x2d
   184cc:	1358003a 	cmpne	r8, #58	; 0x3a
      *n = ' ';
   184d0:	05c21000 	strbeq	r1, [r2]
    {
      fmt = 1;
      if (s[3] != ',')
	ysub = 0;
    }
  for (n = s; *n; ++n)
   184d4:	e51431b8 	ldr	r3, [r4, #-440]	; 0xfffffe48
   184d8:	e2832001 	add	r2, r3, #1
   184dc:	e50421b8 	str	r2, [r4, #-440]	; 0xfffffe48
   184e0:	e5d38001 	ldrb	r8, [r3, #1]
   184e4:	e3580000 	cmp	r8, #0
   184e8:	1afffff6 	bne	184c8 <RTMP_HashSWF+0x510>
    if (*n == '-' || *n == ':')
      *n = ' ';

  time.tm_mon = 0;
  n = strchr(s, ' ');
   184ec:	e2840006 	add	r0, r4, #6
   184f0:	e3a01020 	mov	r1, #32
    }
  for (n = s; *n; ++n)
    if (*n == '-' || *n == ':')
      *n = ' ';

  time.tm_mon = 0;
   184f4:	e5048190 	str	r8, [r4, #-400]	; 0xfffffe70
  n = strchr(s, ' ');
   184f8:	ebffb2fa 	bl	50e8 <strchr@plt>
  if (fmt)
   184fc:	e3570000 	cmp	r7, #0
  for (n = s; *n; ++n)
    if (*n == '-' || *n == ':')
      *n = ' ';

  time.tm_mon = 0;
  n = strchr(s, ' ');
   18500:	e50401b8 	str	r0, [r4, #-440]	; 0xfffffe48
  if (fmt)
   18504:	1a000111 	bne	18950 <RTMP_HashSWF+0x998>
    }
  else
    {
      /* Unix ctime() format. Does not conform to HTTP spec. */
      /* Day MMM DD HH:MM:SS YYYY */
      month = n + 1;
   18508:	e2807001 	add	r7, r0, #1
      n = strchr(month, ' ');
   1850c:	e1a00007 	mov	r0, r7
   18510:	e3a01020 	mov	r1, #32
   18514:	ebffb2f3 	bl	50e8 <strchr@plt>
   18518:	e50401b8 	str	r0, [r4, #-440]	; 0xfffffe48
   1851c:	e1a08000 	mov	r8, r0
   18520:	ea000000 	b	18528 <RTMP_HashSWF+0x570>
      while (isspace(*n))
	n++;
   18524:	e50481b8 	str	r8, [r4, #-440]	; 0xfffffe48
    {
      /* Unix ctime() format. Does not conform to HTTP spec. */
      /* Day MMM DD HH:MM:SS YYYY */
      month = n + 1;
      n = strchr(month, ' ');
      while (isspace(*n))
   18528:	e5d80000 	ldrb	r0, [r8]
   1852c:	ebffb41c 	bl	55a4 <isspace@plt>
   18530:	e1a0a008 	mov	sl, r8
   18534:	e2888001 	add	r8, r8, #1
   18538:	e3500000 	cmp	r0, #0
   1853c:	1afffff8 	bne	18524 <RTMP_HashSWF+0x56c>
   18540:	e1a03000 	mov	r3, r0
	n++;
      time.tm_mday = strtol(n, &n, 0);
   18544:	e28d8050 	add	r8, sp, #80	; 0x50
   18548:	e28d2088 	add	r2, sp, #136	; 0x88
   1854c:	e58d203c 	str	r2, [sp, #60]	; 0x3c
   18550:	e1a01008 	mov	r1, r8
   18554:	e1a02003 	mov	r2, r3
   18558:	e1a0000a 	mov	r0, sl
   1855c:	e58d304c 	str	r3, [sp, #76]	; 0x4c
   18560:	ebffb361 	bl	52ec <strtol@plt>
      time.tm_hour = strtol(n + 1, &n, 0);
   18564:	e514c1b8 	ldr	ip, [r4, #-440]	; 0xfffffe48
   18568:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
   1856c:	e1a01008 	mov	r1, r8
   18570:	e1a02003 	mov	r2, r3
      /* Day MMM DD HH:MM:SS YYYY */
      month = n + 1;
      n = strchr(month, ' ');
      while (isspace(*n))
	n++;
      time.tm_mday = strtol(n, &n, 0);
   18574:	e5040194 	str	r0, [r4, #-404]	; 0xfffffe6c
      time.tm_hour = strtol(n + 1, &n, 0);
   18578:	e28c0001 	add	r0, ip, #1
   1857c:	ebffb35a 	bl	52ec <strtol@plt>
      time.tm_min = strtol(n + 1, &n, 0);
   18580:	e514c1b8 	ldr	ip, [r4, #-440]	; 0xfffffe48
   18584:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
   18588:	e1a01008 	mov	r1, r8
   1858c:	e1a02003 	mov	r2, r3
      month = n + 1;
      n = strchr(month, ' ');
      while (isspace(*n))
	n++;
      time.tm_mday = strtol(n, &n, 0);
      time.tm_hour = strtol(n + 1, &n, 0);
   18590:	e5040198 	str	r0, [r4, #-408]	; 0xfffffe68
      time.tm_min = strtol(n + 1, &n, 0);
   18594:	e28c0001 	add	r0, ip, #1
   18598:	ebffb353 	bl	52ec <strtol@plt>
      time.tm_sec = strtol(n + 1, &n, 0);
   1859c:	e514c1b8 	ldr	ip, [r4, #-440]	; 0xfffffe48
   185a0:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
   185a4:	e1a01008 	mov	r1, r8
   185a8:	e1a02003 	mov	r2, r3
      n = strchr(month, ' ');
      while (isspace(*n))
	n++;
      time.tm_mday = strtol(n, &n, 0);
      time.tm_hour = strtol(n + 1, &n, 0);
      time.tm_min = strtol(n + 1, &n, 0);
   185ac:	e504019c 	str	r0, [r4, #-412]	; 0xfffffe64
      time.tm_sec = strtol(n + 1, &n, 0);
   185b0:	e28c0001 	add	r0, ip, #1
   185b4:	ebffb34c 	bl	52ec <strtol@plt>
      time.tm_year = strtol(n + 1, NULL, 0);
   185b8:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
   185bc:	e514c1b8 	ldr	ip, [r4, #-440]	; 0xfffffe48
   185c0:	e1a01003 	mov	r1, r3
   185c4:	e1a02003 	mov	r2, r3
      while (isspace(*n))
	n++;
      time.tm_mday = strtol(n, &n, 0);
      time.tm_hour = strtol(n + 1, &n, 0);
      time.tm_min = strtol(n + 1, &n, 0);
      time.tm_sec = strtol(n + 1, &n, 0);
   185c8:	e50401a0 	str	r0, [r4, #-416]	; 0xfffffe60
      time.tm_year = strtol(n + 1, NULL, 0);
   185cc:	e28c0001 	add	r0, ip, #1
   185d0:	ebffb345 	bl	52ec <strtol@plt>
   185d4:	e1a03000 	mov	r3, r0
   185d8:	e504018c 	str	r0, [r4, #-396]	; 0xfffffe74
    }
  if (time.tm_year > 100)
   185dc:	e3530064 	cmp	r3, #100	; 0x64
    time.tm_year -= ysub;
   185e0:	c59d2048 	ldrgt	r2, [sp, #72]	; 0x48

  for (i = 0; i < 12; i++)
    if (!strncasecmp(month, monthtab[i], 3))
   185e4:	e1a00007 	mov	r0, r7
      time.tm_min = strtol(n + 1, &n, 0);
      time.tm_sec = strtol(n + 1, &n, 0);
      time.tm_year = strtol(n + 1, NULL, 0);
    }
  if (time.tm_year > 100)
    time.tm_year -= ysub;
   185e8:	c0623003 	rsbgt	r3, r2, r3

  for (i = 0; i < 12; i++)
    if (!strncasecmp(month, monthtab[i], 3))
   185ec:	e59d1040 	ldr	r1, [sp, #64]	; 0x40
   185f0:	e3a02003 	mov	r2, #3
      time.tm_min = strtol(n + 1, &n, 0);
      time.tm_sec = strtol(n + 1, &n, 0);
      time.tm_year = strtol(n + 1, NULL, 0);
    }
  if (time.tm_year > 100)
    time.tm_year -= ysub;
   185f4:	c504318c 	strgt	r3, [r4, #-396]	; 0xfffffe74

  for (i = 0; i < 12; i++)
    if (!strncasecmp(month, monthtab[i], 3))
   185f8:	ebffb371 	bl	53c4 <strncasecmp@plt>
   185fc:	e3500000 	cmp	r0, #0
   18600:	0a0000c2 	beq	18910 <RTMP_HashSWF+0x958>
   18604:	e59f15a8 	ldr	r1, [pc, #1448]	; 18bb4 <RTMP_HashSWF+0xbfc>
   18608:	e1a00007 	mov	r0, r7
   1860c:	e08f1001 	add	r1, pc, r1
   18610:	e3a02003 	mov	r2, #3
   18614:	ebffb36a 	bl	53c4 <strncasecmp@plt>
   18618:	e3500000 	cmp	r0, #0
   1861c:	0a000119 	beq	18a88 <RTMP_HashSWF+0xad0>
   18620:	e59f1590 	ldr	r1, [pc, #1424]	; 18bb8 <RTMP_HashSWF+0xc00>
   18624:	e1a00007 	mov	r0, r7
   18628:	e08f1001 	add	r1, pc, r1
   1862c:	e3a02003 	mov	r2, #3
   18630:	ebffb363 	bl	53c4 <strncasecmp@plt>
   18634:	e3500000 	cmp	r0, #0
   18638:	0a000114 	beq	18a90 <RTMP_HashSWF+0xad8>
   1863c:	e59f1578 	ldr	r1, [pc, #1400]	; 18bbc <RTMP_HashSWF+0xc04>
   18640:	e1a00007 	mov	r0, r7
   18644:	e08f1001 	add	r1, pc, r1
   18648:	e3a02003 	mov	r2, #3
   1864c:	ebffb35c 	bl	53c4 <strncasecmp@plt>
   18650:	e3500000 	cmp	r0, #0
   18654:	0a000113 	beq	18aa8 <RTMP_HashSWF+0xaf0>
   18658:	e59f1560 	ldr	r1, [pc, #1376]	; 18bc0 <RTMP_HashSWF+0xc08>
   1865c:	e1a00007 	mov	r0, r7
   18660:	e08f1001 	add	r1, pc, r1
   18664:	e3a02003 	mov	r2, #3
   18668:	ebffb355 	bl	53c4 <strncasecmp@plt>
   1866c:	e3500000 	cmp	r0, #0
   18670:	0a000108 	beq	18a98 <RTMP_HashSWF+0xae0>
   18674:	e59f1548 	ldr	r1, [pc, #1352]	; 18bc4 <RTMP_HashSWF+0xc0c>
   18678:	e1a00007 	mov	r0, r7
   1867c:	e08f1001 	add	r1, pc, r1
   18680:	e3a02003 	mov	r2, #3
   18684:	ebffb34e 	bl	53c4 <strncasecmp@plt>
   18688:	e3500000 	cmp	r0, #0
   1868c:	0a000103 	beq	18aa0 <RTMP_HashSWF+0xae8>
   18690:	e59f1530 	ldr	r1, [pc, #1328]	; 18bc8 <RTMP_HashSWF+0xc10>
   18694:	e1a00007 	mov	r0, r7
   18698:	e08f1001 	add	r1, pc, r1
   1869c:	e3a02003 	mov	r2, #3
   186a0:	ebffb347 	bl	53c4 <strncasecmp@plt>
   186a4:	e3500000 	cmp	r0, #0
   186a8:	0a000100 	beq	18ab0 <RTMP_HashSWF+0xaf8>
   186ac:	e59f1518 	ldr	r1, [pc, #1304]	; 18bcc <RTMP_HashSWF+0xc14>
   186b0:	e1a00007 	mov	r0, r7
   186b4:	e08f1001 	add	r1, pc, r1
   186b8:	e3a02003 	mov	r2, #3
   186bc:	ebffb340 	bl	53c4 <strncasecmp@plt>
   186c0:	e3500000 	cmp	r0, #0
   186c4:	0a0000ff 	beq	18ac8 <RTMP_HashSWF+0xb10>
   186c8:	e59f1500 	ldr	r1, [pc, #1280]	; 18bd0 <RTMP_HashSWF+0xc18>
   186cc:	e1a00007 	mov	r0, r7
   186d0:	e08f1001 	add	r1, pc, r1
   186d4:	e3a02003 	mov	r2, #3
   186d8:	ebffb339 	bl	53c4 <strncasecmp@plt>
   186dc:	e3500000 	cmp	r0, #0
   186e0:	0a0000f4 	beq	18ab8 <RTMP_HashSWF+0xb00>
   186e4:	e59f14e8 	ldr	r1, [pc, #1256]	; 18bd4 <RTMP_HashSWF+0xc1c>
   186e8:	e1a00007 	mov	r0, r7
   186ec:	e08f1001 	add	r1, pc, r1
   186f0:	e3a02003 	mov	r2, #3
   186f4:	ebffb332 	bl	53c4 <strncasecmp@plt>
   186f8:	e3500000 	cmp	r0, #0
   186fc:	0a0000ef 	beq	18ac0 <RTMP_HashSWF+0xb08>
   18700:	e59f14d0 	ldr	r1, [pc, #1232]	; 18bd8 <RTMP_HashSWF+0xc20>
   18704:	e1a00007 	mov	r0, r7
   18708:	e08f1001 	add	r1, pc, r1
   1870c:	e3a02003 	mov	r2, #3
   18710:	ebffb32b 	bl	53c4 <strncasecmp@plt>
   18714:	e3500000 	cmp	r0, #0
   18718:	0a00007b 	beq	1890c <RTMP_HashSWF+0x954>
   1871c:	e59f14b8 	ldr	r1, [pc, #1208]	; 18bdc <RTMP_HashSWF+0xc24>
   18720:	e1a00007 	mov	r0, r7
   18724:	e08f1001 	add	r1, pc, r1
   18728:	e3a02003 	mov	r2, #3
   1872c:	ebffb324 	bl	53c4 <strncasecmp@plt>
   18730:	e3500000 	cmp	r0, #0
      time.tm_year = strtol(n + 1, NULL, 0);
    }
  if (time.tm_year > 100)
    time.tm_year -= ysub;

  for (i = 0; i < 12; i++)
   18734:	03a0000b 	moveq	r0, #11
    if (!strncasecmp(month, monthtab[i], 3))
   18738:	0a000074 	beq	18910 <RTMP_HashSWF+0x958>
  time.tm_isdst = 0;		/* daylight saving is never in effect in GMT */

  /* this is normally the value of extern int timezone, but some
   * braindead C libraries don't provide it.
   */
  if (!tzchecked)
   1873c:	e59f749c 	ldr	r7, [pc, #1180]	; 18be0 <RTMP_HashSWF+0xc28>
    if (!strncasecmp(month, monthtab[i], 3))
      {
	time.tm_mon = i;
	break;
      }
  time.tm_isdst = 0;		/* daylight saving is never in effect in GMT */
   18740:	e3a02000 	mov	r2, #0

  /* this is normally the value of extern int timezone, but some
   * braindead C libraries don't provide it.
   */
  if (!tzchecked)
   18744:	e08f7007 	add	r7, pc, r7
   18748:	e5973000 	ldr	r3, [r7]
    if (!strncasecmp(month, monthtab[i], 3))
      {
	time.tm_mon = i;
	break;
      }
  time.tm_isdst = 0;		/* daylight saving is never in effect in GMT */
   1874c:	e5042180 	str	r2, [r4, #-384]	; 0xfffffe80

  /* this is normally the value of extern int timezone, but some
   * braindead C libraries don't provide it.
   */
  if (!tzchecked)
   18750:	e1530002 	cmp	r3, r2
   18754:	0a0000a5 	beq	189f0 <RTMP_HashSWF+0xa38>
      time_t then = JAN02_1980;
      tc = localtime(&then);
      tzoff = (12 - tc->tm_hour) * 3600 + tc->tm_min * 60 + tc->tm_sec;
      tzchecked = 1;
    }
  res = mktime(&time);
   18758:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
   1875c:	e2430020 	sub	r0, r3, #32
   18760:	ebffb392 	bl	55b0 <mktime@plt>
  /* Unfortunately, mktime() assumes the input is in local time,
   * not GMT, so we have to correct it here.
   */
  if (res != -1)
   18764:	e3700001 	cmn	r0, #1
      time_t then = JAN02_1980;
      tc = localtime(&then);
      tzoff = (12 - tc->tm_hour) * 3600 + tc->tm_min * 60 + tc->tm_sec;
      tzchecked = 1;
    }
  res = mktime(&time);
   18768:	e1a08000 	mov	r8, r0
  /* Unfortunately, mktime() assumes the input is in local time,
   * not GMT, so we have to correct it here.
   */
  if (res != -1)
    res += tzoff;
   1876c:	159f3470 	ldrne	r3, [pc, #1136]	; 18be4 <RTMP_HashSWF+0xc2c>
   18770:	108f3003 	addne	r3, pc, r3
   18774:	15933004 	ldrne	r3, [r3, #4]
   18778:	10808003 	addne	r8, r0, r3
   1877c:	eafffebc 	b	18274 <RTMP_HashSWF+0x2bc>
	RTMP_Log(RTMP_LOGERROR, "%s: couldn't contact swfurl %s (HTTP error %d)",
	    __FUNCTION__, url, http.status);
    }
  else
    {
      if (got && pos)
   18780:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
   18784:	e3530000 	cmp	r3, #0
   18788:	13550000 	cmpne	r5, #0
   1878c:	1a0000b4 	bne	18a64 <RTMP_HashSWF+0xaac>
	fseek(f, pos, SEEK_SET);
      else
	{
	  char *q;
	  if (!f)
   18790:	e3560000 	cmp	r6, #0
   18794:	0a0000cd 	beq	18ad0 <RTMP_HashSWF+0xb18>
		  "%s: couldn't open %s for writing, errno %d (%s)",
		  __FUNCTION__, path, err, strerror(err));
	      ret = -1;
	      goto out;
	    }
	  fseek(f, 0, SEEK_END);
   18798:	e3a01000 	mov	r1, #0
   1879c:	e3a02002 	mov	r2, #2
   187a0:	e1a00006 	mov	r0, r6
   187a4:	ebffb384 	bl	55bc <fseek@plt>
	  q = strchr(url, '?');
   187a8:	e1a00007 	mov	r0, r7
   187ac:	e3a0103f 	mov	r1, #63	; 0x3f
   187b0:	ebffb24c 	bl	50e8 <strchr@plt>
	  if (q)
   187b4:	e3500000 	cmp	r0, #0
   187b8:	0a0000ae 	beq	18a78 <RTMP_HashSWF+0xac0>
	    i = q - url;
   187bc:	e0672000 	rsb	r2, r7, r0
	  else
	    i = strlen(url);

	  fprintf(f, "url: %.*s\n", i, url);
   187c0:	e59f1420 	ldr	r1, [pc, #1056]	; 18be8 <RTMP_HashSWF+0xc30>
   187c4:	e1a03007 	mov	r3, r7
   187c8:	e1a00006 	mov	r0, r6
   187cc:	e08f1001 	add	r1, pc, r1
   187d0:	ebffb34c 	bl	5508 <fprintf@plt>
static void
strtime(time_t * t, char *s)
{
  struct tm *tm;

  tm = gmtime((time_t *) t);
   187d4:	e24b0020 	sub	r0, fp, #32
   187d8:	ebffb37a 	bl	55c8 <gmtime@plt>
  sprintf(s, "%s, %02d %s %d %02d:%02d:%02d GMT",
   187dc:	e59f2408 	ldr	r2, [pc, #1032]	; 18bec <RTMP_HashSWF+0xc34>
   187e0:	e08f2002 	add	r2, pc, r2
   187e4:	e5901010 	ldr	r1, [r0, #16]
   187e8:	e590c018 	ldr	ip, [r0, #24]
   187ec:	e0823101 	add	r3, r2, r1, lsl #2
   187f0:	e593101c 	ldr	r1, [r3, #28]
   187f4:	e590300c 	ldr	r3, [r0, #12]
   187f8:	e58d1000 	str	r1, [sp]
   187fc:	e5901014 	ldr	r1, [r0, #20]
   18800:	e792210c 	ldr	r2, [r2, ip, lsl #2]
   18804:	e2811e76 	add	r1, r1, #1888	; 0x760
   18808:	e281100c 	add	r1, r1, #12
   1880c:	e58d1004 	str	r1, [sp, #4]
   18810:	e5901008 	ldr	r1, [r0, #8]
   18814:	e58d1008 	str	r1, [sp, #8]
   18818:	e5901004 	ldr	r1, [r0, #4]
   1881c:	e58d100c 	str	r1, [sp, #12]
   18820:	e5901000 	ldr	r1, [r0]
   18824:	e58d1010 	str	r1, [sp, #16]
   18828:	e59f13c0 	ldr	r1, [pc, #960]	; 18bf0 <RTMP_HashSWF+0xc38>
   1882c:	e1a00004 	mov	r0, r4
   18830:	e08f1001 	add	r1, pc, r1
   18834:	ebffb24c 	bl	516c <sprintf@plt>
	    i = strlen(url);

	  fprintf(f, "url: %.*s\n", i, url);
	}
      strtime(&cnow, cctim);
      fprintf(f, "ctim: %s\n", cctim);
   18838:	e59f13b4 	ldr	r1, [pc, #948]	; 18bf4 <RTMP_HashSWF+0xc3c>
   1883c:	e1a02004 	mov	r2, r4
   18840:	e1a00006 	mov	r0, r6
   18844:	e08f1001 	add	r1, pc, r1
   18848:	ebffb32e 	bl	5508 <fprintf@plt>

      if (!in.first)
   1884c:	e514300c 	ldr	r3, [r4, #-12]
   18850:	e3530000 	cmp	r3, #0
{
  FILE *f = NULL;
  char *path, date[64], cctim[64];
  long pos = 0;
  time_t ctim = -1, cnow;
  int i, got = 0, ret = 0;
   18854:	13a04000 	movne	r4, #0
	  fprintf(f, "url: %.*s\n", i, url);
	}
      strtime(&cnow, cctim);
      fprintf(f, "ctim: %s\n", cctim);

      if (!in.first)
   18858:	1afffef1 	bne	18424 <RTMP_HashSWF+0x46c>
	{
	  HMAC_finish(in.ctx, hash, hlen);
   1885c:	e59d7018 	ldr	r7, [sp, #24]
   18860:	e2490038 	sub	r0, r9, #56	; 0x38
   18864:	e1a01007 	mov	r1, r7
   18868:	ebffb212 	bl	50b8 <sha2_hmac_finish@plt>
	  *size = in.size;
   1886c:	e59d101c 	ldr	r1, [sp, #28]
   18870:	e5143004 	ldr	r3, [r4, #-4]
   18874:	e5813000 	str	r3, [r1]

	  fprintf(f, "date: %s\n", date);
   18878:	e59f1378 	ldr	r1, [pc, #888]	; 18bf8 <RTMP_HashSWF+0xc40>
   1887c:	e1a0200a 	mov	r2, sl
   18880:	e08f1001 	add	r1, pc, r1
   18884:	e1a00006 	mov	r0, r6
   18888:	ebffb31e 	bl	5508 <fprintf@plt>
	  fprintf(f, "size: %08x\n", in.size);
   1888c:	e59f1368 	ldr	r1, [pc, #872]	; 18bfc <RTMP_HashSWF+0xc44>
   18890:	e5142004 	ldr	r2, [r4, #-4]
   18894:	e08f1001 	add	r1, pc, r1
   18898:	e1a00006 	mov	r0, r6
   1889c:	ebffb319 	bl	5508 <fprintf@plt>
	  fprintf(f, "hash: ");
   188a0:	e59f0358 	ldr	r0, [pc, #856]	; 18c00 <RTMP_HashSWF+0xc48>
   188a4:	e3a01001 	mov	r1, #1
   188a8:	e08f0000 	add	r0, pc, r0
   188ac:	e3a02006 	mov	r2, #6
   188b0:	e1a03006 	mov	r3, r6
   188b4:	ebffb346 	bl	55d4 <fwrite@plt>
	  for (i = 0; i < SHA256_DIGEST_LENGTH; i++)
	    fprintf(f, "%02x", hash[i]);
   188b8:	e59f5344 	ldr	r5, [pc, #836]	; 18c04 <RTMP_HashSWF+0xc4c>
   188bc:	e247a001 	sub	sl, r7, #1
   188c0:	e08f5005 	add	r5, pc, r5
   188c4:	e287401f 	add	r4, r7, #31
   188c8:	e5fa2001 	ldrb	r2, [sl, #1]!
   188cc:	e1a00006 	mov	r0, r6
   188d0:	e1a01005 	mov	r1, r5
   188d4:	ebffb30b 	bl	5508 <fprintf@plt>
	  *size = in.size;

	  fprintf(f, "date: %s\n", date);
	  fprintf(f, "size: %08x\n", in.size);
	  fprintf(f, "hash: ");
	  for (i = 0; i < SHA256_DIGEST_LENGTH; i++)
   188d8:	e15a0004 	cmp	sl, r4
   188dc:	1afffff9 	bne	188c8 <RTMP_HashSWF+0x910>
	    fprintf(f, "%02x", hash[i]);
	  fprintf(f, "\n");
   188e0:	e1a01006 	mov	r1, r6
   188e4:	e3a0000a 	mov	r0, #10
   188e8:	ebffb33c 	bl	55e0 <fputc@plt>
	}
    }
  HMAC_close(in.ctx);
out:
  free(path);
   188ec:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
   188f0:	ebffb1c3 	bl	5004 <free@plt>
{
  FILE *f = NULL;
  char *path, date[64], cctim[64];
  long pos = 0;
  time_t ctim = -1, cnow;
  int i, got = 0, ret = 0;
   188f4:	e3a04000 	mov	r4, #0
   188f8:	eafffe73 	b	182cc <RTMP_HashSWF+0x314>
  hpre.av_len = 0;
  home.av_val = getenv("HOME");
#define DIRSEP	"/"
#endif
  if (!home.av_val)
    home.av_val = ".";
   188fc:	e59f5304 	ldr	r5, [pc, #772]	; 18c08 <RTMP_HashSWF+0xc50>
   18900:	e3a0000b 	mov	r0, #11
   18904:	e08f5005 	add	r5, pc, r5
   18908:	eafffdd4 	b	18060 <RTMP_HashSWF+0xa8>
      time.tm_year = strtol(n + 1, NULL, 0);
    }
  if (time.tm_year > 100)
    time.tm_year -= ysub;

  for (i = 0; i < 12; i++)
   1890c:	e3a0000a 	mov	r0, #10
    if (!strncasecmp(month, monthtab[i], 3))
      {
	time.tm_mon = i;
   18910:	e5040190 	str	r0, [r4, #-400]	; 0xfffffe70
   18914:	eaffff88 	b	1873c <RTMP_HashSWF+0x784>
      ret = -1;
      if (httpres == HTTPRES_LOST_CONNECTION)
	RTMP_Log(RTMP_LOGERROR, "%s: connection lost while downloading swfurl %s",
	    __FUNCTION__, url);
      else if (httpres == HTTPRES_NOT_FOUND)
	RTMP_Log(RTMP_LOGERROR, "%s: swfurl %s not found", __FUNCTION__, url);
   18918:	e59f22ec 	ldr	r2, [pc, #748]	; 18c0c <RTMP_HashSWF+0xc54>
   1891c:	e59f12ec 	ldr	r1, [pc, #748]	; 18c10 <RTMP_HashSWF+0xc58>
   18920:	e08f2002 	add	r2, pc, r2
   18924:	e1a0000c 	mov	r0, ip
   18928:	e1a03007 	mov	r3, r7
   1892c:	e282200c 	add	r2, r2, #12
   18930:	e08f1001 	add	r1, pc, r1
   18934:	ebfff41c 	bl	159ac <RTMP_Log>

  inflateEnd(&zs);

  if (httpres != HTTPRES_OK && httpres != HTTPRES_OK_NOT_MODIFIED)
    {
      ret = -1;
   18938:	e3e04000 	mvn	r4, #0
   1893c:	eafffeb8 	b	18424 <RTMP_HashSWF+0x46c>
  for (n = s; *n; ++n)
    if (*n == '-' || *n == ':')
      *n = ' ';

  time.tm_mon = 0;
  n = strchr(s, ' ');
   18940:	e3a01020 	mov	r1, #32
    }
  for (n = s; *n; ++n)
    if (*n == '-' || *n == ':')
      *n = ' ';

  time.tm_mon = 0;
   18944:	e5048190 	str	r8, [r4, #-400]	; 0xfffffe70
  n = strchr(s, ' ');
   18948:	ebffb1e6 	bl	50e8 <strchr@plt>
   1894c:	e50401b8 	str	r0, [r4, #-440]	; 0xfffffe48
  if (fmt)
    {
      /* Day, DD-MMM-YYYY HH:MM:SS GMT */
      time.tm_mday = strtol(n + 1, &n, 0);
   18950:	e28d8050 	add	r8, sp, #80	; 0x50
   18954:	e28d3088 	add	r3, sp, #136	; 0x88
   18958:	e3a02000 	mov	r2, #0
   1895c:	e1a01008 	mov	r1, r8
   18960:	e2800001 	add	r0, r0, #1
   18964:	e58d303c 	str	r3, [sp, #60]	; 0x3c
   18968:	ebffb25f 	bl	52ec <strtol@plt>
      month = n + 1;
   1896c:	e51471b8 	ldr	r7, [r4, #-440]	; 0xfffffe48
      n = strchr(month, ' ');
   18970:	e3a01020 	mov	r1, #32
  n = strchr(s, ' ');
  if (fmt)
    {
      /* Day, DD-MMM-YYYY HH:MM:SS GMT */
      time.tm_mday = strtol(n + 1, &n, 0);
      month = n + 1;
   18974:	e2877001 	add	r7, r7, #1
  time.tm_mon = 0;
  n = strchr(s, ' ');
  if (fmt)
    {
      /* Day, DD-MMM-YYYY HH:MM:SS GMT */
      time.tm_mday = strtol(n + 1, &n, 0);
   18978:	e5040194 	str	r0, [r4, #-404]	; 0xfffffe6c
      month = n + 1;
      n = strchr(month, ' ');
   1897c:	e1a00007 	mov	r0, r7
   18980:	ebffb1d8 	bl	50e8 <strchr@plt>
      time.tm_year = strtol(n + 1, &n, 0);
   18984:	e1a01008 	mov	r1, r8
   18988:	e3a02000 	mov	r2, #0
  if (fmt)
    {
      /* Day, DD-MMM-YYYY HH:MM:SS GMT */
      time.tm_mday = strtol(n + 1, &n, 0);
      month = n + 1;
      n = strchr(month, ' ');
   1898c:	e1a03000 	mov	r3, r0
      time.tm_year = strtol(n + 1, &n, 0);
   18990:	e2800001 	add	r0, r0, #1
  if (fmt)
    {
      /* Day, DD-MMM-YYYY HH:MM:SS GMT */
      time.tm_mday = strtol(n + 1, &n, 0);
      month = n + 1;
      n = strchr(month, ' ');
   18994:	e50431b8 	str	r3, [r4, #-440]	; 0xfffffe48
      time.tm_year = strtol(n + 1, &n, 0);
   18998:	ebffb253 	bl	52ec <strtol@plt>
      time.tm_hour = strtol(n + 1, &n, 0);
   1899c:	e51431b8 	ldr	r3, [r4, #-440]	; 0xfffffe48
   189a0:	e1a01008 	mov	r1, r8
   189a4:	e3a02000 	mov	r2, #0
    {
      /* Day, DD-MMM-YYYY HH:MM:SS GMT */
      time.tm_mday = strtol(n + 1, &n, 0);
      month = n + 1;
      n = strchr(month, ' ');
      time.tm_year = strtol(n + 1, &n, 0);
   189a8:	e504018c 	str	r0, [r4, #-396]	; 0xfffffe74
      time.tm_hour = strtol(n + 1, &n, 0);
   189ac:	e2830001 	add	r0, r3, #1
   189b0:	ebffb24d 	bl	52ec <strtol@plt>
      time.tm_min = strtol(n + 1, &n, 0);
   189b4:	e51431b8 	ldr	r3, [r4, #-440]	; 0xfffffe48
   189b8:	e1a01008 	mov	r1, r8
   189bc:	e3a02000 	mov	r2, #0
      /* Day, DD-MMM-YYYY HH:MM:SS GMT */
      time.tm_mday = strtol(n + 1, &n, 0);
      month = n + 1;
      n = strchr(month, ' ');
      time.tm_year = strtol(n + 1, &n, 0);
      time.tm_hour = strtol(n + 1, &n, 0);
   189c0:	e5040198 	str	r0, [r4, #-408]	; 0xfffffe68
      time.tm_min = strtol(n + 1, &n, 0);
   189c4:	e2830001 	add	r0, r3, #1
   189c8:	ebffb247 	bl	52ec <strtol@plt>
      time.tm_sec = strtol(n + 1, NULL, 0);
   189cc:	e51431b8 	ldr	r3, [r4, #-440]	; 0xfffffe48
   189d0:	e3a01000 	mov	r1, #0
   189d4:	e1a02001 	mov	r2, r1
      time.tm_mday = strtol(n + 1, &n, 0);
      month = n + 1;
      n = strchr(month, ' ');
      time.tm_year = strtol(n + 1, &n, 0);
      time.tm_hour = strtol(n + 1, &n, 0);
      time.tm_min = strtol(n + 1, &n, 0);
   189d8:	e504019c 	str	r0, [r4, #-412]	; 0xfffffe64
      time.tm_sec = strtol(n + 1, NULL, 0);
   189dc:	e2830001 	add	r0, r3, #1
   189e0:	ebffb241 	bl	52ec <strtol@plt>
   189e4:	e514318c 	ldr	r3, [r4, #-396]	; 0xfffffe74
   189e8:	e50401a0 	str	r0, [r4, #-416]	; 0xfffffe60
   189ec:	eafffefa 	b	185dc <RTMP_HashSWF+0x624>
   */
  if (!tzchecked)
    {
      struct tm *tc;
      time_t then = JAN02_1980;
      tc = localtime(&then);
   189f0:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
   * braindead C libraries don't provide it.
   */
  if (!tzchecked)
    {
      struct tm *tc;
      time_t then = JAN02_1980;
   189f4:	e59f3218 	ldr	r3, [pc, #536]	; 18c14 <RTMP_HashSWF+0xc5c>
      tc = localtime(&then);
   189f8:	e2420034 	sub	r0, r2, #52	; 0x34
   * braindead C libraries don't provide it.
   */
  if (!tzchecked)
    {
      struct tm *tc;
      time_t then = JAN02_1980;
   189fc:	e50431b4 	str	r3, [r4, #-436]	; 0xfffffe4c
      tc = localtime(&then);
   18a00:	ebffb2f9 	bl	55ec <localtime@plt>
      tzoff = (12 - tc->tm_hour) * 3600 + tc->tm_min * 60 + tc->tm_sec;
   18a04:	e3a02ee1 	mov	r2, #3600	; 0xe10
   18a08:	e5903004 	ldr	r3, [r0, #4]
   18a0c:	e5901008 	ldr	r1, [r0, #8]
   18a10:	e0633203 	rsb	r3, r3, r3, lsl #4
   18a14:	e261100c 	rsb	r1, r1, #12
   18a18:	e1a03103 	lsl	r3, r3, #2
   18a1c:	e0233192 	mla	r3, r2, r1, r3
   18a20:	e5901000 	ldr	r1, [r0]
      tzchecked = 1;
   18a24:	e3a02001 	mov	r2, #1
  if (!tzchecked)
    {
      struct tm *tc;
      time_t then = JAN02_1980;
      tc = localtime(&then);
      tzoff = (12 - tc->tm_hour) * 3600 + tc->tm_min * 60 + tc->tm_sec;
   18a28:	e0833001 	add	r3, r3, r1
      tzchecked = 1;
   18a2c:	e887000c 	stm	r7, {r2, r3}
   18a30:	eaffff48 	b	18758 <RTMP_HashSWF+0x7a0>
    {
      fmt = 1;
      if (s[3] != ',')
	ysub = 0;
    }
  for (n = s; *n; ++n)
   18a34:	e5d48006 	ldrb	r8, [r4, #6]
   18a38:	e2840006 	add	r0, r4, #6
   18a3c:	e3580000 	cmp	r8, #0
/* Parse an HTTP datestamp into Unix time */
static time_t
make_unix_time(char *s)
{
  struct tm time;
  int i, ysub = 1900, fmt = 0;
   18a40:	159f3168 	ldrne	r3, [pc, #360]	; 18bb0 <RTMP_HashSWF+0xbf8>
    {
      fmt = 1;
      if (s[3] != ',')
	ysub = 0;
    }
  for (n = s; *n; ++n)
   18a44:	e50401b8 	str	r0, [r4, #-440]	; 0xfffffe48
/* Parse an HTTP datestamp into Unix time */
static time_t
make_unix_time(char *s)
{
  struct tm time;
  int i, ysub = 1900, fmt = 0;
   18a48:	158d3048 	strne	r3, [sp, #72]	; 0x48
    {
      fmt = 1;
      if (s[3] != ',')
	ysub = 0;
    }
  for (n = s; *n; ++n)
   18a4c:	1afffe9b 	bne	184c0 <RTMP_HashSWF+0x508>
/* Parse an HTTP datestamp into Unix time */
static time_t
make_unix_time(char *s)
{
  struct tm time;
  int i, ysub = 1900, fmt = 0;
   18a50:	e59f3158 	ldr	r3, [pc, #344]	; 18bb0 <RTMP_HashSWF+0xbf8>
    }
  for (n = s; *n; ++n)
    if (*n == '-' || *n == ':')
      *n = ' ';

  time.tm_mon = 0;
   18a54:	e5048190 	str	r8, [r4, #-400]	; 0xfffffe70
/* Parse an HTTP datestamp into Unix time */
static time_t
make_unix_time(char *s)
{
  struct tm time;
  int i, ysub = 1900, fmt = 0;
   18a58:	e58d3048 	str	r3, [sp, #72]	; 0x48
  for (n = s; *n; ++n)
    if (*n == '-' || *n == ':')
      *n = ' ';

  time.tm_mon = 0;
  n = strchr(s, ' ');
   18a5c:	ebffb1a1 	bl	50e8 <strchr@plt>
   18a60:	eafffea8 	b	18508 <RTMP_HashSWF+0x550>
	    __FUNCTION__, url, http.status);
    }
  else
    {
      if (got && pos)
	fseek(f, pos, SEEK_SET);
   18a64:	e1a01003 	mov	r1, r3
   18a68:	e1a00006 	mov	r0, r6
   18a6c:	e3a02000 	mov	r2, #0
   18a70:	ebffb2d1 	bl	55bc <fseek@plt>
   18a74:	eaffff56 	b	187d4 <RTMP_HashSWF+0x81c>
	  fseek(f, 0, SEEK_END);
	  q = strchr(url, '?');
	  if (q)
	    i = q - url;
	  else
	    i = strlen(url);
   18a78:	e1a00007 	mov	r0, r7
   18a7c:	ebffb19f 	bl	5100 <strlen@plt>
   18a80:	e1a02000 	mov	r2, r0
   18a84:	eaffff4d 	b	187c0 <RTMP_HashSWF+0x808>
      time.tm_year = strtol(n + 1, NULL, 0);
    }
  if (time.tm_year > 100)
    time.tm_year -= ysub;

  for (i = 0; i < 12; i++)
   18a88:	e3a00001 	mov	r0, #1
   18a8c:	eaffff9f 	b	18910 <RTMP_HashSWF+0x958>
   18a90:	e3a00002 	mov	r0, #2
   18a94:	eaffff9d 	b	18910 <RTMP_HashSWF+0x958>
   18a98:	e3a00004 	mov	r0, #4
   18a9c:	eaffff9b 	b	18910 <RTMP_HashSWF+0x958>
   18aa0:	e3a00005 	mov	r0, #5
   18aa4:	eaffff99 	b	18910 <RTMP_HashSWF+0x958>
   18aa8:	e3a00003 	mov	r0, #3
   18aac:	eaffff97 	b	18910 <RTMP_HashSWF+0x958>
   18ab0:	e3a00006 	mov	r0, #6
   18ab4:	eaffff95 	b	18910 <RTMP_HashSWF+0x958>
   18ab8:	e3a00008 	mov	r0, #8
   18abc:	eaffff93 	b	18910 <RTMP_HashSWF+0x958>
   18ac0:	e3a00009 	mov	r0, #9
   18ac4:	eaffff91 	b	18910 <RTMP_HashSWF+0x958>
   18ac8:	e3a00007 	mov	r0, #7
   18acc:	eaffff8f 	b	18910 <RTMP_HashSWF+0x958>
	fseek(f, pos, SEEK_SET);
      else
	{
	  char *q;
	  if (!f)
	    f = fopen(path, "w");
   18ad0:	e59f1140 	ldr	r1, [pc, #320]	; 18c18 <RTMP_HashSWF+0xc60>
   18ad4:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
   18ad8:	e08f1001 	add	r1, pc, r1
   18adc:	e58dc020 	str	ip, [sp, #32]
   18ae0:	ebffb29d 	bl	555c <fopen@plt>
	  if (!f)
   18ae4:	e59dc020 	ldr	ip, [sp, #32]
   18ae8:	e2506000 	subs	r6, r0, #0
   18aec:	1affff29 	bne	18798 <RTMP_HashSWF+0x7e0>
   18af0:	e58dc018 	str	ip, [sp, #24]
	    {
	      int err = errno;
   18af4:	ebffb229 	bl	53a0 <__errno@plt>
	      RTMP_Log(RTMP_LOGERROR,
		  "%s: couldn't open %s for writing, errno %d (%s)",
		  __FUNCTION__, path, err, strerror(err));
	      ret = -1;
   18af8:	e3e04000 	mvn	r4, #0
	  char *q;
	  if (!f)
	    f = fopen(path, "w");
	  if (!f)
	    {
	      int err = errno;
   18afc:	e5905000 	ldr	r5, [r0]
	      RTMP_Log(RTMP_LOGERROR,
   18b00:	e1a00005 	mov	r0, r5
   18b04:	ebffb2bb 	bl	55f8 <strerror@plt>
   18b08:	e59f210c 	ldr	r2, [pc, #268]	; 18c1c <RTMP_HashSWF+0xc64>
   18b0c:	e58d5000 	str	r5, [sp]
   18b10:	e59dc018 	ldr	ip, [sp, #24]
   18b14:	e59d5024 	ldr	r5, [sp, #36]	; 0x24
   18b18:	e59f1100 	ldr	r1, [pc, #256]	; 18c20 <RTMP_HashSWF+0xc68>
   18b1c:	e08f2002 	add	r2, pc, r2
   18b20:	e282200c 	add	r2, r2, #12
   18b24:	e08f1001 	add	r1, pc, r1
   18b28:	e1a03005 	mov	r3, r5
   18b2c:	e58d0004 	str	r0, [sp, #4]
   18b30:	e1a0000c 	mov	r0, ip
   18b34:	ebfff39c 	bl	159ac <RTMP_Log>
	  fprintf(f, "\n");
	}
    }
  HMAC_close(in.ctx);
out:
  free(path);
   18b38:	e1a00005 	mov	r0, r5
   18b3c:	ebffb130 	bl	5004 <free@plt>
   18b40:	eafffde3 	b	182d4 <RTMP_HashSWF+0x31c>

  if (httpres != HTTPRES_OK && httpres != HTTPRES_OK_NOT_MODIFIED)
    {
      ret = -1;
      if (httpres == HTTPRES_LOST_CONNECTION)
	RTMP_Log(RTMP_LOGERROR, "%s: connection lost while downloading swfurl %s",
   18b44:	e59f20d8 	ldr	r2, [pc, #216]	; 18c24 <RTMP_HashSWF+0xc6c>
   18b48:	e59f10d8 	ldr	r1, [pc, #216]	; 18c28 <RTMP_HashSWF+0xc70>
   18b4c:	e08f2002 	add	r2, pc, r2
   18b50:	e1a0000c 	mov	r0, ip
   18b54:	e1a03007 	mov	r3, r7
   18b58:	e282200c 	add	r2, r2, #12
   18b5c:	e08f1001 	add	r1, pc, r1
   18b60:	ebfff391 	bl	159ac <RTMP_Log>

  inflateEnd(&zs);

  if (httpres != HTTPRES_OK && httpres != HTTPRES_OK_NOT_MODIFIED)
    {
      ret = -1;
   18b64:	e3e04000 	mvn	r4, #0
   18b68:	eafffe2d 	b	18424 <RTMP_HashSWF+0x46c>
   18b6c:	000091d8 	.word	0x000091d8
   18b70:	0000916c 	.word	0x0000916c
   18b74:	00005dbd 	.word	0x00005dbd
   18b78:	00009160 	.word	0x00009160
   18b7c:	00009114 	.word	0x00009114
   18b80:	0000908c 	.word	0x0000908c
   18b84:	00009068 	.word	0x00009068
   18b88:	00009084 	.word	0x00009084
   18b8c:	00009048 	.word	0x00009048
   18b90:	00009054 	.word	0x00009054
   18b94:	0000906c 	.word	0x0000906c
   18b98:	c22e4507 	.word	0xc22e4507
   18b9c:	00008ed0 	.word	0x00008ed0
   18ba0:	00008ed4 	.word	0x00008ed4
   18ba4:	fffff4b8 	.word	0xfffff4b8
   18ba8:	0000968c 	.word	0x0000968c
   18bac:	00008ea0 	.word	0x00008ea0
   18bb0:	0000076c 	.word	0x0000076c
   18bb4:	00008c10 	.word	0x00008c10
   18bb8:	00008bf8 	.word	0x00008bf8
   18bbc:	00008be0 	.word	0x00008be0
   18bc0:	00008bc8 	.word	0x00008bc8
   18bc4:	00008bb0 	.word	0x00008bb0
   18bc8:	00008b98 	.word	0x00008b98
   18bcc:	00008b80 	.word	0x00008b80
   18bd0:	00008b68 	.word	0x00008b68
   18bd4:	00008b50 	.word	0x00008b50
   18bd8:	00008b38 	.word	0x00008b38
   18bdc:	00008b20 	.word	0x00008b20
   18be0:	0000e0e4 	.word	0x0000e0e4
   18be4:	0000e0b8 	.word	0x0000e0b8
   18be8:	00008b50 	.word	0x00008b50
   18bec:	0000b408 	.word	0x0000b408
   18bf0:	00008af8 	.word	0x00008af8
   18bf4:	00008b08 	.word	0x00008b08
   18bf8:	00008ad8 	.word	0x00008ad8
   18bfc:	00008ad0 	.word	0x00008ad0
   18c00:	00008958 	.word	0x00008958
   18c04:	000058c4 	.word	0x000058c4
   18c08:	000088cc 	.word	0x000088cc
   18c0c:	00009170 	.word	0x00009170
   18c10:	00008970 	.word	0x00008970
   18c14:	12f97ec0 	.word	0x12f97ec0
   18c18:	00008810 	.word	0x00008810
   18c1c:	00008f74 	.word	0x00008f74
   18c20:	000087c8 	.word	0x000087c8
   18c24:	00008f44 	.word	0x00008f44
   18c28:	00008714 	.word	0x00008714

00018c2c <RTMP_ParsePlaypath>:
 *
 * mp4 streams: prepend "mp4:", remove extension
 * mp3 streams: prepend "mp3:", remove extension
 * flv streams: remove extension
 */
void RTMP_ParsePlaypath(AVal *in, AVal *out) {
   18c2c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int addMP4 = 0;
	int addMP3 = 0;
	int subExt = 0;
	const char *playpath = in->av_val;
   18c30:	e5906000 	ldr	r6, [r0]
	const char *ppstart = playpath;
	char *streamname, *destptr, *p;

	int pplen = in->av_len;

	out->av_val = NULL;
   18c34:	e3a03000 	mov	r3, #0
	const char *playpath = in->av_val;
	const char *temp, *q, *ext = NULL;
	const char *ppstart = playpath;
	char *streamname, *destptr, *p;

	int pplen = in->av_len;
   18c38:	e5905004 	ldr	r5, [r0, #4]

	out->av_val = NULL;
   18c3c:	e5813000 	str	r3, [r1]
	out->av_len = 0;
   18c40:	e5813004 	str	r3, [r1, #4]

	if ((*ppstart == '?') &&
   18c44:	e5d63000 	ldrb	r3, [r6]
 *
 * mp4 streams: prepend "mp4:", remove extension
 * mp3 streams: prepend "mp3:", remove extension
 * flv streams: remove extension
 */
void RTMP_ParsePlaypath(AVal *in, AVal *out) {
   18c48:	e24dd014 	sub	sp, sp, #20
	int pplen = in->av_len;

	out->av_val = NULL;
	out->av_len = 0;

	if ((*ppstart == '?') &&
   18c4c:	e353003f 	cmp	r3, #63	; 0x3f
 *
 * mp4 streams: prepend "mp4:", remove extension
 * mp3 streams: prepend "mp3:", remove extension
 * flv streams: remove extension
 */
void RTMP_ParsePlaypath(AVal *in, AVal *out) {
   18c50:	e1a09001 	mov	r9, r1
	int pplen = in->av_len;

	out->av_val = NULL;
	out->av_len = 0;

	if ((*ppstart == '?') &&
   18c54:	0a00006b 	beq	18e08 <RTMP_ParsePlaypath+0x1dc>
   18c58:	e1a04006 	mov	r4, r6
		if (temp) {
			pplen = temp-ppstart;
		}
	}

	q = strchr(ppstart, '?');
   18c5c:	e1a00004 	mov	r0, r4
   18c60:	e3a0103f 	mov	r1, #63	; 0x3f
   18c64:	ebffb11f 	bl	50e8 <strchr@plt>
	if (pplen >= 4) {
   18c68:	e3550003 	cmp	r5, #3
   18c6c:	da000037 	ble	18d50 <RTMP_ParsePlaypath+0x124>
		if (q)
   18c70:	e3500000 	cmp	r0, #0
			ext = q-4;
		else
			ext = &ppstart[pplen-4];
   18c74:	02457004 	subeq	r7, r5, #4
		if ((strncmp(ext, ".f4v", 4) == 0) ||
   18c78:	e59f11ec 	ldr	r1, [pc, #492]	; 18e6c <RTMP_ParsePlaypath+0x240>
	}

	q = strchr(ppstart, '?');
	if (pplen >= 4) {
		if (q)
			ext = q-4;
   18c7c:	12407004 	subne	r7, r0, #4
		else
			ext = &ppstart[pplen-4];
   18c80:	00847007 	addeq	r7, r4, r7
		if ((strncmp(ext, ".f4v", 4) == 0) ||
   18c84:	e1a00007 	mov	r0, r7
   18c88:	e08f1001 	add	r1, pc, r1
   18c8c:	e3a02004 	mov	r2, #4
   18c90:	ebffb1c8 	bl	53b8 <strncmp@plt>
   18c94:	e3500000 	cmp	r0, #0
   18c98:	1a000042 	bne	18da8 <RTMP_ParsePlaypath+0x17c>
			addMP3 = 1;
			subExt = 1;
		}
	}

	streamname = (char *)malloc((pplen+4+1)*sizeof(char));
   18c9c:	e2850005 	add	r0, r5, #5
   18ca0:	ebffb0dd 	bl	501c <malloc@plt>
	if (!streamname)
		return;

	destptr = streamname;
	if (addMP4) {
		if (strncmp(ppstart, "mp4:", 4)) {
   18ca4:	e59f61c4 	ldr	r6, [pc, #452]	; 18e70 <RTMP_ParsePlaypath+0x244>
   18ca8:	e08f6006 	add	r6, pc, r6
			subExt = 1;
		}
	}

	streamname = (char *)malloc((pplen+4+1)*sizeof(char));
	if (!streamname)
   18cac:	e250a000 	subs	sl, r0, #0
   18cb0:	0a000024 	beq	18d48 <RTMP_ParsePlaypath+0x11c>
			destptr += 4;
		} else {
			subExt = 0;
		}
	} else if (addMP3) {
		if (strncmp(ppstart, "mp3:", 4)) {
   18cb4:	e1a01006 	mov	r1, r6
   18cb8:	e1a00004 	mov	r0, r4
   18cbc:	e3a02004 	mov	r2, #4
   18cc0:	ebffb1bc 	bl	53b8 <strncmp@plt>
   18cc4:	e3500000 	cmp	r0, #0
			strcpy(destptr, "mp3:");
   18cc8:	18960003 	ldmne	r6, {r0, r1}
			destptr += 4;
		} else {
			subExt = 0;
   18ccc:	01a08000 	moveq	r8, r0
		} else {
			subExt = 0;
		}
	} else if (addMP3) {
		if (strncmp(ppstart, "mp3:", 4)) {
			strcpy(destptr, "mp3:");
   18cd0:	11a0600a 	movne	r6, sl
   18cd4:	01a0600a 	moveq	r6, sl
		} else if ((ppstart == playpath) &&
		    (strncmp(ext, ".flv", 4) == 0)) {
			subExt = 1;
		} else if (strncmp(ext, ".mp3", 4) == 0) {
			addMP3 = 1;
			subExt = 1;
   18cd8:	13a08001 	movne	r8, #1
		} else {
			subExt = 0;
		}
	} else if (addMP3) {
		if (strncmp(ppstart, "mp3:", 4)) {
			strcpy(destptr, "mp3:");
   18cdc:	14860004 	strne	r0, [r6], #4
   18ce0:	15ca1004 	strbne	r1, [sl, #4]
			pplen -= 4;
			continue;
		}
		if (*p == '%') {
			unsigned int c;
			sscanf(p+1, "%02x", &c);
   18ce4:	e59fb188 	ldr	fp, [pc, #392]	; 18e74 <RTMP_ParsePlaypath+0x248>
   18ce8:	e2088001 	and	r8, r8, #1
   18cec:	e08fb00b 	add	fp, pc, fp
   18cf0:	e28dc00c 	add	ip, sp, #12
		}
	}

 	for (p=(char *)ppstart; pplen >0;) {
		/* skip extension */
		if (subExt && p == ext) {
   18cf4:	e1540007 	cmp	r4, r7
   18cf8:	13a03000 	movne	r3, #0
   18cfc:	02083001 	andeq	r3, r8, #1
   18d00:	e3530000 	cmp	r3, #0
			p += 4;
   18d04:	12844004 	addne	r4, r4, #4
			pplen -= 4;
   18d08:	12455004 	subne	r5, r5, #4
		}
	}

 	for (p=(char *)ppstart; pplen >0;) {
		/* skip extension */
		if (subExt && p == ext) {
   18d0c:	1a000006 	bne	18d2c <RTMP_ParsePlaypath+0x100>
			p += 4;
			pplen -= 4;
			continue;
		}
		if (*p == '%') {
   18d10:	e5d43000 	ldrb	r3, [r4]
   18d14:	e3530025 	cmp	r3, #37	; 0x25
   18d18:	0a000016 	beq	18d78 <RTMP_ParsePlaypath+0x14c>
			sscanf(p+1, "%02x", &c);
			*destptr++ = c;
			pplen -= 3;
			p += 3;
		} else {
			*destptr++ = *p++;
   18d1c:	e5c63000 	strb	r3, [r6]
   18d20:	e2844001 	add	r4, r4, #1
			pplen--;
   18d24:	e2455001 	sub	r5, r5, #1
			sscanf(p+1, "%02x", &c);
			*destptr++ = c;
			pplen -= 3;
			p += 3;
		} else {
			*destptr++ = *p++;
   18d28:	e2866001 	add	r6, r6, #1
		} else {
			subExt = 0;
		}
	}

 	for (p=(char *)ppstart; pplen >0;) {
   18d2c:	e3550000 	cmp	r5, #0
   18d30:	caffffef 	bgt	18cf4 <RTMP_ParsePlaypath+0xc8>
		}
	}
	*destptr = '\0';

	out->av_val = streamname;
	out->av_len = destptr - streamname;
   18d34:	e06a2006 	rsb	r2, sl, r6
		} else {
			*destptr++ = *p++;
			pplen--;
		}
	}
	*destptr = '\0';
   18d38:	e3a03000 	mov	r3, #0

	out->av_val = streamname;
   18d3c:	e589a000 	str	sl, [r9]
	out->av_len = destptr - streamname;
   18d40:	e5892004 	str	r2, [r9, #4]
		} else {
			*destptr++ = *p++;
			pplen--;
		}
	}
	*destptr = '\0';
   18d44:	e5c63000 	strb	r3, [r6]

	out->av_val = streamname;
	out->av_len = destptr - streamname;
}
   18d48:	e28dd014 	add	sp, sp, #20
   18d4c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
void RTMP_ParsePlaypath(AVal *in, AVal *out) {
	int addMP4 = 0;
	int addMP3 = 0;
	int subExt = 0;
	const char *playpath = in->av_val;
	const char *temp, *q, *ext = NULL;
   18d50:	e3a07000 	mov	r7, #0
 * flv streams: remove extension
 */
void RTMP_ParsePlaypath(AVal *in, AVal *out) {
	int addMP4 = 0;
	int addMP3 = 0;
	int subExt = 0;
   18d54:	e1a08007 	mov	r8, r7
			addMP3 = 1;
			subExt = 1;
		}
	}

	streamname = (char *)malloc((pplen+4+1)*sizeof(char));
   18d58:	e2850005 	add	r0, r5, #5
   18d5c:	ebffb0ae 	bl	501c <malloc@plt>
	if (!streamname)
   18d60:	e2506000 	subs	r6, r0, #0
   18d64:	0afffff7 	beq	18d48 <RTMP_ParsePlaypath+0x11c>
		} else {
			subExt = 0;
		}
	}

 	for (p=(char *)ppstart; pplen >0;) {
   18d68:	e3550000 	cmp	r5, #0
			subExt = 1;
		}
	}

	streamname = (char *)malloc((pplen+4+1)*sizeof(char));
	if (!streamname)
   18d6c:	e1a0a006 	mov	sl, r6
		} else {
			subExt = 0;
		}
	}

 	for (p=(char *)ppstart; pplen >0;) {
   18d70:	caffffdb 	bgt	18ce4 <RTMP_ParsePlaypath+0xb8>
   18d74:	eaffffee 	b	18d34 <RTMP_ParsePlaypath+0x108>
			pplen -= 4;
			continue;
		}
		if (*p == '%') {
			unsigned int c;
			sscanf(p+1, "%02x", &c);
   18d78:	e2840001 	add	r0, r4, #1
   18d7c:	e1a0200c 	mov	r2, ip
   18d80:	e1a0100b 	mov	r1, fp
   18d84:	e58dc004 	str	ip, [sp, #4]
   18d88:	ebffb160 	bl	5310 <sscanf@plt>
			*destptr++ = c;
   18d8c:	e59d300c 	ldr	r3, [sp, #12]
   18d90:	e5c63000 	strb	r3, [r6]
			pplen -= 3;
   18d94:	e2455003 	sub	r5, r5, #3
			p += 3;
   18d98:	e2844003 	add	r4, r4, #3
			continue;
		}
		if (*p == '%') {
			unsigned int c;
			sscanf(p+1, "%02x", &c);
			*destptr++ = c;
   18d9c:	e2866001 	add	r6, r6, #1
   18da0:	e59dc004 	ldr	ip, [sp, #4]
   18da4:	eaffffe0 	b	18d2c <RTMP_ParsePlaypath+0x100>
		if (q)
			ext = q-4;
		else
			ext = &ppstart[pplen-4];
		if ((strncmp(ext, ".f4v", 4) == 0) ||
		    (strncmp(ext, ".mp4", 4) == 0)) {
   18da8:	e59f10c8 	ldr	r1, [pc, #200]	; 18e78 <RTMP_ParsePlaypath+0x24c>
   18dac:	e1a00007 	mov	r0, r7
   18db0:	e08f1001 	add	r1, pc, r1
   18db4:	e3a02004 	mov	r2, #4
   18db8:	ebffb17e 	bl	53b8 <strncmp@plt>
	if (pplen >= 4) {
		if (q)
			ext = q-4;
		else
			ext = &ppstart[pplen-4];
		if ((strncmp(ext, ".f4v", 4) == 0) ||
   18dbc:	e3500000 	cmp	r0, #0
   18dc0:	0affffb5 	beq	18c9c <RTMP_ParsePlaypath+0x70>
		    (strncmp(ext, ".mp4", 4) == 0)) {
			addMP4 = 1;
			subExt = 1;
		/* Only remove .flv from rtmp URL, not slist params */
		} else if ((ppstart == playpath) &&
   18dc4:	e1540006 	cmp	r4, r6
   18dc8:	0a00001e 	beq	18e48 <RTMP_ParsePlaypath+0x21c>
		    (strncmp(ext, ".flv", 4) == 0)) {
			subExt = 1;
		} else if (strncmp(ext, ".mp3", 4) == 0) {
   18dcc:	e59f10a8 	ldr	r1, [pc, #168]	; 18e7c <RTMP_ParsePlaypath+0x250>
   18dd0:	e1a00007 	mov	r0, r7
   18dd4:	e08f1001 	add	r1, pc, r1
   18dd8:	e3a02004 	mov	r2, #4
   18ddc:	ebffb175 	bl	53b8 <strncmp@plt>
   18de0:	e3500000 	cmp	r0, #0
 * flv streams: remove extension
 */
void RTMP_ParsePlaypath(AVal *in, AVal *out) {
	int addMP4 = 0;
	int addMP3 = 0;
	int subExt = 0;
   18de4:	13a08000 	movne	r8, #0
			subExt = 1;
		/* Only remove .flv from rtmp URL, not slist params */
		} else if ((ppstart == playpath) &&
		    (strncmp(ext, ".flv", 4) == 0)) {
			subExt = 1;
		} else if (strncmp(ext, ".mp3", 4) == 0) {
   18de8:	1affffda 	bne	18d58 <RTMP_ParsePlaypath+0x12c>
			addMP3 = 1;
			subExt = 1;
		}
	}

	streamname = (char *)malloc((pplen+4+1)*sizeof(char));
   18dec:	e2850005 	add	r0, r5, #5
   18df0:	ebffb089 	bl	501c <malloc@plt>
			destptr += 4;
		} else {
			subExt = 0;
		}
	} else if (addMP3) {
		if (strncmp(ppstart, "mp3:", 4)) {
   18df4:	e59f6084 	ldr	r6, [pc, #132]	; 18e80 <RTMP_ParsePlaypath+0x254>
   18df8:	e08f6006 	add	r6, pc, r6
			subExt = 1;
		}
	}

	streamname = (char *)malloc((pplen+4+1)*sizeof(char));
	if (!streamname)
   18dfc:	e250a000 	subs	sl, r0, #0
   18e00:	1affffab 	bne	18cb4 <RTMP_ParsePlaypath+0x88>
   18e04:	eaffffcf 	b	18d48 <RTMP_ParsePlaypath+0x11c>
	int pplen = in->av_len;

	out->av_val = NULL;
	out->av_len = 0;

	if ((*ppstart == '?') &&
   18e08:	e59f1074 	ldr	r1, [pc, #116]	; 18e84 <RTMP_ParsePlaypath+0x258>
   18e0c:	e1a00006 	mov	r0, r6
   18e10:	e08f1001 	add	r1, pc, r1
   18e14:	ebffb0d7 	bl	5178 <strstr@plt>
   18e18:	e3500000 	cmp	r0, #0
   18e1c:	0affff8d 	beq	18c58 <RTMP_ParsePlaypath+0x2c>
	    (temp=strstr(ppstart, "slist=")) != 0) {
		ppstart = temp+6;
   18e20:	e2804006 	add	r4, r0, #6
		pplen = strlen(ppstart);
   18e24:	e1a00004 	mov	r0, r4
   18e28:	ebffb0b4 	bl	5100 <strlen@plt>

		temp = strchr(ppstart, '&');
   18e2c:	e3a01026 	mov	r1, #38	; 0x26
	out->av_len = 0;

	if ((*ppstart == '?') &&
	    (temp=strstr(ppstart, "slist=")) != 0) {
		ppstart = temp+6;
		pplen = strlen(ppstart);
   18e30:	e1a05000 	mov	r5, r0

		temp = strchr(ppstart, '&');
   18e34:	e1a00004 	mov	r0, r4
   18e38:	ebffb0aa 	bl	50e8 <strchr@plt>
		if (temp) {
   18e3c:	e3500000 	cmp	r0, #0
			pplen = temp-ppstart;
   18e40:	10645000 	rsbne	r5, r4, r0
   18e44:	eaffff84 	b	18c5c <RTMP_ParsePlaypath+0x30>
		    (strncmp(ext, ".mp4", 4) == 0)) {
			addMP4 = 1;
			subExt = 1;
		/* Only remove .flv from rtmp URL, not slist params */
		} else if ((ppstart == playpath) &&
		    (strncmp(ext, ".flv", 4) == 0)) {
   18e48:	e59f1038 	ldr	r1, [pc, #56]	; 18e88 <RTMP_ParsePlaypath+0x25c>
   18e4c:	e1a00007 	mov	r0, r7
   18e50:	e08f1001 	add	r1, pc, r1
   18e54:	e3a02004 	mov	r2, #4
   18e58:	ebffb156 	bl	53b8 <strncmp@plt>
		if ((strncmp(ext, ".f4v", 4) == 0) ||
		    (strncmp(ext, ".mp4", 4) == 0)) {
			addMP4 = 1;
			subExt = 1;
		/* Only remove .flv from rtmp URL, not slist params */
		} else if ((ppstart == playpath) &&
   18e5c:	e3500000 	cmp	r0, #0
   18e60:	1affffd9 	bne	18dcc <RTMP_ParsePlaypath+0x1a0>
		    (strncmp(ext, ".flv", 4) == 0)) {
			subExt = 1;
   18e64:	e3a08001 	mov	r8, #1
   18e68:	eaffffba 	b	18d58 <RTMP_ParsePlaypath+0x12c>
   18e6c:	0000870c 	.word	0x0000870c
   18e70:	0000870c 	.word	0x0000870c
   18e74:	00005498 	.word	0x00005498
   18e78:	000085ec 	.word	0x000085ec
   18e7c:	000085d8 	.word	0x000085d8
   18e80:	000085c4 	.word	0x000085c4
   18e84:	0000857c 	.word	0x0000857c
   18e88:	00008554 	.word	0x00008554

00018e8c <RTMP_ParseURL>:
#include "rtmp_sys.h"
#include "log.h"

int RTMP_ParseURL(const char *url, int *protocol, AVal *host, unsigned int *port,
	AVal *playpath, AVal *app)
{
   18e8c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   18e90:	e1a07001 	mov	r7, r1
	char *p, *end, *col, *ques, *slash;

	RTMP_Log(RTMP_LOGDEBUG, "Parsing...");
   18e94:	e59f140c 	ldr	r1, [pc, #1036]	; 192a8 <RTMP_ParseURL+0x41c>
#include "rtmp_sys.h"
#include "log.h"

int RTMP_ParseURL(const char *url, int *protocol, AVal *host, unsigned int *port,
	AVal *playpath, AVal *app)
{
   18e98:	e24dd014 	sub	sp, sp, #20
   18e9c:	e1a04000 	mov	r4, r0
	char *p, *end, *col, *ques, *slash;

	RTMP_Log(RTMP_LOGDEBUG, "Parsing...");
   18ea0:	e08f1001 	add	r1, pc, r1
   18ea4:	e3a00004 	mov	r0, #4
#include "rtmp_sys.h"
#include "log.h"

int RTMP_ParseURL(const char *url, int *protocol, AVal *host, unsigned int *port,
	AVal *playpath, AVal *app)
{
   18ea8:	e59d603c 	ldr	r6, [sp, #60]	; 0x3c
   18eac:	e1a0a003 	mov	sl, r3
   18eb0:	e1a0b002 	mov	fp, r2
	char *p, *end, *col, *ques, *slash;

	RTMP_Log(RTMP_LOGDEBUG, "Parsing...");
   18eb4:	ebfff2bc 	bl	159ac <RTMP_Log>

	*protocol = RTMP_PROTOCOL_RTMP;
	*port = 0;
	playpath->av_len = 0;
   18eb8:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
	app->av_val = NULL;

	/* Old School Parsing */

	/* look for usual :// pattern */
	p = strstr(url, "://");
   18ebc:	e59f13e8 	ldr	r1, [pc, #1000]	; 192ac <RTMP_ParseURL+0x420>
{
	char *p, *end, *col, *ques, *slash;

	RTMP_Log(RTMP_LOGDEBUG, "Parsing...");

	*protocol = RTMP_PROTOCOL_RTMP;
   18ec0:	e3a03000 	mov	r3, #0
   18ec4:	e5873000 	str	r3, [r7]
	app->av_val = NULL;

	/* Old School Parsing */

	/* look for usual :// pattern */
	p = strstr(url, "://");
   18ec8:	e1a00004 	mov	r0, r4
	char *p, *end, *col, *ques, *slash;

	RTMP_Log(RTMP_LOGDEBUG, "Parsing...");

	*protocol = RTMP_PROTOCOL_RTMP;
	*port = 0;
   18ecc:	e58a3000 	str	r3, [sl]
	app->av_val = NULL;

	/* Old School Parsing */

	/* look for usual :// pattern */
	p = strstr(url, "://");
   18ed0:	e08f1001 	add	r1, pc, r1

	RTMP_Log(RTMP_LOGDEBUG, "Parsing...");

	*protocol = RTMP_PROTOCOL_RTMP;
	*port = 0;
	playpath->av_len = 0;
   18ed4:	e5823004 	str	r3, [r2, #4]
	playpath->av_val = NULL;
   18ed8:	e5823000 	str	r3, [r2]
	app->av_len = 0;
   18edc:	e5863004 	str	r3, [r6, #4]
	app->av_val = NULL;
   18ee0:	e5863000 	str	r3, [r6]

	/* Old School Parsing */

	/* look for usual :// pattern */
	p = strstr(url, "://");
   18ee4:	ebffb0a3 	bl	5178 <strstr@plt>
	if(!p) {
   18ee8:	e2505000 	subs	r5, r0, #0
   18eec:	0a0000d8 	beq	19254 <RTMP_ParseURL+0x3c8>
		RTMP_Log(RTMP_LOGERROR, "RTMP URL: No :// in url!");
		return FALSE;
	}
	{
	int len = (int)(p-url);
   18ef0:	e0649005 	rsb	r9, r4, r5

	if(len == 4 && strncasecmp(url, "rtmp", 4)==0)
   18ef4:	e3590004 	cmp	r9, #4
   18ef8:	0a0000b0 	beq	191c0 <RTMP_ParseURL+0x334>
		*protocol = RTMP_PROTOCOL_RTMP;
	else if(len == 5 && strncasecmp(url, "rtmpt", 5)==0)
   18efc:	e3590005 	cmp	r9, #5
   18f00:	0a000069 	beq	190ac <RTMP_ParseURL+0x220>
	        *protocol = RTMP_PROTOCOL_RTMPS;
	else if(len == 5 && strncasecmp(url, "rtmpe", 5)==0)
	        *protocol = RTMP_PROTOCOL_RTMPE;
	else if(len == 5 && strncasecmp(url, "rtmfp", 5)==0)
	        *protocol = RTMP_PROTOCOL_RTMFP;
	else if(len == 6 && strncasecmp(url, "rtmpte", 6)==0)
   18f04:	e3590006 	cmp	r9, #6
   18f08:	1a00008b 	bne	1913c <RTMP_ParseURL+0x2b0>
   18f0c:	e59f139c 	ldr	r1, [pc, #924]	; 192b0 <RTMP_ParseURL+0x424>
   18f10:	e1a00004 	mov	r0, r4
   18f14:	e08f1001 	add	r1, pc, r1
   18f18:	e1a02009 	mov	r2, r9
   18f1c:	ebffb128 	bl	53c4 <strncasecmp@plt>
   18f20:	e3500000 	cmp	r0, #0
   18f24:	1a0000bd 	bne	19220 <RTMP_ParseURL+0x394>
	        *protocol = RTMP_PROTOCOL_RTMPTE;
   18f28:	e3a02003 	mov	r2, #3
   18f2c:	e5872000 	str	r2, [r7]
		RTMP_Log(RTMP_LOGWARNING, "Unknown protocol!\n");
		goto parsehost;
	}
	}

	RTMP_Log(RTMP_LOGDEBUG, "Parsed protocol: %d", *protocol);
   18f30:	e59f137c 	ldr	r1, [pc, #892]	; 192b4 <RTMP_ParseURL+0x428>
   18f34:	e3a00004 	mov	r0, #4
   18f38:	e08f1001 	add	r1, pc, r1
   18f3c:	ebfff29a 	bl	159ac <RTMP_Log>
parsehost:
	/* let's get the hostname */
	p+=3;

	/* check for sudden death */
	if(*p==0) {
   18f40:	e5d54003 	ldrb	r4, [r5, #3]

	RTMP_Log(RTMP_LOGDEBUG, "Parsed protocol: %d", *protocol);

parsehost:
	/* let's get the hostname */
	p+=3;
   18f44:	e2855003 	add	r5, r5, #3

	/* check for sudden death */
	if(*p==0) {
   18f48:	e3540000 	cmp	r4, #0
   18f4c:	0a000082 	beq	1915c <RTMP_ParseURL+0x2d0>
		RTMP_Log(RTMP_LOGWARNING, "No hostname in URL!");
		return FALSE;
	}

	end   = p + strlen(p);
   18f50:	e1a00005 	mov	r0, r5
   18f54:	ebffb069 	bl	5100 <strlen@plt>
	col   = strchr(p, ':');
   18f58:	e3a0103a 	mov	r1, #58	; 0x3a
	if(*p==0) {
		RTMP_Log(RTMP_LOGWARNING, "No hostname in URL!");
		return FALSE;
	}

	end   = p + strlen(p);
   18f5c:	e1a08000 	mov	r8, r0
	col   = strchr(p, ':');
   18f60:	e1a00005 	mov	r0, r5
   18f64:	ebffb05f 	bl	50e8 <strchr@plt>
	ques  = strchr(p, '?');
   18f68:	e3a0103f 	mov	r1, #63	; 0x3f
	if(*p==0) {
		RTMP_Log(RTMP_LOGWARNING, "No hostname in URL!");
		return FALSE;
	}

	end   = p + strlen(p);
   18f6c:	e0859008 	add	r9, r5, r8
	col   = strchr(p, ':');
   18f70:	e58d0004 	str	r0, [sp, #4]
	ques  = strchr(p, '?');
   18f74:	e1a00005 	mov	r0, r5
   18f78:	ebffb05a 	bl	50e8 <strchr@plt>
	slash = strchr(p, '/');
   18f7c:	e3a0102f 	mov	r1, #47	; 0x2f
		return FALSE;
	}

	end   = p + strlen(p);
	col   = strchr(p, ':');
	ques  = strchr(p, '?');
   18f80:	e1a07000 	mov	r7, r0
	slash = strchr(p, '/');
   18f84:	e1a00005 	mov	r0, r5
   18f88:	ebffb056 	bl	50e8 <strchr@plt>

	{
	int hostlen;
	if(slash)
   18f8c:	e59d3004 	ldr	r3, [sp, #4]
   18f90:	e2504000 	subs	r4, r0, #0
		hostlen = slash - p;
   18f94:	10658004 	rsbne	r8, r5, r4
	else
		hostlen = end - p;
	if(col && col -p < hostlen)
   18f98:	e3530000 	cmp	r3, #0
   18f9c:	0a000002 	beq	18fac <RTMP_ParseURL+0x120>
   18fa0:	e0653003 	rsb	r3, r5, r3
   18fa4:	e1580003 	cmp	r8, r3
   18fa8:	a1a08003 	movge	r8, r3
		hostlen = col - p;

	if(hostlen < 256) {
   18fac:	e35800ff 	cmp	r8, #255	; 0xff
   18fb0:	ca000070 	bgt	19178 <RTMP_ParseURL+0x2ec>
		host->av_val = p;
		host->av_len = hostlen;
		RTMP_Log(RTMP_LOGDEBUG, "Parsed host    : %.*s", hostlen, host->av_val);
   18fb4:	e59f12fc 	ldr	r1, [pc, #764]	; 192b8 <RTMP_ParseURL+0x42c>
   18fb8:	e3a00004 	mov	r0, #4
   18fbc:	e1a03005 	mov	r3, r5
	if(col && col -p < hostlen)
		hostlen = col - p;

	if(hostlen < 256) {
		host->av_val = p;
		host->av_len = hostlen;
   18fc0:	e88b0120 	stm	fp, {r5, r8}
		RTMP_Log(RTMP_LOGDEBUG, "Parsed host    : %.*s", hostlen, host->av_val);
   18fc4:	e08f1001 	add	r1, pc, r1
   18fc8:	e1a02008 	mov	r2, r8
   18fcc:	ebfff276 	bl	159ac <RTMP_Log>

	p+=hostlen;
	}

	/* get the port number if available */
	if(*p == ':') {
   18fd0:	e7d53008 	ldrb	r3, [r5, r8]
		RTMP_Log(RTMP_LOGDEBUG, "Parsed host    : %.*s", hostlen, host->av_val);
	} else {
		RTMP_Log(RTMP_LOGWARNING, "Hostname exceeds 255 characters!");
	}

	p+=hostlen;
   18fd4:	e0850008 	add	r0, r5, r8
	}

	/* get the port number if available */
	if(*p == ':') {
   18fd8:	e353003a 	cmp	r3, #58	; 0x3a
   18fdc:	0a00006d 	beq	19198 <RTMP_ParseURL+0x30c>
		} else {
			*port = p2;
		}
	}

	if(!slash) {
   18fe0:	e3540000 	cmp	r4, #0
   18fe4:	0a0000a0 	beq	1926c <RTMP_ParseURL+0x3e0>
		RTMP_Log(RTMP_LOGWARNING, "No application or playpath in URL!");
		return TRUE;
	}
	p = slash+1;
   18fe8:	e2844001 	add	r4, r4, #1
	 */

	char *slash2, *slash3 = NULL, *slash4 = NULL;
	int applen, appnamelen;

	slash2 = strchr(p, '/');
   18fec:	e1a00004 	mov	r0, r4
   18ff0:	e3a0102f 	mov	r1, #47	; 0x2f
   18ff4:	ebffb03b 	bl	50e8 <strchr@plt>
	if(slash2)
   18ff8:	e2505000 	subs	r5, r0, #0
   18ffc:	0a000091 	beq	19248 <RTMP_ParseURL+0x3bc>
		slash3 = strchr(slash2+1, '/');
   19000:	e2850001 	add	r0, r5, #1
   19004:	e3a0102f 	mov	r1, #47	; 0x2f
   19008:	ebffb036 	bl	50e8 <strchr@plt>
	if(slash3)
   1900c:	e250a000 	subs	sl, r0, #0
	 *
	 * rtmp://host[:port]/app[/appinstance][/...]
	 * application = app[/appinstance]
	 */

	char *slash2, *slash3 = NULL, *slash4 = NULL;
   19010:	01a0800a 	moveq	r8, sl
	int applen, appnamelen;

	slash2 = strchr(p, '/');
	if(slash2)
		slash3 = strchr(slash2+1, '/');
	if(slash3)
   19014:	0a000003 	beq	19028 <RTMP_ParseURL+0x19c>
		slash4 = strchr(slash3+1, '/');
   19018:	e28a0001 	add	r0, sl, #1
   1901c:	e3a0102f 	mov	r1, #47	; 0x2f
   19020:	ebffb030 	bl	50e8 <strchr@plt>
   19024:	e1a08000 	mov	r8, r0

	applen = end-p; /* ondemand, pass all parameters as app */
	appnamelen = applen; /* ondemand length */

	if(ques && strstr(p, "slist=")) { /* whatever it is, the '?' and slist= means we need to use everything as app and parse plapath from slist= */
   19028:	e3570000 	cmp	r7, #0
	if(slash2)
		slash3 = strchr(slash2+1, '/');
	if(slash3)
		slash4 = strchr(slash3+1, '/');

	applen = end-p; /* ondemand, pass all parameters as app */
   1902c:	e064b009 	rsb	fp, r4, r9
	appnamelen = applen; /* ondemand length */

	if(ques && strstr(p, "slist=")) { /* whatever it is, the '?' and slist= means we need to use everything as app and parse plapath from slist= */
   19030:	0a00006b 	beq	191e4 <RTMP_ParseURL+0x358>
   19034:	e59f1280 	ldr	r1, [pc, #640]	; 192bc <RTMP_ParseURL+0x430>
   19038:	e1a00004 	mov	r0, r4
   1903c:	e08f1001 	add	r1, pc, r1
   19040:	ebffb04c 	bl	5178 <strstr@plt>
   19044:	e3500000 	cmp	r0, #0
   19048:	0a000065 	beq	191e4 <RTMP_ParseURL+0x358>
		appnamelen = ques-p;
   1904c:	e0647007 	rsb	r7, r4, r7
		applen = appnamelen;
	}

	app->av_val = p;
	app->av_len = applen;
	RTMP_Log(RTMP_LOGDEBUG, "Parsed app     : %.*s", applen, p);
   19050:	e59f1268 	ldr	r1, [pc, #616]	; 192c0 <RTMP_ParseURL+0x434>
   19054:	e1a03004 	mov	r3, r4

		applen = appnamelen;
	}

	app->av_val = p;
	app->av_len = applen;
   19058:	e8860810 	stm	r6, {r4, fp}
	RTMP_Log(RTMP_LOGDEBUG, "Parsed app     : %.*s", applen, p);
   1905c:	e3a00004 	mov	r0, #4
   19060:	e1a0200b 	mov	r2, fp
   19064:	e08f1001 	add	r1, pc, r1
   19068:	ebfff24f 	bl	159ac <RTMP_Log>

	p += appnamelen;
	}

	if (*p == '/')
   1906c:	e7d43007 	ldrb	r3, [r4, r7]

	app->av_val = p;
	app->av_len = applen;
	RTMP_Log(RTMP_LOGDEBUG, "Parsed app     : %.*s", applen, p);

	p += appnamelen;
   19070:	e0844007 	add	r4, r4, r7
	}

	if (*p == '/')
   19074:	e353002f 	cmp	r3, #47	; 0x2f
		p++;
   19078:	02844001 	addeq	r4, r4, #1

	if (end-p) {
   1907c:	e1590004 	cmp	r9, r4
		AVal av = {p, end-p};
		RTMP_ParsePlaypath(&av, playpath);
	}

	return TRUE;
   19080:	03a00001 	moveq	r0, #1
	}

	if (*p == '/')
		p++;

	if (end-p) {
   19084:	0a000006 	beq	190a4 <RTMP_ParseURL+0x218>
		AVal av = {p, end-p};
		RTMP_ParsePlaypath(&av, playpath);
   19088:	e28d0008 	add	r0, sp, #8

	if (*p == '/')
		p++;

	if (end-p) {
		AVal av = {p, end-p};
   1908c:	e0649009 	rsb	r9, r4, r9
		RTMP_ParsePlaypath(&av, playpath);
   19090:	e59d1038 	ldr	r1, [sp, #56]	; 0x38

	if (*p == '/')
		p++;

	if (end-p) {
		AVal av = {p, end-p};
   19094:	e58d900c 	str	r9, [sp, #12]
   19098:	e58d4008 	str	r4, [sp, #8]
		RTMP_ParsePlaypath(&av, playpath);
   1909c:	ebfffee2 	bl	18c2c <RTMP_ParsePlaypath>
	}

	return TRUE;
   190a0:	e3a00001 	mov	r0, #1
}
   190a4:	e28dd014 	add	sp, sp, #20
   190a8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
	{
	int len = (int)(p-url);

	if(len == 4 && strncasecmp(url, "rtmp", 4)==0)
		*protocol = RTMP_PROTOCOL_RTMP;
	else if(len == 5 && strncasecmp(url, "rtmpt", 5)==0)
   190ac:	e59f1210 	ldr	r1, [pc, #528]	; 192c4 <RTMP_ParseURL+0x438>
   190b0:	e1a02009 	mov	r2, r9
   190b4:	e1a00004 	mov	r0, r4
   190b8:	e08f1001 	add	r1, pc, r1
   190bc:	ebffb0c0 	bl	53c4 <strncasecmp@plt>
   190c0:	e3500000 	cmp	r0, #0
		*protocol = RTMP_PROTOCOL_RTMPT;
   190c4:	03a02001 	moveq	r2, #1
   190c8:	05872000 	streq	r2, [r7]
	{
	int len = (int)(p-url);

	if(len == 4 && strncasecmp(url, "rtmp", 4)==0)
		*protocol = RTMP_PROTOCOL_RTMP;
	else if(len == 5 && strncasecmp(url, "rtmpt", 5)==0)
   190cc:	0affff97 	beq	18f30 <RTMP_ParseURL+0xa4>
		*protocol = RTMP_PROTOCOL_RTMPT;
	else if(len == 5 && strncasecmp(url, "rtmps", 5)==0)
   190d0:	e59f11f0 	ldr	r1, [pc, #496]	; 192c8 <RTMP_ParseURL+0x43c>
   190d4:	e1a02009 	mov	r2, r9
   190d8:	e1a00004 	mov	r0, r4
   190dc:	e08f1001 	add	r1, pc, r1
   190e0:	ebffb0b7 	bl	53c4 <strncasecmp@plt>
   190e4:	e3500000 	cmp	r0, #0
	        *protocol = RTMP_PROTOCOL_RTMPS;
   190e8:	03a02004 	moveq	r2, #4
   190ec:	05872000 	streq	r2, [r7]

	if(len == 4 && strncasecmp(url, "rtmp", 4)==0)
		*protocol = RTMP_PROTOCOL_RTMP;
	else if(len == 5 && strncasecmp(url, "rtmpt", 5)==0)
		*protocol = RTMP_PROTOCOL_RTMPT;
	else if(len == 5 && strncasecmp(url, "rtmps", 5)==0)
   190f0:	0affff8e 	beq	18f30 <RTMP_ParseURL+0xa4>
	        *protocol = RTMP_PROTOCOL_RTMPS;
	else if(len == 5 && strncasecmp(url, "rtmpe", 5)==0)
   190f4:	e59f11d0 	ldr	r1, [pc, #464]	; 192cc <RTMP_ParseURL+0x440>
   190f8:	e1a02009 	mov	r2, r9
   190fc:	e1a00004 	mov	r0, r4
   19100:	e08f1001 	add	r1, pc, r1
   19104:	ebffb0ae 	bl	53c4 <strncasecmp@plt>
   19108:	e3500000 	cmp	r0, #0
	        *protocol = RTMP_PROTOCOL_RTMPE;
   1910c:	03a02002 	moveq	r2, #2
   19110:	05872000 	streq	r2, [r7]
		*protocol = RTMP_PROTOCOL_RTMP;
	else if(len == 5 && strncasecmp(url, "rtmpt", 5)==0)
		*protocol = RTMP_PROTOCOL_RTMPT;
	else if(len == 5 && strncasecmp(url, "rtmps", 5)==0)
	        *protocol = RTMP_PROTOCOL_RTMPS;
	else if(len == 5 && strncasecmp(url, "rtmpe", 5)==0)
   19114:	0affff85 	beq	18f30 <RTMP_ParseURL+0xa4>
	        *protocol = RTMP_PROTOCOL_RTMPE;
	else if(len == 5 && strncasecmp(url, "rtmfp", 5)==0)
   19118:	e59f11b0 	ldr	r1, [pc, #432]	; 192d0 <RTMP_ParseURL+0x444>
   1911c:	e1a02009 	mov	r2, r9
   19120:	e1a00004 	mov	r0, r4
   19124:	e08f1001 	add	r1, pc, r1
   19128:	ebffb0a5 	bl	53c4 <strncasecmp@plt>
   1912c:	e3500000 	cmp	r0, #0
	        *protocol = RTMP_PROTOCOL_RTMFP;
   19130:	03a02008 	moveq	r2, #8
   19134:	05872000 	streq	r2, [r7]
		*protocol = RTMP_PROTOCOL_RTMPT;
	else if(len == 5 && strncasecmp(url, "rtmps", 5)==0)
	        *protocol = RTMP_PROTOCOL_RTMPS;
	else if(len == 5 && strncasecmp(url, "rtmpe", 5)==0)
	        *protocol = RTMP_PROTOCOL_RTMPE;
	else if(len == 5 && strncasecmp(url, "rtmfp", 5)==0)
   19138:	0affff7c 	beq	18f30 <RTMP_ParseURL+0xa4>
	else if(len == 6 && strncasecmp(url, "rtmpte", 6)==0)
	        *protocol = RTMP_PROTOCOL_RTMPTE;
	else if(len == 6 && strncasecmp(url, "rtmpts", 6)==0)
	        *protocol = RTMP_PROTOCOL_RTMPTS;
	else {
		RTMP_Log(RTMP_LOGWARNING, "Unknown protocol!\n");
   1913c:	e59f1190 	ldr	r1, [pc, #400]	; 192d4 <RTMP_ParseURL+0x448>
   19140:	e3a00002 	mov	r0, #2
   19144:	e08f1001 	add	r1, pc, r1
   19148:	ebfff217 	bl	159ac <RTMP_Log>
parsehost:
	/* let's get the hostname */
	p+=3;

	/* check for sudden death */
	if(*p==0) {
   1914c:	e5d54003 	ldrb	r4, [r5, #3]

	RTMP_Log(RTMP_LOGDEBUG, "Parsed protocol: %d", *protocol);

parsehost:
	/* let's get the hostname */
	p+=3;
   19150:	e2855003 	add	r5, r5, #3

	/* check for sudden death */
	if(*p==0) {
   19154:	e3540000 	cmp	r4, #0
   19158:	1affff7c 	bne	18f50 <RTMP_ParseURL+0xc4>
		RTMP_Log(RTMP_LOGWARNING, "No hostname in URL!");
   1915c:	e59f1174 	ldr	r1, [pc, #372]	; 192d8 <RTMP_ParseURL+0x44c>
   19160:	e3a00002 	mov	r0, #2
   19164:	e08f1001 	add	r1, pc, r1
   19168:	ebfff20f 	bl	159ac <RTMP_Log>
		return FALSE;
   1916c:	e1a00004 	mov	r0, r4
		AVal av = {p, end-p};
		RTMP_ParsePlaypath(&av, playpath);
	}

	return TRUE;
}
   19170:	e28dd014 	add	sp, sp, #20
   19174:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if(hostlen < 256) {
		host->av_val = p;
		host->av_len = hostlen;
		RTMP_Log(RTMP_LOGDEBUG, "Parsed host    : %.*s", hostlen, host->av_val);
	} else {
		RTMP_Log(RTMP_LOGWARNING, "Hostname exceeds 255 characters!");
   19178:	e59f115c 	ldr	r1, [pc, #348]	; 192dc <RTMP_ParseURL+0x450>
   1917c:	e3a00002 	mov	r0, #2
   19180:	e08f1001 	add	r1, pc, r1
   19184:	ebfff208 	bl	159ac <RTMP_Log>

	p+=hostlen;
	}

	/* get the port number if available */
	if(*p == ':') {
   19188:	e7d53008 	ldrb	r3, [r5, r8]
		RTMP_Log(RTMP_LOGDEBUG, "Parsed host    : %.*s", hostlen, host->av_val);
	} else {
		RTMP_Log(RTMP_LOGWARNING, "Hostname exceeds 255 characters!");
	}

	p+=hostlen;
   1918c:	e0850008 	add	r0, r5, r8
	}

	/* get the port number if available */
	if(*p == ':') {
   19190:	e353003a 	cmp	r3, #58	; 0x3a
   19194:	1affff91 	bne	18fe0 <RTMP_ParseURL+0x154>
		unsigned int p2;
		p++;
		p2 = atoi(p);
   19198:	e2800001 	add	r0, r0, #1
   1919c:	ebffafda 	bl	510c <atoi@plt>
		if(p2 > 65535) {
   191a0:	e3500801 	cmp	r0, #65536	; 0x10000
			RTMP_Log(RTMP_LOGWARNING, "Invalid port number!");
		} else {
			*port = p2;
   191a4:	358a0000 	strcc	r0, [sl]
	/* get the port number if available */
	if(*p == ':') {
		unsigned int p2;
		p++;
		p2 = atoi(p);
		if(p2 > 65535) {
   191a8:	3affff8c 	bcc	18fe0 <RTMP_ParseURL+0x154>
			RTMP_Log(RTMP_LOGWARNING, "Invalid port number!");
   191ac:	e59f112c 	ldr	r1, [pc, #300]	; 192e0 <RTMP_ParseURL+0x454>
   191b0:	e3a00002 	mov	r0, #2
   191b4:	e08f1001 	add	r1, pc, r1
   191b8:	ebfff1fb 	bl	159ac <RTMP_Log>
   191bc:	eaffff87 	b	18fe0 <RTMP_ParseURL+0x154>
		return FALSE;
	}
	{
	int len = (int)(p-url);

	if(len == 4 && strncasecmp(url, "rtmp", 4)==0)
   191c0:	e59f111c 	ldr	r1, [pc, #284]	; 192e4 <RTMP_ParseURL+0x458>
   191c4:	e1a02009 	mov	r2, r9
   191c8:	e1a00004 	mov	r0, r4
   191cc:	e08f1001 	add	r1, pc, r1
   191d0:	ebffb07b 	bl	53c4 <strncasecmp@plt>
   191d4:	e2502000 	subs	r2, r0, #0
   191d8:	1affffd7 	bne	1913c <RTMP_ParseURL+0x2b0>
	else if(len == 5 && strncasecmp(url, "rtmpe", 5)==0)
	        *protocol = RTMP_PROTOCOL_RTMPE;
	else if(len == 5 && strncasecmp(url, "rtmfp", 5)==0)
	        *protocol = RTMP_PROTOCOL_RTMFP;
	else if(len == 6 && strncasecmp(url, "rtmpte", 6)==0)
	        *protocol = RTMP_PROTOCOL_RTMPTE;
   191dc:	e5872000 	str	r2, [r7]
   191e0:	eaffff52 	b	18f30 <RTMP_ParseURL+0xa4>
	appnamelen = applen; /* ondemand length */

	if(ques && strstr(p, "slist=")) { /* whatever it is, the '?' and slist= means we need to use everything as app and parse plapath from slist= */
		appnamelen = ques-p;
	}
	else if(strncmp(p, "ondemand/", 9)==0) {
   191e4:	e59f10fc 	ldr	r1, [pc, #252]	; 192e8 <RTMP_ParseURL+0x45c>
   191e8:	e1a00004 	mov	r0, r4
   191ec:	e08f1001 	add	r1, pc, r1
   191f0:	e3a02009 	mov	r2, #9
   191f4:	ebffb06f 	bl	53b8 <strncmp@plt>
   191f8:	e3500000 	cmp	r0, #0
   191fc:	1a000002 	bne	1920c <RTMP_ParseURL+0x380>
   19200:	e3a0b008 	mov	fp, #8
                /* app = ondemand/foobar, only pass app=ondemand */
                applen = 8;
   19204:	e1a0700b 	mov	r7, fp
   19208:	eaffff90 	b	19050 <RTMP_ParseURL+0x1c4>
                appnamelen = 8;
        }
	else { /* app!=ondemand, so app is app[/appinstance] */
		if(slash4)
   1920c:	e3580000 	cmp	r8, #0
   19210:	0a00001b 	beq	19284 <RTMP_ParseURL+0x3f8>
			appnamelen = slash4-p;
   19214:	e064b008 	rsb	fp, r4, r8
   19218:	e1a0700b 	mov	r7, fp
   1921c:	eaffff8b 	b	19050 <RTMP_ParseURL+0x1c4>
	        *protocol = RTMP_PROTOCOL_RTMPE;
	else if(len == 5 && strncasecmp(url, "rtmfp", 5)==0)
	        *protocol = RTMP_PROTOCOL_RTMFP;
	else if(len == 6 && strncasecmp(url, "rtmpte", 6)==0)
	        *protocol = RTMP_PROTOCOL_RTMPTE;
	else if(len == 6 && strncasecmp(url, "rtmpts", 6)==0)
   19220:	e59f10c4 	ldr	r1, [pc, #196]	; 192ec <RTMP_ParseURL+0x460>
   19224:	e1a02009 	mov	r2, r9
   19228:	e1a00004 	mov	r0, r4
   1922c:	e08f1001 	add	r1, pc, r1
   19230:	ebffb063 	bl	53c4 <strncasecmp@plt>
   19234:	e3500000 	cmp	r0, #0
	        *protocol = RTMP_PROTOCOL_RTMPTS;
   19238:	03a02005 	moveq	r2, #5
   1923c:	05872000 	streq	r2, [r7]
	        *protocol = RTMP_PROTOCOL_RTMPE;
	else if(len == 5 && strncasecmp(url, "rtmfp", 5)==0)
	        *protocol = RTMP_PROTOCOL_RTMFP;
	else if(len == 6 && strncasecmp(url, "rtmpte", 6)==0)
	        *protocol = RTMP_PROTOCOL_RTMPTE;
	else if(len == 6 && strncasecmp(url, "rtmpts", 6)==0)
   19240:	0affff3a 	beq	18f30 <RTMP_ParseURL+0xa4>
   19244:	eaffffbc 	b	1913c <RTMP_ParseURL+0x2b0>
	 *
	 * rtmp://host[:port]/app[/appinstance][/...]
	 * application = app[/appinstance]
	 */

	char *slash2, *slash3 = NULL, *slash4 = NULL;
   19248:	e1a0a005 	mov	sl, r5
   1924c:	e1a08005 	mov	r8, r5
   19250:	eaffff74 	b	19028 <RTMP_ParseURL+0x19c>
	/* Old School Parsing */

	/* look for usual :// pattern */
	p = strstr(url, "://");
	if(!p) {
		RTMP_Log(RTMP_LOGERROR, "RTMP URL: No :// in url!");
   19254:	e59f1094 	ldr	r1, [pc, #148]	; 192f0 <RTMP_ParseURL+0x464>
   19258:	e3a00001 	mov	r0, #1
   1925c:	e08f1001 	add	r1, pc, r1
   19260:	ebfff1d1 	bl	159ac <RTMP_Log>
		return FALSE;
   19264:	e1a00005 	mov	r0, r5
   19268:	eaffff8d 	b	190a4 <RTMP_ParseURL+0x218>
			*port = p2;
		}
	}

	if(!slash) {
		RTMP_Log(RTMP_LOGWARNING, "No application or playpath in URL!");
   1926c:	e59f1080 	ldr	r1, [pc, #128]	; 192f4 <RTMP_ParseURL+0x468>
   19270:	e3a00002 	mov	r0, #2
   19274:	e08f1001 	add	r1, pc, r1
   19278:	ebfff1cb 	bl	159ac <RTMP_Log>
		return TRUE;
   1927c:	e3a00001 	mov	r0, #1
   19280:	eaffff87 	b	190a4 <RTMP_ParseURL+0x218>
                appnamelen = 8;
        }
	else { /* app!=ondemand, so app is app[/appinstance] */
		if(slash4)
			appnamelen = slash4-p;
		else if(slash3)
   19284:	e35a0000 	cmp	sl, #0
			appnamelen = slash3-p;
   19288:	1064b00a 	rsbne	fp, r4, sl
   1928c:	11a0700b 	movne	r7, fp
   19290:	1affff6e 	bne	19050 <RTMP_ParseURL+0x1c4>
		else if(slash2)
   19294:	e3550000 	cmp	r5, #0
			appnamelen = slash2-p;
   19298:	1064b005 	rsbne	fp, r4, r5
   1929c:	11a0700b 	movne	r7, fp
	else { /* app!=ondemand, so app is app[/appinstance] */
		if(slash4)
			appnamelen = slash4-p;
		else if(slash3)
			appnamelen = slash3-p;
		else if(slash2)
   192a0:	1affff6a 	bne	19050 <RTMP_ParseURL+0x1c4>
   192a4:	eaffffd6 	b	19204 <RTMP_ParseURL+0x378>
   192a8:	00008524 	.word	0x00008524
   192ac:	00005660 	.word	0x00005660
   192b0:	00008500 	.word	0x00008500
   192b4:	00008500 	.word	0x00008500
   192b8:	0000849c 	.word	0x0000849c
   192bc:	00008350 	.word	0x00008350
   192c0:	00008480 	.word	0x00008480
   192c4:	0000833c 	.word	0x0000833c
   192c8:	00008320 	.word	0x00008320
   192cc:	00008304 	.word	0x00008304
   192d0:	000082e8 	.word	0x000082e8
   192d4:	000082e0 	.word	0x000082e0
   192d8:	000082e8 	.word	0x000082e8
   192dc:	000082f8 	.word	0x000082f8
   192e0:	000082e8 	.word	0x000082e8
   192e4:	00008220 	.word	0x00008220
   192e8:	000082ec 	.word	0x000082ec
   192ec:	000081f0 	.word	0x000081f0
   192f0:	00008174 	.word	0x00008174
   192f4:	00008240 	.word	0x00008240

000192f8 <RTMP_Packet_AAC>:

sAudioData:aac裸数据
pAudioBuffer: audio缓冲区
*/
int RTMP_Packet_AAC(RTMP* pRtmp, unsigned char *sAudioData, int size, uint32_t nFrameTime, RTMPBuffer *pAudioBuffer)
{
   192f8:	e92d43f8 	push	{r3, r4, r5, r6, r7, r8, r9, lr}
	RTMPPacket *pPacket = NULL;
	pPacket = (RTMPPacket *)malloc(RTMP_HEAD_SIZE + size + 2);
   192fc:	e2826034 	add	r6, r2, #52	; 0x34

sAudioData:aac裸数据
pAudioBuffer: audio缓冲区
*/
int RTMP_Packet_AAC(RTMP* pRtmp, unsigned char *sAudioData, int size, uint32_t nFrameTime, RTMPBuffer *pAudioBuffer)
{
   19300:	e1a08000 	mov	r8, r0
	RTMPPacket *pPacket = NULL;
	pPacket = (RTMPPacket *)malloc(RTMP_HEAD_SIZE + size + 2);
   19304:	e1a00006 	mov	r0, r6

sAudioData:aac裸数据
pAudioBuffer: audio缓冲区
*/
int RTMP_Packet_AAC(RTMP* pRtmp, unsigned char *sAudioData, int size, uint32_t nFrameTime, RTMPBuffer *pAudioBuffer)
{
   19308:	e1a05002 	mov	r5, r2
   1930c:	e1a09001 	mov	r9, r1
   19310:	e1a07003 	mov	r7, r3
	RTMPPacket *pPacket = NULL;
	pPacket = (RTMPPacket *)malloc(RTMP_HEAD_SIZE + size + 2);
   19314:	ebffaf40 	bl	501c <malloc@plt>
	if (!pPacket)
   19318:	e2504000 	subs	r4, r0, #0
		return FALSE;
   1931c:	01a05004 	moveq	r5, r4
*/
int RTMP_Packet_AAC(RTMP* pRtmp, unsigned char *sAudioData, int size, uint32_t nFrameTime, RTMPBuffer *pAudioBuffer)
{
	RTMPPacket *pPacket = NULL;
	pPacket = (RTMPPacket *)malloc(RTMP_HEAD_SIZE + size + 2);
	if (!pPacket)
   19320:	0a000022 	beq	193b0 <RTMP_Packet_AAC+0xb8>
		return FALSE;
	
	memset(pPacket, 0, RTMP_HEAD_SIZE + size + 2);
   19324:	e1a02006 	mov	r2, r6
   19328:	e3a01000 	mov	r1, #0
   1932c:	ebffaf67 	bl	50d0 <memset@plt>
	pPacket->m_body = (char *)pPacket + RTMP_HEAD_SIZE;
	
	char *body = pPacket->m_body;
	int i = 0;
	body[i++] = pAudioBuffer->pAacConfig;
   19330:	e59d3020 	ldr	r3, [sp, #32]
	body[i++] = 0x01;
   19334:	e3a06001 	mov	r6, #1
	memset(pPacket, 0, RTMP_HEAD_SIZE + size + 2);
	pPacket->m_body = (char *)pPacket + RTMP_HEAD_SIZE;
	
	char *body = pPacket->m_body;
	int i = 0;
	body[i++] = pAudioBuffer->pAacConfig;
   19338:	e5d33018 	ldrb	r3, [r3, #24]
	pPacket = (RTMPPacket *)malloc(RTMP_HEAD_SIZE + size + 2);
	if (!pPacket)
		return FALSE;
	
	memset(pPacket, 0, RTMP_HEAD_SIZE + size + 2);
	pPacket->m_body = (char *)pPacket + RTMP_HEAD_SIZE;
   1933c:	e2842032 	add	r2, r4, #50	; 0x32
	
	char *body = pPacket->m_body;
	int i = 0;
	body[i++] = pAudioBuffer->pAacConfig;
	body[i++] = 0x01;
	memcpy(&body[i], sAudioData, size);
   19340:	e1a01009 	mov	r1, r9
	pPacket = (RTMPPacket *)malloc(RTMP_HEAD_SIZE + size + 2);
	if (!pPacket)
		return FALSE;
	
	memset(pPacket, 0, RTMP_HEAD_SIZE + size + 2);
	pPacket->m_body = (char *)pPacket + RTMP_HEAD_SIZE;
   19344:	e584201c 	str	r2, [r4, #28]
	
	char *body = pPacket->m_body;
	int i = 0;
	body[i++] = pAudioBuffer->pAacConfig;
   19348:	e5c43032 	strb	r3, [r4, #50]	; 0x32
	body[i++] = 0x01;
	memcpy(&body[i], sAudioData, size);
   1934c:	e1a02005 	mov	r2, r5
	pPacket->m_body = (char *)pPacket + RTMP_HEAD_SIZE;
	
	char *body = pPacket->m_body;
	int i = 0;
	body[i++] = pAudioBuffer->pAacConfig;
	body[i++] = 0x01;
   19350:	e5c46033 	strb	r6, [r4, #51]	; 0x33
	memcpy(&body[i], sAudioData, size);
   19354:	e2840034 	add	r0, r4, #52	; 0x34
   19358:	ebffaf9b 	bl	51cc <memcpy@plt>

	//填充packet字段
	pPacket->m_nBodySize = i + size;
   1935c:	e2855002 	add	r5, r5, #2
	pPacket->m_nTimeStamp = nFrameTime;
	pPacket->m_hasAbsTimestamp = 0;
	pPacket->m_packetType = RTMP_PACKET_TYPE_AUDIO;
	pPacket->m_nChannel = 0x04;
	pPacket->m_nInfoField2 = pRtmp->m_stream_id;
   19360:	e5982018 	ldr	r2, [r8, #24]
	memcpy(&body[i], sAudioData, size);

	//填充packet字段
	pPacket->m_nBodySize = i + size;
	pPacket->m_nTimeStamp = nFrameTime;
	pPacket->m_hasAbsTimestamp = 0;
   19364:	e3a03000 	mov	r3, #0
	pPacket->m_packetType = RTMP_PACKET_TYPE_AUDIO;
   19368:	e3a00008 	mov	r0, #8
	pPacket->m_nChannel = 0x04;
   1936c:	e3a01004 	mov	r1, #4
	body[i++] = pAudioBuffer->pAacConfig;
	body[i++] = 0x01;
	memcpy(&body[i], sAudioData, size);

	//填充packet字段
	pPacket->m_nBodySize = i + size;
   19370:	e5845010 	str	r5, [r4, #16]
	pPacket->m_nTimeStamp = nFrameTime;
	pPacket->m_hasAbsTimestamp = 0;
	pPacket->m_packetType = RTMP_PACKET_TYPE_AUDIO;
	pPacket->m_nChannel = 0x04;
	pPacket->m_nInfoField2 = pRtmp->m_stream_id;
   19374:	e584200c 	str	r2, [r4, #12]

	//填充packet字段
	pPacket->m_nBodySize = i + size;
	pPacket->m_nTimeStamp = nFrameTime;
	pPacket->m_hasAbsTimestamp = 0;
	pPacket->m_packetType = RTMP_PACKET_TYPE_AUDIO;
   19378:	e5c40001 	strb	r0, [r4, #1]
	pPacket->m_nChannel = 0x04;
   1937c:	e5841004 	str	r1, [r4, #4]
	body[i++] = 0x01;
	memcpy(&body[i], sAudioData, size);

	//填充packet字段
	pPacket->m_nBodySize = i + size;
	pPacket->m_nTimeStamp = nFrameTime;
   19380:	e5847008 	str	r7, [r4, #8]
	pPacket->m_nChannel = 0x04;
	pPacket->m_nInfoField2 = pRtmp->m_stream_id;
	pPacket->m_headerType = RTMP_PACKET_SIZE_LARGE;
	
	//将packet放入buffer中
	if (!RTMP_Put_Buffer(pAudioBuffer, pPacket, 1))
   19384:	e1a02006 	mov	r2, r6
	memcpy(&body[i], sAudioData, size);

	//填充packet字段
	pPacket->m_nBodySize = i + size;
	pPacket->m_nTimeStamp = nFrameTime;
	pPacket->m_hasAbsTimestamp = 0;
   19388:	e5c43002 	strb	r3, [r4, #2]
	pPacket->m_packetType = RTMP_PACKET_TYPE_AUDIO;
	pPacket->m_nChannel = 0x04;
	pPacket->m_nInfoField2 = pRtmp->m_stream_id;
	pPacket->m_headerType = RTMP_PACKET_SIZE_LARGE;
   1938c:	e5c43000 	strb	r3, [r4]
	
	//将packet放入buffer中
	if (!RTMP_Put_Buffer(pAudioBuffer, pPacket, 1))
   19390:	e59d0020 	ldr	r0, [sp, #32]
   19394:	e1a01004 	mov	r1, r4
   19398:	eb0004f3 	bl	1a76c <RTMP_Put_Buffer>
   1939c:	e2505000 	subs	r5, r0, #0
			pPacket = NULL;
		}
		return FALSE;
	}
	
	return TRUE;
   193a0:	11a05006 	movne	r5, r6
	pPacket->m_nChannel = 0x04;
	pPacket->m_nInfoField2 = pRtmp->m_stream_id;
	pPacket->m_headerType = RTMP_PACKET_SIZE_LARGE;
	
	//将packet放入buffer中
	if (!RTMP_Put_Buffer(pAudioBuffer, pPacket, 1))
   193a4:	1a000001 	bne	193b0 <RTMP_Packet_AAC+0xb8>
	{
		if (pPacket)
		{
			free(pPacket);
   193a8:	e1a00004 	mov	r0, r4
   193ac:	ebffaf14 	bl	5004 <free@plt>
		}
		return FALSE;
	}
	
	return TRUE;
}
   193b0:	e1a00005 	mov	r0, r5
   193b4:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}

000193b8 <RTMP_AAC_SequenceHeader>:

/*
将AAC 的sequence header 封装进packet
*/
int RTMP_AAC_SequenceHeader(RTMP* pRtmp, RTMP_AAC_ASC *pAacConfig, RTMPBuffer *pAudioBuffer)
{
   193b8:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   193bc:	e1a07000 	mov	r7, r0
   193c0:	e24dd00c 	sub	sp, sp, #12
	RTMPPacket *pPacket = NULL;
	pPacket = (RTMPPacket *)malloc(RTMP_HEAD_SIZE + 1024);
   193c4:	e59f016c 	ldr	r0, [pc, #364]	; 19538 <RTMP_AAC_SequenceHeader+0x180>

/*
将AAC 的sequence header 封装进packet
*/
int RTMP_AAC_SequenceHeader(RTMP* pRtmp, RTMP_AAC_ASC *pAacConfig, RTMPBuffer *pAudioBuffer)
{
   193c8:	e1a09001 	mov	r9, r1
   193cc:	e1a06002 	mov	r6, r2
	RTMPPacket *pPacket = NULL;
	pPacket = (RTMPPacket *)malloc(RTMP_HEAD_SIZE + 1024);
   193d0:	ebffaf11 	bl	501c <malloc@plt>
    if (!pPacket)
   193d4:	e2504000 	subs	r4, r0, #0
        return FALSE;
   193d8:	01a05004 	moveq	r5, r4
*/
int RTMP_AAC_SequenceHeader(RTMP* pRtmp, RTMP_AAC_ASC *pAacConfig, RTMPBuffer *pAudioBuffer)
{
	RTMPPacket *pPacket = NULL;
	pPacket = (RTMPPacket *)malloc(RTMP_HEAD_SIZE + 1024);
    if (!pPacket)
   193dc:	0a000052 	beq	1952c <RTMP_AAC_SequenceHeader+0x174>
        return FALSE;
	
	memset(pPacket, 0, RTMP_HEAD_SIZE + 10);
   193e0:	e3a01000 	mov	r1, #0
   193e4:	e3a0203c 	mov	r2, #60	; 0x3c
   193e8:	ebffaf38 	bl	50d0 <memset@plt>
	int i = 0;
	uint8_t audio_sequence = 0;
	audio_sequence |= ((pAacConfig->nSoundFormat << 4) & 0xF0);
	audio_sequence |= ((pAacConfig->nSoundRate << 2) & 0x0C);
	audio_sequence |= ((pAacConfig->nSoundSize << 1) & 0x02);
	audio_sequence |= (pAacConfig->nSoundType & 0x01);
   193ec:	e599100c 	ldr	r1, [r9, #12]
	char *body = pPacket->m_body;

	int i = 0;
	uint8_t audio_sequence = 0;
	audio_sequence |= ((pAacConfig->nSoundFormat << 4) & 0xF0);
	audio_sequence |= ((pAacConfig->nSoundRate << 2) & 0x0C);
   193f0:	e5992004 	ldr	r2, [r9, #4]
	
	char *body = pPacket->m_body;

	int i = 0;
	uint8_t audio_sequence = 0;
	audio_sequence |= ((pAacConfig->nSoundFormat << 4) & 0xF0);
   193f4:	e5998000 	ldr	r8, [r9]
	audio_sequence |= ((pAacConfig->nSoundRate << 2) & 0x0C);
	audio_sequence |= ((pAacConfig->nSoundSize << 1) & 0x02);
   193f8:	e5993008 	ldr	r3, [r9, #8]
	audio_sequence |= (pAacConfig->nSoundType & 0x01);
   193fc:	e2011001 	and	r1, r1, #1
	char *body = pPacket->m_body;

	int i = 0;
	uint8_t audio_sequence = 0;
	audio_sequence |= ((pAacConfig->nSoundFormat << 4) & 0xF0);
	audio_sequence |= ((pAacConfig->nSoundRate << 2) & 0x0C);
   19400:	e1a02102 	lsl	r2, r2, #2
   19404:	e1818208 	orr	r8, r1, r8, lsl #4
   19408:	e202200c 	and	r2, r2, #12
	audio_sequence |= ((pAacConfig->nSoundSize << 1) & 0x02);
   1940c:	e1a03083 	lsl	r3, r3, #1
   19410:	e1888002 	orr	r8, r8, r2
   19414:	e2033002 	and	r3, r3, #2
	audio_sequence |= (pAacConfig->nSoundType & 0x01);
   19418:	e1888003 	orr	r8, r8, r3
   1941c:	e20880ff 	and	r8, r8, #255	; 0xff

	pAudioBuffer->pAacConfig = audio_sequence;
   19420:	e5c68018 	strb	r8, [r6, #24]
	body[i++] = 0x00;

	//audio specification config
	uint16_t audio_specific_config=0;
	audio_specific_config |= ((pAacConfig->nSoundProfile << 11) & 0xF800);
	audio_specific_config |= ((pAacConfig->nSoundFrequencyIndex << 7) & 0x0780);
   19424:	e5993014 	ldr	r3, [r9, #20]
	audio_specific_config |= ((pAacConfig->nChannelConfiguration << 3) & 0x78);
   19428:	e5995018 	ldr	r5, [r9, #24]
	body[i++] = 0x00;

	//audio specification config
	uint16_t audio_specific_config=0;
	audio_specific_config |= ((pAacConfig->nSoundProfile << 11) & 0xF800);
	audio_specific_config |= ((pAacConfig->nSoundFrequencyIndex << 7) & 0x0780);
   1942c:	e1a03383 	lsl	r3, r3, #7
	audio_specific_config |= ((pAacConfig->nChannelConfiguration << 3) & 0x78);
   19430:	e1a05185 	lsl	r5, r5, #3
	body[i++] = audio_sequence;
	body[i++] = 0x00;

	//audio specification config
	uint16_t audio_specific_config=0;
	audio_specific_config |= ((pAacConfig->nSoundProfile << 11) & 0xF800);
   19434:	e5992010 	ldr	r2, [r9, #16]
	audio_specific_config |= ((pAacConfig->nSoundFrequencyIndex << 7) & 0x0780);
   19438:	e2033d1e 	and	r3, r3, #1920	; 0x780
	audio_specific_config |= ((pAacConfig->nChannelConfiguration << 3) & 0x78);
   1943c:	e2055078 	and	r5, r5, #120	; 0x78
   19440:	e1835005 	orr	r5, r3, r5
   19444:	e1855582 	orr	r5, r5, r2, lsl #11
   19448:	e1a05805 	lsl	r5, r5, #16
	audio_sequence |= (pAacConfig->nSoundType & 0x01);

	pAudioBuffer->pAacConfig = audio_sequence;

	body[i++] = audio_sequence;
	body[i++] = 0x00;
   1944c:	e3a09000 	mov	r9, #0

	body[i++] = (audio_specific_config >> 8) & 0xFF;
	body[i++] = audio_specific_config & 0xFF;

	//填充packet字段
	pPacket->m_nBodySize = i;
   19450:	e3a03004 	mov	r3, #4

	//audio specification config
	uint16_t audio_specific_config=0;
	audio_specific_config |= ((pAacConfig->nSoundProfile << 11) & 0xF800);
	audio_specific_config |= ((pAacConfig->nSoundFrequencyIndex << 7) & 0x0780);
	audio_specific_config |= ((pAacConfig->nChannelConfiguration << 3) & 0x78);
   19454:	e1a0a825 	lsr	sl, r5, #16
	pPacket->m_nBodySize = i;
	pPacket->m_nTimeStamp = 0;
	pPacket->m_hasAbsTimestamp = 0;
	pPacket->m_packetType = RTMP_PACKET_TYPE_AUDIO;
	pPacket->m_nChannel = 0x04;
	pPacket->m_nInfoField2 = pRtmp->m_stream_id;
   19458:	e5970018 	ldr	r0, [r7, #24]
	audio_specific_config |= ((pAacConfig->nSoundProfile << 11) & 0xF800);
	audio_specific_config |= ((pAacConfig->nSoundFrequencyIndex << 7) & 0x0780);
	audio_specific_config |= ((pAacConfig->nChannelConfiguration << 3) & 0x78);
	audio_specific_config |= 0 & 0x07;

	body[i++] = (audio_specific_config >> 8) & 0xFF;
   1945c:	e1a05c25 	lsr	r5, r5, #24
	pPacket = (RTMPPacket *)malloc(RTMP_HEAD_SIZE + 1024);
    if (!pPacket)
        return FALSE;
	
	memset(pPacket, 0, RTMP_HEAD_SIZE + 10);
	pPacket->m_body = (char *)pPacket + RTMP_HEAD_SIZE;
   19460:	e2841032 	add	r1, r4, #50	; 0x32

	//填充packet字段
	pPacket->m_nBodySize = i;
	pPacket->m_nTimeStamp = 0;
	pPacket->m_hasAbsTimestamp = 0;
	pPacket->m_packetType = RTMP_PACKET_TYPE_AUDIO;
   19464:	e3a02008 	mov	r2, #8

	body[i++] = (audio_specific_config >> 8) & 0xFF;
	body[i++] = audio_specific_config & 0xFF;

	//填充packet字段
	pPacket->m_nBodySize = i;
   19468:	e5843010 	str	r3, [r4, #16]
	pPacket->m_nTimeStamp = 0;
	pPacket->m_hasAbsTimestamp = 0;
	pPacket->m_packetType = RTMP_PACKET_TYPE_AUDIO;
	pPacket->m_nChannel = 0x04;
   1946c:	e5843004 	str	r3, [r4, #4]
	audio_specific_config |= ((pAacConfig->nSoundFrequencyIndex << 7) & 0x0780);
	audio_specific_config |= ((pAacConfig->nChannelConfiguration << 3) & 0x78);
	audio_specific_config |= 0 & 0x07;

	body[i++] = (audio_specific_config >> 8) & 0xFF;
	body[i++] = audio_specific_config & 0xFF;
   19470:	e5c4a035 	strb	sl, [r4, #53]	; 0x35
	audio_specific_config |= ((pAacConfig->nSoundProfile << 11) & 0xF800);
	audio_specific_config |= ((pAacConfig->nSoundFrequencyIndex << 7) & 0x0780);
	audio_specific_config |= ((pAacConfig->nChannelConfiguration << 3) & 0x78);
	audio_specific_config |= 0 & 0x07;

	body[i++] = (audio_specific_config >> 8) & 0xFF;
   19474:	e5c45034 	strb	r5, [r4, #52]	; 0x34
	pPacket->m_nBodySize = i;
	pPacket->m_nTimeStamp = 0;
	pPacket->m_hasAbsTimestamp = 0;
	pPacket->m_packetType = RTMP_PACKET_TYPE_AUDIO;
	pPacket->m_nChannel = 0x04;
	pPacket->m_nInfoField2 = pRtmp->m_stream_id;
   19478:	e584000c 	str	r0, [r4, #12]
	pPacket = (RTMPPacket *)malloc(RTMP_HEAD_SIZE + 1024);
    if (!pPacket)
        return FALSE;
	
	memset(pPacket, 0, RTMP_HEAD_SIZE + 10);
	pPacket->m_body = (char *)pPacket + RTMP_HEAD_SIZE;
   1947c:	e584101c 	str	r1, [r4, #28]

	//填充packet字段
	pPacket->m_nBodySize = i;
	pPacket->m_nTimeStamp = 0;
	pPacket->m_hasAbsTimestamp = 0;
	pPacket->m_packetType = RTMP_PACKET_TYPE_AUDIO;
   19480:	e5c42001 	strb	r2, [r4, #1]
	pPacket->m_nChannel = 0x04;
	pPacket->m_nInfoField2 = pRtmp->m_stream_id;
	pPacket->m_headerType = RTMP_PACKET_SIZE_LARGE;

	//将video sequence config拷贝到buffer中
	memset(pAudioBuffer->pPacketConfig, 0x00, RTMP_HEAD_SIZE + 1024);
   19484:	e1a01009 	mov	r1, r9
   19488:	e59f20a8 	ldr	r2, [pc, #168]	; 19538 <RTMP_AAC_SequenceHeader+0x180>
	pthread_mutex_lock(&pAudioBuffer->lock);
   1948c:	e286b030 	add	fp, r6, #48	; 0x30
	audio_sequence |= ((pAacConfig->nSoundSize << 1) & 0x02);
	audio_sequence |= (pAacConfig->nSoundType & 0x01);

	pAudioBuffer->pAacConfig = audio_sequence;

	body[i++] = audio_sequence;
   19490:	e5c48032 	strb	r8, [r4, #50]	; 0x32
	body[i++] = 0x00;
   19494:	e5c49033 	strb	r9, [r4, #51]	; 0x33
	body[i++] = (audio_specific_config >> 8) & 0xFF;
	body[i++] = audio_specific_config & 0xFF;

	//填充packet字段
	pPacket->m_nBodySize = i;
	pPacket->m_nTimeStamp = 0;
   19498:	e5849008 	str	r9, [r4, #8]
	pPacket->m_hasAbsTimestamp = 0;
   1949c:	e5c49002 	strb	r9, [r4, #2]
	pPacket->m_packetType = RTMP_PACKET_TYPE_AUDIO;
	pPacket->m_nChannel = 0x04;
	pPacket->m_nInfoField2 = pRtmp->m_stream_id;
	pPacket->m_headerType = RTMP_PACKET_SIZE_LARGE;
   194a0:	e5c49000 	strb	r9, [r4]

	//将video sequence config拷贝到buffer中
	memset(pAudioBuffer->pPacketConfig, 0x00, RTMP_HEAD_SIZE + 1024);
   194a4:	e5960020 	ldr	r0, [r6, #32]
   194a8:	ebffaf08 	bl	50d0 <memset@plt>
	pthread_mutex_lock(&pAudioBuffer->lock);
   194ac:	e1a0000b 	mov	r0, fp
   194b0:	ebffaf69 	bl	525c <pthread_mutex_lock@plt>
	memcpy(pAudioBuffer->pPacketConfig, pPacket, RTMP_HEAD_SIZE + 1024);
   194b4:	e1a01004 	mov	r1, r4
   194b8:	e59f2078 	ldr	r2, [pc, #120]	; 19538 <RTMP_AAC_SequenceHeader+0x180>
   194bc:	e5960020 	ldr	r0, [r6, #32]
   194c0:	ebffaf41 	bl	51cc <memcpy@plt>
	pAudioBuffer->pPacketConfig->m_body= (char *)pAudioBuffer->pPacketConfig + RTMP_HEAD_SIZE;
   194c4:	e5963020 	ldr	r3, [r6, #32]
	pthread_mutex_unlock(&pAudioBuffer->lock);
   194c8:	e1a0000b 	mov	r0, fp

	//将video sequence config拷贝到buffer中
	memset(pAudioBuffer->pPacketConfig, 0x00, RTMP_HEAD_SIZE + 1024);
	pthread_mutex_lock(&pAudioBuffer->lock);
	memcpy(pAudioBuffer->pPacketConfig, pPacket, RTMP_HEAD_SIZE + 1024);
	pAudioBuffer->pPacketConfig->m_body= (char *)pAudioBuffer->pPacketConfig + RTMP_HEAD_SIZE;
   194cc:	e2832032 	add	r2, r3, #50	; 0x32
   194d0:	e583201c 	str	r2, [r3, #28]
	pthread_mutex_unlock(&pAudioBuffer->lock);
   194d4:	ebffaf63 	bl	5268 <pthread_mutex_unlock@plt>

	//将packet放入buffer中
    printf("audio sh size:%d  %d  %d  %d\n", pPacket->m_nBodySize, audio_sequence, (audio_specific_config >> 8) & 0xFF, audio_specific_config & 0xFF);
   194d8:	e59f005c 	ldr	r0, [pc, #92]	; 1953c <RTMP_AAC_SequenceHeader+0x184>
   194dc:	e20aa0f8 	and	sl, sl, #248	; 0xf8
   194e0:	e1a03005 	mov	r3, r5
   194e4:	e5941010 	ldr	r1, [r4, #16]
   194e8:	e1a02008 	mov	r2, r8
   194ec:	e58da000 	str	sl, [sp]
   194f0:	e08f0000 	add	r0, pc, r0
   194f4:	ebffaf82 	bl	5304 <printf@plt>
    RTMP_SendPacket(pRtmp, pPacket, 0);
   194f8:	e1a01004 	mov	r1, r4
   194fc:	e1a02009 	mov	r2, r9
   19500:	e1a00007 	mov	r0, r7
   19504:	ebffc7bc 	bl	b3fc <RTMP_SendPacket>
	if (!RTMP_Put_Buffer(pAudioBuffer, pPacket, 1))
   19508:	e1a00006 	mov	r0, r6
   1950c:	e1a01004 	mov	r1, r4
   19510:	e3a02001 	mov	r2, #1
   19514:	eb000494 	bl	1a76c <RTMP_Put_Buffer>
   19518:	e2505000 	subs	r5, r0, #0
            pPacket = NULL;
        }
		return FALSE;
    }

	return TRUE;
   1951c:	13a05001 	movne	r5, #1
	pthread_mutex_unlock(&pAudioBuffer->lock);

	//将packet放入buffer中
    printf("audio sh size:%d  %d  %d  %d\n", pPacket->m_nBodySize, audio_sequence, (audio_specific_config >> 8) & 0xFF, audio_specific_config & 0xFF);
    RTMP_SendPacket(pRtmp, pPacket, 0);
	if (!RTMP_Put_Buffer(pAudioBuffer, pPacket, 1))
   19520:	1a000001 	bne	1952c <RTMP_AAC_SequenceHeader+0x174>
    {
        if (pPacket)
        {
            free(pPacket);
   19524:	e1a00004 	mov	r0, r4
   19528:	ebffaeb5 	bl	5004 <free@plt>
        }
		return FALSE;
    }

	return TRUE;
}
   1952c:	e1a00005 	mov	r0, r5
   19530:	e28dd00c 	add	sp, sp, #12
   19534:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
   19538:	00000432 	.word	0x00000432
   1953c:	0000800c 	.word	0x0000800c

00019540 <RTMP_Set_AAC_SequenceHeader>:

void RTMP_Set_AAC_SequenceHeader(RTMP_AAC_ASC *pAacConfig, int channel, int FrequencyIndex, int samplesize, int profile)
{
   19540:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
   19544:	e1a06001 	mov	r6, r1
   19548:	e1a05002 	mov	r5, r2
	memset(pAacConfig, 0x00, sizeof(RTMP_AAC_ASC));
   1954c:	e3a01000 	mov	r1, #0
   19550:	e3a0201c 	mov	r2, #28

	return TRUE;
}

void RTMP_Set_AAC_SequenceHeader(RTMP_AAC_ASC *pAacConfig, int channel, int FrequencyIndex, int samplesize, int profile)
{
   19554:	e1a04000 	mov	r4, r0
   19558:	e1a07003 	mov	r7, r3
   1955c:	e59d8018 	ldr	r8, [sp, #24]
	memset(pAacConfig, 0x00, sizeof(RTMP_AAC_ASC));
   19560:	ebffaeda 	bl	50d0 <memset@plt>
	pAacConfig->nChannelConfiguration = channel;
	pAacConfig->nSoundType = channel - 1;
	pAacConfig->nSoundProfile = profile;
	pAacConfig->nSoundFormat = 10;
	
	switch(FrequencyIndex)
   19564:	e59f3148 	ldr	r3, [pc, #328]	; 196b4 <RTMP_Set_AAC_SequenceHeader+0x174>

void RTMP_Set_AAC_SequenceHeader(RTMP_AAC_ASC *pAacConfig, int channel, int FrequencyIndex, int samplesize, int profile)
{
	memset(pAacConfig, 0x00, sizeof(RTMP_AAC_ASC));
	pAacConfig->nChannelConfiguration = channel;
	pAacConfig->nSoundType = channel - 1;
   19568:	e2462001 	sub	r2, r6, #1
	pAacConfig->nSoundProfile = profile;
	pAacConfig->nSoundFormat = 10;
	
	switch(FrequencyIndex)
   1956c:	e1550003 	cmp	r5, r3
{
	memset(pAacConfig, 0x00, sizeof(RTMP_AAC_ASC));
	pAacConfig->nChannelConfiguration = channel;
	pAacConfig->nSoundType = channel - 1;
	pAacConfig->nSoundProfile = profile;
	pAacConfig->nSoundFormat = 10;
   19570:	e3a0300a 	mov	r3, #10
}

void RTMP_Set_AAC_SequenceHeader(RTMP_AAC_ASC *pAacConfig, int channel, int FrequencyIndex, int samplesize, int profile)
{
	memset(pAacConfig, 0x00, sizeof(RTMP_AAC_ASC));
	pAacConfig->nChannelConfiguration = channel;
   19574:	e5846018 	str	r6, [r4, #24]
	pAacConfig->nSoundType = channel - 1;
   19578:	e584200c 	str	r2, [r4, #12]
	pAacConfig->nSoundProfile = profile;
   1957c:	e5848010 	str	r8, [r4, #16]
	pAacConfig->nSoundFormat = 10;
   19580:	e5843000 	str	r3, [r4]
	
	switch(FrequencyIndex)
   19584:	0a000026 	beq	19624 <RTMP_Set_AAC_SequenceHeader+0xe4>
   19588:	da000011 	ble	195d4 <RTMP_Set_AAC_SequenceHeader+0x94>
   1958c:	e3550cfa 	cmp	r5, #64000	; 0xfa00
   19590:	0a00003d 	beq	1968c <RTMP_Set_AAC_SequenceHeader+0x14c>
   19594:	da00001c 	ble	1960c <RTMP_Set_AAC_SequenceHeader+0xcc>
   19598:	e59f3118 	ldr	r3, [pc, #280]	; 196b8 <RTMP_Set_AAC_SequenceHeader+0x178>
   1959c:	e1550003 	cmp	r5, r3
   195a0:	0a000028 	beq	19648 <RTMP_Set_AAC_SequenceHeader+0x108>
   195a4:	e59f3110 	ldr	r3, [pc, #272]	; 196bc <RTMP_Set_AAC_SequenceHeader+0x17c>
   195a8:	e1550003 	cmp	r5, r3
   195ac:	1a00001c 	bne	19624 <RTMP_Set_AAC_SequenceHeader+0xe4>
	{
		case 96000:
			pAacConfig->nSoundFrequencyIndex = 0;
   195b0:	e3a02000 	mov	r2, #0
			pAacConfig->nSoundRate = 3;
   195b4:	e3a03003 	mov	r3, #3
			pAacConfig->nSoundFrequencyIndex = 4;
			pAacConfig->nSoundRate = 3;
			break;
	}
	
	switch(samplesize)
   195b8:	e3570008 	cmp	r7, #8
	pAacConfig->nSoundFormat = 10;
	
	switch(FrequencyIndex)
	{
		case 96000:
			pAacConfig->nSoundFrequencyIndex = 0;
   195bc:	e5842014 	str	r2, [r4, #20]
			pAacConfig->nSoundRate = 3;
   195c0:	e5843004 	str	r3, [r4, #4]
			pAacConfig->nSoundFrequencyIndex = 4;
			pAacConfig->nSoundRate = 3;
			break;
	}
	
	switch(samplesize)
   195c4:	1a00001c 	bne	1963c <RTMP_Set_AAC_SequenceHeader+0xfc>
	{
		case 8:
			pAacConfig->nSoundSize = 0;
   195c8:	e3a03000 	mov	r3, #0
   195cc:	e5843008 	str	r3, [r4, #8]
			break;
   195d0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
	pAacConfig->nChannelConfiguration = channel;
	pAacConfig->nSoundType = channel - 1;
	pAacConfig->nSoundProfile = profile;
	pAacConfig->nSoundFormat = 10;
	
	switch(FrequencyIndex)
   195d4:	e59f30e4 	ldr	r3, [pc, #228]	; 196c0 <RTMP_Set_AAC_SequenceHeader+0x180>
   195d8:	e1550003 	cmp	r5, r3
   195dc:	0a00002f 	beq	196a0 <RTMP_Set_AAC_SequenceHeader+0x160>
   195e0:	da000022 	ble	19670 <RTMP_Set_AAC_SequenceHeader+0x130>
   195e4:	e59f30d8 	ldr	r3, [pc, #216]	; 196c4 <RTMP_Set_AAC_SequenceHeader+0x184>
   195e8:	e1550003 	cmp	r5, r3
   195ec:	0a00001a 	beq	1965c <RTMP_Set_AAC_SequenceHeader+0x11c>
   195f0:	e3550c7d 	cmp	r5, #32000	; 0x7d00
   195f4:	1a00000a 	bne	19624 <RTMP_Set_AAC_SequenceHeader+0xe4>
		case 44100:
			pAacConfig->nSoundFrequencyIndex = 4;
			pAacConfig->nSoundRate = 3;
			break;
		case 32000:
			pAacConfig->nSoundFrequencyIndex = 5;
   195f8:	e3a02005 	mov	r2, #5
			pAacConfig->nSoundRate = 2;
   195fc:	e3a03002 	mov	r3, #2
		case 44100:
			pAacConfig->nSoundFrequencyIndex = 4;
			pAacConfig->nSoundRate = 3;
			break;
		case 32000:
			pAacConfig->nSoundFrequencyIndex = 5;
   19600:	e5842014 	str	r2, [r4, #20]
			pAacConfig->nSoundRate = 2;
   19604:	e5843004 	str	r3, [r4, #4]
			break;
   19608:	ea000009 	b	19634 <RTMP_Set_AAC_SequenceHeader+0xf4>
	pAacConfig->nChannelConfiguration = channel;
	pAacConfig->nSoundType = channel - 1;
	pAacConfig->nSoundProfile = profile;
	pAacConfig->nSoundFormat = 10;
	
	switch(FrequencyIndex)
   1960c:	e59f30b4 	ldr	r3, [pc, #180]	; 196c8 <RTMP_Set_AAC_SequenceHeader+0x188>
   19610:	e1550003 	cmp	r5, r3
		case 64000:
			pAacConfig->nSoundFrequencyIndex = 2;
			pAacConfig->nSoundRate = 3;
			break;
		case 48000:
			pAacConfig->nSoundFrequencyIndex = 3;
   19614:	03a03003 	moveq	r3, #3
   19618:	05843014 	streq	r3, [r4, #20]
			pAacConfig->nSoundRate = 3;
   1961c:	05843004 	streq	r3, [r4, #4]
	pAacConfig->nChannelConfiguration = channel;
	pAacConfig->nSoundType = channel - 1;
	pAacConfig->nSoundProfile = profile;
	pAacConfig->nSoundFormat = 10;
	
	switch(FrequencyIndex)
   19620:	0a000003 	beq	19634 <RTMP_Set_AAC_SequenceHeader+0xf4>
			pAacConfig->nSoundFrequencyIndex = 8;
			pAacConfig->nSoundRate = 0;
			break;

		default:
			pAacConfig->nSoundFrequencyIndex = 4;
   19624:	e3a02004 	mov	r2, #4
			pAacConfig->nSoundRate = 3;
   19628:	e3a03003 	mov	r3, #3
			pAacConfig->nSoundFrequencyIndex = 8;
			pAacConfig->nSoundRate = 0;
			break;

		default:
			pAacConfig->nSoundFrequencyIndex = 4;
   1962c:	e5842014 	str	r2, [r4, #20]
			pAacConfig->nSoundRate = 3;
   19630:	e5843004 	str	r3, [r4, #4]
			break;
	}
	
	switch(samplesize)
   19634:	e3570008 	cmp	r7, #8
   19638:	0affffe2 	beq	195c8 <RTMP_Set_AAC_SequenceHeader+0x88>
			break;
		case 16:
			pAacConfig->nSoundSize = 1;
			break;
		default:
			pAacConfig->nSoundSize = 1;
   1963c:	e3a03001 	mov	r3, #1
   19640:	e5843008 	str	r3, [r4, #8]
   19644:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
		case 96000:
			pAacConfig->nSoundFrequencyIndex = 0;
			pAacConfig->nSoundRate = 3;
			break;
		case 88200:
			pAacConfig->nSoundFrequencyIndex = 1;
   19648:	e3a02001 	mov	r2, #1
			pAacConfig->nSoundRate = 3;
   1964c:	e3a03003 	mov	r3, #3
		case 96000:
			pAacConfig->nSoundFrequencyIndex = 0;
			pAacConfig->nSoundRate = 3;
			break;
		case 88200:
			pAacConfig->nSoundFrequencyIndex = 1;
   19650:	e5842014 	str	r2, [r4, #20]
			pAacConfig->nSoundRate = 3;
   19654:	e5843004 	str	r3, [r4, #4]
			break;
   19658:	eafffff5 	b	19634 <RTMP_Set_AAC_SequenceHeader+0xf4>
		case 32000:
			pAacConfig->nSoundFrequencyIndex = 5;
			pAacConfig->nSoundRate = 2;
			break;
		case 24000:
			pAacConfig->nSoundFrequencyIndex = 6;
   1965c:	e3a02006 	mov	r2, #6
			pAacConfig->nSoundRate = 1;
   19660:	e3a03001 	mov	r3, #1
		case 32000:
			pAacConfig->nSoundFrequencyIndex = 5;
			pAacConfig->nSoundRate = 2;
			break;
		case 24000:
			pAacConfig->nSoundFrequencyIndex = 6;
   19664:	e5842014 	str	r2, [r4, #20]
			pAacConfig->nSoundRate = 1;
   19668:	e5843004 	str	r3, [r4, #4]
			break;
   1966c:	eafffff0 	b	19634 <RTMP_Set_AAC_SequenceHeader+0xf4>
	pAacConfig->nChannelConfiguration = channel;
	pAacConfig->nSoundType = channel - 1;
	pAacConfig->nSoundProfile = profile;
	pAacConfig->nSoundFormat = 10;
	
	switch(FrequencyIndex)
   19670:	e3550dfa 	cmp	r5, #16000	; 0x3e80
   19674:	1affffea 	bne	19624 <RTMP_Set_AAC_SequenceHeader+0xe4>
		case 22050:
			pAacConfig->nSoundFrequencyIndex = 7;
			pAacConfig->nSoundRate = 0;
			break;
		case 16000:
			pAacConfig->nSoundFrequencyIndex = 8;
   19678:	e3a02008 	mov	r2, #8
			pAacConfig->nSoundRate = 0;
   1967c:	e3a03000 	mov	r3, #0
		case 22050:
			pAacConfig->nSoundFrequencyIndex = 7;
			pAacConfig->nSoundRate = 0;
			break;
		case 16000:
			pAacConfig->nSoundFrequencyIndex = 8;
   19680:	e5842014 	str	r2, [r4, #20]
			pAacConfig->nSoundRate = 0;
   19684:	e5843004 	str	r3, [r4, #4]
			break;
   19688:	eaffffe9 	b	19634 <RTMP_Set_AAC_SequenceHeader+0xf4>
		case 88200:
			pAacConfig->nSoundFrequencyIndex = 1;
			pAacConfig->nSoundRate = 3;
			break;
		case 64000:
			pAacConfig->nSoundFrequencyIndex = 2;
   1968c:	e3a02002 	mov	r2, #2
			pAacConfig->nSoundRate = 3;
   19690:	e3a03003 	mov	r3, #3
		case 88200:
			pAacConfig->nSoundFrequencyIndex = 1;
			pAacConfig->nSoundRate = 3;
			break;
		case 64000:
			pAacConfig->nSoundFrequencyIndex = 2;
   19694:	e5842014 	str	r2, [r4, #20]
			pAacConfig->nSoundRate = 3;
   19698:	e5843004 	str	r3, [r4, #4]
			break;
   1969c:	eaffffe4 	b	19634 <RTMP_Set_AAC_SequenceHeader+0xf4>
		case 24000:
			pAacConfig->nSoundFrequencyIndex = 6;
			pAacConfig->nSoundRate = 1;
			break;
		case 22050:
			pAacConfig->nSoundFrequencyIndex = 7;
   196a0:	e3a02007 	mov	r2, #7
			pAacConfig->nSoundRate = 0;
   196a4:	e3a03000 	mov	r3, #0
		case 24000:
			pAacConfig->nSoundFrequencyIndex = 6;
			pAacConfig->nSoundRate = 1;
			break;
		case 22050:
			pAacConfig->nSoundFrequencyIndex = 7;
   196a8:	e5842014 	str	r2, [r4, #20]
			pAacConfig->nSoundRate = 0;
   196ac:	e5843004 	str	r3, [r4, #4]
			break;
   196b0:	eaffffdf 	b	19634 <RTMP_Set_AAC_SequenceHeader+0xf4>
   196b4:	0000ac44 	.word	0x0000ac44
   196b8:	00015888 	.word	0x00015888
   196bc:	00017700 	.word	0x00017700
   196c0:	00005622 	.word	0x00005622
   196c4:	00005dc0 	.word	0x00005dc0
   196c8:	0000bb80 	.word	0x0000bb80

000196cc <RTMP_Decode_SPS>:

int RTMP_Decode_SPS(unsigned char *sVideoData,RTMP_SPS_PPS *sSps)
{

	return TRUE;
}
   196cc:	e3a00001 	mov	r0, #1
   196d0:	e12fff1e 	bx	lr

000196d4 <RTMP_Packet_SPS_PPS>:

/*
将SPS，PPS数据组装成packet
*/
int RTMP_Packet_SPS_PPS(RTMP* pRtmp,RTMP_SPS_PPS sSPSPPS,uint32_t nTime,RTMPPacket *pPacket)
{
   196d4:	e24dd010 	sub	sp, sp, #16
   196d8:	e92d4ff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   196dc:	e59d5040 	ldr	r5, [sp, #64]	; 0x40
   196e0:	e28dc02c 	add	ip, sp, #44	; 0x2c
	unsigned char *body = (unsigned char *)pPacket->m_body;
   196e4:	e595401c 	ldr	r4, [r5, #28]

/*
将SPS，PPS数据组装成packet
*/
int RTMP_Packet_SPS_PPS(RTMP* pRtmp,RTMP_SPS_PPS sSPSPPS,uint32_t nTime,RTMPPacket *pPacket)
{
   196e8:	e88c000e 	stm	ip, {r1, r2, r3}
   196ec:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
	unsigned char *body = (unsigned char *)pPacket->m_body;
	int i = 0;

	body[i++] = 0x17; // 1:keyframe 7:AVCVIDEOPACKET
	body[i++] = 0x00; // 0:AVC sequence header
   196f0:	e3a06000 	mov	r6, #0
	body[i++] = 0x00; // Composion Time
	body[i++] = 0x00; // Composion Time
	body[i++] = 0x00; // Composion Time

	/*AVCDecoderConfigurationRecord*/
	body[i++] = 0x01; // 版本号，1
   196f4:	e3a0a001 	mov	sl, #1
int RTMP_Packet_SPS_PPS(RTMP* pRtmp,RTMP_SPS_PPS sSPSPPS,uint32_t nTime,RTMPPacket *pPacket)
{
	unsigned char *body = (unsigned char *)pPacket->m_body;
	int i = 0;

	body[i++] = 0x17; // 1:keyframe 7:AVCVIDEOPACKET
   196f8:	e3a03017 	mov	r3, #23
   196fc:	e59d702c 	ldr	r7, [sp, #44]	; 0x2c
   19700:	e5c43000 	strb	r3, [r4]
	body[i++] = 0x00; // 0:AVC sequence header
   19704:	e5c46001 	strb	r6, [r4, #1]

	body[i++] = 0x00; // Composion Time
   19708:	e5c46002 	strb	r6, [r4, #2]
	body[i++] = 0x00; // Composion Time
   1970c:	e5c46003 	strb	r6, [r4, #3]
	body[i++] = 0x00; // Composion Time
   19710:	e5c46004 	strb	r6, [r4, #4]

	/*AVCDecoderConfigurationRecord*/
	body[i++] = 0x01; // 版本号，1
   19714:	e5c4a005 	strb	sl, [r4, #5]
	body[i++] = sSPSPPS.sSPS[1]; // sps[1]
   19718:	e5d13001 	ldrb	r3, [r1, #1]
   1971c:	e5c43006 	strb	r3, [r4, #6]
	body[i++] = sSPSPPS.sSPS[2]; // sps[2]
   19720:	e5d13002 	ldrb	r3, [r1, #2]
   19724:	e59d9034 	ldr	r9, [sp, #52]	; 0x34
   19728:	e5c43007 	strb	r3, [r4, #7]
	body[i++] = sSPSPPS.sSPS[3]; // sps[3]
	body[i++] = 0xff; // 6bit：reserved，111111；2bit：lengthSizeMinusOne，一般为3
   1972c:	e3e0e000 	mvn	lr, #0

	/*AVCDecoderConfigurationRecord*/
	body[i++] = 0x01; // 版本号，1
	body[i++] = sSPSPPS.sSPS[1]; // sps[1]
	body[i++] = sSPSPPS.sSPS[2]; // sps[2]
	body[i++] = sSPSPPS.sSPS[3]; // sps[3]
   19730:	e5d18003 	ldrb	r8, [r1, #3]
	body[i++] = 0xff; // 6bit：reserved，111111；2bit：lengthSizeMinusOne，一般为3

	/* SPS */
	body[i++] = 0xe1; // 3bit：reserved，111；5bit：numOfSequenceParameterSets，一般为1
   19734:	e3e0c01e 	mvn	ip, #30
	body[i++] = (sSPSPPS.nSPSLen >> 8) & 0xff;
   19738:	e1a02427 	lsr	r2, r7, #8

/*
将SPS，PPS数据组装成packet
*/
int RTMP_Packet_SPS_PPS(RTMP* pRtmp,RTMP_SPS_PPS sSPSPPS,uint32_t nTime,RTMPPacket *pPacket)
{
   1973c:	e1a0b000 	mov	fp, r0

	/*AVCDecoderConfigurationRecord*/
	body[i++] = 0x01; // 版本号，1
	body[i++] = sSPSPPS.sSPS[1]; // sps[1]
	body[i++] = sSPSPPS.sSPS[2]; // sps[2]
	body[i++] = sSPSPPS.sSPS[3]; // sps[3]
   19740:	e5c48008 	strb	r8, [r4, #8]
	body[i++] = 0xff; // 6bit：reserved，111111；2bit：lengthSizeMinusOne，一般为3
   19744:	e5c4e009 	strb	lr, [r4, #9]

	/* SPS */
	body[i++] = 0xe1; // 3bit：reserved，111；5bit：numOfSequenceParameterSets，一般为1
   19748:	e5c4c00a 	strb	ip, [r4, #10]
	body[i++] = (sSPSPPS.nSPSLen >> 8) & 0xff;
	body[i++] = sSPSPPS.nSPSLen & 0xff;	
   1974c:	e5c4700c 	strb	r7, [r4, #12]
	body[i++] = sSPSPPS.sSPS[3]; // sps[3]
	body[i++] = 0xff; // 6bit：reserved，111111；2bit：lengthSizeMinusOne，一般为3

	/* SPS */
	body[i++] = 0xe1; // 3bit：reserved，111；5bit：numOfSequenceParameterSets，一般为1
	body[i++] = (sSPSPPS.nSPSLen >> 8) & 0xff;
   19750:	e5c4200b 	strb	r2, [r4, #11]
	body[i++] = sSPSPPS.nSPSLen & 0xff;	
	memcpy(&body[i], sSPSPPS.sSPS, sSPSPPS.nSPSLen);
   19754:	e284000d 	add	r0, r4, #13
   19758:	e1a02007 	mov	r2, r7
   1975c:	ebffae9a 	bl	51cc <memcpy@plt>
	i += sSPSPPS.nSPSLen;

	/* PPS */
	body[i++] = 0x01; // numOfPictureParameterSets，一般为1
	body[i++] = (sSPSPPS.nPPSLen >> 8) & 0xff;
	body[i++] = (sSPSPPS.nPPSLen) & 0xff;	
   19760:	e2878010 	add	r8, r7, #16
	body[i++] = sSPSPPS.nSPSLen & 0xff;	
	memcpy(&body[i], sSPSPPS.sSPS, sSPSPPS.nSPSLen);
	i += sSPSPPS.nSPSLen;

	/* PPS */
	body[i++] = 0x01; // numOfPictureParameterSets，一般为1
   19764:	e1a02004 	mov	r2, r4
	body[i++] = (sSPSPPS.nPPSLen >> 8) & 0xff;
   19768:	e1a01429 	lsr	r1, r9, #8
	/* SPS */
	body[i++] = 0xe1; // 3bit：reserved，111；5bit：numOfSequenceParameterSets，一般为1
	body[i++] = (sSPSPPS.nSPSLen >> 8) & 0xff;
	body[i++] = sSPSPPS.nSPSLen & 0xff;	
	memcpy(&body[i], sSPSPPS.sSPS, sSPSPPS.nSPSLen);
	i += sSPSPPS.nSPSLen;
   1976c:	e287700d 	add	r7, r7, #13

	/* PPS */
	body[i++] = 0x01; // numOfPictureParameterSets，一般为1
   19770:	e7e2a007 	strb	sl, [r2, r7]!
	body[i++] = (sSPSPPS.nPPSLen >> 8) & 0xff;
	body[i++] = (sSPSPPS.nPPSLen) & 0xff;	
	memcpy(&body[i], sSPSPPS.sPPS, sSPSPPS.nPPSLen);
   19774:	e0840008 	add	r0, r4, r8
	i += sSPSPPS.nSPSLen;

	/* PPS */
	body[i++] = 0x01; // numOfPictureParameterSets，一般为1
	body[i++] = (sSPSPPS.nPPSLen >> 8) & 0xff;
	body[i++] = (sSPSPPS.nPPSLen) & 0xff;	
   19778:	e5c29002 	strb	r9, [r2, #2]
	memcpy(&body[i], sSPSPPS.sSPS, sSPSPPS.nSPSLen);
	i += sSPSPPS.nSPSLen;

	/* PPS */
	body[i++] = 0x01; // numOfPictureParameterSets，一般为1
	body[i++] = (sSPSPPS.nPPSLen >> 8) & 0xff;
   1977c:	e5c21001 	strb	r1, [r2, #1]
	body[i++] = (sSPSPPS.nPPSLen) & 0xff;	
	memcpy(&body[i], sSPSPPS.sPPS, sSPSPPS.nPPSLen);
   19780:	e1a02009 	mov	r2, r9
   19784:	e59d1038 	ldr	r1, [sp, #56]	; 0x38
   19788:	ebffae8f 	bl	51cc <memcpy@plt>
	i +=  sSPSPPS.nPPSLen;

	//构建packet字段
	pPacket->m_packetType = RTMP_PACKET_TYPE_VIDEO;	
   1978c:	e3a02009 	mov	r2, #9
	pPacket->m_nBodySize = i;	
	pPacket->m_nChannel = 0x04;	
	pPacket->m_nTimeStamp = nTime;	
	pPacket->m_hasAbsTimestamp = 0;	
   19790:	e5c56002 	strb	r6, [r5, #2]
	pPacket->m_headerType = RTMP_PACKET_SIZE_LARGE;
   19794:	e5c56000 	strb	r6, [r5]
	body[i++] = (sSPSPPS.nPPSLen) & 0xff;	
	memcpy(&body[i], sSPSPPS.sPPS, sSPSPPS.nPPSLen);
	i +=  sSPSPPS.nPPSLen;

	//构建packet字段
	pPacket->m_packetType = RTMP_PACKET_TYPE_VIDEO;	
   19798:	e5c52001 	strb	r2, [r5, #1]
	pPacket->m_nChannel = 0x04;	
	pPacket->m_nTimeStamp = nTime;	
	pPacket->m_hasAbsTimestamp = 0;	
	pPacket->m_headerType = RTMP_PACKET_SIZE_LARGE;
	//printf(" stream id: %d \n",pRtmp->m_stream_id);
	pPacket->m_nInfoField2 = pRtmp->m_stream_id;
   1979c:	e59b2018 	ldr	r2, [fp, #24]
	/* PPS */
	body[i++] = 0x01; // numOfPictureParameterSets，一般为1
	body[i++] = (sSPSPPS.nPPSLen >> 8) & 0xff;
	body[i++] = (sSPSPPS.nPPSLen) & 0xff;	
	memcpy(&body[i], sSPSPPS.sPPS, sSPSPPS.nPPSLen);
	i +=  sSPSPPS.nPPSLen;
   197a0:	e0888009 	add	r8, r8, r9

	//构建packet字段
	pPacket->m_packetType = RTMP_PACKET_TYPE_VIDEO;	
	pPacket->m_nBodySize = i;	
	pPacket->m_nChannel = 0x04;	
   197a4:	e3a03004 	mov	r3, #4
	pPacket->m_nTimeStamp = nTime;	
   197a8:	e59d103c 	ldr	r1, [sp, #60]	; 0x3c
	//printf(" stream id: %d \n",pRtmp->m_stream_id);
	pPacket->m_nInfoField2 = pRtmp->m_stream_id;
	//pPacket->m_nInfoField2 = 0;
	
	return TRUE;
}
   197ac:	e1a0000a 	mov	r0, sl
	memcpy(&body[i], sSPSPPS.sPPS, sSPSPPS.nPPSLen);
	i +=  sSPSPPS.nPPSLen;

	//构建packet字段
	pPacket->m_packetType = RTMP_PACKET_TYPE_VIDEO;	
	pPacket->m_nBodySize = i;	
   197b0:	e5858010 	str	r8, [r5, #16]
	pPacket->m_nChannel = 0x04;	
	pPacket->m_nTimeStamp = nTime;	
   197b4:	e5851008 	str	r1, [r5, #8]
	pPacket->m_hasAbsTimestamp = 0;	
	pPacket->m_headerType = RTMP_PACKET_SIZE_LARGE;
	//printf(" stream id: %d \n",pRtmp->m_stream_id);
	pPacket->m_nInfoField2 = pRtmp->m_stream_id;
   197b8:	e585200c 	str	r2, [r5, #12]
	i +=  sSPSPPS.nPPSLen;

	//构建packet字段
	pPacket->m_packetType = RTMP_PACKET_TYPE_VIDEO;	
	pPacket->m_nBodySize = i;	
	pPacket->m_nChannel = 0x04;	
   197bc:	e5853004 	str	r3, [r5, #4]
	//printf(" stream id: %d \n",pRtmp->m_stream_id);
	pPacket->m_nInfoField2 = pRtmp->m_stream_id;
	//pPacket->m_nInfoField2 = 0;
	
	return TRUE;
}
   197c0:	e8bd4ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   197c4:	e28dd010 	add	sp, sp, #16
   197c8:	e12fff1e 	bx	lr

000197cc <RTMP_Packet_NAL>:
/*
将H264 NAL 组装成packet
*/

int RTMP_Packet_NAL(RTMP* pRtmp, unsigned char *sVideoData, int size, uint32_t pts, uint32_t dts, int iKey, RTMPPacket *pPacket)
{
   197cc:	e92d4ff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   197d0:	e59d4030 	ldr	r4, [sp, #48]	; 0x30
	{
		body[i++] = 0x27; // 2:interframe  7:AVC
	}
	
	body[i++] = 0x01; // 1: AVC NALU
	uint32_t cts = pts - dts;
   197d4:	e59dc028 	ldr	ip, [sp, #40]	; 0x28
/*
将H264 NAL 组装成packet
*/

int RTMP_Packet_NAL(RTMP* pRtmp, unsigned char *sVideoData, int size, uint32_t pts, uint32_t dts, int iKey, RTMPPacket *pPacket)
{
   197d8:	e59de02c 	ldr	lr, [sp, #44]	; 0x2c
	{
		body[i++] = 0x27; // 2:interframe  7:AVC
	}
	
	body[i++] = 0x01; // 1: AVC NALU
	uint32_t cts = pts - dts;
   197dc:	e06c3003 	rsb	r3, ip, r3
将H264 NAL 组装成packet
*/

int RTMP_Packet_NAL(RTMP* pRtmp, unsigned char *sVideoData, int size, uint32_t pts, uint32_t dts, int iKey, RTMPPacket *pPacket)
{
	unsigned char *body = (unsigned char *)pPacket->m_body;
   197e0:	e594c01c 	ldr	ip, [r4, #28]
		body[i++] = 0x27; // 2:interframe  7:AVC
	}
	
	body[i++] = 0x01; // 1: AVC NALU
	uint32_t cts = pts - dts;
	body[i++] = (cts >> 16) & 0xff;
   197e4:	e1a06823 	lsr	r6, r3, #16
	{
		body[i++] = 0x17; // 1:keyframe  7:AVC
	}
	else//P frame
	{
		body[i++] = 0x27; // 2:interframe  7:AVC
   197e8:	e35e0000 	cmp	lr, #0
	}
	
	body[i++] = 0x01; // 1: AVC NALU
	uint32_t cts = pts - dts;
	body[i++] = (cts >> 16) & 0xff;
	body[i++] = (cts >> 8) & 0xff;
   197ec:	e1a0b423 	lsr	fp, r3, #8
	body[i++] = cts & 0xff;
		
	// NALU size 
#if !defined(_LINUX_IOS_)
	body[i++] = size >> 24 & 0xff;
   197f0:	e1a0ac22 	lsr	sl, r2, #24
	body[i++] = size >> 16 & 0xff;
   197f4:	e1a09842 	asr	r9, r2, #16
	body[i++] = size >> 8 & 0xff;
   197f8:	e1a08442 	asr	r8, r2, #8
	{
		body[i++] = 0x17; // 1:keyframe  7:AVC
	}
	else//P frame
	{
		body[i++] = 0x27; // 2:interframe  7:AVC
   197fc:	13a0e017 	movne	lr, #23
   19800:	03a0e027 	moveq	lr, #39	; 0x27
	}
	
	body[i++] = 0x01; // 1: AVC NALU
	uint32_t cts = pts - dts;
	body[i++] = (cts >> 16) & 0xff;
   19804:	e5cc6002 	strb	r6, [ip, #2]
	else//P frame
	{
		body[i++] = 0x27; // 2:interframe  7:AVC
	}
	
	body[i++] = 0x01; // 1: AVC NALU
   19808:	e3a06001 	mov	r6, #1
/*
将H264 NAL 组装成packet
*/

int RTMP_Packet_NAL(RTMP* pRtmp, unsigned char *sVideoData, int size, uint32_t pts, uint32_t dts, int iKey, RTMPPacket *pPacket)
{
   1980c:	e1a07000 	mov	r7, r0
	
	body[i++] = 0x01; // 1: AVC NALU
	uint32_t cts = pts - dts;
	body[i++] = (cts >> 16) & 0xff;
	body[i++] = (cts >> 8) & 0xff;
	body[i++] = cts & 0xff;
   19810:	e5cc3004 	strb	r3, [ip, #4]
	// NALU size 
#if !defined(_LINUX_IOS_)
	body[i++] = size >> 24 & 0xff;
	body[i++] = size >> 16 & 0xff;
	body[i++] = size >> 8 & 0xff;
	body[i++] = size & 0xff;
   19814:	e5cc2008 	strb	r2, [ip, #8]
	}
	
	body[i++] = 0x01; // 1: AVC NALU
	uint32_t cts = pts - dts;
	body[i++] = (cts >> 16) & 0xff;
	body[i++] = (cts >> 8) & 0xff;
   19818:	e5ccb003 	strb	fp, [ip, #3]
   1981c:	e5cce000 	strb	lr, [ip]
	body[i++] = cts & 0xff;
		
	// NALU size 
#if !defined(_LINUX_IOS_)
	body[i++] = size >> 24 & 0xff;
   19820:	e5cca005 	strb	sl, [ip, #5]
	body[i++] = size >> 16 & 0xff;
   19824:	e5cc9006 	strb	r9, [ip, #6]
	body[i++] = size >> 8 & 0xff;
   19828:	e5cc8007 	strb	r8, [ip, #7]
	else//P frame
	{
		body[i++] = 0x27; // 2:interframe  7:AVC
	}
	
	body[i++] = 0x01; // 1: AVC NALU
   1982c:	e5cc6001 	strb	r6, [ip, #1]
	body[i++] = size >> 8 & 0xff;
	body[i++] = size & 0xff;
#endif
		
	// copy NALU data to packet		
	memcpy(&body[i], sVideoData, size);
   19830:	e28c0009 	add	r0, ip, #9
/*
将H264 NAL 组装成packet
*/

int RTMP_Packet_NAL(RTMP* pRtmp, unsigned char *sVideoData, int size, uint32_t pts, uint32_t dts, int iKey, RTMPPacket *pPacket)
{
   19834:	e1a05002 	mov	r5, r2
	body[i++] = size >> 8 & 0xff;
	body[i++] = size & 0xff;
#endif
		
	// copy NALU data to packet		
	memcpy(&body[i], sVideoData, size);
   19838:	ebffae63 	bl	51cc <memcpy@plt>
	//填充packet字段
	pPacket->m_nBodySize = i + size;
	pPacket->m_nTimeStamp = dts;
	pPacket->m_hasAbsTimestamp = 0;
	pPacket->m_packetType = RTMP_PACKET_TYPE_VIDEO;
   1983c:	e3a02009 	mov	r2, #9
	// copy NALU data to packet		
	memcpy(&body[i], sVideoData, size);
	//填充packet字段
	pPacket->m_nBodySize = i + size;
	pPacket->m_nTimeStamp = dts;
	pPacket->m_hasAbsTimestamp = 0;
   19840:	e3a03000 	mov	r3, #0
#endif
		
	// copy NALU data to packet		
	memcpy(&body[i], sVideoData, size);
	//填充packet字段
	pPacket->m_nBodySize = i + size;
   19844:	e0855002 	add	r5, r5, r2
	pPacket->m_nTimeStamp = dts;
   19848:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
	pPacket->m_hasAbsTimestamp = 0;
	pPacket->m_packetType = RTMP_PACKET_TYPE_VIDEO;
   1984c:	e5c42001 	strb	r2, [r4, #1]
	pPacket->m_nChannel = 0x04;
   19850:	e3a01004 	mov	r1, #4
	// copy NALU data to packet		
	memcpy(&body[i], sVideoData, size);
	//填充packet字段
	pPacket->m_nBodySize = i + size;
	pPacket->m_nTimeStamp = dts;
	pPacket->m_hasAbsTimestamp = 0;
   19854:	e5c43002 	strb	r3, [r4, #2]
	pPacket->m_packetType = RTMP_PACKET_TYPE_VIDEO;
	pPacket->m_nChannel = 0x04;
	//printf(" stream id: %d \n",pRtmp->m_stream_id);
	pPacket->m_nInfoField2 = pRtmp->m_stream_id;
   19858:	e5972018 	ldr	r2, [r7, #24]
   1985c:	e584200c 	str	r2, [r4, #12]
		
	// copy NALU data to packet		
	memcpy(&body[i], sVideoData, size);
	//填充packet字段
	pPacket->m_nBodySize = i + size;
	pPacket->m_nTimeStamp = dts;
   19860:	e5840008 	str	r0, [r4, #8]
#endif
		
	// copy NALU data to packet		
	memcpy(&body[i], sVideoData, size);
	//填充packet字段
	pPacket->m_nBodySize = i + size;
   19864:	e5845010 	str	r5, [r4, #16]
	pPacket->m_nInfoField2 = pRtmp->m_stream_id;
	//pPacket->m_nInfoField2=0;
	pPacket->m_headerType = RTMP_PACKET_SIZE_LARGE;	
	
	return TRUE;
}
   19868:	e1a00006 	mov	r0, r6
	//填充packet字段
	pPacket->m_nBodySize = i + size;
	pPacket->m_nTimeStamp = dts;
	pPacket->m_hasAbsTimestamp = 0;
	pPacket->m_packetType = RTMP_PACKET_TYPE_VIDEO;
	pPacket->m_nChannel = 0x04;
   1986c:	e5841004 	str	r1, [r4, #4]
	//printf(" stream id: %d \n",pRtmp->m_stream_id);
	pPacket->m_nInfoField2 = pRtmp->m_stream_id;
	//pPacket->m_nInfoField2=0;
	pPacket->m_headerType = RTMP_PACKET_SIZE_LARGE;	
   19870:	e5c43000 	strb	r3, [r4]
	
	return TRUE;
}
   19874:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

00019878 <RTMP_Packet_H264>:
将H264裸数据打包成packet，病放入buffer中
sVideoData :H264 裸数据，一个NAL数据

*/
int RTMP_Packet_H264(RTMP* pRtmp, unsigned char *sVideoData, int size, uint32_t pts, uint32_t dts, RTMPBuffer *pVideoBuffer)
{
   19878:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1987c:	e24dd014 	sub	sp, sp, #20
   19880:	e59d503c 	ldr	r5, [sp, #60]	; 0x3c
   19884:	e3550000 	cmp	r5, #0
   19888:	13520000 	cmpne	r2, #0
   1988c:	03a0c001 	moveq	ip, #1
   19890:	13a0c000 	movne	ip, #0
	//printf("---- RTMP_Packet_H264 ----\n");
	//没有数据，或者，传入的数据小于11,或者缓冲区为空
	
	if(sVideoData ==NULL || size==0 || pVideoBuffer==NULL)
   19894:	e3510000 	cmp	r1, #0
   19898:	11a0400c 	movne	r4, ip
   1989c:	038c4001 	orreq	r4, ip, #1
   198a0:	e3540000 	cmp	r4, #0
   198a4:	1a00004f 	bne	199e8 <RTMP_Packet_H264+0x170>
	RTMPPacket *pPacket=NULL;
	
	
	//获取本NAL的类型。7: sps 8:pps 5:关键帧 1:非关键帧
	int nal_type;
	nal_type=sVideoData[0]&0x1F; 
   198a8:	e5d1c000 	ldrb	ip, [r1]
   198ac:	e1a07001 	mov	r7, r1
   198b0:	e20cc01f 	and	ip, ip, #31
	
	//SPS,只有SPS时不能建立一个packet放入buffer中，必须跟PPS一起
	if(nal_type==7)
   198b4:	e35c0007 	cmp	ip, #7
   198b8:	e1a06002 	mov	r6, r2
   198bc:	e1a08003 	mov	r8, r3
   198c0:	e1a09000 	mov	r9, r0
   198c4:	0a00004b 	beq	199f8 <RTMP_Packet_H264+0x180>
		RTMP_Decode_SPS(sVideoData,&pVideoBuffer->pSPSPPSData);
		//SPS不需要组装Packet，直接返回
		return TRUE;
	}
	//PPS
	else if(nal_type==8)
   198c8:	e35c0008 	cmp	ip, #8
   198cc:	0a00002d 	beq	19988 <RTMP_Packet_H264+0x110>
	{
		//printf("  NAL packet \n");
		
		iKeyFrame=(nal_type==5)?TRUE:FALSE;
		
		pPacket = (RTMPPacket *)calloc(1,RTMP_HEAD_SIZE+size+9);
   198d0:	e3a00001 	mov	r0, #1
   198d4:	e282103b 	add	r1, r2, #59	; 0x3b
	}
	else 
	{
		//printf("  NAL packet \n");
		
		iKeyFrame=(nal_type==5)?TRUE:FALSE;
   198d8:	e24ca005 	sub	sl, ip, #5
		
		pPacket = (RTMPPacket *)calloc(1,RTMP_HEAD_SIZE+size+9);
   198dc:	ebffae10 	bl	5124 <calloc@plt>
	}
	else 
	{
		//printf("  NAL packet \n");
		
		iKeyFrame=(nal_type==5)?TRUE:FALSE;
   198e0:	e16faf1a 	clz	sl, sl
   198e4:	e1a0a2aa 	lsr	sl, sl, #5
		
		pPacket = (RTMPPacket *)calloc(1,RTMP_HEAD_SIZE+size+9);
        if(!pPacket)
   198e8:	e250b000 	subs	fp, r0, #0
   198ec:	0a00003d 	beq	199e8 <RTMP_Packet_H264+0x170>
        {
            return FALSE;
        }
		memset(pPacket,0,RTMP_HEAD_SIZE);
   198f0:	e1a0c00b 	mov	ip, fp
   198f4:	e48c4004 	str	r4, [ip], #4
   198f8:	e28cc004 	add	ip, ip, #4
   198fc:	e58b4004 	str	r4, [fp, #4]
		
		pPacket->m_body = (char *)pPacket + RTMP_HEAD_SIZE;
   19900:	e28be032 	add	lr, fp, #50	; 0x32
		pPacket = (RTMPPacket *)calloc(1,RTMP_HEAD_SIZE+size+9);
        if(!pPacket)
        {
            return FALSE;
        }
		memset(pPacket,0,RTMP_HEAD_SIZE);
   19904:	e48c4004 	str	r4, [ip], #4
   19908:	e48c4004 	str	r4, [ip], #4
   1990c:	e48c4004 	str	r4, [ip], #4
   19910:	e48c4004 	str	r4, [ip], #4
   19914:	e48c4004 	str	r4, [ip], #4
   19918:	e48c4004 	str	r4, [ip], #4
   1991c:	e48c4004 	str	r4, [ip], #4
   19920:	e48c4004 	str	r4, [ip], #4
   19924:	e48c4004 	str	r4, [ip], #4
   19928:	e48c4004 	str	r4, [ip], #4
   1992c:	e1cc40b0 	strh	r4, [ip]
		pPacket->m_body = (char *)pPacket + RTMP_HEAD_SIZE;

#if defined(_LINUX_IOS_)
		if (!RTMP_Packet_NAL(pRtmp, sVideoData - 4, size + 4, pts, dts, iKeyFrame, pPacket))
#else
		if (!RTMP_Packet_NAL(pRtmp, sVideoData, size, pts, dts, iKeyFrame, pPacket))
   19930:	e59dc038 	ldr	ip, [sp, #56]	; 0x38
        {
            return FALSE;
        }
		memset(pPacket,0,RTMP_HEAD_SIZE);
		
		pPacket->m_body = (char *)pPacket + RTMP_HEAD_SIZE;
   19934:	e58be01c 	str	lr, [fp, #28]

#if defined(_LINUX_IOS_)
		if (!RTMP_Packet_NAL(pRtmp, sVideoData - 4, size + 4, pts, dts, iKeyFrame, pPacket))
#else
		if (!RTMP_Packet_NAL(pRtmp, sVideoData, size, pts, dts, iKeyFrame, pPacket))
   19938:	e1a00009 	mov	r0, r9
   1993c:	e1a01007 	mov	r1, r7
   19940:	e1a02006 	mov	r2, r6
   19944:	e1a03008 	mov	r3, r8
   19948:	e58dc000 	str	ip, [sp]
   1994c:	e98d0c00 	stmib	sp, {sl, fp}
   19950:	ebffff9d 	bl	197cc <RTMP_Packet_NAL>
   19954:	e3500000 	cmp	r0, #0
   19958:	0a000022 	beq	199e8 <RTMP_Packet_H264+0x170>
			return FALSE;
	}

	//给buffer node分配空间，加入buffer中
	
	if(!RTMP_Put_Buffer(pVideoBuffer,pPacket,iKeyFrame))
   1995c:	e1a00005 	mov	r0, r5
   19960:	e1a0200a 	mov	r2, sl
   19964:	e1a0100b 	mov	r1, fp
   19968:	eb00037f 	bl	1a76c <RTMP_Put_Buffer>
   1996c:	e2504000 	subs	r4, r0, #0
   19970:	1a000067 	bne	19b14 <RTMP_Packet_H264+0x29c>
    {
        if(pPacket)
        {
            free(pPacket);
   19974:	e1a0000b 	mov	r0, fp
   19978:	ebffada1 	bl	5004 <free@plt>

	
	
	return TRUE;
	
}
   1997c:	e1a00004 	mov	r0, r4
   19980:	e28dd014 	add	sp, sp, #20
   19984:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
	else if(nal_type==8)
	{
		//printf(" PPS packet \n");
		iKeyFrame=TRUE;
		pVideoBuffer->pSPSPPSData.nPPSLen=size;
		if(pVideoBuffer->pSPSPPSData.sPPS!=NULL)
   19988:	e5950014 	ldr	r0, [r5, #20]
	//PPS
	else if(nal_type==8)
	{
		//printf(" PPS packet \n");
		iKeyFrame=TRUE;
		pVideoBuffer->pSPSPPSData.nPPSLen=size;
   1998c:	e5852010 	str	r2, [r5, #16]
		if(pVideoBuffer->pSPSPPSData.sPPS!=NULL)
   19990:	e3500000 	cmp	r0, #0
   19994:	0a000000 	beq	1999c <RTMP_Packet_H264+0x124>
		{
			free(pVideoBuffer->pSPSPPSData.sPPS);
   19998:	ebffad99 	bl	5004 <free@plt>
		}
		pVideoBuffer->pSPSPPSData.sPPS=NULL;
		pVideoBuffer->pSPSPPSData.sPPS=(unsigned char *)malloc(size);
   1999c:	e1a00006 	mov	r0, r6
   199a0:	ebffad9d 	bl	501c <malloc@plt>
        if(!pVideoBuffer->pSPSPPSData.sPPS)
   199a4:	e3500000 	cmp	r0, #0
		if(pVideoBuffer->pSPSPPSData.sPPS!=NULL)
		{
			free(pVideoBuffer->pSPSPPSData.sPPS);
		}
		pVideoBuffer->pSPSPPSData.sPPS=NULL;
		pVideoBuffer->pSPSPPSData.sPPS=(unsigned char *)malloc(size);
   199a8:	e5850014 	str	r0, [r5, #20]
        if(!pVideoBuffer->pSPSPPSData.sPPS)
   199ac:	0a00000d 	beq	199e8 <RTMP_Packet_H264+0x170>
            return FALSE;
		memcpy(pVideoBuffer->pSPSPPSData.sPPS,sVideoData,size);
   199b0:	e1a01007 	mov	r1, r7
   199b4:	e1a02006 	mov	r2, r6
   199b8:	ebffae03 	bl	51cc <memcpy@plt>
		pVideoBuffer->pSPSPPSData.nPPSLen=size;
		//判断一下，如果SPS和PPS同时有数据，则组装packet
		if(pVideoBuffer->pSPSPPSData.nSPSLen!=0 && pVideoBuffer->pSPSPPSData.nPPSLen!=0)
   199bc:	e5951008 	ldr	r1, [r5, #8]
		pVideoBuffer->pSPSPPSData.sPPS=NULL;
		pVideoBuffer->pSPSPPSData.sPPS=(unsigned char *)malloc(size);
        if(!pVideoBuffer->pSPSPPSData.sPPS)
            return FALSE;
		memcpy(pVideoBuffer->pSPSPPSData.sPPS,sVideoData,size);
		pVideoBuffer->pSPSPPSData.nPPSLen=size;
   199c0:	e5856010 	str	r6, [r5, #16]
		//判断一下，如果SPS和PPS同时有数据，则组装packet
		if(pVideoBuffer->pSPSPPSData.nSPSLen!=0 && pVideoBuffer->pSPSPPSData.nPPSLen!=0)
   199c4:	e3510000 	cmp	r1, #0
   199c8:	0a000020 	beq	19a50 <RTMP_Packet_H264+0x1d8>
   199cc:	e2811096 	add	r1, r1, #150	; 0x96
		{
		
			pPacket = (RTMPPacket *)calloc(1,RTMP_HEAD_SIZE+100+pVideoBuffer->pSPSPPSData.nSPSLen+pVideoBuffer->pSPSPPSData.nPPSLen);
   199d0:	e0816006 	add	r6, r1, r6
   199d4:	e1a01006 	mov	r1, r6
   199d8:	e3a00001 	mov	r0, #1
   199dc:	ebffadd0 	bl	5124 <calloc@plt>
            
            if(!pPacket)
   199e0:	e250b000 	subs	fp, r0, #0
   199e4:	1a000021 	bne	19a70 <RTMP_Packet_H264+0x1f8>
	//printf("---- RTMP_Packet_H264 ----\n");
	//没有数据，或者，传入的数据小于11,或者缓冲区为空
	
	if(sVideoData ==NULL || size==0 || pVideoBuffer==NULL)
	{
		return FALSE;
   199e8:	e3a04000 	mov	r4, #0

	
	
	return TRUE;
	
}
   199ec:	e1a00004 	mov	r0, r4
   199f0:	e28dd014 	add	sp, sp, #20
   199f4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
	//SPS,只有SPS时不能建立一个packet放入buffer中，必须跟PPS一起
	if(nal_type==7)
	{
		//printf(" SPS packet \n");
		pVideoBuffer->pSPSPPSData.nSPSLen=size;
		if(pVideoBuffer->pSPSPPSData.sPPS!=NULL)
   199f8:	e5953014 	ldr	r3, [r5, #20]
	
	//SPS,只有SPS时不能建立一个packet放入buffer中，必须跟PPS一起
	if(nal_type==7)
	{
		//printf(" SPS packet \n");
		pVideoBuffer->pSPSPPSData.nSPSLen=size;
   199fc:	e5852008 	str	r2, [r5, #8]
		if(pVideoBuffer->pSPSPPSData.sPPS!=NULL)
   19a00:	e3530000 	cmp	r3, #0
   19a04:	0a000001 	beq	19a10 <RTMP_Packet_H264+0x198>
		{
			free(pVideoBuffer->pSPSPPSData.sSPS);
   19a08:	e595000c 	ldr	r0, [r5, #12]
   19a0c:	ebffad7c 	bl	5004 <free@plt>
			
		}
		pVideoBuffer->pSPSPPSData.sSPS=NULL;
		pVideoBuffer->pSPSPPSData.sSPS=(unsigned char *)malloc(size);
   19a10:	e1a00006 	mov	r0, r6
   19a14:	ebffad80 	bl	501c <malloc@plt>
        if(!pVideoBuffer->pSPSPPSData.sSPS)
   19a18:	e3500000 	cmp	r0, #0
		{
			free(pVideoBuffer->pSPSPPSData.sSPS);
			
		}
		pVideoBuffer->pSPSPPSData.sSPS=NULL;
		pVideoBuffer->pSPSPPSData.sSPS=(unsigned char *)malloc(size);
   19a1c:	e585000c 	str	r0, [r5, #12]
        if(!pVideoBuffer->pSPSPPSData.sSPS)
   19a20:	0afffff0 	beq	199e8 <RTMP_Packet_H264+0x170>
            return FALSE;
		memcpy(pVideoBuffer->pSPSPPSData.sSPS,sVideoData,size);
   19a24:	e1a01007 	mov	r1, r7
   19a28:	e1a02006 	mov	r2, r6
   19a2c:	ebffade6 	bl	51cc <memcpy@plt>
		pVideoBuffer->pSPSPPSData.nSPSLen=size;
   19a30:	e1a01005 	mov	r1, r5
   19a34:	e5a16008 	str	r6, [r1, #8]!
		//decode SPS
		
		RTMP_Decode_SPS(sVideoData,&pVideoBuffer->pSPSPPSData);
   19a38:	e1a00007 	mov	r0, r7
   19a3c:	ebffff22 	bl	196cc <RTMP_Decode_SPS>
		//SPS不需要组装Packet，直接返回
		return TRUE;
   19a40:	e3a04001 	mov	r4, #1

	
	
	return TRUE;
	
}
   19a44:	e1a00004 	mov	r0, r4
   19a48:	e28dd014 	add	sp, sp, #20
   19a4c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
			return FALSE;
	}

	//给buffer node分配空间，加入buffer中
	
	if(!RTMP_Put_Buffer(pVideoBuffer,pPacket,iKeyFrame))
   19a50:	e1a00005 	mov	r0, r5
   19a54:	e3a02001 	mov	r2, #1
   19a58:	eb000343 	bl	1a76c <RTMP_Put_Buffer>
   19a5c:	e2904000 	adds	r4, r0, #0
   19a60:	13a04001 	movne	r4, #1

	
	
	return TRUE;
	
}
   19a64:	e1a00004 	mov	r0, r4
   19a68:	e28dd014 	add	sp, sp, #20
   19a6c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
            if(!pPacket)
            {
                return FALSE;
            }
			
			memset(pPacket,0,RTMP_HEAD_SIZE+100+pVideoBuffer->pSPSPPSData.nSPSLen+pVideoBuffer->pSPSPPSData.nPPSLen);	
   19a70:	e1a02006 	mov	r2, r6
   19a74:	e3a01000 	mov	r1, #0
   19a78:	ebffad94 	bl	50d0 <memset@plt>
			
			pPacket->m_body = (char *)pPacket + RTMP_HEAD_SIZE;
			
			
			if(!RTMP_Packet_SPS_PPS(pRtmp,pVideoBuffer->pSPSPPSData,pts,pPacket))
   19a7c:	e595c014 	ldr	ip, [r5, #20]
                return FALSE;
            }
			
			memset(pPacket,0,RTMP_HEAD_SIZE+100+pVideoBuffer->pSPSPPSData.nSPSLen+pVideoBuffer->pSPSPPSData.nPPSLen);	
			
			pPacket->m_body = (char *)pPacket + RTMP_HEAD_SIZE;
   19a80:	e28b2032 	add	r2, fp, #50	; 0x32
			
			
			if(!RTMP_Packet_SPS_PPS(pRtmp,pVideoBuffer->pSPSPPSData,pts,pPacket))
   19a84:	e2853008 	add	r3, r5, #8
                return FALSE;
            }
			
			memset(pPacket,0,RTMP_HEAD_SIZE+100+pVideoBuffer->pSPSPPSData.nSPSLen+pVideoBuffer->pSPSPPSData.nPPSLen);	
			
			pPacket->m_body = (char *)pPacket + RTMP_HEAD_SIZE;
   19a88:	e58b201c 	str	r2, [fp, #28]
			
			
			if(!RTMP_Packet_SPS_PPS(pRtmp,pVideoBuffer->pSPSPPSData,pts,pPacket))
   19a8c:	e1a00009 	mov	r0, r9
   19a90:	e893000e 	ldm	r3, {r1, r2, r3}
   19a94:	e98d0900 	stmib	sp, {r8, fp}
   19a98:	e58dc000 	str	ip, [sp]
   19a9c:	ebffff0c 	bl	196d4 <RTMP_Packet_SPS_PPS>
   19aa0:	e3500000 	cmp	r0, #0
   19aa4:	0affffcf 	beq	199e8 <RTMP_Packet_H264+0x170>
				return FALSE;

			//将video sequence config拷贝到buffer中
			
			pthread_mutex_lock(&pVideoBuffer->lock);
   19aa8:	e2857030 	add	r7, r5, #48	; 0x30
   19aac:	e1a00007 	mov	r0, r7
   19ab0:	ebffade9 	bl	525c <pthread_mutex_lock@plt>
			if(pVideoBuffer->pPacketConfig)
   19ab4:	e5950020 	ldr	r0, [r5, #32]
   19ab8:	e3500000 	cmp	r0, #0
   19abc:	0a000000 	beq	19ac4 <RTMP_Packet_H264+0x24c>
				free(pVideoBuffer->pPacketConfig);
   19ac0:	ebffad4f 	bl	5004 <free@plt>
			pVideoBuffer->pPacketConfig=(RTMPPacket *)calloc(1,RTMP_HEAD_SIZE+100+pVideoBuffer->pSPSPPSData.nSPSLen+pVideoBuffer->pSPSPPSData.nPPSLen);
   19ac4:	e5953008 	ldr	r3, [r5, #8]
   19ac8:	e5954010 	ldr	r4, [r5, #16]
   19acc:	e3a00001 	mov	r0, #1
   19ad0:	e0834004 	add	r4, r3, r4
   19ad4:	e2844096 	add	r4, r4, #150	; 0x96
   19ad8:	e1a01004 	mov	r1, r4
   19adc:	ebffad90 	bl	5124 <calloc@plt>
            if(!pVideoBuffer->pPacketConfig)
   19ae0:	e3500000 	cmp	r0, #0
			//将video sequence config拷贝到buffer中
			
			pthread_mutex_lock(&pVideoBuffer->lock);
			if(pVideoBuffer->pPacketConfig)
				free(pVideoBuffer->pPacketConfig);
			pVideoBuffer->pPacketConfig=(RTMPPacket *)calloc(1,RTMP_HEAD_SIZE+100+pVideoBuffer->pSPSPPSData.nSPSLen+pVideoBuffer->pSPSPPSData.nPPSLen);
   19ae4:	e1a06000 	mov	r6, r0
   19ae8:	e5850020 	str	r0, [r5, #32]
            if(!pVideoBuffer->pPacketConfig)
   19aec:	0affffbd 	beq	199e8 <RTMP_Packet_H264+0x170>
            {
                return FALSE;
            }
			memcpy(pVideoBuffer->pPacketConfig,pPacket,RTMP_HEAD_SIZE+100+pVideoBuffer->pSPSPPSData.nSPSLen+pVideoBuffer->pSPSPPSData.nPPSLen);
   19af0:	e1a02004 	mov	r2, r4
   19af4:	e1a0100b 	mov	r1, fp
   19af8:	ebffadb3 	bl	51cc <memcpy@plt>
			pVideoBuffer->pPacketConfig->m_body=(char *)pVideoBuffer->pPacketConfig+RTMP_HEAD_SIZE;
   19afc:	e2863032 	add	r3, r6, #50	; 0x32
			pthread_mutex_unlock(&pVideoBuffer->lock);
   19b00:	e1a00007 	mov	r0, r7
            if(!pVideoBuffer->pPacketConfig)
            {
                return FALSE;
            }
			memcpy(pVideoBuffer->pPacketConfig,pPacket,RTMP_HEAD_SIZE+100+pVideoBuffer->pSPSPPSData.nSPSLen+pVideoBuffer->pSPSPPSData.nPPSLen);
			pVideoBuffer->pPacketConfig->m_body=(char *)pVideoBuffer->pPacketConfig+RTMP_HEAD_SIZE;
   19b04:	e586301c 	str	r3, [r6, #28]
	}
	//PPS
	else if(nal_type==8)
	{
		//printf(" PPS packet \n");
		iKeyFrame=TRUE;
   19b08:	e3a0a001 	mov	sl, #1
            {
                return FALSE;
            }
			memcpy(pVideoBuffer->pPacketConfig,pPacket,RTMP_HEAD_SIZE+100+pVideoBuffer->pSPSPPSData.nSPSLen+pVideoBuffer->pSPSPPSData.nPPSLen);
			pVideoBuffer->pPacketConfig->m_body=(char *)pVideoBuffer->pPacketConfig+RTMP_HEAD_SIZE;
			pthread_mutex_unlock(&pVideoBuffer->lock);
   19b0c:	ebffadd5 	bl	5268 <pthread_mutex_unlock@plt>
   19b10:	eaffff91 	b	1995c <RTMP_Packet_H264+0xe4>
		return FALSE;
    }

	
	
	return TRUE;
   19b14:	e3a04001 	mov	r4, #1
   19b18:	eaffffb3 	b	199ec <RTMP_Packet_H264+0x174>

00019b1c <put_bytes>:


#include "rtmp_metadata.h"

char * put_bytes(char *c,char *bytes,int len)
{
   19b1c:	e92d4010 	push	{r4, lr}
   19b20:	e1a04002 	mov	r4, r2
	memcpy(c,bytes,len);
   19b24:	ebffada8 	bl	51cc <memcpy@plt>
	return c + len;
}
   19b28:	e0800004 	add	r0, r0, r4
   19b2c:	e8bd8010 	pop	{r4, pc}

00019b30 <put_byte>:

char * put_byte( char *output, uint8_t nVal )    
{    
	output[0] = nVal;    
   19b30:	e4c01001 	strb	r1, [r0], #1
	return output+1;    
}  
   19b34:	e12fff1e 	bx	lr

00019b38 <put_be16>:

char * put_be16(char *output, uint16_t nVal )    
{    
	output[1] = nVal & 0xff;    
	output[0] = nVal >> 8;    
   19b38:	e1a03000 	mov	r3, r0
   19b3c:	e1a02421 	lsr	r2, r1, #8
	return output+1;    
}  

char * put_be16(char *output, uint16_t nVal )    
{    
	output[1] = nVal & 0xff;    
   19b40:	e5c01001 	strb	r1, [r0, #1]
	output[0] = nVal >> 8;    
   19b44:	e4c32002 	strb	r2, [r3], #2
	return output+2;    
}  
   19b48:	e1a00003 	mov	r0, r3
   19b4c:	e12fff1e 	bx	lr

00019b50 <put_be24>:

char * put_be24(char *output,uint32_t nVal )    
{    
	output[2] = nVal & 0xff;    
	output[1] = nVal >> 8;    
	output[0] = nVal >> 16;    
   19b50:	e1a03000 	mov	r3, r0
}  

char * put_be24(char *output,uint32_t nVal )    
{    
	output[2] = nVal & 0xff;    
	output[1] = nVal >> 8;    
   19b54:	e1a0c421 	lsr	ip, r1, #8
	output[0] = nVal >> 16;    
   19b58:	e1a02821 	lsr	r2, r1, #16
	return output+2;    
}  

char * put_be24(char *output,uint32_t nVal )    
{    
	output[2] = nVal & 0xff;    
   19b5c:	e5c01002 	strb	r1, [r0, #2]
	output[1] = nVal >> 8;    
   19b60:	e5c0c001 	strb	ip, [r0, #1]
	output[0] = nVal >> 16;    
   19b64:	e4c32003 	strb	r2, [r3], #3
	return output+3;    
}    
   19b68:	e1a00003 	mov	r0, r3
   19b6c:	e12fff1e 	bx	lr

00019b70 <put_be32>:
char * put_be32(char *output, uint32_t nVal )    
{    
   19b70:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
   19b74:	e1a03000 	mov	r3, r0
	output[3] = nVal & 0xff;    
	output[2] = nVal >> 8;    
   19b78:	e1a0e421 	lsr	lr, r1, #8
	output[1] = nVal >> 16;    
   19b7c:	e1a0c821 	lsr	ip, r1, #16
	output[0] = nVal >> 24;    
   19b80:	e1a02c21 	lsr	r2, r1, #24
	output[0] = nVal >> 16;    
	return output+3;    
}    
char * put_be32(char *output, uint32_t nVal )    
{    
	output[3] = nVal & 0xff;    
   19b84:	e5c31003 	strb	r1, [r3, #3]
	output[2] = nVal >> 8;    
   19b88:	e5c3e002 	strb	lr, [r3, #2]
	output[1] = nVal >> 16;    
   19b8c:	e5c3c001 	strb	ip, [r3, #1]
	output[0] = nVal >> 24;    
   19b90:	e4c02004 	strb	r2, [r0], #4
	return output+4;    
}    
   19b94:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00019b98 <put_be64>:
char *  put_be64( char *output, uint64_t nVal )    
{    
   19b98:	e92d4010 	push	{r4, lr}
	output=put_be32( output, nVal >> 32 );    
   19b9c:	e1a01003 	mov	r1, r3
	output[1] = nVal >> 16;    
	output[0] = nVal >> 24;    
	return output+4;    
}    
char *  put_be64( char *output, uint64_t nVal )    
{    
   19ba0:	e1a04002 	mov	r4, r2
	output=put_be32( output, nVal >> 32 );    
   19ba4:	ebfffff1 	bl	19b70 <put_be32>
	output=put_be32( output, nVal );    
   19ba8:	e1a01004 	mov	r1, r4
	return output;    
}  
   19bac:	e8bd4010 	pop	{r4, lr}
	return output+4;    
}    
char *  put_be64( char *output, uint64_t nVal )    
{    
	output=put_be32( output, nVal >> 32 );    
	output=put_be32( output, nVal );    
   19bb0:	eaffffee 	b	19b70 <put_be32>

00019bb4 <put_amf_bool>:
	return output;    
}  

char * put_amf_bool(char *c, uint8_t b)
{
	*c++ = AMF_BOOLEAN;
   19bb4:	e3a03001 	mov	r3, #1
	{
		unsigned char *ci, *co;    
		ci = (unsigned char *)&b;    
		co = (unsigned char *)c;
		co[0] = ci[0];
   19bb8:	e5c01001 	strb	r1, [r0, #1]
	return output;    
}  

char * put_amf_bool(char *c, uint8_t b)
{
	*c++ = AMF_BOOLEAN;
   19bbc:	e5c03000 	strb	r3, [r0]
		ci = (unsigned char *)&b;    
		co = (unsigned char *)c;
		co[0] = ci[0];
	}
	return c + 1;
}
   19bc0:	e2800002 	add	r0, r0, #2
   19bc4:	e12fff1e 	bx	lr

00019bc8 <put_amf_string>:


char * put_amf_string( char *c, const char *str )    
{    
   19bc8:	e92d4070 	push	{r4, r5, r6, lr}
   19bcc:	e1a06000 	mov	r6, r0
	uint16_t len = strlen( str );    
   19bd0:	e1a00001 	mov	r0, r1
	return c + 1;
}


char * put_amf_string( char *c, const char *str )    
{    
   19bd4:	e1a05001 	mov	r5, r1
	uint16_t len = strlen( str );    
   19bd8:	ebffad48 	bl	5100 <strlen@plt>
	c=put_be16( c, len );    
   19bdc:	e1a00800 	lsl	r0, r0, #16
   19be0:	e1a04820 	lsr	r4, r0, #16
   19be4:	e1a01004 	mov	r1, r4
   19be8:	e1a00006 	mov	r0, r6
   19bec:	ebffffd1 	bl	19b38 <put_be16>
	memcpy(c,str,len);    
   19bf0:	e1a01005 	mov	r1, r5
   19bf4:	e1a02004 	mov	r2, r4
   19bf8:	ebffad73 	bl	51cc <memcpy@plt>
	return c+len;    
}    
   19bfc:	e0800004 	add	r0, r0, r4
   19c00:	e8bd8070 	pop	{r4, r5, r6, pc}

00019c04 <put_amf_double>:
char * put_amf_double( char *c, double d )    
{    
   19c04:	e92d40f0 	push	{r4, r5, r6, r7, lr}
   19c08:	e24dd00c 	sub	sp, sp, #12
   19c0c:	e1cd20f0 	strd	r2, [sp]
	*c++ = AMF_NUMBER;  /* type: Number */    
   19c10:	e3a07000 	mov	r7, #0
	{    
		unsigned char *ci, *co;    
		ci = (unsigned char *)&d;    
		co = (unsigned char *)c;    
		co[0] = ci[7];    
   19c14:	e5dd6007 	ldrb	r6, [sp, #7]
		co[1] = ci[6];    
   19c18:	e5dd5006 	ldrb	r5, [sp, #6]
		co[2] = ci[5];    
   19c1c:	e5dd4005 	ldrb	r4, [sp, #5]
		co[3] = ci[4];    
   19c20:	e5dde004 	ldrb	lr, [sp, #4]
		co[4] = ci[3];    
   19c24:	e5ddc003 	ldrb	ip, [sp, #3]
		co[5] = ci[2];    
   19c28:	e5dd1002 	ldrb	r1, [sp, #2]
		co[6] = ci[1];    
   19c2c:	e5dd2001 	ldrb	r2, [sp, #1]
		co[7] = ci[0];    
   19c30:	e5dd3000 	ldrb	r3, [sp]
	memcpy(c,str,len);    
	return c+len;    
}    
char * put_amf_double( char *c, double d )    
{    
	*c++ = AMF_NUMBER;  /* type: Number */    
   19c34:	e5c07000 	strb	r7, [r0]
	{    
		unsigned char *ci, *co;    
		ci = (unsigned char *)&d;    
		co = (unsigned char *)c;    
		co[0] = ci[7];    
   19c38:	e5c06001 	strb	r6, [r0, #1]
		co[1] = ci[6];    
   19c3c:	e5c05002 	strb	r5, [r0, #2]
		co[2] = ci[5];    
   19c40:	e5c04003 	strb	r4, [r0, #3]
		co[3] = ci[4];    
   19c44:	e5c0e004 	strb	lr, [r0, #4]
		co[4] = ci[3];    
   19c48:	e5c0c005 	strb	ip, [r0, #5]
		co[5] = ci[2];    
   19c4c:	e5c01006 	strb	r1, [r0, #6]
		co[6] = ci[1];    
   19c50:	e5c02007 	strb	r2, [r0, #7]
		co[7] = ci[0];    
   19c54:	e5c03008 	strb	r3, [r0, #8]
	}    
	return c+8;    
} 
   19c58:	e2800009 	add	r0, r0, #9
   19c5c:	e28dd00c 	add	sp, sp, #12
   19c60:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

00019c64 <SendMetadataPacket>:


//////////////////////////////////////
int SendMetadataPacket(RTMP *pRtmp ,RTMPMetadata* lpMetaData)
{
	if(lpMetaData == NULL)  
   19c64:	e3510000 	cmp	r1, #0
   19c68:	0a00007d 	beq	19e64 <SendMetadataPacket+0x200>
} 


//////////////////////////////////////
int SendMetadataPacket(RTMP *pRtmp ,RTMPMetadata* lpMetaData)
{
   19c6c:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
   19c70:	e1a04001 	mov	r4, r1
   19c74:	e1a06000 	mov	r6, r0
	{  
		return FALSE;  
	}
	
	RTMPPacket *pPacket = NULL;
	pPacket = (RTMPPacket *)calloc(1, RTMP_HEAD_SIZE + 1024);
   19c78:	e59f11ec 	ldr	r1, [pc, #492]	; 19e6c <SendMetadataPacket+0x208>
   19c7c:	e3a00001 	mov	r0, #1
   19c80:	ebffad27 	bl	5124 <calloc@plt>
	pPacket->m_body = (char *)pPacket + RTMP_HEAD_SIZE;
	
	char * p = (char *)pPacket->m_body;
	p = put_byte(p, AMF_STRING );
   19c84:	e3a01002 	mov	r1, #2
		return FALSE;  
	}
	
	RTMPPacket *pPacket = NULL;
	pPacket = (RTMPPacket *)calloc(1, RTMP_HEAD_SIZE + 1024);
	pPacket->m_body = (char *)pPacket + RTMP_HEAD_SIZE;
   19c88:	e2803032 	add	r3, r0, #50	; 0x32
	{  
		return FALSE;  
	}
	
	RTMPPacket *pPacket = NULL;
	pPacket = (RTMPPacket *)calloc(1, RTMP_HEAD_SIZE + 1024);
   19c8c:	e1a05000 	mov	r5, r0
	pPacket->m_body = (char *)pPacket + RTMP_HEAD_SIZE;
	
	char * p = (char *)pPacket->m_body;
	p = put_byte(p, AMF_STRING );
   19c90:	e1a00003 	mov	r0, r3
		return FALSE;  
	}
	
	RTMPPacket *pPacket = NULL;
	pPacket = (RTMPPacket *)calloc(1, RTMP_HEAD_SIZE + 1024);
	pPacket->m_body = (char *)pPacket + RTMP_HEAD_SIZE;
   19c94:	e585301c 	str	r3, [r5, #28]
	
	char * p = (char *)pPacket->m_body;
	p = put_byte(p, AMF_STRING );
   19c98:	ebffffa4 	bl	19b30 <put_byte>
	p = put_amf_string(p, "@setDataFrame");
   19c9c:	e59f11cc 	ldr	r1, [pc, #460]	; 19e70 <SendMetadataPacket+0x20c>
   19ca0:	e08f1001 	add	r1, pc, r1
   19ca4:	ebffffc7 	bl	19bc8 <put_amf_string>
	
	p = put_byte(p, AMF_STRING );
   19ca8:	e3a01002 	mov	r1, #2
   19cac:	ebffff9f 	bl	19b30 <put_byte>
	p = put_amf_string(p, "onMetaData");
   19cb0:	e59f11bc 	ldr	r1, [pc, #444]	; 19e74 <SendMetadataPacket+0x210>
   19cb4:	e08f1001 	add	r1, pc, r1
   19cb8:	ebffffc2 	bl	19bc8 <put_amf_string>
	
	p = put_byte(p, AMF_OBJECT );
   19cbc:	e3a01003 	mov	r1, #3
   19cc0:	ebffff9a 	bl	19b30 <put_byte>
	p = put_amf_string(p, "copyright");
   19cc4:	e59f11ac 	ldr	r1, [pc, #428]	; 19e78 <SendMetadataPacket+0x214>
   19cc8:	e08f1001 	add	r1, pc, r1
   19ccc:	ebffffbd 	bl	19bc8 <put_amf_string>
	p = put_byte(p, AMF_STRING );
   19cd0:	e3a01002 	mov	r1, #2
   19cd4:	ebffff95 	bl	19b30 <put_byte>
	p = put_amf_string(p, "pingan.com");
   19cd8:	e59f119c 	ldr	r1, [pc, #412]	; 19e7c <SendMetadataPacket+0x218>
   19cdc:	e08f1001 	add	r1, pc, r1
   19ce0:	ebffffb8 	bl	19bc8 <put_amf_string>
	
	p = put_amf_string(p, "hasVideo");
   19ce4:	e59f1194 	ldr	r1, [pc, #404]	; 19e80 <SendMetadataPacket+0x21c>
   19ce8:	e08f1001 	add	r1, pc, r1
   19cec:	ebffffb5 	bl	19bc8 <put_amf_string>
	p = put_amf_bool(p, lpMetaData->bHasVideo);
   19cf0:	e5d41000 	ldrb	r1, [r4]
   19cf4:	ebffffae 	bl	19bb4 <put_amf_bool>
	
	p = put_amf_string(p, "hasAudio");
   19cf8:	e59f1184 	ldr	r1, [pc, #388]	; 19e84 <SendMetadataPacket+0x220>
   19cfc:	e08f1001 	add	r1, pc, r1
   19d00:	ebffffb0 	bl	19bc8 <put_amf_string>
	p = put_amf_bool(p, lpMetaData->bHasAudio);
   19d04:	e5d41014 	ldrb	r1, [r4, #20]
   19d08:	ebffffa9 	bl	19bb4 <put_amf_bool>
	
	p = put_amf_string(p, "width");
   19d0c:	e59f1174 	ldr	r1, [pc, #372]	; 19e88 <SendMetadataPacket+0x224>
   19d10:	e08f1001 	add	r1, pc, r1
   19d14:	ebffffab 	bl	19bc8 <put_amf_string>
   19d18:	e1a07000 	mov	r7, r0
	p = put_amf_double(p, lpMetaData->nWidth);
   19d1c:	e5940004 	ldr	r0, [r4, #4]
   19d20:	eb000820 	bl	1bda8 <__aeabi_ui2d>
   19d24:	e1a02000 	mov	r2, r0
   19d28:	e1a03001 	mov	r3, r1
   19d2c:	e1a00007 	mov	r0, r7
   19d30:	ebffffb3 	bl	19c04 <put_amf_double>
	
	p = put_amf_string(p, "height");
   19d34:	e59f1150 	ldr	r1, [pc, #336]	; 19e8c <SendMetadataPacket+0x228>
   19d38:	e08f1001 	add	r1, pc, r1
   19d3c:	ebffffa1 	bl	19bc8 <put_amf_string>
   19d40:	e1a07000 	mov	r7, r0
	p = put_amf_double(p, lpMetaData->nHeight);
   19d44:	e5940008 	ldr	r0, [r4, #8]
   19d48:	eb000816 	bl	1bda8 <__aeabi_ui2d>
   19d4c:	e1a02000 	mov	r2, r0
   19d50:	e1a03001 	mov	r3, r1
   19d54:	e1a00007 	mov	r0, r7
   19d58:	ebffffa9 	bl	19c04 <put_amf_double>
	
	p = put_amf_string(p, "audiocodecid");
   19d5c:	e59f112c 	ldr	r1, [pc, #300]	; 19e90 <SendMetadataPacket+0x22c>
   19d60:	e08f1001 	add	r1, pc, r1
   19d64:	ebffff97 	bl	19bc8 <put_amf_string>
	p = put_amf_double(p, FLV_CODECID_AAC);
   19d68:	e3a02000 	mov	r2, #0
   19d6c:	e59f3120 	ldr	r3, [pc, #288]	; 19e94 <SendMetadataPacket+0x230>
   19d70:	ebffffa3 	bl	19c04 <put_amf_double>
	
	p = put_amf_string(p, "audiosamplerate");
   19d74:	e59f111c 	ldr	r1, [pc, #284]	; 19e98 <SendMetadataPacket+0x234>
   19d78:	e08f1001 	add	r1, pc, r1
   19d7c:	ebffff91 	bl	19bc8 <put_amf_string>
   19d80:	e1a07000 	mov	r7, r0
	p = put_amf_double(p, lpMetaData->nAudioSampleRate);
   19d84:	e5940018 	ldr	r0, [r4, #24]
   19d88:	eb000806 	bl	1bda8 <__aeabi_ui2d>
   19d8c:	e1a02000 	mov	r2, r0
   19d90:	e1a03001 	mov	r3, r1
   19d94:	e1a00007 	mov	r0, r7
   19d98:	ebffff99 	bl	19c04 <put_amf_double>
	
	p = put_amf_string(p, "stereo");
   19d9c:	e59f10f8 	ldr	r1, [pc, #248]	; 19e9c <SendMetadataPacket+0x238>
   19da0:	e08f1001 	add	r1, pc, r1
   19da4:	ebffff87 	bl	19bc8 <put_amf_string>
	p = put_amf_bool(p, lpMetaData->nAudioChannels == 2);
   19da8:	e5941020 	ldr	r1, [r4, #32]
   19dac:	e2411002 	sub	r1, r1, #2
   19db0:	e16f1f11 	clz	r1, r1
   19db4:	e1a012a1 	lsr	r1, r1, #5
   19db8:	ebffff7d 	bl	19bb4 <put_amf_bool>
	
	p = put_amf_string(p, "framerate");
   19dbc:	e59f10dc 	ldr	r1, [pc, #220]	; 19ea0 <SendMetadataPacket+0x23c>
   19dc0:	e08f1001 	add	r1, pc, r1
   19dc4:	ebffff7f 	bl	19bc8 <put_amf_string>
   19dc8:	e1a07000 	mov	r7, r0
	p = put_amf_double(p, lpMetaData->nFrameRate);
   19dcc:	e594000c 	ldr	r0, [r4, #12]
   19dd0:	eb0007f4 	bl	1bda8 <__aeabi_ui2d>
	
	pPacket->m_nBodySize = index;
	pPacket->m_nTimeStamp = 0;
	pPacket->m_hasAbsTimestamp = 0;
	pPacket->m_packetType = RTMP_PACKET_TYPE_INFO;
	pPacket->m_nChannel = 0x04;
   19dd4:	e3a04004 	mov	r4, #4
	
	p = put_amf_string(p, "stereo");
	p = put_amf_bool(p, lpMetaData->nAudioChannels == 2);
	
	p = put_amf_string(p, "framerate");
	p = put_amf_double(p, lpMetaData->nFrameRate);
   19dd8:	e1a02000 	mov	r2, r0
   19ddc:	e1a03001 	mov	r3, r1
   19de0:	e1a00007 	mov	r0, r7
   19de4:	ebffff86 	bl	19c04 <put_amf_double>
	
	p = put_amf_string(p, "videocodecid");
   19de8:	e59f10b4 	ldr	r1, [pc, #180]	; 19ea4 <SendMetadataPacket+0x240>
	//SendPacket(RTMP_PACKET_TYPE_INFO,(unsigned char*)body,p-body,0);
	
	pPacket->m_nBodySize = index;
	pPacket->m_nTimeStamp = 0;
	pPacket->m_hasAbsTimestamp = 0;
	pPacket->m_packetType = RTMP_PACKET_TYPE_INFO;
   19dec:	e3a07012 	mov	r7, #18
	p = put_amf_bool(p, lpMetaData->nAudioChannels == 2);
	
	p = put_amf_string(p, "framerate");
	p = put_amf_double(p, lpMetaData->nFrameRate);
	
	p = put_amf_string(p, "videocodecid");
   19df0:	e08f1001 	add	r1, pc, r1
   19df4:	ebffff73 	bl	19bc8 <put_amf_string>
	p = put_amf_double(p, FLV_CODECID_H264);
   19df8:	e3a02000 	mov	r2, #0
   19dfc:	e59f30a4 	ldr	r3, [pc, #164]	; 19ea8 <SendMetadataPacket+0x244>
   19e00:	ebffff7f 	bl	19c04 <put_amf_double>
	
	p = put_amf_string(p, "");
   19e04:	e59f10a0 	ldr	r1, [pc, #160]	; 19eac <SendMetadataPacket+0x248>
   19e08:	e08f1001 	add	r1, pc, r1
   19e0c:	ebffff6d 	bl	19bc8 <put_amf_string>
	p = put_byte(p, AMF_OBJECT_END);
   19e10:	e3a01009 	mov	r1, #9
   19e14:	ebffff45 	bl	19b30 <put_byte>
	int index = p-pPacket->m_body;
   19e18:	e595c01c 	ldr	ip, [r5, #28]
	//SendPacket(RTMP_PACKET_TYPE_INFO,(unsigned char*)body,p-body,0);
	
	pPacket->m_nBodySize = index;
	pPacket->m_nTimeStamp = 0;
   19e1c:	e3a03000 	mov	r3, #0
	pPacket->m_hasAbsTimestamp = 0;
	pPacket->m_packetType = RTMP_PACKET_TYPE_INFO;
	pPacket->m_nChannel = 0x04;
	
	pPacket->m_nInfoField2 = pRtmp->m_stream_id;
   19e20:	e596e018 	ldr	lr, [r6, #24]
	
	pPacket->m_headerType = RTMP_PACKET_SIZE_LARGE;	

	RTMP_SendPacket(pRtmp,pPacket,0);
   19e24:	e1a01005 	mov	r1, r5
   19e28:	e1a02003 	mov	r2, r3
	pPacket->m_nTimeStamp = 0;
	pPacket->m_hasAbsTimestamp = 0;
	pPacket->m_packetType = RTMP_PACKET_TYPE_INFO;
	pPacket->m_nChannel = 0x04;
	
	pPacket->m_nInfoField2 = pRtmp->m_stream_id;
   19e2c:	e585e00c 	str	lr, [r5, #12]
	p = put_byte(p, AMF_OBJECT_END);
	int index = p-pPacket->m_body;
	//SendPacket(RTMP_PACKET_TYPE_INFO,(unsigned char*)body,p-body,0);
	
	pPacket->m_nBodySize = index;
	pPacket->m_nTimeStamp = 0;
   19e30:	e5853008 	str	r3, [r5, #8]
	pPacket->m_hasAbsTimestamp = 0;
   19e34:	e5c53002 	strb	r3, [r5, #2]
	pPacket->m_packetType = RTMP_PACKET_TYPE_INFO;
	pPacket->m_nChannel = 0x04;
	
	pPacket->m_nInfoField2 = pRtmp->m_stream_id;
	
	pPacket->m_headerType = RTMP_PACKET_SIZE_LARGE;	
   19e38:	e5c53000 	strb	r3, [r5]
	//SendPacket(RTMP_PACKET_TYPE_INFO,(unsigned char*)body,p-body,0);
	
	pPacket->m_nBodySize = index;
	pPacket->m_nTimeStamp = 0;
	pPacket->m_hasAbsTimestamp = 0;
	pPacket->m_packetType = RTMP_PACKET_TYPE_INFO;
   19e3c:	e5c57001 	strb	r7, [r5, #1]
	pPacket->m_nChannel = 0x04;
   19e40:	e5854004 	str	r4, [r5, #4]
	p = put_amf_string(p, "videocodecid");
	p = put_amf_double(p, FLV_CODECID_H264);
	
	p = put_amf_string(p, "");
	p = put_byte(p, AMF_OBJECT_END);
	int index = p-pPacket->m_body;
   19e44:	e06cc000 	rsb	ip, ip, r0
	
	pPacket->m_nInfoField2 = pRtmp->m_stream_id;
	
	pPacket->m_headerType = RTMP_PACKET_SIZE_LARGE;	

	RTMP_SendPacket(pRtmp,pPacket,0);
   19e48:	e1a00006 	mov	r0, r6
	p = put_amf_string(p, "");
	p = put_byte(p, AMF_OBJECT_END);
	int index = p-pPacket->m_body;
	//SendPacket(RTMP_PACKET_TYPE_INFO,(unsigned char*)body,p-body,0);
	
	pPacket->m_nBodySize = index;
   19e4c:	e585c010 	str	ip, [r5, #16]
	
	pPacket->m_nInfoField2 = pRtmp->m_stream_id;
	
	pPacket->m_headerType = RTMP_PACKET_SIZE_LARGE;	

	RTMP_SendPacket(pRtmp,pPacket,0);
   19e50:	ebffc569 	bl	b3fc <RTMP_SendPacket>

	free(pPacket);
   19e54:	e1a00005 	mov	r0, r5
   19e58:	ebffac69 	bl	5004 <free@plt>
	
	return TRUE;
   19e5c:	e3a00001 	mov	r0, #1
   19e60:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
//////////////////////////////////////
int SendMetadataPacket(RTMP *pRtmp ,RTMPMetadata* lpMetaData)
{
	if(lpMetaData == NULL)  
	{  
		return FALSE;  
   19e64:	e1a00001 	mov	r0, r1
   19e68:	e12fff1e 	bx	lr
   19e6c:	00000432 	.word	0x00000432
   19e70:	00006ad4 	.word	0x00006ad4
   19e74:	00004e60 	.word	0x00004e60
   19e78:	00007854 	.word	0x00007854
   19e7c:	0000784c 	.word	0x0000784c
   19e80:	0000784c 	.word	0x0000784c
   19e84:	00007844 	.word	0x00007844
   19e88:	0000783c 	.word	0x0000783c
   19e8c:	0000781c 	.word	0x0000781c
   19e90:	000077fc 	.word	0x000077fc
   19e94:	40240000 	.word	0x40240000
   19e98:	000077f4 	.word	0x000077f4
   19e9c:	000077dc 	.word	0x000077dc
   19ea0:	000077c4 	.word	0x000077c4
   19ea4:	000077a0 	.word	0x000077a0
   19ea8:	401c0000 	.word	0x401c0000
   19eac:	00004029 	.word	0x00004029

00019eb0 <Set_Wait_Time>:
#include "StasticEvent.h"


void Set_Wait_Time(BufferConfig *pConfig,uint32_t iWaitTime)
{
	pConfig->iWaitTime=iWaitTime;
   19eb0:	e5801014 	str	r1, [r0, #20]
   19eb4:	e12fff1e 	bx	lr

00019eb8 <Set_Max_Delay>:
}

void Set_Max_Delay(BufferConfig *pConfig,uint32_t iDelayTime)
{
	pConfig->iMaxDelay=iDelayTime;
   19eb8:	e5801010 	str	r1, [r0, #16]
   19ebc:	e12fff1e 	bx	lr

00019ec0 <Buffer_Control>:
/*
 缓冲控制线程
*/

int Buffer_Control(RTMPMetadata *pMetadata, BufferConfig *pConfig,RTMPAccess *pAccess,void (*ChangeState)(int))
{
   19ec0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
	RTMPPacket *pSendPacket = NULL;
	uint32_t iCurrentTime = 0;//当前系统时间
	uint32_t iLastTime = 0;//缓冲区最后一个I帧的时间
	uint32_t iWaitTime = 0;//缓冲区数据等待时间
	RTMPBuffer *pVideoBuffer = pConfig->pVideoBuffer;
	RTMPBuffer *pAudioBuffer = pConfig->pAudioBuffer;
   19ec4:	e8911c00 	ldm	r1, {sl, fp, ip}
	int iSendVideo = 1;//发不发送video packet.0:不发送  1: 发送
	uint32_t iLastDelay_Time = 0;//最近一次到达最大延迟的系统时间
	int iSendFrameType = 1;//当前 send packet的类型。0: P frame 。  1: I frame
	
	// 指针判空
	if (!pRtmp || !pVideoBuffer || !pAudioBuffer)
   19ec8:	e35a0000 	cmp	sl, #0
   19ecc:	135b0000 	cmpne	fp, #0
   19ed0:	03a06001 	moveq	r6, #1
   19ed4:	13a06000 	movne	r6, #0
   19ed8:	e35c0000 	cmp	ip, #0
   19edc:	03866001 	orreq	r6, r6, #1
/*
 缓冲控制线程
*/

int Buffer_Control(RTMPMetadata *pMetadata, BufferConfig *pConfig,RTMPAccess *pAccess,void (*ChangeState)(int))
{
   19ee0:	e24dd03c 	sub	sp, sp, #60	; 0x3c
	int iSendVideo = 1;//发不发送video packet.0:不发送  1: 发送
	uint32_t iLastDelay_Time = 0;//最近一次到达最大延迟的系统时间
	int iSendFrameType = 1;//当前 send packet的类型。0: P frame 。  1: I frame
	
	// 指针判空
	if (!pRtmp || !pVideoBuffer || !pAudioBuffer)
   19ee4:	e3560000 	cmp	r6, #0
	RTMPPacket *pSendPacket = NULL;
	uint32_t iCurrentTime = 0;//当前系统时间
	uint32_t iLastTime = 0;//缓冲区最后一个I帧的时间
	uint32_t iWaitTime = 0;//缓冲区数据等待时间
	RTMPBuffer *pVideoBuffer = pConfig->pVideoBuffer;
	RTMPBuffer *pAudioBuffer = pConfig->pAudioBuffer;
   19ee8:	e1a0400c 	mov	r4, ip
   19eec:	e58dc010 	str	ip, [sp, #16]
	int iSendFrameType = 1;//当前 send packet的类型。0: P frame 。  1: I frame
	
	// 指针判空
	if (!pRtmp || !pVideoBuffer || !pAudioBuffer)
	{
		return FALSE;
   19ef0:	13a03000 	movne	r3, #0
	int iSendVideo = 1;//发不发送video packet.0:不发送  1: 发送
	uint32_t iLastDelay_Time = 0;//最近一次到达最大延迟的系统时间
	int iSendFrameType = 1;//当前 send packet的类型。0: P frame 。  1: I frame
	
	// 指针判空
	if (!pRtmp || !pVideoBuffer || !pAudioBuffer)
   19ef4:	1a0000d5 	bne	1a250 <Buffer_Control+0x390>
   19ef8:	e58d0028 	str	r0, [sp, #40]	; 0x28
	{
		return FALSE;
	}
	
	pVideoNode = RTMP_Get_Buffer(pVideoBuffer);
   19efc:	e1a0000b 	mov	r0, fp
   19f00:	e58d3024 	str	r3, [sp, #36]	; 0x24
   19f04:	e58d202c 	str	r2, [sp, #44]	; 0x2c
   19f08:	e1a08001 	mov	r8, r1
   19f0c:	eb00023f 	bl	1a810 <RTMP_Get_Buffer>
   19f10:	e1a05000 	mov	r5, r0
	pAudioNode = RTMP_Get_Buffer(pAudioBuffer);
   19f14:	e1a00004 	mov	r0, r4
   19f18:	eb00023c 	bl	1a810 <RTMP_Get_Buffer>
   19f1c:	e28a3c4b 	add	r3, sl, #19200	; 0x4b00
   19f20:	e1a02003 	mov	r2, r3
   19f24:	e28330ac 	add	r3, r3, #172	; 0xac
   19f28:	e58d3018 	str	r3, [sp, #24]
   19f2c:	e28230a0 	add	r3, r2, #160	; 0xa0
   19f30:	e58d301c 	str	r3, [sp, #28]
	uint32_t iLastTime = 0;//缓冲区最后一个I帧的时间
	uint32_t iWaitTime = 0;//缓冲区数据等待时间
	RTMPBuffer *pVideoBuffer = pConfig->pVideoBuffer;
	RTMPBuffer *pAudioBuffer = pConfig->pAudioBuffer;
	RTMP *pRtmp = pConfig->pRTMP;
	int iSendVideo = 1;//发不发送video packet.0:不发送  1: 发送
   19f34:	e3a03001 	mov	r3, #1
   19f38:	e58d3020 	str	r3, [sp, #32]
   19f3c:	e2883024 	add	r3, r8, #36	; 0x24
   19f40:	e58d300c 	str	r3, [sp, #12]
					free(pSendPacket);
				pSendPacket = NULL;
			}
			else
			{
				RTMP_Log(RTMP_LOGINFO,"push : =============== drop frame ========to  %d \n",iLastTime);
   19f44:	e59f369c 	ldr	r3, [pc, #1692]	; 1a5e8 <Buffer_Control+0x728>
	uint32_t iWaitTime = 0;//缓冲区数据等待时间
	RTMPBuffer *pVideoBuffer = pConfig->pVideoBuffer;
	RTMPBuffer *pAudioBuffer = pConfig->pAudioBuffer;
	RTMP *pRtmp = pConfig->pRTMP;
	int iSendVideo = 1;//发不发送video packet.0:不发送  1: 发送
	uint32_t iLastDelay_Time = 0;//最近一次到达最大延迟的系统时间
   19f48:	e58d6030 	str	r6, [sp, #48]	; 0x30
					free(pSendPacket);
				pSendPacket = NULL;
			}
			else
			{
				RTMP_Log(RTMP_LOGINFO,"push : =============== drop frame ========to  %d \n",iLastTime);
   19f4c:	e08f3003 	add	r3, pc, r3
   19f50:	e58d3034 	str	r3, [sp, #52]	; 0x34
	{
		return FALSE;
	}
	
	pVideoNode = RTMP_Get_Buffer(pVideoBuffer);
	pAudioNode = RTMP_Get_Buffer(pAudioBuffer);
   19f54:	e1a04000 	mov	r4, r0
	int min_bitrate_status = 0;
	//发送数据
	while (TRUE)
	{
		//drop data
		pthread_mutex_lock(&pRtmp->lock_drop);
   19f58:	e59d7018 	ldr	r7, [sp, #24]
   19f5c:	e1a00007 	mov	r0, r7
   19f60:	ebffacbd 	bl	525c <pthread_mutex_lock@plt>
		pRtmp->m_drop_data += drop_data;
   19f64:	e59d101c 	ldr	r1, [sp, #28]
		pthread_mutex_unlock(&pRtmp->lock_drop);
   19f68:	e1a00007 	mov	r0, r7
	//发送数据
	while (TRUE)
	{
		//drop data
		pthread_mutex_lock(&pRtmp->lock_drop);
		pRtmp->m_drop_data += drop_data;
   19f6c:	e1c120d0 	ldrd	r2, [r1]
   19f70:	e0922006 	adds	r2, r2, r6
   19f74:	e0a33fc6 	adc	r3, r3, r6, asr #31
   19f78:	e1c120f0 	strd	r2, [r1]
		pthread_mutex_unlock(&pRtmp->lock_drop);
   19f7c:	ebffacb9 	bl	5268 <pthread_mutex_unlock@plt>
		
		drop_data = 0;
		
		// video buffer 和audio buffer 都为空，sleep 100毫秒等待缓冲区数据，10秒后还没有数据则退出
		iWaitTime = 0;
		while (!pVideoNode && !pAudioNode && iWaitTime<pConfig->iWaitTime)
   19f80:	e3540000 	cmp	r4, #0
   19f84:	03550000 	cmpeq	r5, #0
   19f88:	03a06001 	moveq	r6, #1
   19f8c:	13a06000 	movne	r6, #0
   19f90:	1a00000d 	bne	19fcc <Buffer_Control+0x10c>
   19f94:	e5983014 	ldr	r3, [r8, #20]
   19f98:	e3530000 	cmp	r3, #0
   19f9c:	0a0000a2 	beq	1a22c <Buffer_Control+0x36c>
   19fa0:	e59d700c 	ldr	r7, [sp, #12]
   19fa4:	e3a06000 	mov	r6, #0
		{
			pthread_mutex_lock(&pConfig->lock);
   19fa8:	e1a00007 	mov	r0, r7
   19fac:	ebffacaa 	bl	525c <pthread_mutex_lock@plt>
			state_rtmp = pConfig->state;
   19fb0:	e598400c 	ldr	r4, [r8, #12]
			pthread_mutex_unlock(&pConfig->lock);
   19fb4:	e1a00007 	mov	r0, r7
   19fb8:	ebffacaa 	bl	5268 <pthread_mutex_unlock@plt>
			
			if (state_rtmp != send_status)
   19fbc:	e3540002 	cmp	r4, #2
   19fc0:	0a00008b 	beq	1a1f4 <Buffer_Control+0x334>
   19fc4:	e3a04000 	mov	r4, #0
   19fc8:	e1a05004 	mov	r5, r4
			pAudioNode = RTMP_Get_Buffer(pAudioBuffer);
			iWaitTime += 10;
			//RTMP_Log(RTMP_LOGINFO,"push : **** buffer is no data to send ,pConfig->state:%d ****\n",pConfig->state);
			continue;
		}
		if (iWaitTime >= pConfig->iWaitTime)
   19fcc:	e5983014 	ldr	r3, [r8, #20]
   19fd0:	e1530006 	cmp	r3, r6
   19fd4:	9a000094 	bls	1a22c <Buffer_Control+0x36c>
			break;
		}
		else
			iWaitTime = 0;
		
		pthread_mutex_lock(&pConfig->lock);
   19fd8:	e59d700c 	ldr	r7, [sp, #12]
   19fdc:	e1a00007 	mov	r0, r7
   19fe0:	ebffac9d 	bl	525c <pthread_mutex_lock@plt>
		state_rtmp = pConfig->state;
   19fe4:	e598600c 	ldr	r6, [r8, #12]
		pthread_mutex_unlock(&pConfig->lock);
   19fe8:	e1a00007 	mov	r0, r7
   19fec:	ebffac9d 	bl	5268 <pthread_mutex_unlock@plt>
		
		if (state_rtmp != send_status)
   19ff0:	e3560002 	cmp	r6, #2
   19ff4:	1a000090 	bne	1a23c <Buffer_Control+0x37c>
			break;
		
		if (pVideoNode)
   19ff8:	e3550000 	cmp	r5, #0
   19ffc:	0a000099 	beq	1a268 <Buffer_Control+0x3a8>
			pVideoPacket = pVideoNode->pPacket;
		}
		else
			pVideoPacket = NULL;
		
		if (pAudioNode)
   1a000:	e3540000 	cmp	r4, #0
		if (state_rtmp != send_status)
			break;
		
		if (pVideoNode)
		{
			pVideoPacket = pVideoNode->pPacket;
   1a004:	e5956000 	ldr	r6, [r5]
		}
		else
			pVideoPacket = NULL;
		
		if (pAudioNode)
   1a008:	0a000093 	beq	1a25c <Buffer_Control+0x39c>
		{
			pAudioPacket = pAudioNode->pPacket;
   1a00c:	e5947000 	ldr	r7, [r4]
		}
		else
			pAudioPacket=NULL;
		
		if (pVideoPacket && pAudioPacket)
   1a010:	e2963000 	adds	r3, r6, #0
   1a014:	13a03001 	movne	r3, #1
   1a018:	e2972000 	adds	r2, r7, #0
   1a01c:	13a02001 	movne	r2, #1
   1a020:	e1120003 	tst	r2, r3
   1a024:	0a000031 	beq	1a0f0 <Buffer_Control+0x230>
		{
			if (pVideoPacket->m_nTimeStamp < pAudioPacket->m_nTimeStamp)
   1a028:	e5962008 	ldr	r2, [r6, #8]
   1a02c:	e5973008 	ldr	r3, [r7, #8]
   1a030:	e1520003 	cmp	r2, r3
   1a034:	2a000031 	bcs	1a100 <Buffer_Control+0x240>
		{
			pSendPacket = pVideoPacket;
			iSendFrameType = pVideoNode->nFrame_type;
			//RTMP_Free_BufferNode(pVideoNode);
			if (pVideoNode)
				free(pVideoNode);
   1a038:	e1a00005 	mov	r0, r5
			pAudioNode = RTMP_Get_Buffer(pAudioBuffer);
		}
		else if (pVideoPacket && !pAudioPacket)//只有 video packet
		{
			pSendPacket = pVideoPacket;
			iSendFrameType = pVideoNode->nFrame_type;
   1a03c:	e5959004 	ldr	r9, [r5, #4]
			//RTMP_Free_BufferNode(pVideoNode);
			if (pVideoNode)
				free(pVideoNode);
   1a040:	ebffabef 	bl	5004 <free@plt>
			pVideoNode = NULL;
			pVideoNode = RTMP_Get_Buffer(pVideoBuffer);
   1a044:	e1a0000b 	mov	r0, fp
   1a048:	eb0001f0 	bl	1a810 <RTMP_Get_Buffer>
   1a04c:	e1a07006 	mov	r7, r6
   1a050:	e1a05000 	mov	r5, r0
		}
		else
			continue;
		
		iCurrentTime = pVideoBuffer->iLast_frame_time > pAudioBuffer->iLast_frame_time ? pVideoBuffer->iLast_frame_time : pAudioBuffer->iLast_frame_time;
   1a054:	e59d2010 	ldr	r2, [sp, #16]
   1a058:	e59b3048 	ldr	r3, [fp, #72]	; 0x48
   1a05c:	e5926048 	ldr	r6, [r2, #72]	; 0x48
		
		if ((iCurrentTime) < (pConfig->iMaxDelay+pSendPacket->m_nTimeStamp))
   1a060:	e597c008 	ldr	ip, [r7, #8]
			pVideoNode = RTMP_Get_Buffer(pVideoBuffer);
		}
		else
			continue;
		
		iCurrentTime = pVideoBuffer->iLast_frame_time > pAudioBuffer->iLast_frame_time ? pVideoBuffer->iLast_frame_time : pAudioBuffer->iLast_frame_time;
   1a064:	e1530006 	cmp	r3, r6
		
		if ((iCurrentTime) < (pConfig->iMaxDelay+pSendPacket->m_nTimeStamp))
   1a068:	e5982010 	ldr	r2, [r8, #16]
			pVideoNode = RTMP_Get_Buffer(pVideoBuffer);
		}
		else
			continue;
		
		iCurrentTime = pVideoBuffer->iLast_frame_time > pAudioBuffer->iLast_frame_time ? pVideoBuffer->iLast_frame_time : pAudioBuffer->iLast_frame_time;
   1a06c:	31a03006 	movcc	r3, r6
   1a070:	e1a01003 	mov	r1, r3
   1a074:	e58d3014 	str	r3, [sp, #20]
		
		if ((iCurrentTime) < (pConfig->iMaxDelay+pSendPacket->m_nTimeStamp))
   1a078:	e08c3002 	add	r3, ip, r2
   1a07c:	e1510003 	cmp	r1, r3
   1a080:	2a000048 	bcs	1a1a8 <Buffer_Control+0x2e8>
		{
			if ((iCurrentTime-pSendPacket->m_nTimeStamp) > (pConfig->iMaxDelay/2))
   1a084:	e06cc001 	rsb	ip, ip, r1
   1a088:	e15c00a2 	cmp	ip, r2, lsr #1
   1a08c:	9a000006 	bls	1a0ac <Buffer_Control+0x1ec>
			{
				if (pAudioBuffer)
				{
					if (iSendVideo == 1)
   1a090:	e59d3020 	ldr	r3, [sp, #32]
   1a094:	e3530001 	cmp	r3, #1
   1a098:	0a0000e9 	beq	1a444 <Buffer_Control+0x584>
   1a09c:	e59d3014 	ldr	r3, [sp, #20]
   1a0a0:	e58d3030 	str	r3, [sp, #48]	; 0x30
					{
						ChangeState(publish_audio_only);
					}
					iSendVideo = 0;
   1a0a4:	e3a03000 	mov	r3, #0
   1a0a8:	e58d3020 	str	r3, [sp, #32]
				else //没有audio 流
				{
					iSendVideo = 1;
				}
			}
			if (pSendPacket->m_packetType == 8 || pSendPacket->m_packetType == 18)
   1a0ac:	e5d73001 	ldrb	r3, [r7, #1]
   1a0b0:	e3530008 	cmp	r3, #8
   1a0b4:	13530012 	cmpne	r3, #18
   1a0b8:	1a00001e 	bne	1a138 <Buffer_Control+0x278>
			{
				//RTMP_Log(RTMP_LOGINFO,"~~~ SEND AUDIO  : %d \n",pSendPacket->m_nTimeStamp);
				if (!RTMP_SendPacket_reconnect(pMetadata, pConfig, pSendPacket, pAccess, ChangeState))
   1a0bc:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
   1a0c0:	e58d3000 	str	r3, [sp]
   1a0c4:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
   1a0c8:	e1a01008 	mov	r1, r8
   1a0cc:	e1a02007 	mov	r2, r7
   1a0d0:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
   1a0d4:	ebffdf52 	bl	11e24 <RTMP_SendPacket_reconnect>
   1a0d8:	e3500000 	cmp	r0, #0
   1a0dc:	0a00011f 	beq	1a560 <Buffer_Control+0x6a0>
		//drop data
		pthread_mutex_lock(&pRtmp->lock_drop);
		pRtmp->m_drop_data += drop_data;
		pthread_mutex_unlock(&pRtmp->lock_drop);
		
		drop_data = 0;
   1a0e0:	e3a06000 	mov	r6, #0
						drop_data += pSendPacket->m_nBodySize;
					}
				}
			}
			if (pSendPacket)
				free(pSendPacket);
   1a0e4:	e1a00007 	mov	r0, r7
   1a0e8:	ebffabc5 	bl	5004 <free@plt>
   1a0ec:	eaffff99 	b	19f58 <Buffer_Control+0x98>
   1a0f0:	e16f1f16 	clz	r1, r6
   1a0f4:	e1a012a1 	lsr	r1, r1, #5
					free(pAudioNode);
				pAudioNode = NULL;
				pAudioNode = RTMP_Get_Buffer(pAudioBuffer);
			}
		}
		else if (!pVideoPacket && pAudioPacket)//只有 audio packet
   1a0f8:	e1110002 	tst	r1, r2
   1a0fc:	0a000006 	beq	1a11c <Buffer_Control+0x25c>
		{
			pSendPacket = pAudioPacket;
			iSendFrameType = pAudioNode->nFrame_type;
			//RTMP_Free_BufferNode(pAudioNode);
			if (pAudioNode)
				free(pAudioNode);
   1a100:	e1a00004 	mov	r0, r4
			}
		}
		else if (!pVideoPacket && pAudioPacket)//只有 audio packet
		{
			pSendPacket = pAudioPacket;
			iSendFrameType = pAudioNode->nFrame_type;
   1a104:	e5949004 	ldr	r9, [r4, #4]
			//RTMP_Free_BufferNode(pAudioNode);
			if (pAudioNode)
				free(pAudioNode);
   1a108:	ebffabbd 	bl	5004 <free@plt>
			pAudioNode = NULL;
			pAudioNode = RTMP_Get_Buffer(pAudioBuffer);
   1a10c:	e59d0010 	ldr	r0, [sp, #16]
   1a110:	eb0001be 	bl	1a810 <RTMP_Get_Buffer>
   1a114:	e1a04000 	mov	r4, r0
   1a118:	eaffffcd 	b	1a054 <Buffer_Control+0x194>
   1a11c:	e3570000 	cmp	r7, #0
   1a120:	13a03000 	movne	r3, #0
   1a124:	02033001 	andeq	r3, r3, #1
		}
		else if (pVideoPacket && !pAudioPacket)//只有 video packet
   1a128:	e3530000 	cmp	r3, #0
   1a12c:	1affffc1 	bne	1a038 <Buffer_Control+0x178>
		//drop data
		pthread_mutex_lock(&pRtmp->lock_drop);
		pRtmp->m_drop_data += drop_data;
		pthread_mutex_unlock(&pRtmp->lock_drop);
		
		drop_data = 0;
   1a130:	e3a06000 	mov	r6, #0
   1a134:	eaffff87 	b	19f58 <Buffer_Control+0x98>
					return FALSE;
				}
			}
			else //video
			{
				pthread_mutex_lock(&pConfig->lock_min_bitrate_status);
   1a138:	e288a02c 	add	sl, r8, #44	; 0x2c
   1a13c:	e1a0000a 	mov	r0, sl
   1a140:	ebffac45 	bl	525c <pthread_mutex_lock@plt>
				min_bitrate_status = pConfig->min_bitrate_status;
   1a144:	e5986028 	ldr	r6, [r8, #40]	; 0x28
				pthread_mutex_unlock(&pConfig->lock_min_bitrate_status);
   1a148:	e1a0000a 	mov	r0, sl
   1a14c:	ebffac45 	bl	5268 <pthread_mutex_unlock@plt>
				
				//RTMP_Log(RTMP_LOGINFO,"  push : min bitrate : %d \n",min_bitrate_status);
				if (min_bitrate_status == 0)
   1a150:	e3560000 	cmp	r6, #0
   1a154:	0a000096 	beq	1a3b4 <Buffer_Control+0x4f4>
						return FALSE;
					}
				}
				else
				{
					if (pConfig->send_video_type == 1
   1a158:	e5983018 	ldr	r3, [r8, #24]
   1a15c:	e3530001 	cmp	r3, #1
   1a160:	0a0000a5 	beq	1a3fc <Buffer_Control+0x53c>
					   || ( pConfig->send_video_type == 0 && iSendVideo == 1 ))
   1a164:	e59d2020 	ldr	r2, [sp, #32]
   1a168:	e3530000 	cmp	r3, #0
   1a16c:	13a02000 	movne	r2, #0
   1a170:	02022001 	andeq	r2, r2, #1
   1a174:	e3520000 	cmp	r2, #0
   1a178:	1a00009f 	bne	1a3fc <Buffer_Control+0x53c>
								pSendPacket = NULL;
							}
							return FALSE;
						}
					}
					else if (iSendVideo == 0  &&  (iCurrentTime-iLastDelay_Time)>=pConfig->iMaxRetryTime) //pConfig->iMaxRetryTime
   1a17c:	e59d3020 	ldr	r3, [sp, #32]
   1a180:	e3530000 	cmp	r3, #0
   1a184:	1a000005 	bne	1a1a0 <Buffer_Control+0x2e0>
   1a188:	e59d3014 	ldr	r3, [sp, #20]
   1a18c:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
   1a190:	e598c020 	ldr	ip, [r8, #32]
   1a194:	e0623003 	rsb	r3, r2, r3
   1a198:	e153000c 	cmp	r3, ip
   1a19c:	2a0000dc 	bcs	1a514 <Buffer_Control+0x654>
						else
							drop_data += pSendPacket->m_nBodySize;
					}
					else
					{
						drop_data += pSendPacket->m_nBodySize;
   1a1a0:	e5976010 	ldr	r6, [r7, #16]
   1a1a4:	eaffffce 	b	1a0e4 <Buffer_Control+0x224>
				free(pSendPacket);
			pSendPacket = NULL;
		}
		else
		{
			iLastTime = RTMP_Get_Last_Time(pVideoBuffer);
   1a1a8:	e1a0000b 	mov	r0, fp
   1a1ac:	eb0001af 	bl	1a870 <RTMP_Get_Last_Time>
			//RTMP_Log(RTMP_LOGINFO," skip frame : last i frame time :%d  packet time : %d   current time: %d  type :%d \n",iLastTime,pSendPacket->m_nTimeStamp,iCurrentTime,pSendPacket->m_packetType);
			if (iLastTime <= pSendPacket->m_nTimeStamp)
   1a1b0:	e5973008 	ldr	r3, [r7, #8]
   1a1b4:	e1500003 	cmp	r0, r3
				free(pSendPacket);
			pSendPacket = NULL;
		}
		else
		{
			iLastTime = RTMP_Get_Last_Time(pVideoBuffer);
   1a1b8:	e1a0a000 	mov	sl, r0
			//RTMP_Log(RTMP_LOGINFO," skip frame : last i frame time :%d  packet time : %d   current time: %d  type :%d \n",iLastTime,pSendPacket->m_nTimeStamp,iCurrentTime,pSendPacket->m_packetType);
			if (iLastTime <= pSendPacket->m_nTimeStamp)
   1a1bc:	8a000032 	bhi	1a28c <Buffer_Control+0x3cc>
			{
				//RTMP_Log(RTMP_LOGINFO,"~~~ type: %d %d  packet time: %d   system time: %d \n",pSendPacket->m_packetType,iSendFrameType,pSendPacket->m_nTimeStamp,iCurrentTime);
				if (!RTMP_SendPacket_reconnect(pMetadata, pConfig, pSendPacket, pAccess, ChangeState))
   1a1c0:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
   1a1c4:	e58d3000 	str	r3, [sp]
   1a1c8:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
   1a1cc:	e1a01008 	mov	r1, r8
   1a1d0:	e1a02007 	mov	r2, r7
   1a1d4:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
   1a1d8:	ebffdf11 	bl	11e24 <RTMP_SendPacket_reconnect>
   1a1dc:	e3500000 	cmp	r0, #0
   1a1e0:	0a0000ed 	beq	1a59c <Buffer_Control+0x6dc>
					}
					return FALSE;
				}
				
				if (pSendPacket)
					free(pSendPacket);
   1a1e4:	e1a00007 	mov	r0, r7
   1a1e8:	ebffab85 	bl	5004 <free@plt>
		//drop data
		pthread_mutex_lock(&pRtmp->lock_drop);
		pRtmp->m_drop_data += drop_data;
		pthread_mutex_unlock(&pRtmp->lock_drop);
		
		drop_data = 0;
   1a1ec:	e3a06000 	mov	r6, #0
   1a1f0:	eaffff58 	b	19f58 <Buffer_Control+0x98>
			pthread_mutex_unlock(&pConfig->lock);
			
			if (state_rtmp != send_status)
				break;
			
			msleep(10);
   1a1f4:	e59f03f0 	ldr	r0, [pc, #1008]	; 1a5ec <Buffer_Control+0x72c>
   1a1f8:	ebffad01 	bl	5604 <usleep@plt>
			pVideoNode = RTMP_Get_Buffer(pVideoBuffer);
   1a1fc:	e1a0000b 	mov	r0, fp
   1a200:	eb000182 	bl	1a810 <RTMP_Get_Buffer>
			pAudioNode = RTMP_Get_Buffer(pAudioBuffer);
			iWaitTime += 10;
   1a204:	e286600a 	add	r6, r6, #10
			
			if (state_rtmp != send_status)
				break;
			
			msleep(10);
			pVideoNode = RTMP_Get_Buffer(pVideoBuffer);
   1a208:	e1a05000 	mov	r5, r0
			pAudioNode = RTMP_Get_Buffer(pAudioBuffer);
   1a20c:	e59d0010 	ldr	r0, [sp, #16]
   1a210:	eb00017e 	bl	1a810 <RTMP_Get_Buffer>
		
		drop_data = 0;
		
		// video buffer 和audio buffer 都为空，sleep 100毫秒等待缓冲区数据，10秒后还没有数据则退出
		iWaitTime = 0;
		while (!pVideoNode && !pAudioNode && iWaitTime<pConfig->iWaitTime)
   1a214:	e3500000 	cmp	r0, #0
   1a218:	03550000 	cmpeq	r5, #0
   1a21c:	1a0000d8 	bne	1a584 <Buffer_Control+0x6c4>
   1a220:	e5983014 	ldr	r3, [r8, #20]
   1a224:	e1530006 	cmp	r3, r6
   1a228:	8affff5e 	bhi	19fa8 <Buffer_Control+0xe8>
			//RTMP_Log(RTMP_LOGINFO,"push : **** buffer is no data to send ,pConfig->state:%d ****\n",pConfig->state);
			continue;
		}
		if (iWaitTime >= pConfig->iWaitTime)
		{
			RTMP_Log(RTMP_LOGINFO,"*** buffer is null ***\n");
   1a22c:	e59f13bc 	ldr	r1, [pc, #956]	; 1a5f0 <Buffer_Control+0x730>
   1a230:	e3a00003 	mov	r0, #3
   1a234:	e08f1001 	add	r1, pc, r1
   1a238:	ebffeddb 	bl	159ac <RTMP_Log>
				}
				//LOGE_jni("=============== drop  end ========to  %d \n",iLastTime);
			}
		}
	}
	RTMP_Log(RTMP_LOGINFO, "**** buffer_control end  *****\n");
   1a23c:	e59f13b0 	ldr	r1, [pc, #944]	; 1a5f4 <Buffer_Control+0x734>
   1a240:	e3a00003 	mov	r0, #3
   1a244:	e08f1001 	add	r1, pc, r1
   1a248:	ebffedd7 	bl	159ac <RTMP_Log>
	
	return TRUE;
   1a24c:	e3a03001 	mov	r3, #1
}
   1a250:	e1a00003 	mov	r0, r3
   1a254:	e28dd03c 	add	sp, sp, #60	; 0x3c
   1a258:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1a25c:	e2963000 	adds	r3, r6, #0
   1a260:	13a03001 	movne	r3, #1
   1a264:	eaffffaf 	b	1a128 <Buffer_Control+0x268>
			pVideoPacket = pVideoNode->pPacket;
		}
		else
			pVideoPacket = NULL;
		
		if (pAudioNode)
   1a268:	e3540000 	cmp	r4, #0
   1a26c:	0affffaf 	beq	1a130 <Buffer_Control+0x270>
		{
			pAudioPacket = pAudioNode->pPacket;
   1a270:	e5947000 	ldr	r7, [r4]
		}
		else
			pAudioPacket=NULL;
		
		if (pVideoPacket && pAudioPacket)
   1a274:	e1a03005 	mov	r3, r5
   1a278:	e2972000 	adds	r2, r7, #0
   1a27c:	13a02001 	movne	r2, #1
   1a280:	e3a01001 	mov	r1, #1
		if (pVideoNode)
		{
			pVideoPacket = pVideoNode->pPacket;
		}
		else
			pVideoPacket = NULL;
   1a284:	e1a06005 	mov	r6, r5
   1a288:	eaffff9a 	b	1a0f8 <Buffer_Control+0x238>
					free(pSendPacket);
				pSendPacket = NULL;
			}
			else
			{
				RTMP_Log(RTMP_LOGINFO,"push : =============== drop frame ========to  %d \n",iLastTime);
   1a28c:	e3a00003 	mov	r0, #3
   1a290:	e59d1034 	ldr	r1, [sp, #52]	; 0x34
   1a294:	e1a0200a 	mov	r2, sl
   1a298:	ebffedc3 	bl	159ac <RTMP_Log>
				
				int isendpacket_time = pSendPacket->m_nTimeStamp;
				while (pVideoNode)
   1a29c:	e3550000 	cmp	r5, #0
			}
			else
			{
				RTMP_Log(RTMP_LOGINFO,"push : =============== drop frame ========to  %d \n",iLastTime);
				
				int isendpacket_time = pSendPacket->m_nTimeStamp;
   1a2a0:	e5979008 	ldr	r9, [r7, #8]
				while (pVideoNode)
   1a2a4:	0a0000b8 	beq	1a58c <Buffer_Control+0x6cc>
				{
					pVideoPacket = pVideoNode->pPacket;
   1a2a8:	e595c000 	ldr	ip, [r5]
					if (!pVideoPacket)
   1a2ac:	e35c0000 	cmp	ip, #0
   1a2b0:	158d4020 	strne	r4, [sp, #32]
   1a2b4:	13a06000 	movne	r6, #0
   1a2b8:	11a0400c 	movne	r4, ip
   1a2bc:	1a000003 	bne	1a2d0 <Buffer_Control+0x410>
   1a2c0:	ea0000b3 	b	1a594 <Buffer_Control+0x6d4>
				RTMP_Log(RTMP_LOGINFO,"push : =============== drop frame ========to  %d \n",iLastTime);
				
				int isendpacket_time = pSendPacket->m_nTimeStamp;
				while (pVideoNode)
				{
					pVideoPacket = pVideoNode->pPacket;
   1a2c4:	e5954000 	ldr	r4, [r5]
					if (!pVideoPacket)
   1a2c8:	e3540000 	cmp	r4, #0
   1a2cc:	0a00000f 	beq	1a310 <Buffer_Control+0x450>
						break;
					if (isendpacket_time < iLastTime)
   1a2d0:	e15a0009 	cmp	sl, r9
					}
					else
					{
						drop_data += pVideoPacket->m_nBodySize;
						if (pVideoNode)
							free(pVideoNode);
   1a2d4:	e1a00005 	mov	r0, r5
				while (pVideoNode)
				{
					pVideoPacket = pVideoNode->pPacket;
					if (!pVideoPacket)
						break;
					if (isendpacket_time < iLastTime)
   1a2d8:	9a000002 	bls	1a2e8 <Buffer_Control+0x428>
					{
						if (pVideoPacket->m_nTimeStamp < iLastTime)
   1a2dc:	e5942008 	ldr	r2, [r4, #8]
   1a2e0:	e15a0002 	cmp	sl, r2
   1a2e4:	9a000075 	bls	1a4c0 <Buffer_Control+0x600>
							break;
						}
					}
					else
					{
						drop_data += pVideoPacket->m_nBodySize;
   1a2e8:	e5942010 	ldr	r2, [r4, #16]
   1a2ec:	e0866002 	add	r6, r6, r2
						if (pVideoNode)
							free(pVideoNode);
   1a2f0:	ebffab43 	bl	5004 <free@plt>
						pVideoNode = NULL;
						if (pVideoPacket)
							free(pVideoPacket);
   1a2f4:	e1a00004 	mov	r0, r4
   1a2f8:	ebffab41 	bl	5004 <free@plt>
						pVideoPacket = NULL;
						pVideoNode = RTMP_Get_Buffer(pVideoBuffer);
   1a2fc:	e1a0000b 	mov	r0, fp
   1a300:	eb000142 	bl	1a810 <RTMP_Get_Buffer>
			else
			{
				RTMP_Log(RTMP_LOGINFO,"push : =============== drop frame ========to  %d \n",iLastTime);
				
				int isendpacket_time = pSendPacket->m_nTimeStamp;
				while (pVideoNode)
   1a304:	e3500000 	cmp	r0, #0
							free(pVideoNode);
						pVideoNode = NULL;
						if (pVideoPacket)
							free(pVideoPacket);
						pVideoPacket = NULL;
						pVideoNode = RTMP_Get_Buffer(pVideoBuffer);
   1a308:	e1a05000 	mov	r5, r0
			else
			{
				RTMP_Log(RTMP_LOGINFO,"push : =============== drop frame ========to  %d \n",iLastTime);
				
				int isendpacket_time = pSendPacket->m_nTimeStamp;
				while (pVideoNode)
   1a30c:	1affffec 	bne	1a2c4 <Buffer_Control+0x404>
   1a310:	e59d4020 	ldr	r4, [sp, #32]
						pVideoPacket = NULL;
						pVideoNode = RTMP_Get_Buffer(pVideoBuffer);
					}
				}
				
				while (pAudioNode)
   1a314:	e3540000 	cmp	r4, #0
   1a318:	0a00001e 	beq	1a398 <Buffer_Control+0x4d8>
				{
					pAudioPacket = pAudioNode->pPacket;
   1a31c:	e594c000 	ldr	ip, [r4]
					if (!pAudioPacket)
   1a320:	e35c0000 	cmp	ip, #0
   1a324:	0a00001b 	beq	1a398 <Buffer_Control+0x4d8>
   1a328:	e58d5020 	str	r5, [sp, #32]
   1a32c:	e58d7030 	str	r7, [sp, #48]	; 0x30
   1a330:	e59d5010 	ldr	r5, [sp, #16]
   1a334:	e1a07006 	mov	r7, r6
   1a338:	e1a0600c 	mov	r6, ip
   1a33c:	ea000002 	b	1a34c <Buffer_Control+0x48c>
					}
				}
				
				while (pAudioNode)
				{
					pAudioPacket = pAudioNode->pPacket;
   1a340:	e5946000 	ldr	r6, [r4]
					if (!pAudioPacket)
   1a344:	e3560000 	cmp	r6, #0
   1a348:	0a00000f 	beq	1a38c <Buffer_Control+0x4cc>
						break;
					//LOGE_jni(" drop audio node ");
					if (isendpacket_time < iLastTime)
   1a34c:	e15a0009 	cmp	sl, r9
					}
					else
					{
						drop_data += pAudioPacket->m_nBodySize;
						if (pAudioNode)
							free(pAudioNode);
   1a350:	e1a00004 	mov	r0, r4
				{
					pAudioPacket = pAudioNode->pPacket;
					if (!pAudioPacket)
						break;
					//LOGE_jni(" drop audio node ");
					if (isendpacket_time < iLastTime)
   1a354:	9a000002 	bls	1a364 <Buffer_Control+0x4a4>
					{
						if (pAudioPacket->m_nTimeStamp < iLastTime)
   1a358:	e5962008 	ldr	r2, [r6, #8]
   1a35c:	e15a0002 	cmp	sl, r2
   1a360:	9a00003f 	bls	1a464 <Buffer_Control+0x5a4>
							break;
						}
					}
					else
					{
						drop_data += pAudioPacket->m_nBodySize;
   1a364:	e5962010 	ldr	r2, [r6, #16]
   1a368:	e0877002 	add	r7, r7, r2
						if (pAudioNode)
							free(pAudioNode);
   1a36c:	ebffab24 	bl	5004 <free@plt>
						pAudioNode = NULL;
						if (pAudioPacket)
							free(pAudioPacket);
   1a370:	e1a00006 	mov	r0, r6
   1a374:	ebffab22 	bl	5004 <free@plt>
						pAudioPacket = NULL;
						pAudioNode = RTMP_Get_Buffer(pAudioBuffer);
   1a378:	e1a00005 	mov	r0, r5
   1a37c:	eb000123 	bl	1a810 <RTMP_Get_Buffer>
						pVideoPacket = NULL;
						pVideoNode = RTMP_Get_Buffer(pVideoBuffer);
					}
				}
				
				while (pAudioNode)
   1a380:	e3500000 	cmp	r0, #0
							free(pAudioNode);
						pAudioNode = NULL;
						if (pAudioPacket)
							free(pAudioPacket);
						pAudioPacket = NULL;
						pAudioNode = RTMP_Get_Buffer(pAudioBuffer);
   1a384:	e1a04000 	mov	r4, r0
						pVideoPacket = NULL;
						pVideoNode = RTMP_Get_Buffer(pVideoBuffer);
					}
				}
				
				while (pAudioNode)
   1a388:	1affffec 	bne	1a340 <Buffer_Control+0x480>
   1a38c:	e1a06007 	mov	r6, r7
   1a390:	e59d5020 	ldr	r5, [sp, #32]
   1a394:	e59d7030 	ldr	r7, [sp, #48]	; 0x30
					iSendVideo = 1;
				}
				
				if (pSendPacket)
				{
					free(pSendPacket);
   1a398:	e1a00007 	mov	r0, r7
   1a39c:	ebffab18 	bl	5004 <free@plt>
   1a3a0:	e59d3014 	ldr	r3, [sp, #20]
   1a3a4:	e58d3030 	str	r3, [sp, #48]	; 0x30
   1a3a8:	e3a03000 	mov	r3, #0
   1a3ac:	e58d3020 	str	r3, [sp, #32]
   1a3b0:	eafffee8 	b	19f58 <Buffer_Control+0x98>
				pthread_mutex_unlock(&pConfig->lock_min_bitrate_status);
				
				//RTMP_Log(RTMP_LOGINFO,"  push : min bitrate : %d \n",min_bitrate_status);
				if (min_bitrate_status == 0)
				{
					if (!RTMP_SendPacket_reconnect(pMetadata, pConfig, pSendPacket, pAccess, ChangeState))
   1a3b4:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
   1a3b8:	e58d3000 	str	r3, [sp]
   1a3bc:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
   1a3c0:	e1a01008 	mov	r1, r8
   1a3c4:	e1a02007 	mov	r2, r7
   1a3c8:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
   1a3cc:	ebffde94 	bl	11e24 <RTMP_SendPacket_reconnect>
   1a3d0:	e3500000 	cmp	r0, #0
   1a3d4:	1affff42 	bne	1a0e4 <Buffer_Control+0x224>
					{
						RTMP_Log(RTMP_LOGINFO, "push: *** send VIDEO data to server fail");
   1a3d8:	e59f1218 	ldr	r1, [pc, #536]	; 1a5f8 <Buffer_Control+0x738>
   1a3dc:	e58d000c 	str	r0, [sp, #12]
   1a3e0:	e08f1001 	add	r1, pc, r1
   1a3e4:	e3a00003 	mov	r0, #3
   1a3e8:	ebffed6f 	bl	159ac <RTMP_Log>
						if (pSendPacket)
						{
							free(pSendPacket);
   1a3ec:	e1a00007 	mov	r0, r7
   1a3f0:	ebffab03 	bl	5004 <free@plt>
   1a3f4:	e59d300c 	ldr	r3, [sp, #12]
   1a3f8:	eaffff94 	b	1a250 <Buffer_Control+0x390>
				{
					if (pConfig->send_video_type == 1
					   || ( pConfig->send_video_type == 0 && iSendVideo == 1 ))
					{
						//RTMP_Log(RTMP_LOGINFO,"*** SEND video: type  %d  packet time: %d  \n",iSendFrameType,pSendPacket->m_nTimeStamp);
						if (!RTMP_SendPacket_reconnect(pMetadata, pConfig, pSendPacket, pAccess, ChangeState))
   1a3fc:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
   1a400:	e58d3000 	str	r3, [sp]
   1a404:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
   1a408:	e1a01008 	mov	r1, r8
   1a40c:	e1a02007 	mov	r2, r7
   1a410:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
   1a414:	ebffde82 	bl	11e24 <RTMP_SendPacket_reconnect>
   1a418:	e3500000 	cmp	r0, #0
   1a41c:	1affff2f 	bne	1a0e0 <Buffer_Control+0x220>
						{
							RTMP_Log(RTMP_LOGINFO, "push: *** send VIDEO data to server fail");
   1a420:	e59f11d4 	ldr	r1, [pc, #468]	; 1a5fc <Buffer_Control+0x73c>
   1a424:	e58d000c 	str	r0, [sp, #12]
   1a428:	e08f1001 	add	r1, pc, r1
   1a42c:	e3a00003 	mov	r0, #3
   1a430:	ebffed5d 	bl	159ac <RTMP_Log>
							if (pSendPacket)
							{
								free(pSendPacket);
   1a434:	e1a00007 	mov	r0, r7
   1a438:	ebffaaf1 	bl	5004 <free@plt>
   1a43c:	e59d300c 	ldr	r3, [sp, #12]
   1a440:	eaffff82 	b	1a250 <Buffer_Control+0x390>
			{
				if (pAudioBuffer)
				{
					if (iSendVideo == 1)
					{
						ChangeState(publish_audio_only);
   1a444:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
   1a448:	e3a0000a 	mov	r0, #10
   1a44c:	e12fff33 	blx	r3
   1a450:	e59d3014 	ldr	r3, [sp, #20]
   1a454:	e58d3030 	str	r3, [sp, #48]	; 0x30
					}
					iSendVideo = 0;
   1a458:	e3a03000 	mov	r3, #0
   1a45c:	e58d3020 	str	r3, [sp, #32]
   1a460:	eaffff11 	b	1a0ac <Buffer_Control+0x1ec>
   1a464:	e1a0c006 	mov	ip, r6
							pAudioPacket = NULL;
							pAudioNode = RTMP_Get_Buffer(pAudioBuffer);
						}
						else
						{
							if (!RTMP_SendPacket_reconnect(pMetadata, pConfig, pAudioPacket, pAccess, ChangeState))
   1a468:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
   1a46c:	e58d3000 	str	r3, [sp]
   1a470:	e1a0200c 	mov	r2, ip
   1a474:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
   1a478:	e1a01008 	mov	r1, r8
   1a47c:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
   1a480:	e59d5020 	ldr	r5, [sp, #32]
   1a484:	e1a06007 	mov	r6, r7
   1a488:	e58dc020 	str	ip, [sp, #32]
   1a48c:	e59d7030 	ldr	r7, [sp, #48]	; 0x30
   1a490:	ebffde63 	bl	11e24 <RTMP_SendPacket_reconnect>
   1a494:	e59dc020 	ldr	ip, [sp, #32]
   1a498:	e3500000 	cmp	r0, #0
   1a49c:	0a000043 	beq	1a5b0 <Buffer_Control+0x6f0>
								}
								return FALSE;
							}
							
							if (pAudioPacket)
								free(pAudioPacket);
   1a4a0:	e1a0000c 	mov	r0, ip
   1a4a4:	ebffaad6 	bl	5004 <free@plt>
							pAudioPacket = NULL;
							if (pAudioNode)
							{
								free(pAudioNode);
   1a4a8:	e1a00004 	mov	r0, r4
   1a4ac:	ebffaad4 	bl	5004 <free@plt>
								pAudioNode = NULL;
							}
							pAudioNode = RTMP_Get_Buffer(pAudioBuffer);
   1a4b0:	e59d0010 	ldr	r0, [sp, #16]
   1a4b4:	eb0000d5 	bl	1a810 <RTMP_Get_Buffer>
   1a4b8:	e1a04000 	mov	r4, r0
							break;
   1a4bc:	eaffffb5 	b	1a398 <Buffer_Control+0x4d8>
   1a4c0:	e1a0c004 	mov	ip, r4
							pVideoPacket = NULL;
							pVideoNode = RTMP_Get_Buffer(pVideoBuffer);
						}
						else
						{
							if (!RTMP_SendPacket_reconnect(pMetadata, pConfig, pVideoPacket, pAccess, ChangeState))
   1a4c4:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
   1a4c8:	e58d3000 	str	r3, [sp]
   1a4cc:	e1a0200c 	mov	r2, ip
   1a4d0:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
   1a4d4:	e1a01008 	mov	r1, r8
   1a4d8:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
   1a4dc:	e59d4020 	ldr	r4, [sp, #32]
   1a4e0:	e58dc020 	str	ip, [sp, #32]
   1a4e4:	ebffde4e 	bl	11e24 <RTMP_SendPacket_reconnect>
   1a4e8:	e59dc020 	ldr	ip, [sp, #32]
   1a4ec:	e3500000 	cmp	r0, #0
   1a4f0:	0a000035 	beq	1a5cc <Buffer_Control+0x70c>
								
								return FALSE;
							}
							
							if (pVideoPacket)
								free(pVideoPacket);
   1a4f4:	e1a0000c 	mov	r0, ip
   1a4f8:	ebffaac1 	bl	5004 <free@plt>
							pVideoPacket = NULL;
							//pSendPacket=NULL;
							if (pVideoNode)
								free(pVideoNode);
   1a4fc:	e1a00005 	mov	r0, r5
   1a500:	ebffaabf 	bl	5004 <free@plt>
							pVideoNode = NULL;
							pVideoNode = RTMP_Get_Buffer(pVideoBuffer);
   1a504:	e1a0000b 	mov	r0, fp
   1a508:	eb0000c0 	bl	1a810 <RTMP_Get_Buffer>
   1a50c:	e1a05000 	mov	r5, r0
							break;
   1a510:	eaffff7f 	b	1a314 <Buffer_Control+0x454>
						}
					}
					else if (iSendVideo == 0  &&  (iCurrentTime-iLastDelay_Time)>=pConfig->iMaxRetryTime) //pConfig->iMaxRetryTime
					{
						//int iLastVideoTime=RTMP_Get_Last_Time(pConfig->pVideoBuffer);
						int iLastAudioTime=RTMP_Get_Last_Time(pConfig->pAudioBuffer);
   1a514:	e5980008 	ldr	r0, [r8, #8]
   1a518:	eb0000d4 	bl	1a870 <RTMP_Get_Last_Time>
						
						if (iSendFrameType == 1)
   1a51c:	e3590001 	cmp	r9, #1
   1a520:	1affff1e 	bne	1a1a0 <Buffer_Control+0x2e0>
						{
							//RTMP_Log(RTMP_LOGINFO,"### type: %d %d  packet time: %d   system time: %d \n",pSendPacket->m_packetType,iSendFrameType,pSendPacket->m_nTimeStamp,iCurrentTime);
							if (!RTMP_SendPacket_reconnect(pMetadata, pConfig, pSendPacket, pAccess, ChangeState))
   1a524:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
   1a528:	e58d3000 	str	r3, [sp]
   1a52c:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
   1a530:	e1a01008 	mov	r1, r8
   1a534:	e1a02007 	mov	r2, r7
   1a538:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
   1a53c:	ebffde38 	bl	11e24 <RTMP_SendPacket_reconnect>
   1a540:	e3500000 	cmp	r0, #0
   1a544:	0a000014 	beq	1a59c <Buffer_Control+0x6dc>
									pSendPacket = NULL;
								}
								return FALSE;
							}
							
							ChangeState(publish_all);
   1a548:	e3a0000b 	mov	r0, #11
   1a54c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
		//drop data
		pthread_mutex_lock(&pRtmp->lock_drop);
		pRtmp->m_drop_data += drop_data;
		pthread_mutex_unlock(&pRtmp->lock_drop);
		
		drop_data = 0;
   1a550:	e59d6020 	ldr	r6, [sp, #32]
									pSendPacket = NULL;
								}
								return FALSE;
							}
							
							ChangeState(publish_all);
   1a554:	e12fff33 	blx	r3
							iSendVideo=1;
   1a558:	e58d9020 	str	r9, [sp, #32]
   1a55c:	eafffee0 	b	1a0e4 <Buffer_Control+0x224>
			if (pSendPacket->m_packetType == 8 || pSendPacket->m_packetType == 18)
			{
				//RTMP_Log(RTMP_LOGINFO,"~~~ SEND AUDIO  : %d \n",pSendPacket->m_nTimeStamp);
				if (!RTMP_SendPacket_reconnect(pMetadata, pConfig, pSendPacket, pAccess, ChangeState))
				{
					RTMP_Log(RTMP_LOGINFO, "push: *** send AUDIO data to server fail");
   1a560:	e59f1098 	ldr	r1, [pc, #152]	; 1a600 <Buffer_Control+0x740>
   1a564:	e58d000c 	str	r0, [sp, #12]
   1a568:	e08f1001 	add	r1, pc, r1
   1a56c:	e3a00003 	mov	r0, #3
   1a570:	ebffed0d 	bl	159ac <RTMP_Log>
					if (pSendPacket)
					{
						free(pSendPacket);
   1a574:	e1a00007 	mov	r0, r7
   1a578:	ebffaaa1 	bl	5004 <free@plt>
   1a57c:	e59d300c 	ldr	r3, [sp, #12]
   1a580:	eaffff32 	b	1a250 <Buffer_Control+0x390>
   1a584:	e1a04000 	mov	r4, r0
   1a588:	eafffe8f 	b	19fcc <Buffer_Control+0x10c>
		//drop data
		pthread_mutex_lock(&pRtmp->lock_drop);
		pRtmp->m_drop_data += drop_data;
		pthread_mutex_unlock(&pRtmp->lock_drop);
		
		drop_data = 0;
   1a58c:	e1a06005 	mov	r6, r5
   1a590:	eaffff5f 	b	1a314 <Buffer_Control+0x454>
   1a594:	e1a0600c 	mov	r6, ip
   1a598:	eaffff5d 	b	1a314 <Buffer_Control+0x454>
   1a59c:	e58d000c 	str	r0, [sp, #12]
				if (!RTMP_SendPacket_reconnect(pMetadata, pConfig, pSendPacket, pAccess, ChangeState))
				{
					//RTMP_Log(RTMP_LOGINFO,"*** send data to server fail \n");
					if (pSendPacket)
					{
						free(pSendPacket);
   1a5a0:	e1a00007 	mov	r0, r7
   1a5a4:	ebffaa96 	bl	5004 <free@plt>
   1a5a8:	e59d300c 	ldr	r3, [sp, #12]
   1a5ac:	eaffff27 	b	1a250 <Buffer_Control+0x390>
   1a5b0:	e58d000c 	str	r0, [sp, #12]
						{
							if (!RTMP_SendPacket_reconnect(pMetadata, pConfig, pAudioPacket, pAccess, ChangeState))
							{
								if (pAudioPacket)
								{
									free(pAudioPacket);
   1a5b4:	e1a0000c 	mov	r0, ip
   1a5b8:	ebffaa91 	bl	5004 <free@plt>
									pAudioPacket = NULL;
									free(pAudioNode);
   1a5bc:	e1a00004 	mov	r0, r4
   1a5c0:	ebffaa8f 	bl	5004 <free@plt>
   1a5c4:	e59d300c 	ldr	r3, [sp, #12]
   1a5c8:	eaffff20 	b	1a250 <Buffer_Control+0x390>
   1a5cc:	e58d000c 	str	r0, [sp, #12]
						{
							if (!RTMP_SendPacket_reconnect(pMetadata, pConfig, pVideoPacket, pAccess, ChangeState))
							{
								if (pVideoPacket)
								{
									free(pVideoPacket);
   1a5d0:	e1a0000c 	mov	r0, ip
   1a5d4:	ebffaa8a 	bl	5004 <free@plt>
									pSendPacket = NULL;
									free(pVideoNode);
   1a5d8:	e1a00005 	mov	r0, r5
   1a5dc:	ebffaa88 	bl	5004 <free@plt>
   1a5e0:	e59d300c 	ldr	r3, [sp, #12]
   1a5e4:	eaffff19 	b	1a250 <Buffer_Control+0x390>
   1a5e8:	000076c4 	.word	0x000076c4
   1a5ec:	00002710 	.word	0x00002710
   1a5f0:	0000736c 	.word	0x0000736c
   1a5f4:	00007400 	.word	0x00007400
   1a5f8:	00007204 	.word	0x00007204
   1a5fc:	000071bc 	.word	0x000071bc
   1a600:	00007050 	.word	0x00007050

0001a604 <RTMP_Alloc_Buffer>:
分配缓冲区
*/
RTMPBuffer* RTMP_Alloc_Buffer()
{
	//printf("---RTMP_Alloc_Buffer-----\n");
	return calloc(1,sizeof(RTMPBuffer));
   1a604:	e3a00001 	mov	r0, #1
   1a608:	e3a0104c 	mov	r1, #76	; 0x4c
   1a60c:	eaffaac4 	b	5124 <calloc@plt>

0001a610 <RTMP_Init_Buffer>:

}

/*初始化缓冲区*/
int RTMP_Init_Buffer(RTMPBuffer *pBuffer)
{
   1a610:	e92d4038 	push	{r3, r4, r5, lr}

	pBuffer->pBufferNode=NULL;
   1a614:	e3a05000 	mov	r5, #0
	pBuffer->pLastNode=NULL;
	pBuffer->pAacConfig=0xAF;
   1a618:	e3e03050 	mvn	r3, #80	; 0x50

}

/*初始化缓冲区*/
int RTMP_Init_Buffer(RTMPBuffer *pBuffer)
{
   1a61c:	e1a04000 	mov	r4, r0

	pBuffer->pBufferNode=NULL;
	pBuffer->pLastNode=NULL;
	pBuffer->pAacConfig=0xAF;
   1a620:	e5c03018 	strb	r3, [r0, #24]

/*初始化缓冲区*/
int RTMP_Init_Buffer(RTMPBuffer *pBuffer)
{

	pBuffer->pBufferNode=NULL;
   1a624:	e5805000 	str	r5, [r0]
	pBuffer->pLastNode=NULL;
   1a628:	e5805004 	str	r5, [r0, #4]
	pBuffer->pAacConfig=0xAF;
	pBuffer->iBeginTime=0;
   1a62c:	e5805024 	str	r5, [r0, #36]	; 0x24
	pBuffer->pPacketConfig=(RTMPPacket *)calloc(1,RTMP_HEAD_SIZE+1024);	
   1a630:	e59f1028 	ldr	r1, [pc, #40]	; 1a660 <RTMP_Init_Buffer+0x50>
   1a634:	e3a00001 	mov	r0, #1
   1a638:	ebffaab9 	bl	5124 <calloc@plt>
	pBuffer->pPacketConfig->m_body=(char *)pBuffer->pPacketConfig+RTMP_HEAD_SIZE;
	pBuffer->packet_count=0;
   1a63c:	e5845044 	str	r5, [r4, #68]	; 0x44

	pBuffer->pBufferNode=NULL;
	pBuffer->pLastNode=NULL;
	pBuffer->pAacConfig=0xAF;
	pBuffer->iBeginTime=0;
	pBuffer->pPacketConfig=(RTMPPacket *)calloc(1,RTMP_HEAD_SIZE+1024);	
   1a640:	e1a03000 	mov	r3, r0
	pBuffer->pPacketConfig->m_body=(char *)pBuffer->pPacketConfig+RTMP_HEAD_SIZE;
   1a644:	e2832032 	add	r2, r3, #50	; 0x32

	pBuffer->pBufferNode=NULL;
	pBuffer->pLastNode=NULL;
	pBuffer->pAacConfig=0xAF;
	pBuffer->iBeginTime=0;
	pBuffer->pPacketConfig=(RTMPPacket *)calloc(1,RTMP_HEAD_SIZE+1024);	
   1a648:	e5840020 	str	r0, [r4, #32]
	pBuffer->pPacketConfig->m_body=(char *)pBuffer->pPacketConfig+RTMP_HEAD_SIZE;
   1a64c:	e583201c 	str	r2, [r3, #28]
	pBuffer->packet_count=0;
	rtmp_mutex_init(&pBuffer->lock);
   1a650:	e2840030 	add	r0, r4, #48	; 0x30
   1a654:	eb00012a 	bl	1ab04 <rtmp_mutex_init>
    //pBuffer->buffer_state=0;
	
	
	return TRUE;
}
   1a658:	e3a00001 	mov	r0, #1
   1a65c:	e8bd8038 	pop	{r3, r4, r5, pc}
   1a660:	00000432 	.word	0x00000432

0001a664 <RTMP_Alloc_BufferNode>:
给buffer node分配空间
*/
RTMPBuffer_Node* RTMP_Alloc_BufferNode()
{
	//printf("----RTMP_Alloc_BufferNode -----\n");
	return calloc(1,sizeof(RTMPBuffer_Node));
   1a664:	e3a00001 	mov	r0, #1
   1a668:	e3a0100c 	mov	r1, #12
   1a66c:	eaffaaac 	b	5124 <calloc@plt>

0001a670 <RTMP_Free_BufferNode>:
}

int RTMP_Free_BufferNode(RTMPBuffer_Node *pNode)
{
	//printf("----RTMP_Free_BufferNode -----\n");
	if(pNode)
   1a670:	e3500000 	cmp	r0, #0
   1a674:	0a000003 	beq	1a688 <RTMP_Free_BufferNode+0x18>
	//printf("----RTMP_Alloc_BufferNode -----\n");
	return calloc(1,sizeof(RTMPBuffer_Node));
}

int RTMP_Free_BufferNode(RTMPBuffer_Node *pNode)
{
   1a678:	e92d4008 	push	{r3, lr}
	//printf("----RTMP_Free_BufferNode -----\n");
	if(pNode)
	{
		free(pNode);
   1a67c:	ebffaa60 	bl	5004 <free@plt>
	}
	pNode=NULL;
	return TRUE;
}
   1a680:	e3a00001 	mov	r0, #1
   1a684:	e8bd8008 	pop	{r3, pc}
   1a688:	e3a00001 	mov	r0, #1
   1a68c:	e12fff1e 	bx	lr

0001a690 <RTMP_Free_SPS_PPS>:

int RTMP_Free_SPS_PPS(RTMP_SPS_PPS *pSPSPPS)
{
	//printf("----RTMP_Free_SPS_PPS ----\n");
	if(pSPSPPS)
   1a690:	e3500000 	cmp	r0, #0
   1a694:	0a00000e 	beq	1a6d4 <RTMP_Free_SPS_PPS+0x44>
	pNode=NULL;
	return TRUE;
}

int RTMP_Free_SPS_PPS(RTMP_SPS_PPS *pSPSPPS)
{
   1a698:	e92d4010 	push	{r4, lr}
   1a69c:	e1a04000 	mov	r4, r0
	//printf("----RTMP_Free_SPS_PPS ----\n");
	if(pSPSPPS)
	{
		if(pSPSPPS->sPPS)
   1a6a0:	e590000c 	ldr	r0, [r0, #12]
   1a6a4:	e3500000 	cmp	r0, #0
   1a6a8:	0a000000 	beq	1a6b0 <RTMP_Free_SPS_PPS+0x20>
			free(pSPSPPS->sPPS);
   1a6ac:	ebffaa54 	bl	5004 <free@plt>
		if(pSPSPPS->sSPS)
   1a6b0:	e5940004 	ldr	r0, [r4, #4]
   1a6b4:	e3500000 	cmp	r0, #0
   1a6b8:	0a000000 	beq	1a6c0 <RTMP_Free_SPS_PPS+0x30>
			free(pSPSPPS->sSPS);
   1a6bc:	ebffaa50 	bl	5004 <free@plt>
		pSPSPPS->sPPS=NULL;
   1a6c0:	e3a03000 	mov	r3, #0
   1a6c4:	e584300c 	str	r3, [r4, #12]
		pSPSPPS->sSPS=NULL;
   1a6c8:	e5843004 	str	r3, [r4, #4]
		//free(pSPSPPS);
		//pSPSPPS=NULL;
	}
	
	return TRUE;
}
   1a6cc:	e3a00001 	mov	r0, #1
   1a6d0:	e8bd8010 	pop	{r4, pc}
   1a6d4:	e3a00001 	mov	r0, #1
   1a6d8:	e12fff1e 	bx	lr

0001a6dc <RTMP_Free_Buffer>:
释放缓冲区
*/
int RTMP_Free_Buffer(RTMPBuffer *pBuffer)
{
	//printf("-----RTMP_Free_Buffer ------\n");
	if(pBuffer!=NULL)
   1a6dc:	e3500000 	cmp	r0, #0
   1a6e0:	0a00001f 	beq	1a764 <RTMP_Free_Buffer+0x88>
}
/*
释放缓冲区
*/
int RTMP_Free_Buffer(RTMPBuffer *pBuffer)
{
   1a6e4:	e92d4070 	push	{r4, r5, r6, lr}
	//printf("-----RTMP_Free_Buffer ------\n");
	if(pBuffer!=NULL)
	{
		//释放缓冲区链表
        pthread_mutex_lock(&pBuffer->lock);
   1a6e8:	e2805030 	add	r5, r0, #48	; 0x30
   1a6ec:	e1a04000 	mov	r4, r0
   1a6f0:	e1a00005 	mov	r0, r5
   1a6f4:	ebffaad8 	bl	525c <pthread_mutex_lock@plt>
		RTMPBuffer_Node *tmp;
		while(pBuffer->pBufferNode)
   1a6f8:	e5940000 	ldr	r0, [r4]
   1a6fc:	e3500000 	cmp	r0, #0
   1a700:	0a000005 	beq	1a71c <RTMP_Free_Buffer+0x40>
		{
			tmp=pBuffer->pBufferNode;
			pBuffer->pBufferNode=pBuffer->pBufferNode->next;
   1a704:	e5903008 	ldr	r3, [r0, #8]
   1a708:	e5843000 	str	r3, [r4]
			RTMP_Free_BufferNode(tmp);
   1a70c:	ebffffd7 	bl	1a670 <RTMP_Free_BufferNode>
	if(pBuffer!=NULL)
	{
		//释放缓冲区链表
        pthread_mutex_lock(&pBuffer->lock);
		RTMPBuffer_Node *tmp;
		while(pBuffer->pBufferNode)
   1a710:	e5940000 	ldr	r0, [r4]
   1a714:	e3500000 	cmp	r0, #0
   1a718:	1afffff9 	bne	1a704 <RTMP_Free_Buffer+0x28>
			tmp=pBuffer->pBufferNode;
			pBuffer->pBufferNode=pBuffer->pBufferNode->next;
			RTMP_Free_BufferNode(tmp);
            
		}
		pBuffer->pBufferNode=NULL;
   1a71c:	e3a06000 	mov	r6, #0
   1a720:	e5846000 	str	r6, [r4]
		pBuffer->pLastNode=NULL;
   1a724:	e5846004 	str	r6, [r4, #4]
		
		RTMP_Free_SPS_PPS(&pBuffer->pSPSPPSData);
   1a728:	e2840008 	add	r0, r4, #8
   1a72c:	ebffffd7 	bl	1a690 <RTMP_Free_SPS_PPS>

		if(pBuffer->pPacketConfig)
   1a730:	e5940020 	ldr	r0, [r4, #32]
   1a734:	e1500006 	cmp	r0, r6
   1a738:	0a000001 	beq	1a744 <RTMP_Free_Buffer+0x68>
		{
            free(pBuffer->pPacketConfig);
   1a73c:	ebffaa30 	bl	5004 <free@plt>
			pBuffer->pPacketConfig=NULL;
   1a740:	e5846020 	str	r6, [r4, #32]
		}
		pthread_mutex_unlock(&pBuffer->lock);
   1a744:	e1a00005 	mov	r0, r5
   1a748:	ebffaac6 	bl	5268 <pthread_mutex_unlock@plt>
		rtmp_mutex_destroy(&pBuffer->lock);
   1a74c:	e1a00005 	mov	r0, r5
   1a750:	eb000110 	bl	1ab98 <rtmp_mutex_destroy>
		
		free(pBuffer);
   1a754:	e1a00004 	mov	r0, r4
   1a758:	ebffaa29 	bl	5004 <free@plt>
	}
	pBuffer=NULL;
	return TRUE;
}
   1a75c:	e3a00001 	mov	r0, #1
   1a760:	e8bd8070 	pop	{r4, r5, r6, pc}
   1a764:	e3a00001 	mov	r0, #1
   1a768:	e12fff1e 	bx	lr

0001a76c <RTMP_Put_Buffer>:
将packet放入buffer中,packet已经分配好空间了
*/
int RTMP_Put_Buffer(RTMPBuffer *pBuffer,RTMPPacket *pPacket,int iKeyFrame)
{
	//printf("---- RTMP_Put_Buffer ----\n");
	if(!pBuffer || !pPacket)
   1a76c:	e3510000 	cmp	r1, #0
   1a770:	13500000 	cmpne	r0, #0

/*
将packet放入buffer中,packet已经分配好空间了
*/
int RTMP_Put_Buffer(RTMPBuffer *pBuffer,RTMPPacket *pPacket,int iKeyFrame)
{
   1a774:	e92d43f8 	push	{r3, r4, r5, r6, r7, r8, r9, lr}
	//printf("---- RTMP_Put_Buffer ----\n");
	if(!pBuffer || !pPacket)
   1a778:	03a08001 	moveq	r8, #1
   1a77c:	13a08000 	movne	r8, #0
   1a780:	1a000001 	bne	1a78c <RTMP_Put_Buffer+0x20>
		return FALSE;
   1a784:	e3a00000 	mov	r0, #0
   1a788:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
   1a78c:	e1a07001 	mov	r7, r1
   1a790:	e1a04000 	mov	r4, r0
   1a794:	e1a05002 	mov	r5, r2
	
	//首先分配bufferNode
	RTMPBuffer_Node *pNode=NULL;
	
	pNode=RTMP_Alloc_BufferNode();
   1a798:	ebffffb1 	bl	1a664 <RTMP_Alloc_BufferNode>
	if(!pNode)
   1a79c:	e2506000 	subs	r6, r0, #0
   1a7a0:	0afffff7 	beq	1a784 <RTMP_Put_Buffer+0x18>
	//赋值
	pNode->pPacket=pPacket;
	pNode->next=NULL;
	pNode->nFrame_type=iKeyFrame;
	
	pthread_mutex_lock(&pBuffer->lock);
   1a7a4:	e2849030 	add	r9, r4, #48	; 0x30
	
	pNode=RTMP_Alloc_BufferNode();
	if(!pNode)
		return FALSE;
	//赋值
	pNode->pPacket=pPacket;
   1a7a8:	e5867000 	str	r7, [r6]
	pNode->next=NULL;
	pNode->nFrame_type=iKeyFrame;
   1a7ac:	e9860120 	stmib	r6, {r5, r8}
	
	pthread_mutex_lock(&pBuffer->lock);
   1a7b0:	e1a00009 	mov	r0, r9
   1a7b4:	ebffaaa8 	bl	525c <pthread_mutex_lock@plt>
	//加入链表
	if(pBuffer)
	{
		if(pBuffer->pBufferNode==NULL)
   1a7b8:	e5943000 	ldr	r3, [r4]
   1a7bc:	e3530000 	cmp	r3, #0
		{
			pBuffer->pBufferNode=pNode;
   1a7c0:	05846000 	streq	r6, [r4]
			pBuffer->pLastNode=pNode;
   1a7c4:	05846004 	streq	r6, [r4, #4]
	
	pthread_mutex_lock(&pBuffer->lock);
	//加入链表
	if(pBuffer)
	{
		if(pBuffer->pBufferNode==NULL)
   1a7c8:	0a000005 	beq	1a7e4 <RTMP_Put_Buffer+0x78>
			pBuffer->pBufferNode=pNode;
			pBuffer->pLastNode=pNode;
		}
		else
		{
			if(pBuffer->pLastNode)
   1a7cc:	e5943004 	ldr	r3, [r4, #4]
   1a7d0:	e3530000 	cmp	r3, #0
			{
				pBuffer->pLastNode->next=pNode;
   1a7d4:	15836008 	strne	r6, [r3, #8]
				pBuffer->pLastNode=pNode;
			}
			else // need discuss
			{
				pBuffer->pLastNode=pNode;
   1a7d8:	05846004 	streq	r6, [r4, #4]
		else
		{
			if(pBuffer->pLastNode)
			{
				pBuffer->pLastNode->next=pNode;
				pBuffer->pLastNode=pNode;
   1a7dc:	15846004 	strne	r6, [r4, #4]
			}
			else // need discuss
			{
				pBuffer->pLastNode=pNode;
				pBuffer->pLastNode->next=pNode;
   1a7e0:	05866008 	streq	r6, [r6, #8]
		if(iKeyFrame)
		{
			pBuffer->iLast_i_frame_time=pPacket->m_nTimeStamp;
		}
			
		pBuffer->packet_count++;
   1a7e4:	e5943044 	ldr	r3, [r4, #68]	; 0x44
			}
		}
		//更新最后一个I帧的时间
		if(iKeyFrame)
		{
			pBuffer->iLast_i_frame_time=pPacket->m_nTimeStamp;
   1a7e8:	e5972008 	ldr	r2, [r7, #8]
				pBuffer->pLastNode=pNode;
				pBuffer->pLastNode->next=pNode;
			}
		}
		//更新最后一个I帧的时间
		if(iKeyFrame)
   1a7ec:	e3550000 	cmp	r5, #0
		{
			pBuffer->iLast_i_frame_time=pPacket->m_nTimeStamp;
		}
			
		pBuffer->packet_count++;
   1a7f0:	e2833001 	add	r3, r3, #1
			}
		}
		//更新最后一个I帧的时间
		if(iKeyFrame)
		{
			pBuffer->iLast_i_frame_time=pPacket->m_nTimeStamp;
   1a7f4:	1584201c 	strne	r2, [r4, #28]
		}
			
		pBuffer->packet_count++;
		pBuffer->iLast_frame_time=pPacket->m_nTimeStamp;
   1a7f8:	e5842048 	str	r2, [r4, #72]	; 0x48
		
		pthread_mutex_unlock(&pBuffer->lock);
   1a7fc:	e1a00009 	mov	r0, r9
		if(iKeyFrame)
		{
			pBuffer->iLast_i_frame_time=pPacket->m_nTimeStamp;
		}
			
		pBuffer->packet_count++;
   1a800:	e5843044 	str	r3, [r4, #68]	; 0x44
		pBuffer->iLast_frame_time=pPacket->m_nTimeStamp;
		
		pthread_mutex_unlock(&pBuffer->lock);
   1a804:	ebffaa97 	bl	5268 <pthread_mutex_unlock@plt>
		}
		pthread_mutex_unlock(&pBuffer->lock);
		return FALSE;
	}
	
	return TRUE;
   1a808:	e3a00001 	mov	r0, #1
}
   1a80c:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}

0001a810 <RTMP_Get_Buffer>:

/*
从buffer中读取一个packet
*/
RTMPBuffer_Node* RTMP_Get_Buffer(RTMPBuffer *pBuffer)
{
   1a810:	e92d4070 	push	{r4, r5, r6, lr}
	//printf("---- RTMP_Get_Buffer ----\n");
	if(!pBuffer || !pBuffer->pBufferNode)
   1a814:	e2504000 	subs	r4, r0, #0
   1a818:	0a000012 	beq	1a868 <RTMP_Get_Buffer+0x58>
   1a81c:	e5940000 	ldr	r0, [r4]
   1a820:	e3500000 	cmp	r0, #0
   1a824:	08bd8070 	popeq	{r4, r5, r6, pc}
		return NULL;
	RTMPBuffer_Node *pNode=NULL;
	
	pthread_mutex_lock(&pBuffer->lock);
   1a828:	e2846030 	add	r6, r4, #48	; 0x30
   1a82c:	e1a00006 	mov	r0, r6
   1a830:	ebffaa89 	bl	525c <pthread_mutex_lock@plt>
	
	pNode=pBuffer->pBufferNode;
   1a834:	e5945000 	ldr	r5, [r4]
    
	pBuffer->pBufferNode=pBuffer->pBufferNode->next;
	if(pNode)
    {
        pBuffer->packet_count--;
   1a838:	e5943044 	ldr	r3, [r4, #68]	; 0x44
        pBuffer->iBeginTime=pNode->pPacket->m_nTimeStamp;
   1a83c:	e5951000 	ldr	r1, [r5]
	
	pthread_mutex_lock(&pBuffer->lock);
	
	pNode=pBuffer->pBufferNode;
    
	pBuffer->pBufferNode=pBuffer->pBufferNode->next;
   1a840:	e5952008 	ldr	r2, [r5, #8]
	if(pNode)
    {
        pBuffer->packet_count--;
        pBuffer->iBeginTime=pNode->pPacket->m_nTimeStamp;
   1a844:	e5911008 	ldr	r1, [r1, #8]
	pNode=pBuffer->pBufferNode;
    
	pBuffer->pBufferNode=pBuffer->pBufferNode->next;
	if(pNode)
    {
        pBuffer->packet_count--;
   1a848:	e2433001 	sub	r3, r3, #1
        pBuffer->iBeginTime=pNode->pPacket->m_nTimeStamp;
    }
    
	pthread_mutex_unlock(&pBuffer->lock);
   1a84c:	e1a00006 	mov	r0, r6
    
	pBuffer->pBufferNode=pBuffer->pBufferNode->next;
	if(pNode)
    {
        pBuffer->packet_count--;
        pBuffer->iBeginTime=pNode->pPacket->m_nTimeStamp;
   1a850:	e5841024 	str	r1, [r4, #36]	; 0x24
	
	pthread_mutex_lock(&pBuffer->lock);
	
	pNode=pBuffer->pBufferNode;
    
	pBuffer->pBufferNode=pBuffer->pBufferNode->next;
   1a854:	e5842000 	str	r2, [r4]
	if(pNode)
    {
        pBuffer->packet_count--;
   1a858:	e5843044 	str	r3, [r4, #68]	; 0x44
        pBuffer->iBeginTime=pNode->pPacket->m_nTimeStamp;
    }
    
	pthread_mutex_unlock(&pBuffer->lock);
   1a85c:	ebffaa81 	bl	5268 <pthread_mutex_unlock@plt>
	
	return pNode;
   1a860:	e1a00005 	mov	r0, r5
   1a864:	e8bd8070 	pop	{r4, r5, r6, pc}
*/
RTMPBuffer_Node* RTMP_Get_Buffer(RTMPBuffer *pBuffer)
{
	//printf("---- RTMP_Get_Buffer ----\n");
	if(!pBuffer || !pBuffer->pBufferNode)
		return NULL;
   1a868:	e1a00004 	mov	r0, r4
    
	pthread_mutex_unlock(&pBuffer->lock);
	
	return pNode;

}
   1a86c:	e8bd8070 	pop	{r4, r5, r6, pc}

0001a870 <RTMP_Get_Last_Time>:

uint32_t RTMP_Get_Last_Time(RTMPBuffer *pBuffer)
{
	if(pBuffer==NULL)
   1a870:	e3500000 	cmp	r0, #0
   1a874:	0a000009 	beq	1a8a0 <RTMP_Get_Last_Time+0x30>
	return pNode;

}

uint32_t RTMP_Get_Last_Time(RTMPBuffer *pBuffer)
{
   1a878:	e92d4038 	push	{r3, r4, r5, lr}
	if(pBuffer==NULL)
		return -1;
	uint32_t iTime=0;
	pthread_mutex_lock(&pBuffer->lock);
   1a87c:	e2805030 	add	r5, r0, #48	; 0x30
   1a880:	e1a04000 	mov	r4, r0
   1a884:	e1a00005 	mov	r0, r5
   1a888:	ebffaa73 	bl	525c <pthread_mutex_lock@plt>
	iTime=pBuffer->iLast_i_frame_time;
   1a88c:	e594401c 	ldr	r4, [r4, #28]
	pthread_mutex_unlock(&pBuffer->lock);
   1a890:	e1a00005 	mov	r0, r5
   1a894:	ebffaa73 	bl	5268 <pthread_mutex_unlock@plt>
	return iTime;
   1a898:	e1a00004 	mov	r0, r4
   1a89c:	e8bd8038 	pop	{r3, r4, r5, pc}
}

uint32_t RTMP_Get_Last_Time(RTMPBuffer *pBuffer)
{
	if(pBuffer==NULL)
		return -1;
   1a8a0:	e3e00000 	mvn	r0, #0
   1a8a4:	e12fff1e 	bx	lr

0001a8a8 <RTMP_Send_Sequence>:
	return iTime;

}

int RTMP_Send_Sequence(RTMP *pRtmp,RTMPBuffer *pBuffer,uint32_t iTime)
{
   1a8a8:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	//get sequence
	pthread_mutex_lock(&pBuffer->lock);
   1a8ac:	e2815030 	add	r5, r1, #48	; 0x30
	return iTime;

}

int RTMP_Send_Sequence(RTMP *pRtmp,RTMPBuffer *pBuffer,uint32_t iTime)
{
   1a8b0:	e1a04001 	mov	r4, r1
   1a8b4:	e1a06000 	mov	r6, r0
	//get sequence
	pthread_mutex_lock(&pBuffer->lock);
   1a8b8:	e1a00005 	mov	r0, r5
	return iTime;

}

int RTMP_Send_Sequence(RTMP *pRtmp,RTMPBuffer *pBuffer,uint32_t iTime)
{
   1a8bc:	e1a07002 	mov	r7, r2
	//get sequence
	pthread_mutex_lock(&pBuffer->lock);
   1a8c0:	ebffaa65 	bl	525c <pthread_mutex_lock@plt>
	RTMPPacket *pPacket=pBuffer->pPacketConfig;
   1a8c4:	e5944020 	ldr	r4, [r4, #32]
	pthread_mutex_unlock(&pBuffer->lock);
   1a8c8:	e1a00005 	mov	r0, r5
   1a8cc:	ebffaa65 	bl	5268 <pthread_mutex_unlock@plt>
	pPacket->m_nTimeStamp=iTime;
   1a8d0:	e5847008 	str	r7, [r4, #8]
	if(!RTMP_SendPacket(pRtmp,pPacket,0))
   1a8d4:	e1a01004 	mov	r1, r4
   1a8d8:	e1a00006 	mov	r0, r6
   1a8dc:	e3a02000 	mov	r2, #0
   1a8e0:	ebffc2c5 	bl	b3fc <RTMP_SendPacket>
   1a8e4:	e2504000 	subs	r4, r0, #0
	{
		printf(" send sequence fail \n");
		return FALSE;
	}

	return TRUE;
   1a8e8:	13a04001 	movne	r4, #1
	//get sequence
	pthread_mutex_lock(&pBuffer->lock);
	RTMPPacket *pPacket=pBuffer->pPacketConfig;
	pthread_mutex_unlock(&pBuffer->lock);
	pPacket->m_nTimeStamp=iTime;
	if(!RTMP_SendPacket(pRtmp,pPacket,0))
   1a8ec:	1a000002 	bne	1a8fc <RTMP_Send_Sequence+0x54>
	{
		printf(" send sequence fail \n");
   1a8f0:	e59f000c 	ldr	r0, [pc, #12]	; 1a904 <RTMP_Send_Sequence+0x5c>
   1a8f4:	e08f0000 	add	r0, pc, r0
   1a8f8:	ebffaa54 	bl	5250 <puts@plt>
		return FALSE;
	}

	return TRUE;
}
   1a8fc:	e1a00004 	mov	r0, r4
   1a900:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
   1a904:	00006d70 	.word	0x00006d70

0001a908 <InitBufferConfig>:

int InitBufferConfig(BufferConfig *pConfig,int max_delay,int wait_time,int discard_type,int send_window,int retrytime)
{
   1a908:	e92d4ff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1a90c:	e59d6028 	ldr	r6, [sp, #40]	; 0x28
   1a910:	e1a04000 	mov	r4, r0
   1a914:	e1a08002 	mov	r8, r2
   1a918:	e1a07003 	mov	r7, r3
   1a91c:	e1a09001 	mov	r9, r1
	RTMP * pRTMP = NULL;
	RTMPBuffer *pVideoBuffer = NULL;
	RTMPBuffer *pAudioBuffer = NULL;

	//建立 RTMP 连接
	pRTMP = RTMP_Alloc();
   1a920:	ebffb7f4 	bl	88f8 <RTMP_Alloc>
    
	//video buffer
	pVideoBuffer = (RTMPBuffer *)calloc(1,sizeof(RTMPBuffer));
   1a924:	e3a0104c 	mov	r1, #76	; 0x4c
	RTMP * pRTMP = NULL;
	RTMPBuffer *pVideoBuffer = NULL;
	RTMPBuffer *pAudioBuffer = NULL;

	//建立 RTMP 连接
	pRTMP = RTMP_Alloc();
   1a928:	e1a05000 	mov	r5, r0
    
	//video buffer
	pVideoBuffer = (RTMPBuffer *)calloc(1,sizeof(RTMPBuffer));
   1a92c:	e3a00001 	mov	r0, #1
   1a930:	ebffa9fb 	bl	5124 <calloc@plt>
   1a934:	e1a0b000 	mov	fp, r0
	RTMP_Init_Buffer(pVideoBuffer);
   1a938:	ebffff34 	bl	1a610 <RTMP_Init_Buffer>
	pAudioBuffer = (RTMPBuffer *)calloc(1,sizeof(RTMPBuffer));
   1a93c:	e3a0104c 	mov	r1, #76	; 0x4c
   1a940:	e3a00001 	mov	r0, #1
   1a944:	ebffa9f6 	bl	5124 <calloc@plt>
   1a948:	e1a0a000 	mov	sl, r0
	RTMP_Init_Buffer(pAudioBuffer);
   1a94c:	ebffff2f 	bl	1a610 <RTMP_Init_Buffer>

	pConfig->pRTMP = pRTMP;
    
	pConfig->pVideoBuffer = pVideoBuffer;
	pConfig->pAudioBuffer = pAudioBuffer;
	pConfig->state = init_status;
   1a950:	e3a01000 	mov	r1, #0
    
	pConfig->iMaxDelay = max_delay;
	pConfig->iWaitTime = wait_time;
	pConfig->send_video_type = discard_type;
	pConfig->iReSend_Window_Time = send_window;
    pConfig->iMaxRetryTime = retrytime;
   1a954:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
   1a958:	e5843020 	str	r3, [r4, #32]

	pConfig->pRTMP = pRTMP;
    
	pConfig->pVideoBuffer = pVideoBuffer;
	pConfig->pAudioBuffer = pAudioBuffer;
	pConfig->state = init_status;
   1a95c:	e584100c 	str	r1, [r4, #12]
	pConfig->iWaitTime = wait_time;
	pConfig->send_video_type = discard_type;
	pConfig->iReSend_Window_Time = send_window;
    pConfig->iMaxRetryTime = retrytime;
    
    pConfig->min_bitrate_status = 0;
   1a960:	e5841028 	str	r1, [r4, #40]	; 0x28
	RTMP_Init_Buffer(pAudioBuffer);


	pConfig->pRTMP = pRTMP;
    
	pConfig->pVideoBuffer = pVideoBuffer;
   1a964:	e8840820 	stm	r4, {r5, fp}
	pConfig->pAudioBuffer = pAudioBuffer;
   1a968:	e584a008 	str	sl, [r4, #8]
	pConfig->state = init_status;
    
    
	pConfig->iMaxDelay = max_delay;
   1a96c:	e5849010 	str	r9, [r4, #16]
	pConfig->iWaitTime = wait_time;
   1a970:	e5848014 	str	r8, [r4, #20]
	pConfig->send_video_type = discard_type;
   1a974:	e5847018 	str	r7, [r4, #24]
	pConfig->iReSend_Window_Time = send_window;
   1a978:	e584601c 	str	r6, [r4, #28]
    pConfig->iMaxRetryTime = retrytime;
    
    pConfig->min_bitrate_status = 0;
    
    rtmp_mutex_init(&pConfig->lock_min_bitrate_status);
   1a97c:	e284002c 	add	r0, r4, #44	; 0x2c
   1a980:	eb00005f 	bl	1ab04 <rtmp_mutex_init>
    rtmp_mutex_init(&pConfig->lock);
   1a984:	e2840024 	add	r0, r4, #36	; 0x24
   1a988:	eb00005d 	bl	1ab04 <rtmp_mutex_init>
    rtmp_mutex_init(&pConfig->lock_net_change);
   1a98c:	e2840034 	add	r0, r4, #52	; 0x34
   1a990:	eb00005b 	bl	1ab04 <rtmp_mutex_init>
 
    

	return TRUE;
}
   1a994:	e3a00001 	mov	r0, #1
   1a998:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

0001a99c <FreeBufferConfig>:

void FreeBufferConfig(BufferConfig *pConfig)
{
	if(pConfig!=NULL)
   1a99c:	e3500000 	cmp	r0, #0
   1a9a0:	012fff1e 	bxeq	lr

	return TRUE;
}

void FreeBufferConfig(BufferConfig *pConfig)
{
   1a9a4:	e92d4010 	push	{r4, lr}
   1a9a8:	e1a04000 	mov	r4, r0
	if(pConfig!=NULL)
	{
        rtmp_mutex_destroy(&pConfig->lock);
   1a9ac:	e2800024 	add	r0, r0, #36	; 0x24
   1a9b0:	eb000078 	bl	1ab98 <rtmp_mutex_destroy>
        rtmp_mutex_destroy(&pConfig->lock_min_bitrate_status);
   1a9b4:	e284002c 	add	r0, r4, #44	; 0x2c
   1a9b8:	eb000076 	bl	1ab98 <rtmp_mutex_destroy>
        rtmp_mutex_destroy(&pConfig->lock_net_change);
   1a9bc:	e2840034 	add	r0, r4, #52	; 0x34
   1a9c0:	eb000074 	bl	1ab98 <rtmp_mutex_destroy>
        
		if(pConfig->pVideoBuffer!=NULL)
   1a9c4:	e5940004 	ldr	r0, [r4, #4]
   1a9c8:	e3500000 	cmp	r0, #0
   1a9cc:	0a000002 	beq	1a9dc <FreeBufferConfig+0x40>
		{
           
			RTMP_Free_Buffer(pConfig->pVideoBuffer);
   1a9d0:	ebffff41 	bl	1a6dc <RTMP_Free_Buffer>
			pConfig->pVideoBuffer=NULL;
   1a9d4:	e3a03000 	mov	r3, #0
   1a9d8:	e5843004 	str	r3, [r4, #4]
            
		}
		if(pConfig->pAudioBuffer)
   1a9dc:	e5940008 	ldr	r0, [r4, #8]
   1a9e0:	e3500000 	cmp	r0, #0
   1a9e4:	0a000002 	beq	1a9f4 <FreeBufferConfig+0x58>
		{
           
			RTMP_Free_Buffer(pConfig->pAudioBuffer);
   1a9e8:	ebffff3b 	bl	1a6dc <RTMP_Free_Buffer>
			pConfig->pAudioBuffer=NULL;
   1a9ec:	e3a03000 	mov	r3, #0
   1a9f0:	e5843008 	str	r3, [r4, #8]
            
		}
        
        
        if(pConfig->pRTMP)
   1a9f4:	e5940000 	ldr	r0, [r4]
   1a9f8:	e3500000 	cmp	r0, #0
   1a9fc:	0a000002 	beq	1aa0c <FreeBufferConfig+0x70>
        {
            free_portal(pConfig->pRTMP);
   1aa00:	ebffb3cc 	bl	7938 <free_portal>
            
            free(pConfig->pRTMP);
   1aa04:	e5940000 	ldr	r0, [r4]
   1aa08:	ebffa97d 	bl	5004 <free@plt>
            pConfig->pRTMP = NULL;
        }
		free(pConfig);
   1aa0c:	e1a00004 	mov	r0, r4
		pConfig=NULL;
	}
}
   1aa10:	e8bd4010 	pop	{r4, lr}
            free_portal(pConfig->pRTMP);
            
            free(pConfig->pRTMP);
            pConfig->pRTMP = NULL;
        }
		free(pConfig);
   1aa14:	eaffa97a 	b	5004 <free@plt>

0001aa18 <GetBufferCurrentTime>:
}

int GetBufferCurrentTime(BufferConfig *pConfig)
{
	int iCurrentTime=0;
	if(pConfig->pVideoBuffer)
   1aa18:	e5903004 	ldr	r3, [r0, #4]
   1aa1c:	e3530000 	cmp	r3, #0
   1aa20:	0a000002 	beq	1aa30 <GetBufferCurrentTime+0x18>
		iCurrentTime=RTMP_GetTime_m(pConfig->pVideoBuffer->t_start);
   1aa24:	e2833028 	add	r3, r3, #40	; 0x28
   1aa28:	e8930003 	ldm	r3, {r0, r1}
   1aa2c:	eaffb6eb 	b	85e0 <RTMP_GetTime_m>
	else if(pConfig->pAudioBuffer)
   1aa30:	e5900008 	ldr	r0, [r0, #8]
   1aa34:	e3500000 	cmp	r0, #0
   1aa38:	012fff1e 	bxeq	lr
		iCurrentTime=RTMP_GetTime_m(pConfig->pAudioBuffer->t_start);
   1aa3c:	e2800028 	add	r0, r0, #40	; 0x28
   1aa40:	e8900003 	ldm	r0, {r0, r1}
   1aa44:	eaffb6e5 	b	85e0 <RTMP_GetTime_m>

0001aa48 <SetBufferStartTime>:
	return iCurrentTime;
}
void SetBufferStartTime(BufferConfig *pConfig)
{
   1aa48:	e92d4030 	push	{r4, r5, lr}
   1aa4c:	e24dd00c 	sub	sp, sp, #12
	struct timeval tCurrentTime;
	gettimeofday(&tCurrentTime, NULL);
   1aa50:	e3a01000 	mov	r1, #0
	else if(pConfig->pAudioBuffer)
		iCurrentTime=RTMP_GetTime_m(pConfig->pAudioBuffer->t_start);
	return iCurrentTime;
}
void SetBufferStartTime(BufferConfig *pConfig)
{
   1aa54:	e1a05000 	mov	r5, r0
	struct timeval tCurrentTime;
	gettimeofday(&tCurrentTime, NULL);
   1aa58:	e1a0000d 	mov	r0, sp
   1aa5c:	ebffaa0a 	bl	528c <gettimeofday@plt>

	if(pConfig->pVideoBuffer)
   1aa60:	e5953004 	ldr	r3, [r5, #4]
   1aa64:	e3530000 	cmp	r3, #0
		pConfig->pVideoBuffer->t_start=tCurrentTime;
   1aa68:	189d0003 	ldmne	sp, {r0, r1}
   1aa6c:	12833028 	addne	r3, r3, #40	; 0x28
   1aa70:	18830003 	stmne	r3, {r0, r1}
	if(pConfig->pAudioBuffer)
   1aa74:	e5953008 	ldr	r3, [r5, #8]
   1aa78:	e3530000 	cmp	r3, #0
		pConfig->pAudioBuffer->t_start=tCurrentTime;
   1aa7c:	189d0003 	ldmne	sp, {r0, r1}
   1aa80:	12833028 	addne	r3, r3, #40	; 0x28
   1aa84:	18830003 	stmne	r3, {r0, r1}
}
   1aa88:	e28dd00c 	add	sp, sp, #12
   1aa8c:	e8bd8030 	pop	{r4, r5, pc}

0001aa90 <ThreadCreate>:
#include "log.h"


pthread_t
ThreadCreate(thrfunc *routine, void *args)
{
   1aa90:	e92d4070 	push	{r4, r5, r6, lr}
   1aa94:	e24dd020 	sub	sp, sp, #32
  pthread_t id = 0;
  pthread_attr_t attributes;
  int ret;

  pthread_attr_init(&attributes);
   1aa98:	e28d4008 	add	r4, sp, #8


pthread_t
ThreadCreate(thrfunc *routine, void *args)
{
  pthread_t id = 0;
   1aa9c:	e3a03000 	mov	r3, #0
#include "log.h"


pthread_t
ThreadCreate(thrfunc *routine, void *args)
{
   1aaa0:	e1a06000 	mov	r6, r0
  pthread_t id = 0;
  pthread_attr_t attributes;
  int ret;

  pthread_attr_init(&attributes);
   1aaa4:	e1a00004 	mov	r0, r4
#include "log.h"


pthread_t
ThreadCreate(thrfunc *routine, void *args)
{
   1aaa8:	e1a05001 	mov	r5, r1
  pthread_t id = 0;
   1aaac:	e58d3004 	str	r3, [sp, #4]
  pthread_attr_t attributes;
  int ret;

  pthread_attr_init(&attributes);
   1aab0:	ebffaad6 	bl	5610 <pthread_attr_init@plt>
  pthread_attr_setdetachstate(&attributes, PTHREAD_CREATE_DETACHED);
   1aab4:	e3a01001 	mov	r1, #1
   1aab8:	e1a00004 	mov	r0, r4
   1aabc:	ebffaad6 	bl	561c <pthread_attr_setdetachstate@plt>

  ret =
   1aac0:	e1a02006 	mov	r2, r6
   1aac4:	e1a01004 	mov	r1, r4
   1aac8:	e1a03005 	mov	r3, r5
   1aacc:	e28d0004 	add	r0, sp, #4
   1aad0:	ebffaad4 	bl	5628 <pthread_create@plt>
    pthread_create(&id, &attributes, routine, args);
  if (ret != 0)
   1aad4:	e2502000 	subs	r2, r0, #0
   1aad8:	0a000004 	beq	1aaf0 <ThreadCreate+0x60>
    RTMP_LogPrintf("%s, pthread_create failed with %d\n", __FUNCTION__, ret);
   1aadc:	e59f0018 	ldr	r0, [pc, #24]	; 1aafc <ThreadCreate+0x6c>
   1aae0:	e59f1018 	ldr	r1, [pc, #24]	; 1ab00 <ThreadCreate+0x70>
   1aae4:	e08f0000 	add	r0, pc, r0
   1aae8:	e08f1001 	add	r1, pc, r1
   1aaec:	ebffec5c 	bl	15c64 <RTMP_LogPrintf>

  return id;
}
   1aaf0:	e59d0004 	ldr	r0, [sp, #4]
   1aaf4:	e28dd020 	add	sp, sp, #32
   1aaf8:	e8bd8070 	pop	{r4, r5, r6, pc}
   1aafc:	00006b98 	.word	0x00006b98
   1ab00:	00006fc4 	.word	0x00006fc4

0001ab04 <rtmp_mutex_init>:

//初始化互斥锁
int rtmp_mutex_init( pthread_mutex_t *p_mutex )
{
   1ab04:	e92d4070 	push	{r4, r5, r6, lr}
   1ab08:	e24dd008 	sub	sp, sp, #8
    pthread_mutexattr_t attr;

    if (pthread_mutexattr_init (&attr))
   1ab0c:	e28d4004 	add	r4, sp, #4
  return id;
}

//初始化互斥锁
int rtmp_mutex_init( pthread_mutex_t *p_mutex )
{
   1ab10:	e1a06000 	mov	r6, r0
    pthread_mutexattr_t attr;

    if (pthread_mutexattr_init (&attr))
   1ab14:	e1a00004 	mov	r0, r4
   1ab18:	ebffaac5 	bl	5634 <pthread_mutexattr_init@plt>
   1ab1c:	e2505000 	subs	r5, r0, #0
   1ab20:	1a000013 	bne	1ab74 <rtmp_mutex_init+0x70>
		RTMP_LogPrintf(" pthread_mutexattr_init() fail \n ");
		return 0;
	}
        

    pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_DEFAULT);
   1ab24:	e1a01005 	mov	r1, r5
   1ab28:	e1a00004 	mov	r0, r4
   1ab2c:	ebffaac3 	bl	5640 <pthread_mutexattr_settype@plt>

    if (pthread_mutex_init (p_mutex, &attr))
   1ab30:	e1a00006 	mov	r0, r6
   1ab34:	e1a01004 	mov	r1, r4
   1ab38:	ebffaac3 	bl	564c <pthread_mutex_init@plt>
   1ab3c:	e3500000 	cmp	r0, #0
   1ab40:	1a000005 	bne	1ab5c <rtmp_mutex_init+0x58>
    {
		RTMP_LogPrintf(" pthread_mutex_init() fail \n");
		return 0;
	}
        
    pthread_mutexattr_destroy( &attr );
   1ab44:	e1a00004 	mov	r0, r4
   1ab48:	ebffaac2 	bl	5658 <pthread_mutexattr_destroy@plt>
	return 1;
   1ab4c:	e3a05001 	mov	r5, #1
	
}
   1ab50:	e1a00005 	mov	r0, r5
   1ab54:	e28dd008 	add	sp, sp, #8
   1ab58:	e8bd8070 	pop	{r4, r5, r6, pc}

    pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_DEFAULT);

    if (pthread_mutex_init (p_mutex, &attr))
    {
		RTMP_LogPrintf(" pthread_mutex_init() fail \n");
   1ab5c:	e59f002c 	ldr	r0, [pc, #44]	; 1ab90 <rtmp_mutex_init+0x8c>
   1ab60:	e08f0000 	add	r0, pc, r0
   1ab64:	ebffec3e 	bl	15c64 <RTMP_LogPrintf>
	}
        
    pthread_mutexattr_destroy( &attr );
	return 1;
	
}
   1ab68:	e1a00005 	mov	r0, r5
   1ab6c:	e28dd008 	add	sp, sp, #8
   1ab70:	e8bd8070 	pop	{r4, r5, r6, pc}
{
    pthread_mutexattr_t attr;

    if (pthread_mutexattr_init (&attr))
    {
		RTMP_LogPrintf(" pthread_mutexattr_init() fail \n ");
   1ab74:	e59f0018 	ldr	r0, [pc, #24]	; 1ab94 <rtmp_mutex_init+0x90>
		return 0;
   1ab78:	e3a05000 	mov	r5, #0
{
    pthread_mutexattr_t attr;

    if (pthread_mutexattr_init (&attr))
    {
		RTMP_LogPrintf(" pthread_mutexattr_init() fail \n ");
   1ab7c:	e08f0000 	add	r0, pc, r0
   1ab80:	ebffec37 	bl	15c64 <RTMP_LogPrintf>
	}
        
    pthread_mutexattr_destroy( &attr );
	return 1;
	
}
   1ab84:	e1a00005 	mov	r0, r5
   1ab88:	e28dd008 	add	sp, sp, #8
   1ab8c:	e8bd8070 	pop	{r4, r5, r6, pc}
   1ab90:	00006b64 	.word	0x00006b64
   1ab94:	00006b24 	.word	0x00006b24

0001ab98 <rtmp_mutex_destroy>:

//销毁互斥锁
int rtmp_mutex_destroy (pthread_mutex_t *p_mutex)
{
   1ab98:	e92d4008 	push	{r3, lr}
    int val = pthread_mutex_destroy( p_mutex );
   1ab9c:	ebffaab0 	bl	5664 <pthread_mutex_destroy@plt>
    if(val)
   1aba0:	e3500000 	cmp	r0, #0
   1aba4:	1a000001 	bne	1abb0 <rtmp_mutex_destroy+0x18>
    {
		RTMP_LogPrintf(" rtmp_mutex_destroy() fail \n");
		return 0;
	}

	return 1;
   1aba8:	e3a00001 	mov	r0, #1
}
   1abac:	e8bd8008 	pop	{r3, pc}
int rtmp_mutex_destroy (pthread_mutex_t *p_mutex)
{
    int val = pthread_mutex_destroy( p_mutex );
    if(val)
    {
		RTMP_LogPrintf(" rtmp_mutex_destroy() fail \n");
   1abb0:	e59f000c 	ldr	r0, [pc, #12]	; 1abc4 <rtmp_mutex_destroy+0x2c>
   1abb4:	e08f0000 	add	r0, pc, r0
   1abb8:	ebffec29 	bl	15c64 <RTMP_LogPrintf>
		return 0;
   1abbc:	e3a00000 	mov	r0, #0
   1abc0:	e8bd8008 	pop	{r3, pc}
   1abc4:	00006b30 	.word	0x00006b30

0001abc8 <connectRtmp>:
#endif


int connectRtmp(LIBRTMP *pLibrtmp)
{
    if(!pLibrtmp || !pLibrtmp->pConfig || !pLibrtmp->pConfig->pRTMP)
   1abc8:	e3500000 	cmp	r0, #0
LIBRTMP *pLibrtmp;
#endif


int connectRtmp(LIBRTMP *pLibrtmp)
{
   1abcc:	e92d40f0 	push	{r4, r5, r6, r7, lr}
   1abd0:	e24ddf7f 	sub	sp, sp, #508	; 0x1fc
    if(!pLibrtmp || !pLibrtmp->pConfig || !pLibrtmp->pConfig->pRTMP)
   1abd4:	0a000080 	beq	1addc <connectRtmp+0x214>
   1abd8:	e59051f4 	ldr	r5, [r0, #500]	; 0x1f4
   1abdc:	e3550000 	cmp	r5, #0
   1abe0:	0a000081 	beq	1adec <connectRtmp+0x224>
   1abe4:	e5956000 	ldr	r6, [r5]
   1abe8:	e3560000 	cmp	r6, #0
   1abec:	0a000059 	beq	1ad58 <connectRtmp+0x190>
    BufferConfig *pConfig = pLibrtmp->pConfig;
    char *sUrl = pLibrtmp->sUrl;
    
    if(pConfig->pRTMP)
    {
        RTMP_Log(RTMP_LOGINFO,"rtmp connect begin.....\n");
   1abf0:	e59f126c 	ldr	r1, [pc, #620]	; 1ae64 <connectRtmp+0x29c>
   1abf4:	e1a04000 	mov	r4, r0
   1abf8:	e08f1001 	add	r1, pc, r1
   1abfc:	e3a00003 	mov	r0, #3
        
        char rtmp_url[500] = {'\0'};
   1ac00:	e28d7004 	add	r7, sp, #4
    BufferConfig *pConfig = pLibrtmp->pConfig;
    char *sUrl = pLibrtmp->sUrl;
    
    if(pConfig->pRTMP)
    {
        RTMP_Log(RTMP_LOGINFO,"rtmp connect begin.....\n");
   1ac04:	ebffeb68 	bl	159ac <RTMP_Log>
        
        char rtmp_url[500] = {'\0'};
   1ac08:	e3a01000 	mov	r1, #0
   1ac0c:	e3a02f7d 	mov	r2, #500	; 0x1f4
   1ac10:	e1a00007 	mov	r0, r7
   1ac14:	ebffa92d 	bl	50d0 <memset@plt>
        RTMP_Init(pConfig->pRTMP);
   1ac18:	e5950000 	ldr	r0, [r5]
   1ac1c:	ebffb73a 	bl	890c <RTMP_Init>
        pConfig->pRTMP->m_os = 2;
		
        pLibrtmp->pConfig->pRTMP->interrupt_callback.callback=isInterrupted;
   1ac20:	e59411f4 	ldr	r1, [r4, #500]	; 0x1f4
    {
        RTMP_Log(RTMP_LOGINFO,"rtmp connect begin.....\n");
        
        char rtmp_url[500] = {'\0'};
        RTMP_Init(pConfig->pRTMP);
        pConfig->pRTMP->m_os = 2;
   1ac24:	e5956000 	ldr	r6, [r5]
		
        pLibrtmp->pConfig->pRTMP->interrupt_callback.callback=isInterrupted;
   1ac28:	e5913000 	ldr	r3, [r1]
    {
        RTMP_Log(RTMP_LOGINFO,"rtmp connect begin.....\n");
        
        char rtmp_url[500] = {'\0'};
        RTMP_Init(pConfig->pRTMP);
        pConfig->pRTMP->m_os = 2;
   1ac2c:	e2860901 	add	r0, r6, #16384	; 0x4000
		
        pLibrtmp->pConfig->pRTMP->interrupt_callback.callback=isInterrupted;
   1ac30:	e2833901 	add	r3, r3, #16384	; 0x4000
    {
        RTMP_Log(RTMP_LOGINFO,"rtmp connect begin.....\n");
        
        char rtmp_url[500] = {'\0'};
        RTMP_Init(pConfig->pRTMP);
        pConfig->pRTMP->m_os = 2;
   1ac34:	e3a0c002 	mov	ip, #2
		
        pLibrtmp->pConfig->pRTMP->interrupt_callback.callback=isInterrupted;
   1ac38:	e59f2228 	ldr	r2, [pc, #552]	; 1ae68 <connectRtmp+0x2a0>
    {
        RTMP_Log(RTMP_LOGINFO,"rtmp connect begin.....\n");
        
        char rtmp_url[500] = {'\0'};
        RTMP_Init(pConfig->pRTMP);
        pConfig->pRTMP->m_os = 2;
   1ac3c:	e580cb94 	str	ip, [r0, #2964]	; 0xb94
		
        pLibrtmp->pConfig->pRTMP->interrupt_callback.callback=isInterrupted;
        pLibrtmp->pConfig->pRTMP->interrupt_callback.opaque=pLibrtmp->pConfig;
   1ac40:	e5831204 	str	r1, [r3, #516]	; 0x204
		
        if (strstr(sUrl, "rtmp://gb.push.live.kankan.com") != NULL)
   1ac44:	e59f1220 	ldr	r1, [pc, #544]	; 1ae6c <connectRtmp+0x2a4>
        
        char rtmp_url[500] = {'\0'};
        RTMP_Init(pConfig->pRTMP);
        pConfig->pRTMP->m_os = 2;
		
        pLibrtmp->pConfig->pRTMP->interrupt_callback.callback=isInterrupted;
   1ac48:	e79f2002 	ldr	r2, [pc, r2]
        pLibrtmp->pConfig->pRTMP->interrupt_callback.opaque=pLibrtmp->pConfig;
		
        if (strstr(sUrl, "rtmp://gb.push.live.kankan.com") != NULL)
   1ac4c:	e1a00004 	mov	r0, r4
        
        char rtmp_url[500] = {'\0'};
        RTMP_Init(pConfig->pRTMP);
        pConfig->pRTMP->m_os = 2;
		
        pLibrtmp->pConfig->pRTMP->interrupt_callback.callback=isInterrupted;
   1ac50:	e5832200 	str	r2, [r3, #512]	; 0x200
        pLibrtmp->pConfig->pRTMP->interrupt_callback.opaque=pLibrtmp->pConfig;
		
        if (strstr(sUrl, "rtmp://gb.push.live.kankan.com") != NULL)
   1ac54:	e08f1001 	add	r1, pc, r1
   1ac58:	ebffa946 	bl	5178 <strstr@plt>
   1ac5c:	e3500000 	cmp	r0, #0
   1ac60:	0a000063 	beq	1adf4 <connectRtmp+0x22c>
        {
            memcpy(&pConfig->pRTMP->access,pLibrtmp->pAccess,sizeof(RTMPAccess));
   1ac64:	e2860c42 	add	r0, r6, #16896	; 0x4200
   1ac68:	e5941200 	ldr	r1, [r4, #512]	; 0x200
   1ac6c:	e59f21fc 	ldr	r2, [pc, #508]	; 1ae70 <connectRtmp+0x2a8>
   1ac70:	e2800008 	add	r0, r0, #8
   1ac74:	ebffa954 	bl	51cc <memcpy@plt>
            
            if(!RTMP_Request_Access(pConfig->pRTMP,sUrl,rtmp_url))
   1ac78:	e5950000 	ldr	r0, [r5]
   1ac7c:	e1a01004 	mov	r1, r4
   1ac80:	e1a02007 	mov	r2, r7
   1ac84:	ebffc015 	bl	ace0 <RTMP_Request_Access>
   1ac88:	e2506000 	subs	r6, r0, #0
   1ac8c:	0a000034 	beq	1ad64 <connectRtmp+0x19c>
                pConfig->bKeyFramePutted = FALSE;
                pthread_mutex_unlock(&pConfig->lock);
                return FALSE;
            }
            
            memcpy(pLibrtmp->pAccess,&pConfig->pRTMP->access,sizeof(RTMPAccess));
   1ac90:	e5951000 	ldr	r1, [r5]
   1ac94:	e5940200 	ldr	r0, [r4, #512]	; 0x200
   1ac98:	e2811c42 	add	r1, r1, #16896	; 0x4200
   1ac9c:	e2811008 	add	r1, r1, #8
   1aca0:	e59f21c8 	ldr	r2, [pc, #456]	; 1ae70 <connectRtmp+0x2a8>
   1aca4:	ebffa948 	bl	51cc <memcpy@plt>
        }
        else
        {
            memcpy(rtmp_url,sUrl,strlen(sUrl));//add for no key
        }
        memcpy(pLibrtmp->pAccess->src_url,sUrl,strlen(sUrl));
   1aca8:	e1a00004 	mov	r0, r4
   1acac:	ebffa913 	bl	5100 <strlen@plt>
   1acb0:	e5943200 	ldr	r3, [r4, #512]	; 0x200
   1acb4:	e1a01004 	mov	r1, r4
   1acb8:	e1a02000 	mov	r2, r0
   1acbc:	e2830e79 	add	r0, r3, #1936	; 0x790
   1acc0:	e2800008 	add	r0, r0, #8
   1acc4:	ebffa940 	bl	51cc <memcpy@plt>
        
        RTMP_Log(RTMP_LOGINFO,"real rtmp url:%s \n",rtmp_url);
   1acc8:	e59f11a4 	ldr	r1, [pc, #420]	; 1ae74 <connectRtmp+0x2ac>
   1accc:	e1a02007 	mov	r2, r7
   1acd0:	e3a00003 	mov	r0, #3
   1acd4:	e08f1001 	add	r1, pc, r1
   1acd8:	ebffeb33 	bl	159ac <RTMP_Log>
        
        int ret = RTMP_Connect_kk(pConfig->pRTMP,rtmp_url);
   1acdc:	e1a01007 	mov	r1, r7
   1ace0:	e5950000 	ldr	r0, [r5]
   1ace4:	ebffdeba 	bl	127d4 <RTMP_Connect_kk>
        
        printf("rtmp connect end..... %d \n",pConfig->pRTMP->m_sb.sb_socket);
   1ace8:	e5953000 	ldr	r3, [r5]
   1acec:	e59310e0 	ldr	r1, [r3, #224]	; 0xe0
        }
        memcpy(pLibrtmp->pAccess->src_url,sUrl,strlen(sUrl));
        
        RTMP_Log(RTMP_LOGINFO,"real rtmp url:%s \n",rtmp_url);
        
        int ret = RTMP_Connect_kk(pConfig->pRTMP,rtmp_url);
   1acf0:	e1a06000 	mov	r6, r0
        
        printf("rtmp connect end..... %d \n",pConfig->pRTMP->m_sb.sb_socket);
   1acf4:	e59f017c 	ldr	r0, [pc, #380]	; 1ae78 <connectRtmp+0x2b0>
   1acf8:	e08f0000 	add	r0, pc, r0
   1acfc:	ebffa980 	bl	5304 <printf@plt>
        if(ret == FALSE)
   1ad00:	e3560000 	cmp	r6, #0
   1ad04:	0a000027 	beq	1ada8 <connectRtmp+0x1e0>
            pLibrtmp->RTMPSetStatus(pConfig->state);//yiqin todo
            pthread_mutex_unlock(&pConfig->lock);
        }
        else
        {
            pthread_mutex_lock(&pConfig->lock);
   1ad08:	e2856024 	add	r6, r5, #36	; 0x24
   1ad0c:	e1a00006 	mov	r0, r6
   1ad10:	ebffa951 	bl	525c <pthread_mutex_lock@plt>
            pConfig->state = connect_success;
   1ad14:	e3a00001 	mov	r0, #1
   1ad18:	e585000c 	str	r0, [r5, #12]
            pLibrtmp->RTMPSetStatus(pConfig->state);//todo yiqin
   1ad1c:	e5943208 	ldr	r3, [r4, #520]	; 0x208
   1ad20:	e12fff33 	blx	r3
            pConfig->bKeyFramePutted = FALSE;
            RTMP_Log(RTMP_LOGINFO," change state to : connect success \n");
   1ad24:	e59f1150 	ldr	r1, [pc, #336]	; 1ae7c <connectRtmp+0x2b4>
        else
        {
            pthread_mutex_lock(&pConfig->lock);
            pConfig->state = connect_success;
            pLibrtmp->RTMPSetStatus(pConfig->state);//todo yiqin
            pConfig->bKeyFramePutted = FALSE;
   1ad28:	e3a03000 	mov	r3, #0
   1ad2c:	e5853038 	str	r3, [r5, #56]	; 0x38
            RTMP_Log(RTMP_LOGINFO," change state to : connect success \n");
   1ad30:	e08f1001 	add	r1, pc, r1
   1ad34:	e3a00003 	mov	r0, #3
   1ad38:	ebffeb1b 	bl	159ac <RTMP_Log>
            pthread_mutex_unlock(&pConfig->lock);
   1ad3c:	e1a00006 	mov	r0, r6
   1ad40:	ebffa948 	bl	5268 <pthread_mutex_unlock@plt>
            ret = RTMP_SendChunkSize(pConfig->pRTMP);
   1ad44:	e5950000 	ldr	r0, [r5]
   1ad48:	ebffc838 	bl	ce30 <RTMP_SendChunkSize>
            if(ret == FALSE)
   1ad4c:	e3500000 	cmp	r0, #0
   1ad50:	1a00002e 	bne	1ae10 <connectRtmp+0x248>
LIBRTMP *pLibrtmp;
#endif


int connectRtmp(LIBRTMP *pLibrtmp)
{
   1ad54:	e3a06000 	mov	r6, #0
        
        return ret;
    }
    else
        return FALSE;
}
   1ad58:	e1a00006 	mov	r0, r6
   1ad5c:	e28ddf7f 	add	sp, sp, #508	; 0x1fc
   1ad60:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
        {
            memcpy(&pConfig->pRTMP->access,pLibrtmp->pAccess,sizeof(RTMPAccess));
            
            if(!RTMP_Request_Access(pConfig->pRTMP,sUrl,rtmp_url))
            {
                printf("request push access fail ,%s \n",rtmp_url);
   1ad64:	e59f0114 	ldr	r0, [pc, #276]	; 1ae80 <connectRtmp+0x2b8>
   1ad68:	e1a01007 	mov	r1, r7
   1ad6c:	e08f0000 	add	r0, pc, r0
                
                pthread_mutex_lock(&pConfig->lock);
   1ad70:	e2857024 	add	r7, r5, #36	; 0x24
        {
            memcpy(&pConfig->pRTMP->access,pLibrtmp->pAccess,sizeof(RTMPAccess));
            
            if(!RTMP_Request_Access(pConfig->pRTMP,sUrl,rtmp_url))
            {
                printf("request push access fail ,%s \n",rtmp_url);
   1ad74:	ebffa962 	bl	5304 <printf@plt>
                
                pthread_mutex_lock(&pConfig->lock);
   1ad78:	e1a00007 	mov	r0, r7
   1ad7c:	ebffa936 	bl	525c <pthread_mutex_lock@plt>
                pConfig->state = connect_fail;
   1ad80:	e3e00000 	mvn	r0, #0
                pLibrtmp->RTMPSetStatus(pConfig->state);
   1ad84:	e5943208 	ldr	r3, [r4, #520]	; 0x208
            if(!RTMP_Request_Access(pConfig->pRTMP,sUrl,rtmp_url))
            {
                printf("request push access fail ,%s \n",rtmp_url);
                
                pthread_mutex_lock(&pConfig->lock);
                pConfig->state = connect_fail;
   1ad88:	e585000c 	str	r0, [r5, #12]
                pLibrtmp->RTMPSetStatus(pConfig->state);
   1ad8c:	e12fff33 	blx	r3
                pConfig->bKeyFramePutted = FALSE;
                pthread_mutex_unlock(&pConfig->lock);
   1ad90:	e1a00007 	mov	r0, r7
                printf("request push access fail ,%s \n",rtmp_url);
                
                pthread_mutex_lock(&pConfig->lock);
                pConfig->state = connect_fail;
                pLibrtmp->RTMPSetStatus(pConfig->state);
                pConfig->bKeyFramePutted = FALSE;
   1ad94:	e5856038 	str	r6, [r5, #56]	; 0x38
                pthread_mutex_unlock(&pConfig->lock);
   1ad98:	ebffa932 	bl	5268 <pthread_mutex_unlock@plt>
        
        return ret;
    }
    else
        return FALSE;
}
   1ad9c:	e1a00006 	mov	r0, r6
   1ada0:	e28ddf7f 	add	sp, sp, #508	; 0x1fc
   1ada4:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
        int ret = RTMP_Connect_kk(pConfig->pRTMP,rtmp_url);
        
        printf("rtmp connect end..... %d \n",pConfig->pRTMP->m_sb.sb_socket);
        if(ret == FALSE)
        {
            pthread_mutex_lock(&pConfig->lock);
   1ada8:	e2857024 	add	r7, r5, #36	; 0x24
   1adac:	e1a00007 	mov	r0, r7
   1adb0:	ebffa929 	bl	525c <pthread_mutex_lock@plt>
            pConfig->state = connect_fail;
   1adb4:	e3e00000 	mvn	r0, #0
            pConfig->bKeyFramePutted = FALSE;
            pLibrtmp->RTMPSetStatus(pConfig->state);//yiqin todo
   1adb8:	e5943208 	ldr	r3, [r4, #520]	; 0x208
        printf("rtmp connect end..... %d \n",pConfig->pRTMP->m_sb.sb_socket);
        if(ret == FALSE)
        {
            pthread_mutex_lock(&pConfig->lock);
            pConfig->state = connect_fail;
            pConfig->bKeyFramePutted = FALSE;
   1adbc:	e5856038 	str	r6, [r5, #56]	; 0x38
        
        printf("rtmp connect end..... %d \n",pConfig->pRTMP->m_sb.sb_socket);
        if(ret == FALSE)
        {
            pthread_mutex_lock(&pConfig->lock);
            pConfig->state = connect_fail;
   1adc0:	e585000c 	str	r0, [r5, #12]
            pConfig->bKeyFramePutted = FALSE;
            pLibrtmp->RTMPSetStatus(pConfig->state);//yiqin todo
   1adc4:	e12fff33 	blx	r3
            pthread_mutex_unlock(&pConfig->lock);
   1adc8:	e1a00007 	mov	r0, r7
   1adcc:	ebffa925 	bl	5268 <pthread_mutex_unlock@plt>
        
        return ret;
    }
    else
        return FALSE;
}
   1add0:	e1a00006 	mov	r0, r6
   1add4:	e28ddf7f 	add	sp, sp, #508	; 0x1fc
   1add8:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}


int connectRtmp(LIBRTMP *pLibrtmp)
{
    if(!pLibrtmp || !pLibrtmp->pConfig || !pLibrtmp->pConfig->pRTMP)
        return FALSE;
   1addc:	e1a06000 	mov	r6, r0
        
        return ret;
    }
    else
        return FALSE;
}
   1ade0:	e1a00006 	mov	r0, r6
   1ade4:	e28ddf7f 	add	sp, sp, #508	; 0x1fc
   1ade8:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}


int connectRtmp(LIBRTMP *pLibrtmp)
{
    if(!pLibrtmp || !pLibrtmp->pConfig || !pLibrtmp->pConfig->pRTMP)
        return FALSE;
   1adec:	e1a06005 	mov	r6, r5
   1adf0:	eaffffd8 	b	1ad58 <connectRtmp+0x190>
            
            memcpy(pLibrtmp->pAccess,&pConfig->pRTMP->access,sizeof(RTMPAccess));
        }
        else
        {
            memcpy(rtmp_url,sUrl,strlen(sUrl));//add for no key
   1adf4:	e1a00004 	mov	r0, r4
   1adf8:	ebffa8c0 	bl	5100 <strlen@plt>
   1adfc:	e1a01004 	mov	r1, r4
   1ae00:	e1a02000 	mov	r2, r0
   1ae04:	e1a00007 	mov	r0, r7
   1ae08:	ebffa8ef 	bl	51cc <memcpy@plt>
   1ae0c:	eaffffa5 	b	1aca8 <connectRtmp+0xe0>
            pthread_mutex_unlock(&pConfig->lock);
            ret = RTMP_SendChunkSize(pConfig->pRTMP);
            if(ret == FALSE)
                return ret;
            
            ret=SendMetadataPacket(pConfig->pRTMP,pLibrtmp->pMetaData);
   1ae10:	e59411f8 	ldr	r1, [r4, #504]	; 0x1f8
   1ae14:	e5950000 	ldr	r0, [r5]
   1ae18:	ebfffb91 	bl	19c64 <SendMetadataPacket>
            if(ret == FALSE)
   1ae1c:	e2501000 	subs	r1, r0, #0
   1ae20:	0affffcb 	beq	1ad54 <connectRtmp+0x18c>
                return ret;
            
            printf("send metadata :%d \n",ret);
   1ae24:	e59f0058 	ldr	r0, [pc, #88]	; 1ae84 <connectRtmp+0x2bc>
   1ae28:	e08f0000 	add	r0, pc, r0
   1ae2c:	ebffa934 	bl	5304 <printf@plt>
           
            ret = RTMP_AAC_SequenceHeader(pConfig->pRTMP,pLibrtmp->pAacConfig,pConfig->pAudioBuffer);
   1ae30:	e59411fc 	ldr	r1, [r4, #508]	; 0x1fc
   1ae34:	e5950000 	ldr	r0, [r5]
   1ae38:	e5952008 	ldr	r2, [r5, #8]
   1ae3c:	ebfff95d 	bl	193b8 <RTMP_AAC_SequenceHeader>
            if(ret == FALSE)
   1ae40:	e2506000 	subs	r6, r0, #0
   1ae44:	0affffc3 	beq	1ad58 <connectRtmp+0x190>
                return ret;
            
            printf("==== put aac sequence header .ret:%d",ret);
   1ae48:	e59f0038 	ldr	r0, [pc, #56]	; 1ae88 <connectRtmp+0x2c0>
   1ae4c:	e1a01006 	mov	r1, r6
   1ae50:	e08f0000 	add	r0, pc, r0
   1ae54:	ebffa92a 	bl	5304 <printf@plt>
            
            SetBufferStartTime(pConfig);
   1ae58:	e1a00005 	mov	r0, r5
   1ae5c:	ebfffef9 	bl	1aa48 <SetBufferStartTime>
   1ae60:	eaffffbc 	b	1ad58 <connectRtmp+0x190>
   1ae64:	00006b0c 	.word	0x00006b0c
   1ae68:	00009168 	.word	0x00009168
   1ae6c:	000058e8 	.word	0x000058e8
   1ae70:	0000098c 	.word	0x0000098c
   1ae74:	00006a6c 	.word	0x00006a6c
   1ae78:	00006a5c 	.word	0x00006a5c
   1ae7c:	00006a40 	.word	0x00006a40
   1ae80:	000069b4 	.word	0x000069b4
   1ae84:	00006970 	.word	0x00006970
   1ae88:	0000695c 	.word	0x0000695c

0001ae8c <Librtmp_FreeBufferConfig>:
        return FALSE;
}

void Librtmp_FreeBufferConfig(LIBRTMP *pLibrtmp)
{
    if(!pLibrtmp)
   1ae8c:	e3500000 	cmp	r0, #0
   1ae90:	012fff1e 	bxeq	lr
    else
        return FALSE;
}

void Librtmp_FreeBufferConfig(LIBRTMP *pLibrtmp)
{
   1ae94:	e92d4010 	push	{r4, lr}
   1ae98:	e1a04000 	mov	r4, r0
    if(!pLibrtmp)
        return;
    
    FreeBufferConfig(pLibrtmp->pConfig);
   1ae9c:	e59001f4 	ldr	r0, [r0, #500]	; 0x1f4
   1aea0:	ebfffebd 	bl	1a99c <FreeBufferConfig>
    free(pLibrtmp->pMetaData);
   1aea4:	e59401f8 	ldr	r0, [r4, #504]	; 0x1f8
   1aea8:	ebffa855 	bl	5004 <free@plt>
    free(pLibrtmp->pAacConfig);
   1aeac:	e59401fc 	ldr	r0, [r4, #508]	; 0x1fc
   1aeb0:	ebffa853 	bl	5004 <free@plt>
    free(pLibrtmp->pAccess);
   1aeb4:	e5940200 	ldr	r0, [r4, #512]	; 0x200
   1aeb8:	ebffa851 	bl	5004 <free@plt>
    pLibrtmp->pConfig=NULL;
   1aebc:	e3a03000 	mov	r3, #0
   1aec0:	e58431f4 	str	r3, [r4, #500]	; 0x1f4
    pLibrtmp->pMetaData=NULL;
   1aec4:	e58431f8 	str	r3, [r4, #504]	; 0x1f8
    pLibrtmp->pAacConfig=NULL;
   1aec8:	e58431fc 	str	r3, [r4, #508]	; 0x1fc
    pLibrtmp->pAccess=NULL;
   1aecc:	e5843200 	str	r3, [r4, #512]	; 0x200
   1aed0:	e8bd8010 	pop	{r4, pc}

0001aed4 <StartSend>:
}

int StartSend(LIBRTMP *pLibrtmp)
{
    if(!pLibrtmp)
   1aed4:	e3500000 	cmp	r0, #0
   1aed8:	0a00000a 	beq	1af08 <StartSend+0x34>
    pLibrtmp->pAacConfig=NULL;
    pLibrtmp->pAccess=NULL;
}

int StartSend(LIBRTMP *pLibrtmp)
{
   1aedc:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
   1aee0:	e1a04000 	mov	r4, r0
    if(!pLibrtmp)
        return FALSE;
    
    printf("===RTMP :JNI  start send BEGIN====");
   1aee4:	e59f00d0 	ldr	r0, [pc, #208]	; 1afbc <StartSend+0xe8>
   1aee8:	e08f0000 	add	r0, pc, r0
   1aeec:	ebffa904 	bl	5304 <printf@plt>
    BufferConfig *pConfig = pLibrtmp->pConfig;
   1aef0:	e59461f4 	ldr	r6, [r4, #500]	; 0x1f4
    int ret = TRUE;
    if((pConfig->state) == connect_success)
   1aef4:	e596300c 	ldr	r3, [r6, #12]
   1aef8:	e3530001 	cmp	r3, #1
   1aefc:	0a000003 	beq	1af10 <StartSend+0x3c>
}

int StartSend(LIBRTMP *pLibrtmp)
{
    if(!pLibrtmp)
        return FALSE;
   1af00:	e3a00000 	mov	r0, #0
   1af04:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
   1af08:	e3a00000 	mov	r0, #0
        printf("==== RTMP:JNI START SEND END ,ret:%d",ret);
        return ret;
    }
    else
        return FALSE;
}
   1af0c:	e12fff1e 	bx	lr
    printf("===RTMP :JNI  start send BEGIN====");
    BufferConfig *pConfig = pLibrtmp->pConfig;
    int ret = TRUE;
    if((pConfig->state) == connect_success)
    {
        pthread_mutex_lock(&pConfig->lock);
   1af10:	e2867024 	add	r7, r6, #36	; 0x24
   1af14:	e1a00007 	mov	r0, r7
   1af18:	ebffa8cf 	bl	525c <pthread_mutex_lock@plt>
        pConfig->state = send_status;
   1af1c:	e3a00002 	mov	r0, #2
        pLibrtmp->RTMPSetStatus(pConfig->state);
   1af20:	e5943208 	ldr	r3, [r4, #520]	; 0x208
    BufferConfig *pConfig = pLibrtmp->pConfig;
    int ret = TRUE;
    if((pConfig->state) == connect_success)
    {
        pthread_mutex_lock(&pConfig->lock);
        pConfig->state = send_status;
   1af24:	e586000c 	str	r0, [r6, #12]
        pLibrtmp->RTMPSetStatus(pConfig->state);
   1af28:	e12fff33 	blx	r3
        RTMP_Log(RTMP_LOGINFO," change state to : send data \n");
   1af2c:	e59f108c 	ldr	r1, [pc, #140]	; 1afc0 <StartSend+0xec>
   1af30:	e3a00003 	mov	r0, #3
   1af34:	e08f1001 	add	r1, pc, r1
   1af38:	ebffea9b 	bl	159ac <RTMP_Log>
       
        pthread_mutex_unlock(&pConfig->lock);
   1af3c:	e1a00007 	mov	r0, r7
   1af40:	ebffa8c8 	bl	5268 <pthread_mutex_unlock@plt>
        
        ret = Buffer_Control(pLibrtmp->pMetaData, pConfig,pLibrtmp->pAccess,pLibrtmp->RTMPSetStatus);
   1af44:	e5943208 	ldr	r3, [r4, #520]	; 0x208
   1af48:	e1a01006 	mov	r1, r6
   1af4c:	e5942200 	ldr	r2, [r4, #512]	; 0x200
   1af50:	e59401f8 	ldr	r0, [r4, #504]	; 0x1f8
   1af54:	ebfffbd9 	bl	19ec0 <Buffer_Control>
   1af58:	e1a05000 	mov	r5, r0
        
        pthread_mutex_lock(&pConfig->lock);
   1af5c:	e1a00007 	mov	r0, r7
   1af60:	ebffa8bd 	bl	525c <pthread_mutex_lock@plt>
        if(pConfig->state != stop_send)
   1af64:	e596300c 	ldr	r3, [r6, #12]
   1af68:	e3530004 	cmp	r3, #4
   1af6c:	0a000008 	beq	1af94 <StartSend+0xc0>
        {
            pLibrtmp->RTMPSetStatus(stop_send_abnormal);
   1af70:	e5943208 	ldr	r3, [r4, #520]	; 0x208
   1af74:	e3a00005 	mov	r0, #5
   1af78:	e12fff33 	blx	r3
            pConfig->bKeyFramePutted = FALSE;
            RTMP_Log(RTMP_LOGINFO," change state to : reconnect fail \n");
   1af7c:	e59f1040 	ldr	r1, [pc, #64]	; 1afc4 <StartSend+0xf0>
        
        pthread_mutex_lock(&pConfig->lock);
        if(pConfig->state != stop_send)
        {
            pLibrtmp->RTMPSetStatus(stop_send_abnormal);
            pConfig->bKeyFramePutted = FALSE;
   1af80:	e3a03000 	mov	r3, #0
   1af84:	e5863038 	str	r3, [r6, #56]	; 0x38
            RTMP_Log(RTMP_LOGINFO," change state to : reconnect fail \n");
   1af88:	e3a00003 	mov	r0, #3
   1af8c:	e08f1001 	add	r1, pc, r1
   1af90:	ebffea85 	bl	159ac <RTMP_Log>
        }
        pConfig->state = disconnect_status;
   1af94:	e3a03003 	mov	r3, #3
   1af98:	e586300c 	str	r3, [r6, #12]
        pthread_mutex_unlock(&pConfig->lock);
   1af9c:	e1a00007 	mov	r0, r7
   1afa0:	ebffa8b0 	bl	5268 <pthread_mutex_unlock@plt>
        printf("==== RTMP:JNI START SEND END ,ret:%d",ret);
   1afa4:	e59f001c 	ldr	r0, [pc, #28]	; 1afc8 <StartSend+0xf4>
   1afa8:	e1a01005 	mov	r1, r5
   1afac:	e08f0000 	add	r0, pc, r0
   1afb0:	ebffa8d3 	bl	5304 <printf@plt>
        return ret;
   1afb4:	e1a00005 	mov	r0, r5
    }
    else
        return FALSE;
}
   1afb8:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
   1afbc:	000068ec 	.word	0x000068ec
   1afc0:	000068c4 	.word	0x000068c4
   1afc4:	0000688c 	.word	0x0000688c
   1afc8:	00006890 	.word	0x00006890

0001afcc <start_send>:
    }
}


void *start_send(void *pLibrtmp)
{
   1afcc:	e92d4038 	push	{r3, r4, r5, lr}
    LIBRTMP *librtmp = (LIBRTMP *)pLibrtmp;
    
    if(!librtmp || !librtmp->pConfig)
   1afd0:	e2504000 	subs	r4, r0, #0
   1afd4:	0a000022 	beq	1b064 <start_send+0x98>
   1afd8:	e59431f4 	ldr	r3, [r4, #500]	; 0x1f4
   1afdc:	e3530000 	cmp	r3, #0
   1afe0:	0a00001f 	beq	1b064 <start_send+0x98>
        return NULL;
    
    int ret = 0;
    ret = connectRtmp(librtmp);
   1afe4:	ebfffef7 	bl	1abc8 <connectRtmp>
    if(ret == 1)
   1afe8:	e3500001 	cmp	r0, #1
   1afec:	0a00001e 	beq	1b06c <start_send+0xa0>
        StartSend(librtmp);
    //close socket
    if(librtmp->pConfig->pRTMP)
   1aff0:	e59431f4 	ldr	r3, [r4, #500]	; 0x1f4
   1aff4:	e5930000 	ldr	r0, [r3]
   1aff8:	e3500000 	cmp	r0, #0
   1affc:	0a000001 	beq	1b008 <start_send+0x3c>
    {
        RTMP_Close_kk(librtmp->pConfig->pRTMP);
   1b000:	ebffde30 	bl	128c8 <RTMP_Close_kk>
   1b004:	e59431f4 	ldr	r3, [r4, #500]	; 0x1f4
        
    }
    pthread_mutex_lock(&librtmp->pConfig->lock);
   1b008:	e2830024 	add	r0, r3, #36	; 0x24
   1b00c:	ebffa892 	bl	525c <pthread_mutex_lock@plt>
    
    librtmp->pConfig->state = disconnect_status;
   1b010:	e59401f4 	ldr	r0, [r4, #500]	; 0x1f4
   1b014:	e3a05003 	mov	r5, #3
   1b018:	e580500c 	str	r5, [r0, #12]
    
    pthread_mutex_unlock(&librtmp->pConfig->lock);
   1b01c:	e2800024 	add	r0, r0, #36	; 0x24
   1b020:	ebffa890 	bl	5268 <pthread_mutex_unlock@plt>
    
    //wait for speed thread stop,when state == 3 speed thread stop
    pthread_join(librtmp->speed_thread,NULL);
   1b024:	e3a01000 	mov	r1, #0
   1b028:	e5940214 	ldr	r0, [r4, #532]	; 0x214
   1b02c:	ebffa98f 	bl	5670 <pthread_join@plt>
    
    Librtmp_FreeBufferConfig(pLibrtmp);
   1b030:	e1a00004 	mov	r0, r4
   1b034:	ebffff94 	bl	1ae8c <Librtmp_FreeBufferConfig>
    
    librtmp->RTMPSetStatus(disconnect_status);
   1b038:	e5943208 	ldr	r3, [r4, #520]	; 0x208
   1b03c:	e1a00005 	mov	r0, r5
   1b040:	e12fff33 	blx	r3
    
    RTMP_Log(RTMP_LOGINFO," change state to : disconnect \n");
   1b044:	e59f102c 	ldr	r1, [pc, #44]	; 1b078 <start_send+0xac>
   1b048:	e1a00005 	mov	r0, r5
   1b04c:	e08f1001 	add	r1, pc, r1
   1b050:	ebffea55 	bl	159ac <RTMP_Log>
    
    if(librtmp && librtmp->relievebind)
   1b054:	e594320c 	ldr	r3, [r4, #524]	; 0x20c
   1b058:	e3530000 	cmp	r3, #0
   1b05c:	0a000000 	beq	1b064 <start_send+0x98>
        librtmp->relievebind();
   1b060:	e12fff33 	blx	r3
    
    return NULL;
}
   1b064:	e3a00000 	mov	r0, #0
   1b068:	e8bd8038 	pop	{r3, r4, r5, pc}
        return NULL;
    
    int ret = 0;
    ret = connectRtmp(librtmp);
    if(ret == 1)
        StartSend(librtmp);
   1b06c:	e1a00004 	mov	r0, r4
   1b070:	ebffff97 	bl	1aed4 <StartSend>
   1b074:	eaffffdd 	b	1aff0 <start_send+0x24>
   1b078:	00006818 	.word	0x00006818

0001b07c <StopSend>:
}


void StopSend(LIBRTMP *pLibrtmp)
{
    if(!pLibrtmp || !pLibrtmp->pConfig)
   1b07c:	e3500000 	cmp	r0, #0
   1b080:	012fff1e 	bxeq	lr
        return FALSE;
}


void StopSend(LIBRTMP *pLibrtmp)
{
   1b084:	e92d4038 	push	{r3, r4, r5, lr}
    if(!pLibrtmp || !pLibrtmp->pConfig)
   1b088:	e59041f4 	ldr	r4, [r0, #500]	; 0x1f4
   1b08c:	e3540000 	cmp	r4, #0
   1b090:	08bd8038 	popeq	{r3, r4, r5, pc}
        return;
    
    BufferConfig *pConfig = pLibrtmp->pConfig;
    if(pConfig)
    {
        pthread_mutex_lock(&pConfig->lock);
   1b094:	e2845024 	add	r5, r4, #36	; 0x24
   1b098:	e1a00005 	mov	r0, r5
   1b09c:	ebffa86e 	bl	525c <pthread_mutex_lock@plt>
        if(pConfig->state == send_status)
   1b0a0:	e594300c 	ldr	r3, [r4, #12]
            pConfig->state = stop_send;
        else
            pConfig->state = disconnect_status;
        
        RTMP_Log(RTMP_LOGINFO," push : change state to : stop \n");
   1b0a4:	e3a00003 	mov	r0, #3
    {
        pthread_mutex_lock(&pConfig->lock);
        if(pConfig->state == send_status)
            pConfig->state = stop_send;
        else
            pConfig->state = disconnect_status;
   1b0a8:	e3530002 	cmp	r3, #2
        
        RTMP_Log(RTMP_LOGINFO," push : change state to : stop \n");
   1b0ac:	e59f102c 	ldr	r1, [pc, #44]	; 1b0e0 <StopSend+0x64>
    {
        pthread_mutex_lock(&pConfig->lock);
        if(pConfig->state == send_status)
            pConfig->state = stop_send;
        else
            pConfig->state = disconnect_status;
   1b0b0:	11a03000 	movne	r3, r0
   1b0b4:	03a03004 	moveq	r3, #4
   1b0b8:	e584300c 	str	r3, [r4, #12]
        
        RTMP_Log(RTMP_LOGINFO," push : change state to : stop \n");
   1b0bc:	e08f1001 	add	r1, pc, r1
   1b0c0:	ebffea39 	bl	159ac <RTMP_Log>
        pthread_mutex_unlock(&pConfig->lock);
   1b0c4:	e1a00005 	mov	r0, r5
   1b0c8:	ebffa866 	bl	5268 <pthread_mutex_unlock@plt>
    
        printf("rtmp stop send,state:%d \n",pConfig->state);
   1b0cc:	e59f0010 	ldr	r0, [pc, #16]	; 1b0e4 <StopSend+0x68>
   1b0d0:	e594100c 	ldr	r1, [r4, #12]
   1b0d4:	e08f0000 	add	r0, pc, r0
    }
}
   1b0d8:	e8bd4038 	pop	{r3, r4, r5, lr}
            pConfig->state = disconnect_status;
        
        RTMP_Log(RTMP_LOGINFO," push : change state to : stop \n");
        pthread_mutex_unlock(&pConfig->lock);
    
        printf("rtmp stop send,state:%d \n",pConfig->state);
   1b0dc:	eaffa888 	b	5304 <printf@plt>
   1b0e0:	000067c8 	.word	0x000067c8
   1b0e4:	000067d4 	.word	0x000067d4

0001b0e8 <change_bitrate>:
#define PACKET_LOSS_MIN 0
#define PACKET_LOSS_MAX 30
// calculate drop/send
int change_bitrate(int drop_data,int send_data)
{
    if((send_data+drop_data) == 0)
   1b0e8:	e0911000 	adds	r1, r1, r0
   1b0ec:	1a000001 	bne	1b0f8 <change_bitrate+0x10>
        return 1;
    else if(packet_loss >= PACKET_LOSS_MAX )
        return -1;
    else
        return 0;
}
   1b0f0:	e1a00001 	mov	r0, r1
   1b0f4:	e12fff1e 	bx	lr
}
#define PACKET_LOSS_MIN 0
#define PACKET_LOSS_MAX 30
// calculate drop/send
int change_bitrate(int drop_data,int send_data)
{
   1b0f8:	e92d4038 	push	{r3, r4, r5, lr}
    if((send_data+drop_data) == 0)
        return 0;
    float packet_loss=(float)(drop_data*100/(send_data+drop_data));
   1b0fc:	e3a03064 	mov	r3, #100	; 0x64
   1b100:	e0000093 	mul	r0, r3, r0
   1b104:	eb00023a 	bl	1b9f4 <__aeabi_idiv>
   1b108:	eb00054d 	bl	1c644 <__aeabi_i2f>
    
    RTMP_Log(RTMP_LOGINFO,"push : drop/send+drop %f \n",packet_loss);
   1b10c:	e59f4050 	ldr	r4, [pc, #80]	; 1b164 <change_bitrate+0x7c>
   1b110:	e08f4004 	add	r4, pc, r4
// calculate drop/send
int change_bitrate(int drop_data,int send_data)
{
    if((send_data+drop_data) == 0)
        return 0;
    float packet_loss=(float)(drop_data*100/(send_data+drop_data));
   1b114:	e1a05000 	mov	r5, r0
    
    RTMP_Log(RTMP_LOGINFO,"push : drop/send+drop %f \n",packet_loss);
   1b118:	eb000335 	bl	1bdf4 <__aeabi_f2d>
   1b11c:	e1a02000 	mov	r2, r0
   1b120:	e1a03001 	mov	r3, r1
   1b124:	e3a00003 	mov	r0, #3
   1b128:	e1a01004 	mov	r1, r4
   1b12c:	ebffea1e 	bl	159ac <RTMP_Log>
    
    if(packet_loss <= PACKET_LOSS_MIN)
   1b130:	e3a01000 	mov	r1, #0
   1b134:	e1a00005 	mov	r0, r5
   1b138:	eb00059c 	bl	1c7b0 <__aeabi_fcmple>
   1b13c:	e3500000 	cmp	r0, #0
        return 1;
   1b140:	13a01001 	movne	r1, #1
        return 0;
    float packet_loss=(float)(drop_data*100/(send_data+drop_data));
    
    RTMP_Log(RTMP_LOGINFO,"push : drop/send+drop %f \n",packet_loss);
    
    if(packet_loss <= PACKET_LOSS_MIN)
   1b144:	1a000004 	bne	1b15c <change_bitrate+0x74>
        return 1;
    else if(packet_loss >= PACKET_LOSS_MAX )
   1b148:	e59f1018 	ldr	r1, [pc, #24]	; 1b168 <change_bitrate+0x80>
   1b14c:	e1a00005 	mov	r0, r5
   1b150:	eb00059b 	bl	1c7c4 <__aeabi_fcmpge>
   1b154:	e2901000 	adds	r1, r0, #0
   1b158:	13e01000 	mvnne	r1, #0
        return -1;
    else
        return 0;
}
   1b15c:	e1a00001 	mov	r0, r1
   1b160:	e8bd8038 	pop	{r3, r4, r5, pc}
   1b164:	000067b4 	.word	0x000067b4
   1b168:	41f00000 	.word	0x41f00000

0001b16c <speed_calculate>:
#define TIME_INTERVAL 10

void *speed_calculate(void *pLibrtmp)
{
	LIBRTMP *librtmp=(LIBRTMP *)pLibrtmp;
	if(!librtmp || !librtmp->pConfig || !librtmp->pConfig->pRTMP)
   1b16c:	e3500000 	cmp	r0, #0
   1b170:	0a0000e8 	beq	1b518 <speed_calculate+0x3ac>
   1b174:	e59031f4 	ldr	r3, [r0, #500]	; 0x1f4
   1b178:	e3530000 	cmp	r3, #0
   1b17c:	0a0000e5 	beq	1b518 <speed_calculate+0x3ac>
        return 0;
}
#define TIME_INTERVAL 10

void *speed_calculate(void *pLibrtmp)
{
   1b180:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
	LIBRTMP *librtmp=(LIBRTMP *)pLibrtmp;
	if(!librtmp || !librtmp->pConfig || !librtmp->pConfig->pRTMP)
   1b184:	e5937000 	ldr	r7, [r3]
        return 0;
}
#define TIME_INTERVAL 10

void *speed_calculate(void *pLibrtmp)
{
   1b188:	e24dd034 	sub	sp, sp, #52	; 0x34
	LIBRTMP *librtmp=(LIBRTMP *)pLibrtmp;
	if(!librtmp || !librtmp->pConfig || !librtmp->pConfig->pRTMP)
   1b18c:	e3570000 	cmp	r7, #0
   1b190:	0a0000a5 	beq	1b42c <speed_calculate+0x2c0>
	int stable_drop_data_times = 0;
	int stable_min_bitrate_times = 0;
	int stable_max_bitrate_times = 0;
    int sleep_time = 0;
	
    RTMP_Log(RTMP_LOGINFO," speed thread begin\n");
   1b194:	e59f13a0 	ldr	r1, [pc, #928]	; 1b53c <speed_calculate+0x3d0>
   1b198:	e1a04000 	mov	r4, r0
   1b19c:	e08f1001 	add	r1, pc, r1
   1b1a0:	e3a00003 	mov	r0, #3
   1b1a4:	ebffea00 	bl	159ac <RTMP_Log>
        
        //RTMP_Log(RTMP_LOGINFO," push : [after]drop : %d  last drop:%d   stable_drop_data_times:%d \n",drop_data,last_drop_data,stable_drop_data_times);
        
        int iChangebitrate=change_bitrate(drop_data,send_data);
        
        RTMP_Log(RTMP_LOGINFO, "push: drop: %d  send:%d  iChangebitrate:%d", drop_data, send_data, iChangebitrate);
   1b1a8:	e59f2390 	ldr	r2, [pc, #912]	; 1b540 <speed_calculate+0x3d4>
	int pre_bitrate = -1;
	int new_bitrate = -1;
	int last_drop_data = -1;
	int stable_drop_data_times = 0;
	int stable_min_bitrate_times = 0;
	int stable_max_bitrate_times = 0;
   1b1ac:	e3a03000 	mov	r3, #0
        
        //RTMP_Log(RTMP_LOGINFO," push : [after]drop : %d  last drop:%d   stable_drop_data_times:%d \n",drop_data,last_drop_data,stable_drop_data_times);
        
        int iChangebitrate=change_bitrate(drop_data,send_data);
        
        RTMP_Log(RTMP_LOGINFO, "push: drop: %d  send:%d  iChangebitrate:%d", drop_data, send_data, iChangebitrate);
   1b1b0:	e08f2002 	add	r2, pc, r2
   1b1b4:	e58d2014 	str	r2, [sp, #20]
			
            if(stable_min_bitrate_times >= 6)
            {
                librtmp->RTMPSetStatus(network_poor);
                stable_min_bitrate_times = 0;
                RTMP_Log(RTMP_LOGINFO, "push: set network poor");
   1b1b8:	e59f2384 	ldr	r2, [pc, #900]	; 1b544 <speed_calculate+0x3d8>
        pthread_mutex_unlock(&librtmp->pConfig->lock);
        
        if(state_rtmp == disconnect_status)
            break;
        //send data
        pthread_mutex_lock(&pRtmp->lock_speed);
   1b1bc:	e2877c4b 	add	r7, r7, #19200	; 0x4b00
			
            if(stable_min_bitrate_times >= 6)
            {
                librtmp->RTMPSetStatus(network_poor);
                stable_min_bitrate_times = 0;
                RTMP_Log(RTMP_LOGINFO, "push: set network poor");
   1b1c0:	e08f2002 	add	r2, pc, r2
   1b1c4:	e58d2028 	str	r2, [sp, #40]	; 0x28
			
			if (stable_max_bitrate_times >= 12)
			{
				librtmp->RTMPSetStatus(network_good);
				stable_max_bitrate_times = 0;
				RTMP_Log(RTMP_LOGINFO, "push: set network good");
   1b1c8:	e59f2378 	ldr	r2, [pc, #888]	; 1b548 <speed_calculate+0x3dc>
	int drop_data = 0;
	int want_bitrate = 0;
	int time_interval = 0;
	int pre_bitrate = -1;
	int new_bitrate = -1;
	int last_drop_data = -1;
   1b1cc:	e3e05000 	mvn	r5, #0
			
			if (stable_max_bitrate_times >= 12)
			{
				librtmp->RTMPSetStatus(network_good);
				stable_max_bitrate_times = 0;
				RTMP_Log(RTMP_LOGINFO, "push: set network good");
   1b1d0:	e08f2002 	add	r2, pc, r2
   1b1d4:	e58d202c 	str	r2, [sp, #44]	; 0x2c
	RTMP *pRtmp=librtmp->pConfig->pRTMP;
	int state_rtmp = init_status;
	int send_data = 0;
	int drop_data = 0;
	int want_bitrate = 0;
	int time_interval = 0;
   1b1d8:	e1a09003 	mov	r9, r3
        pthread_mutex_unlock(&librtmp->pConfig->lock);
        
        if(state_rtmp == disconnect_status)
            break;
        //send data
        pthread_mutex_lock(&pRtmp->lock_speed);
   1b1dc:	e28720a8 	add	r2, r7, #168	; 0xa8
	int pre_bitrate = -1;
	int new_bitrate = -1;
	int last_drop_data = -1;
	int stable_drop_data_times = 0;
	int stable_min_bitrate_times = 0;
	int stable_max_bitrate_times = 0;
   1b1e0:	e58d301c 	str	r3, [sp, #28]
        pthread_mutex_unlock(&librtmp->pConfig->lock);
        
        if(state_rtmp == disconnect_status)
            break;
        //send data
        pthread_mutex_lock(&pRtmp->lock_speed);
   1b1e4:	e58d2010 	str	r2, [sp, #16]
	int time_interval = 0;
	int pre_bitrate = -1;
	int new_bitrate = -1;
	int last_drop_data = -1;
	int stable_drop_data_times = 0;
	int stable_min_bitrate_times = 0;
   1b1e8:	e58d3018 	str	r3, [sp, #24]
	int want_bitrate = 0;
	int time_interval = 0;
	int pre_bitrate = -1;
	int new_bitrate = -1;
	int last_drop_data = -1;
	int stable_drop_data_times = 0;
   1b1ec:	e58d300c 	str	r3, [sp, #12]
	int send_data = 0;
	int drop_data = 0;
	int want_bitrate = 0;
	int time_interval = 0;
	int pre_bitrate = -1;
	int new_bitrate = -1;
   1b1f0:	e58d5020 	str	r5, [sp, #32]
	int state_rtmp = init_status;
	int send_data = 0;
	int drop_data = 0;
	int want_bitrate = 0;
	int time_interval = 0;
	int pre_bitrate = -1;
   1b1f4:	e58d5024 	str	r5, [sp, #36]	; 0x24
    RTMP_Log(RTMP_LOGINFO," speed thread begin\n");
    
    while (1)
	{
        //read state from bufferconfig
        pthread_mutex_lock(&librtmp->pConfig->lock);
   1b1f8:	e59401f4 	ldr	r0, [r4, #500]	; 0x1f4
   1b1fc:	e2800024 	add	r0, r0, #36	; 0x24
   1b200:	ebffa815 	bl	525c <pthread_mutex_lock@plt>
        state_rtmp = librtmp->pConfig->state;
   1b204:	e59401f4 	ldr	r0, [r4, #500]	; 0x1f4
   1b208:	e590600c 	ldr	r6, [r0, #12]
        pthread_mutex_unlock(&librtmp->pConfig->lock);
   1b20c:	e2800024 	add	r0, r0, #36	; 0x24
   1b210:	ebffa814 	bl	5268 <pthread_mutex_unlock@plt>
        
        if(state_rtmp == disconnect_status)
   1b214:	e3560003 	cmp	r6, #3
   1b218:	0a00007f 	beq	1b41c <speed_calculate+0x2b0>
            break;
        //send data
        pthread_mutex_lock(&pRtmp->lock_speed);
   1b21c:	e59da010 	ldr	sl, [sp, #16]
		send_data=pRtmp->m_send_data / 1024;
   1b220:	e28760a0 	add	r6, r7, #160	; 0xa0
        pthread_mutex_unlock(&librtmp->pConfig->lock);
        
        if(state_rtmp == disconnect_status)
            break;
        //send data
        pthread_mutex_lock(&pRtmp->lock_speed);
   1b224:	e1a0000a 	mov	r0, sl
   1b228:	ebffa80b 	bl	525c <pthread_mutex_lock@plt>
		send_data=pRtmp->m_send_data / 1024;
   1b22c:	e9160108 	ldmdb	r6, {r3, r8}
        pthread_mutex_unlock(&pRtmp->lock_speed);
   1b230:	e1a0000a 	mov	r0, sl
        
        if(state_rtmp == disconnect_status)
            break;
        //send data
        pthread_mutex_lock(&pRtmp->lock_speed);
		send_data=pRtmp->m_send_data / 1024;
   1b234:	e1a03523 	lsr	r3, r3, #10
        pthread_mutex_unlock(&pRtmp->lock_speed);
        
        //drop data
        pthread_mutex_lock(&pRtmp->lock_drop);
   1b238:	e287a0ac 	add	sl, r7, #172	; 0xac
        
        if(state_rtmp == disconnect_status)
            break;
        //send data
        pthread_mutex_lock(&pRtmp->lock_speed);
		send_data=pRtmp->m_send_data / 1024;
   1b23c:	e1838b08 	orr	r8, r3, r8, lsl #22
        pthread_mutex_unlock(&pRtmp->lock_speed);
   1b240:	ebffa808 	bl	5268 <pthread_mutex_unlock@plt>
        
        //drop data
        pthread_mutex_lock(&pRtmp->lock_drop);
   1b244:	e1a0000a 	mov	r0, sl
   1b248:	ebffa803 	bl	525c <pthread_mutex_lock@plt>
        drop_data=pRtmp->m_drop_data / 1024;
   1b24c:	e59730a0 	ldr	r3, [r7, #160]	; 0xa0
   1b250:	e5962004 	ldr	r2, [r6, #4]
   1b254:	e1a0b523 	lsr	fp, r3, #10
        pthread_mutex_unlock(&pRtmp->lock_drop);
   1b258:	e1a0000a 	mov	r0, sl
		send_data=pRtmp->m_send_data / 1024;
        pthread_mutex_unlock(&pRtmp->lock_speed);
        
        //drop data
        pthread_mutex_lock(&pRtmp->lock_drop);
        drop_data=pRtmp->m_drop_data / 1024;
   1b25c:	e18bbb02 	orr	fp, fp, r2, lsl #22
        pthread_mutex_unlock(&pRtmp->lock_drop);
   1b260:	ebffa800 	bl	5268 <pthread_mutex_unlock@plt>
        
        //RTMP_Log(RTMP_LOGINFO," push : [before]drop : %d  last drop:%d   stable_drop_data_times:%d \n",drop_data,last_drop_data,stable_drop_data_times);
        if(drop_data == last_drop_data)
   1b264:	e15b0005 	cmp	fp, r5
        {
            stable_drop_data_times++;
        }
        else{
            stable_drop_data_times = 0;
   1b268:	13a03000 	movne	r3, #0
   1b26c:	11a0500b 	movne	r5, fp
   1b270:	158d300c 	strne	r3, [sp, #12]
        pthread_mutex_lock(&pRtmp->lock_drop);
        drop_data=pRtmp->m_drop_data / 1024;
        pthread_mutex_unlock(&pRtmp->lock_drop);
        
        //RTMP_Log(RTMP_LOGINFO," push : [before]drop : %d  last drop:%d   stable_drop_data_times:%d \n",drop_data,last_drop_data,stable_drop_data_times);
        if(drop_data == last_drop_data)
   1b274:	0a000058 	beq	1b3dc <speed_calculate+0x270>
        }
        last_drop_data = drop_data;
        
        //RTMP_Log(RTMP_LOGINFO," push : [after]drop : %d  last drop:%d   stable_drop_data_times:%d \n",drop_data,last_drop_data,stable_drop_data_times);
        
        int iChangebitrate=change_bitrate(drop_data,send_data);
   1b278:	e1a01008 	mov	r1, r8
   1b27c:	e1a00005 	mov	r0, r5
   1b280:	ebffff98 	bl	1b0e8 <change_bitrate>
        
        RTMP_Log(RTMP_LOGINFO, "push: drop: %d  send:%d  iChangebitrate:%d", drop_data, send_data, iChangebitrate);
   1b284:	e1a03008 	mov	r3, r8
   1b288:	e59d1014 	ldr	r1, [sp, #20]
   1b28c:	e1a02005 	mov	r2, r5
        }
        last_drop_data = drop_data;
        
        //RTMP_Log(RTMP_LOGINFO," push : [after]drop : %d  last drop:%d   stable_drop_data_times:%d \n",drop_data,last_drop_data,stable_drop_data_times);
        
        int iChangebitrate=change_bitrate(drop_data,send_data);
   1b290:	e1a0b000 	mov	fp, r0
        
        RTMP_Log(RTMP_LOGINFO, "push: drop: %d  send:%d  iChangebitrate:%d", drop_data, send_data, iChangebitrate);
   1b294:	e58d0000 	str	r0, [sp]
   1b298:	e3a00003 	mov	r0, #3
   1b29c:	ebffe9c2 	bl	159ac <RTMP_Log>
        
        if(iChangebitrate && librtmp->WantBitrate && time_interval>TIME_INTERVAL)
   1b2a0:	e35b0000 	cmp	fp, #0
   1b2a4:	0a00004a 	beq	1b3d4 <speed_calculate+0x268>
   1b2a8:	e5943210 	ldr	r3, [r4, #528]	; 0x210
   1b2ac:	e3530000 	cmp	r3, #0
   1b2b0:	1359000a 	cmpne	r9, #10
   1b2b4:	da000046 	ble	1b3d4 <speed_calculate+0x268>
        {
            if(iChangebitrate == 1)
   1b2b8:	e35b0001 	cmp	fp, #1
            {
                pthread_mutex_lock(&librtmp->pConfig->lock_net_change);
   1b2bc:	e59401f4 	ldr	r0, [r4, #500]	; 0x1f4
        
        RTMP_Log(RTMP_LOGINFO, "push: drop: %d  send:%d  iChangebitrate:%d", drop_data, send_data, iChangebitrate);
        
        if(iChangebitrate && librtmp->WantBitrate && time_interval>TIME_INTERVAL)
        {
            if(iChangebitrate == 1)
   1b2c0:	0a000065 	beq	1b45c <speed_calculate+0x2f0>
                }
                pthread_mutex_unlock(&librtmp->pConfig->lock_net_change);
            }
            else
            {
                pthread_mutex_lock(&librtmp->pConfig->lock_net_change);
   1b2c4:	e2800034 	add	r0, r0, #52	; 0x34
   1b2c8:	ebffa7e3 	bl	525c <pthread_mutex_lock@plt>
                librtmp->pConfig->net_change = 0;
   1b2cc:	e59401f4 	ldr	r0, [r4, #500]	; 0x1f4
   1b2d0:	e3a09000 	mov	r9, #0
   1b2d4:	e5809030 	str	r9, [r0, #48]	; 0x30
                pthread_mutex_unlock(&librtmp->pConfig->lock_net_change);
   1b2d8:	e2800034 	add	r0, r0, #52	; 0x34
   1b2dc:	ebffa7e1 	bl	5268 <pthread_mutex_unlock@plt>
                
                new_bitrate=librtmp->WantBitrate(iChangebitrate);
   1b2e0:	e5943210 	ldr	r3, [r4, #528]	; 0x210
   1b2e4:	e1a0000b 	mov	r0, fp
   1b2e8:	e12fff33 	blx	r3
   1b2ec:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
   1b2f0:	e3700001 	cmn	r0, #1
   1b2f4:	e0603001 	rsb	r3, r0, r1
   1b2f8:	e16f3f13 	clz	r3, r3
   1b2fc:	e1a032a3 	lsr	r3, r3, #5
   1b300:	03a03000 	moveq	r3, #0
            }
            
            if((iChangebitrate == -1)&& (pre_bitrate == new_bitrate) && (new_bitrate != -1))//bitrate is min
   1b304:	e37b0001 	cmn	fp, #1
   1b308:	13a0c000 	movne	ip, #0
   1b30c:	03a0c001 	moveq	ip, #1
   1b310:	e01c8003 	ands	r8, ip, r3
            {
                pthread_mutex_lock(&librtmp->pConfig->lock_net_change);
                librtmp->pConfig->net_change = 0;
                pthread_mutex_unlock(&librtmp->pConfig->lock_net_change);
                
                new_bitrate=librtmp->WantBitrate(iChangebitrate);
   1b314:	e58d0020 	str	r0, [sp, #32]
            }
            
            if((iChangebitrate == -1)&& (pre_bitrate == new_bitrate) && (new_bitrate != -1))//bitrate is min
            {
                pthread_mutex_lock(&librtmp->pConfig->lock_min_bitrate_status);
   1b318:	e59401f4 	ldr	r0, [r4, #500]	; 0x1f4
                pthread_mutex_unlock(&librtmp->pConfig->lock_net_change);
                
                new_bitrate=librtmp->WantBitrate(iChangebitrate);
            }
            
            if((iChangebitrate == -1)&& (pre_bitrate == new_bitrate) && (new_bitrate != -1))//bitrate is min
   1b31c:	0a000074 	beq	1b4f4 <speed_calculate+0x388>
            {
                pthread_mutex_lock(&librtmp->pConfig->lock_min_bitrate_status);
                librtmp->pConfig->min_bitrate_status=1;
                stable_min_bitrate_times++;
   1b320:	e59d3018 	ldr	r3, [sp, #24]
                new_bitrate=librtmp->WantBitrate(iChangebitrate);
            }
            
            if((iChangebitrate == -1)&& (pre_bitrate == new_bitrate) && (new_bitrate != -1))//bitrate is min
            {
                pthread_mutex_lock(&librtmp->pConfig->lock_min_bitrate_status);
   1b324:	e280002c 	add	r0, r0, #44	; 0x2c
                librtmp->pConfig->min_bitrate_status=1;
                stable_min_bitrate_times++;
   1b328:	e2833001 	add	r3, r3, #1
   1b32c:	e1a08003 	mov	r8, r3
   1b330:	e58d3018 	str	r3, [sp, #24]
                new_bitrate=librtmp->WantBitrate(iChangebitrate);
            }
            
            if((iChangebitrate == -1)&& (pre_bitrate == new_bitrate) && (new_bitrate != -1))//bitrate is min
            {
                pthread_mutex_lock(&librtmp->pConfig->lock_min_bitrate_status);
   1b334:	ebffa7c8 	bl	525c <pthread_mutex_lock@plt>
                librtmp->pConfig->min_bitrate_status=1;
   1b338:	e59401f4 	ldr	r0, [r4, #500]	; 0x1f4
   1b33c:	e3a03001 	mov	r3, #1
   1b340:	e5803028 	str	r3, [r0, #40]	; 0x28
                stable_min_bitrate_times++;
                pthread_mutex_unlock(&librtmp->pConfig->lock_min_bitrate_status);
   1b344:	e280002c 	add	r0, r0, #44	; 0x2c
   1b348:	ebffa7c6 	bl	5268 <pthread_mutex_unlock@plt>
				stable_max_bitrate_times = 0;
			}
			
            pre_bitrate=new_bitrate;
			
            if(stable_min_bitrate_times >= 6)
   1b34c:	e3580005 	cmp	r8, #5
			{
				stable_max_bitrate_times++;
			}
			else
			{
				stable_max_bitrate_times = 0;
   1b350:	d58d901c 	strle	r9, [sp, #28]
			}
			
            pre_bitrate=new_bitrate;
			
            if(stable_min_bitrate_times >= 6)
   1b354:	ca000037 	bgt	1b438 <speed_calculate+0x2cc>
			}
				
            time_interval=-1;
            
            //send data
            pthread_mutex_lock(&pRtmp->lock_speed);
   1b358:	e59db010 	ldr	fp, [sp, #16]
            pRtmp->m_send_data=0;
   1b35c:	e3a09000 	mov	r9, #0
   1b360:	e3a08000 	mov	r8, #0
			}
				
            time_interval=-1;
            
            //send data
            pthread_mutex_lock(&pRtmp->lock_speed);
   1b364:	e1a0000b 	mov	r0, fp
   1b368:	ebffa7bb 	bl	525c <pthread_mutex_lock@plt>
            pRtmp->m_send_data=0;
   1b36c:	e14680f8 	strd	r8, [r6, #-8]
            pthread_mutex_unlock(&pRtmp->lock_speed);
   1b370:	e1a0000b 	mov	r0, fp
   1b374:	ebffa7bb 	bl	5268 <pthread_mutex_unlock@plt>
            
            //drop data
            pthread_mutex_lock(&pRtmp->lock_drop);
   1b378:	e1a0000a 	mov	r0, sl
   1b37c:	ebffa7b6 	bl	525c <pthread_mutex_lock@plt>
            pRtmp->m_drop_data=0;
   1b380:	e1c78af0 	strd	r8, [r7, #160]	; 0xa0
            pthread_mutex_unlock(&pRtmp->lock_drop);
   1b384:	e1a0000a 	mov	r0, sl
   1b388:	ebffa7b6 	bl	5268 <pthread_mutex_unlock@plt>
   1b38c:	e3a09000 	mov	r9, #0
   1b390:	e59d3020 	ldr	r3, [sp, #32]
   1b394:	e58d3024 	str	r3, [sp, #36]	; 0x24
   1b398:	e3a06ffa 	mov	r6, #1000	; 0x3e8
        }
        sleep_time = 1000;
        while (sleep_time > 0 && state_rtmp != disconnect_status)
        {
            pthread_mutex_lock(&librtmp->pConfig->lock);//yiqin todo
   1b39c:	e59401f4 	ldr	r0, [r4, #500]	; 0x1f4
            state_rtmp = librtmp->pConfig->state;
            pthread_mutex_unlock(&librtmp->pConfig->lock);
            usleep(10 * 1000);
            sleep_time -= 10;
   1b3a0:	e246600a 	sub	r6, r6, #10
            pthread_mutex_unlock(&pRtmp->lock_drop);
        }
        sleep_time = 1000;
        while (sleep_time > 0 && state_rtmp != disconnect_status)
        {
            pthread_mutex_lock(&librtmp->pConfig->lock);//yiqin todo
   1b3a4:	e2800024 	add	r0, r0, #36	; 0x24
   1b3a8:	ebffa7ab 	bl	525c <pthread_mutex_lock@plt>
            state_rtmp = librtmp->pConfig->state;
   1b3ac:	e59401f4 	ldr	r0, [r4, #500]	; 0x1f4
   1b3b0:	e590800c 	ldr	r8, [r0, #12]
            pthread_mutex_unlock(&librtmp->pConfig->lock);
   1b3b4:	e2800024 	add	r0, r0, #36	; 0x24
   1b3b8:	ebffa7aa 	bl	5268 <pthread_mutex_unlock@plt>
            usleep(10 * 1000);
   1b3bc:	e59f0188 	ldr	r0, [pc, #392]	; 1b54c <speed_calculate+0x3e0>
   1b3c0:	ebffa88f 	bl	5604 <usleep@plt>
            pthread_mutex_lock(&pRtmp->lock_drop);
            pRtmp->m_drop_data=0;
            pthread_mutex_unlock(&pRtmp->lock_drop);
        }
        sleep_time = 1000;
        while (sleep_time > 0 && state_rtmp != disconnect_status)
   1b3c4:	e3580003 	cmp	r8, #3
   1b3c8:	13560000 	cmpne	r6, #0
   1b3cc:	cafffff2 	bgt	1b39c <speed_calculate+0x230>
   1b3d0:	eaffff88 	b	1b1f8 <speed_calculate+0x8c>
   1b3d4:	e2899001 	add	r9, r9, #1
   1b3d8:	eaffffee 	b	1b398 <speed_calculate+0x22c>
        pthread_mutex_unlock(&pRtmp->lock_drop);
        
        //RTMP_Log(RTMP_LOGINFO," push : [before]drop : %d  last drop:%d   stable_drop_data_times:%d \n",drop_data,last_drop_data,stable_drop_data_times);
        if(drop_data == last_drop_data)
        {
            stable_drop_data_times++;
   1b3dc:	e59d300c 	ldr	r3, [sp, #12]
   1b3e0:	e2833001 	add	r3, r3, #1
        }
        else{
            stable_drop_data_times = 0;
        }
        if(stable_drop_data_times >= 60)
   1b3e4:	e353003b 	cmp	r3, #59	; 0x3b
        pthread_mutex_unlock(&pRtmp->lock_drop);
        
        //RTMP_Log(RTMP_LOGINFO," push : [before]drop : %d  last drop:%d   stable_drop_data_times:%d \n",drop_data,last_drop_data,stable_drop_data_times);
        if(drop_data == last_drop_data)
        {
            stable_drop_data_times++;
   1b3e8:	e58d300c 	str	r3, [sp, #12]
        }
        else{
            stable_drop_data_times = 0;
        }
        if(stable_drop_data_times >= 60)
   1b3ec:	daffffa1 	ble	1b278 <speed_calculate+0x10c>
		{
            pthread_mutex_lock(&pRtmp->lock_drop);
   1b3f0:	e1a0000a 	mov	r0, sl
   1b3f4:	ebffa798 	bl	525c <pthread_mutex_lock@plt>
            drop_data=pRtmp->m_drop_data=0;
   1b3f8:	e3a02000 	mov	r2, #0
   1b3fc:	e3a03000 	mov	r3, #0
   1b400:	e1c72af0 	strd	r2, [r7, #160]	; 0xa0
            pthread_mutex_unlock(&pRtmp->lock_drop);
   1b404:	e1a0000a 	mov	r0, sl
            stable_drop_data_times = 0;
   1b408:	e3a03000 	mov	r3, #0
   1b40c:	e1a05003 	mov	r5, r3
   1b410:	e58d300c 	str	r3, [sp, #12]
        }
        if(stable_drop_data_times >= 60)
		{
            pthread_mutex_lock(&pRtmp->lock_drop);
            drop_data=pRtmp->m_drop_data=0;
            pthread_mutex_unlock(&pRtmp->lock_drop);
   1b414:	ebffa793 	bl	5268 <pthread_mutex_unlock@plt>
   1b418:	eaffff96 	b	1b278 <speed_calculate+0x10c>
            sleep_time -= 10;
        }
        time_interval++;
    }
    
    RTMP_Log(RTMP_LOGINFO," speed thread stop");
   1b41c:	e59f112c 	ldr	r1, [pc, #300]	; 1b550 <speed_calculate+0x3e4>
   1b420:	e1a00006 	mov	r0, r6
   1b424:	e08f1001 	add	r1, pc, r1
   1b428:	ebffe95f 	bl	159ac <RTMP_Log>
    return NULL;
}
   1b42c:	e3a00000 	mov	r0, #0
   1b430:	e28dd034 	add	sp, sp, #52	; 0x34
   1b434:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
			
            pre_bitrate=new_bitrate;
			
            if(stable_min_bitrate_times >= 6)
            {
                librtmp->RTMPSetStatus(network_poor);
   1b438:	e5943208 	ldr	r3, [r4, #520]	; 0x208
   1b43c:	e3a00008 	mov	r0, #8
                stable_min_bitrate_times = 0;
                RTMP_Log(RTMP_LOGINFO, "push: set network poor");
   1b440:	e58d9018 	str	r9, [sp, #24]
			
            pre_bitrate=new_bitrate;
			
            if(stable_min_bitrate_times >= 6)
            {
                librtmp->RTMPSetStatus(network_poor);
   1b444:	e12fff33 	blx	r3
                stable_min_bitrate_times = 0;
                RTMP_Log(RTMP_LOGINFO, "push: set network poor");
   1b448:	e3a00003 	mov	r0, #3
   1b44c:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
   1b450:	e58d901c 	str	r9, [sp, #28]
   1b454:	ebffe954 	bl	159ac <RTMP_Log>
   1b458:	eaffffbe 	b	1b358 <speed_calculate+0x1ec>
        
        if(iChangebitrate && librtmp->WantBitrate && time_interval>TIME_INTERVAL)
        {
            if(iChangebitrate == 1)
            {
                pthread_mutex_lock(&librtmp->pConfig->lock_net_change);
   1b45c:	e2800034 	add	r0, r0, #52	; 0x34
   1b460:	ebffa77d 	bl	525c <pthread_mutex_lock@plt>
                if(librtmp->pConfig->net_change == 1)
   1b464:	e59431f4 	ldr	r3, [r4, #500]	; 0x1f4
   1b468:	e5930030 	ldr	r0, [r3, #48]	; 0x30
   1b46c:	e3500001 	cmp	r0, #1
   1b470:	0a00002a 	beq	1b520 <speed_calculate+0x3b4>
                {
					librtmp->pConfig->net_change = 0;
                    new_bitrate=librtmp->WantBitrate(iChangebitrate);
                }
                pthread_mutex_unlock(&librtmp->pConfig->lock_net_change);
   1b474:	e2830034 	add	r0, r3, #52	; 0x34
   1b478:	ebffa77a 	bl	5268 <pthread_mutex_unlock@plt>
                stable_min_bitrate_times++;
                pthread_mutex_unlock(&librtmp->pConfig->lock_min_bitrate_status);
            }
            else
            {
                pthread_mutex_lock(&librtmp->pConfig->lock_min_bitrate_status);
   1b47c:	e59401f4 	ldr	r0, [r4, #500]	; 0x1f4
                librtmp->pConfig->min_bitrate_status = 0;
   1b480:	e3a08000 	mov	r8, #0
                stable_min_bitrate_times++;
                pthread_mutex_unlock(&librtmp->pConfig->lock_min_bitrate_status);
            }
            else
            {
                pthread_mutex_lock(&librtmp->pConfig->lock_min_bitrate_status);
   1b484:	e280002c 	add	r0, r0, #44	; 0x2c
   1b488:	ebffa773 	bl	525c <pthread_mutex_lock@plt>
                librtmp->pConfig->min_bitrate_status = 0;
   1b48c:	e59401f4 	ldr	r0, [r4, #500]	; 0x1f4
   1b490:	e5808028 	str	r8, [r0, #40]	; 0x28
                stable_min_bitrate_times = 0;
                pthread_mutex_unlock(&librtmp->pConfig->lock_min_bitrate_status);
   1b494:	e280002c 	add	r0, r0, #44	; 0x2c
   1b498:	ebffa772 	bl	5268 <pthread_mutex_unlock@plt>
            }
			
			if ((iChangebitrate == 1) && (pre_bitrate == new_bitrate))
   1b49c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
   1b4a0:	e59d2020 	ldr	r2, [sp, #32]
   1b4a4:	e1530002 	cmp	r3, r2
            }
            else
            {
                pthread_mutex_lock(&librtmp->pConfig->lock_min_bitrate_status);
                librtmp->pConfig->min_bitrate_status = 0;
                stable_min_bitrate_times = 0;
   1b4a8:	11a03008 	movne	r3, r8
   1b4ac:	158d301c 	strne	r3, [sp, #28]
			{
				stable_max_bitrate_times++;
			}
			else
			{
				stable_max_bitrate_times = 0;
   1b4b0:	158d3018 	strne	r3, [sp, #24]
                librtmp->pConfig->min_bitrate_status = 0;
                stable_min_bitrate_times = 0;
                pthread_mutex_unlock(&librtmp->pConfig->lock_min_bitrate_status);
            }
			
			if ((iChangebitrate == 1) && (pre_bitrate == new_bitrate))
   1b4b4:	1affffa7 	bne	1b358 <speed_calculate+0x1ec>
			{
				stable_max_bitrate_times++;
   1b4b8:	e59d301c 	ldr	r3, [sp, #28]
   1b4bc:	e2833001 	add	r3, r3, #1
                librtmp->RTMPSetStatus(network_poor);
                stable_min_bitrate_times = 0;
                RTMP_Log(RTMP_LOGINFO, "push: set network poor");
            }
			
			if (stable_max_bitrate_times >= 12)
   1b4c0:	e353000b 	cmp	r3, #11
                pthread_mutex_unlock(&librtmp->pConfig->lock_min_bitrate_status);
            }
			
			if ((iChangebitrate == 1) && (pre_bitrate == new_bitrate))
			{
				stable_max_bitrate_times++;
   1b4c4:	e58d301c 	str	r3, [sp, #28]
   1b4c8:	d58d8018 	strle	r8, [sp, #24]
                librtmp->RTMPSetStatus(network_poor);
                stable_min_bitrate_times = 0;
                RTMP_Log(RTMP_LOGINFO, "push: set network poor");
            }
			
			if (stable_max_bitrate_times >= 12)
   1b4cc:	daffffa1 	ble	1b358 <speed_calculate+0x1ec>
			{
				librtmp->RTMPSetStatus(network_good);
   1b4d0:	e5943208 	ldr	r3, [r4, #520]	; 0x208
   1b4d4:	e3a00009 	mov	r0, #9
				stable_max_bitrate_times = 0;
				RTMP_Log(RTMP_LOGINFO, "push: set network good");
   1b4d8:	e58d801c 	str	r8, [sp, #28]
                RTMP_Log(RTMP_LOGINFO, "push: set network poor");
            }
			
			if (stable_max_bitrate_times >= 12)
			{
				librtmp->RTMPSetStatus(network_good);
   1b4dc:	e12fff33 	blx	r3
				stable_max_bitrate_times = 0;
				RTMP_Log(RTMP_LOGINFO, "push: set network good");
   1b4e0:	e3a00003 	mov	r0, #3
   1b4e4:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
            }
			
			if (stable_max_bitrate_times >= 12)
			{
				librtmp->RTMPSetStatus(network_good);
				stable_max_bitrate_times = 0;
   1b4e8:	e58d8018 	str	r8, [sp, #24]
				RTMP_Log(RTMP_LOGINFO, "push: set network good");
   1b4ec:	ebffe92e 	bl	159ac <RTMP_Log>
   1b4f0:	eaffff98 	b	1b358 <speed_calculate+0x1ec>
                stable_min_bitrate_times++;
                pthread_mutex_unlock(&librtmp->pConfig->lock_min_bitrate_status);
            }
            else
            {
                pthread_mutex_lock(&librtmp->pConfig->lock_min_bitrate_status);
   1b4f4:	e280002c 	add	r0, r0, #44	; 0x2c
                librtmp->pConfig->min_bitrate_status = 0;
                stable_min_bitrate_times = 0;
   1b4f8:	e58d8018 	str	r8, [sp, #24]
                stable_min_bitrate_times++;
                pthread_mutex_unlock(&librtmp->pConfig->lock_min_bitrate_status);
            }
            else
            {
                pthread_mutex_lock(&librtmp->pConfig->lock_min_bitrate_status);
   1b4fc:	ebffa756 	bl	525c <pthread_mutex_lock@plt>
                librtmp->pConfig->min_bitrate_status = 0;
   1b500:	e59401f4 	ldr	r0, [r4, #500]	; 0x1f4
   1b504:	e5808028 	str	r8, [r0, #40]	; 0x28
                stable_min_bitrate_times = 0;
                pthread_mutex_unlock(&librtmp->pConfig->lock_min_bitrate_status);
   1b508:	e280002c 	add	r0, r0, #44	; 0x2c
   1b50c:	ebffa755 	bl	5268 <pthread_mutex_unlock@plt>
			{
				stable_max_bitrate_times++;
			}
			else
			{
				stable_max_bitrate_times = 0;
   1b510:	e58d801c 	str	r8, [sp, #28]
   1b514:	eaffff8f 	b	1b358 <speed_calculate+0x1ec>
        time_interval++;
    }
    
    RTMP_Log(RTMP_LOGINFO," speed thread stop");
    return NULL;
}
   1b518:	e3a00000 	mov	r0, #0
   1b51c:	e12fff1e 	bx	lr
            if(iChangebitrate == 1)
            {
                pthread_mutex_lock(&librtmp->pConfig->lock_net_change);
                if(librtmp->pConfig->net_change == 1)
                {
					librtmp->pConfig->net_change = 0;
   1b520:	e3a02000 	mov	r2, #0
   1b524:	e5832030 	str	r2, [r3, #48]	; 0x30
                    new_bitrate=librtmp->WantBitrate(iChangebitrate);
   1b528:	e5943210 	ldr	r3, [r4, #528]	; 0x210
   1b52c:	e12fff33 	blx	r3
   1b530:	e59431f4 	ldr	r3, [r4, #500]	; 0x1f4
   1b534:	e58d0020 	str	r0, [sp, #32]
   1b538:	eaffffcd 	b	1b474 <speed_calculate+0x308>
   1b53c:	00006744 	.word	0x00006744
   1b540:	00006748 	.word	0x00006748
   1b544:	00006764 	.word	0x00006764
   1b548:	0000676c 	.word	0x0000676c
   1b54c:	00002710 	.word	0x00002710
   1b550:	00006530 	.word	0x00006530

0001b554 <Librtmp_Stop>:
#if defined(_LINUX_IOS_)
int Librtmp_Stop()
#else
int Librtmp_Stop(LIBRTMP *pLibrtmp)
#endif
{
   1b554:	e92d4008 	push	{r3, lr}
    if(!pLibrtmp)
   1b558:	e2503000 	subs	r3, r0, #0
   1b55c:	0a000002 	beq	1b56c <Librtmp_Stop+0x18>
        return FALSE;
    
    StopSend(pLibrtmp);
   1b560:	ebfffec5 	bl	1b07c <StopSend>
    return TRUE;
   1b564:	e3a00001 	mov	r0, #1
   1b568:	e8bd8008 	pop	{r3, pc}
#else
int Librtmp_Stop(LIBRTMP *pLibrtmp)
#endif
{
    if(!pLibrtmp)
        return FALSE;
   1b56c:	e1a00003 	mov	r0, r3
    
    StopSend(pLibrtmp);
    return TRUE;
}
   1b570:	e8bd8008 	pop	{r3, pc}

0001b574 <Librtmp_InitBufferConfig>:

int Librtmp_InitBufferConfig(LIBRTMP *pLibrtmp, int max_delay, int wait_time, int discard_type, int send_window, int retrytime)
{   
    if (pLibrtmp == NULL)
   1b574:	e3500000 	cmp	r0, #0
   1b578:	0a00002d 	beq	1b634 <Librtmp_InitBufferConfig+0xc0>
    StopSend(pLibrtmp);
    return TRUE;
}

int Librtmp_InitBufferConfig(LIBRTMP *pLibrtmp, int max_delay, int wait_time, int discard_type, int send_window, int retrytime)
{   
   1b57c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
   1b580:	e1a04000 	mov	r4, r0
   1b584:	e24dd008 	sub	sp, sp, #8
   1b588:	e1a06001 	mov	r6, r1
    if (pLibrtmp == NULL)
        return FALSE;

    if ((pLibrtmp->pAacConfig = (RTMP_AAC_ASC *)calloc(1, sizeof(RTMP_AAC_ASC))) == NULL)
   1b58c:	e3a00001 	mov	r0, #1
   1b590:	e3a0101c 	mov	r1, #28
   1b594:	e1a05003 	mov	r5, r3
   1b598:	e1a07002 	mov	r7, r2
   1b59c:	ebffa6e0 	bl	5124 <calloc@plt>
   1b5a0:	e3500000 	cmp	r0, #0
   1b5a4:	e58401fc 	str	r0, [r4, #508]	; 0x1fc
   1b5a8:	0a00001e 	beq	1b628 <Librtmp_InitBufferConfig+0xb4>
        return FALSE;
    
    if ((pLibrtmp->pMetaData = (RTMPMetadata *)calloc(1, sizeof(RTMPMetadata))) == NULL)
   1b5ac:	e3a00001 	mov	r0, #1
   1b5b0:	e3a01030 	mov	r1, #48	; 0x30
   1b5b4:	ebffa6da 	bl	5124 <calloc@plt>
   1b5b8:	e3500000 	cmp	r0, #0
   1b5bc:	e58401f8 	str	r0, [r4, #504]	; 0x1f8
   1b5c0:	0a000018 	beq	1b628 <Librtmp_InitBufferConfig+0xb4>
        return FALSE;
    
    if ((pLibrtmp->pConfig = (BufferConfig *)calloc(1, sizeof(BufferConfig))) == NULL)
   1b5c4:	e3a00001 	mov	r0, #1
   1b5c8:	e3a0103c 	mov	r1, #60	; 0x3c
   1b5cc:	ebffa6d4 	bl	5124 <calloc@plt>
   1b5d0:	e3500000 	cmp	r0, #0
   1b5d4:	e1a08000 	mov	r8, r0
   1b5d8:	e58401f4 	str	r0, [r4, #500]	; 0x1f4
   1b5dc:	0a000011 	beq	1b628 <Librtmp_InitBufferConfig+0xb4>
        return FALSE;
    
    if ((pLibrtmp->pAccess = (RTMPAccess *)calloc(1, sizeof(RTMPAccess))) == NULL)
   1b5e0:	e3a00001 	mov	r0, #1
   1b5e4:	e59f1050 	ldr	r1, [pc, #80]	; 1b63c <Librtmp_InitBufferConfig+0xc8>
   1b5e8:	ebffa6cd 	bl	5124 <calloc@plt>
   1b5ec:	e3500000 	cmp	r0, #0
   1b5f0:	e5840200 	str	r0, [r4, #512]	; 0x200
   1b5f4:	0a00000b 	beq	1b628 <Librtmp_InitBufferConfig+0xb4>
        return FALSE;
    
    InitBufferConfig(pLibrtmp->pConfig, max_delay, wait_time, discard_type, send_window, retrytime);
   1b5f8:	e59d3020 	ldr	r3, [sp, #32]
   1b5fc:	e58d3000 	str	r3, [sp]
   1b600:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
   1b604:	e58d3004 	str	r3, [sp, #4]
   1b608:	e1a00008 	mov	r0, r8
   1b60c:	e1a01006 	mov	r1, r6
   1b610:	e1a02007 	mov	r2, r7
   1b614:	e1a03005 	mov	r3, r5
   1b618:	ebfffcba 	bl	1a908 <InitBufferConfig>

    return TRUE;
   1b61c:	e3a00001 	mov	r0, #1
}
   1b620:	e28dd008 	add	sp, sp, #8
   1b624:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
}

int Librtmp_InitBufferConfig(LIBRTMP *pLibrtmp, int max_delay, int wait_time, int discard_type, int send_window, int retrytime)
{   
    if (pLibrtmp == NULL)
        return FALSE;
   1b628:	e3a00000 	mov	r0, #0
        return FALSE;
    
    InitBufferConfig(pLibrtmp->pConfig, max_delay, wait_time, discard_type, send_window, retrytime);

    return TRUE;
}
   1b62c:	e28dd008 	add	sp, sp, #8
   1b630:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
}

int Librtmp_InitBufferConfig(LIBRTMP *pLibrtmp, int max_delay, int wait_time, int discard_type, int send_window, int retrytime)
{   
    if (pLibrtmp == NULL)
        return FALSE;
   1b634:	e3a00000 	mov	r0, #0
        return FALSE;
    
    InitBufferConfig(pLibrtmp->pConfig, max_delay, wait_time, discard_type, send_window, retrytime);

    return TRUE;
}
   1b638:	e12fff1e 	bx	lr
   1b63c:	0000098c 	.word	0x0000098c

0001b640 <Librtmp_SetParam>:

void Librtmp_SetParam(LIBRTMP *pLibrtmp, RTMP_METADATA *pParam)
{
    if(!pLibrtmp)
   1b640:	e3500000 	cmp	r0, #0
   1b644:	012fff1e 	bxeq	lr

    return TRUE;
}

void Librtmp_SetParam(LIBRTMP *pLibrtmp, RTMP_METADATA *pParam)
{
   1b648:	e92d4070 	push	{r4, r5, r6, lr}
   1b64c:	e1a04001 	mov	r4, r1
   1b650:	e1a0c000 	mov	ip, r0
    
    RTMPMetadata *pMetaData=pLibrtmp->pMetaData;
    RTMP_AAC_ASC *pAacConfig=pLibrtmp->pAacConfig;
    
    //printf("librtmp audio: %d %d %d %d \n,",audio_channel,audio_sample,audio_samplesize,profile);
    RTMP_Set_AAC_SequenceHeader(pAacConfig,pParam->audio_channel,pParam->audio_sample,pParam->audio_samplesize,pParam->profile);
   1b654:	e594e020 	ldr	lr, [r4, #32]

    return TRUE;
}

void Librtmp_SetParam(LIBRTMP *pLibrtmp, RTMP_METADATA *pParam)
{
   1b658:	e24dd008 	sub	sp, sp, #8
    
    RTMPMetadata *pMetaData=pLibrtmp->pMetaData;
    RTMP_AAC_ASC *pAacConfig=pLibrtmp->pAacConfig;
    
    //printf("librtmp audio: %d %d %d %d \n,",audio_channel,audio_sample,audio_samplesize,profile);
    RTMP_Set_AAC_SequenceHeader(pAacConfig,pParam->audio_channel,pParam->audio_sample,pParam->audio_samplesize,pParam->profile);
   1b65c:	e2811008 	add	r1, r1, #8
void Librtmp_SetParam(LIBRTMP *pLibrtmp, RTMP_METADATA *pParam)
{
    if(!pLibrtmp)
        return;
    
    RTMPMetadata *pMetaData=pLibrtmp->pMetaData;
   1b660:	e59c51f8 	ldr	r5, [ip, #504]	; 0x1f8
    RTMP_AAC_ASC *pAacConfig=pLibrtmp->pAacConfig;
    
    //printf("librtmp audio: %d %d %d %d \n,",audio_channel,audio_sample,audio_samplesize,profile);
    RTMP_Set_AAC_SequenceHeader(pAacConfig,pParam->audio_channel,pParam->audio_sample,pParam->audio_samplesize,pParam->profile);
   1b664:	e891000e 	ldm	r1, {r1, r2, r3}
   1b668:	e59001fc 	ldr	r0, [r0, #508]	; 0x1fc
   1b66c:	e58de000 	str	lr, [sp]
   1b670:	ebfff7b2 	bl	19540 <RTMP_Set_AAC_SequenceHeader>
    
    
    pMetaData->bHasAudio=pParam->hasaudio;
   1b674:	e5943000 	ldr	r3, [r4]
   1b678:	e5c53014 	strb	r3, [r5, #20]
    pMetaData->bHasVideo=pParam->hasvideo;
   1b67c:	e5943004 	ldr	r3, [r4, #4]
   1b680:	e5c53000 	strb	r3, [r5]
    pMetaData->nAudioChannels=pParam->audio_channel;
   1b684:	e5946008 	ldr	r6, [r4, #8]
    pMetaData->nAudioSampleRate=pParam->audio_sample;
   1b688:	e594e00c 	ldr	lr, [r4, #12]
    pMetaData->nAudioSampleSize=pParam->audio_samplesize;
   1b68c:	e594c010 	ldr	ip, [r4, #16]
    pMetaData->nFrameRate=pParam->video_framerate;
   1b690:	e5940014 	ldr	r0, [r4, #20]
    pMetaData->nHeight=pParam->video_height;
   1b694:	e594101c 	ldr	r1, [r4, #28]
    pMetaData->nWidth=pParam->video_width;
   1b698:	e5942018 	ldr	r2, [r4, #24]
    pMetaData->nVideoDataRate=pParam->bitrate;
   1b69c:	e5943024 	ldr	r3, [r4, #36]	; 0x24
   1b6a0:	e5853010 	str	r3, [r5, #16]
    RTMP_Set_AAC_SequenceHeader(pAacConfig,pParam->audio_channel,pParam->audio_sample,pParam->audio_samplesize,pParam->profile);
    
    
    pMetaData->bHasAudio=pParam->hasaudio;
    pMetaData->bHasVideo=pParam->hasvideo;
    pMetaData->nAudioChannels=pParam->audio_channel;
   1b6a4:	e5856020 	str	r6, [r5, #32]
    pMetaData->nAudioSampleRate=pParam->audio_sample;
   1b6a8:	e585e018 	str	lr, [r5, #24]
    pMetaData->nAudioSampleSize=pParam->audio_samplesize;
   1b6ac:	e585c01c 	str	ip, [r5, #28]
    pMetaData->nFrameRate=pParam->video_framerate;
   1b6b0:	e585000c 	str	r0, [r5, #12]
    pMetaData->nHeight=pParam->video_height;
   1b6b4:	e5851008 	str	r1, [r5, #8]
    pMetaData->nWidth=pParam->video_width;
   1b6b8:	e5852004 	str	r2, [r5, #4]
    pMetaData->nVideoDataRate=pParam->bitrate;
}
   1b6bc:	e28dd008 	add	sp, sp, #8
   1b6c0:	e8bd8070 	pop	{r4, r5, r6, pc}

0001b6c4 <Librtmp_SetPropertiesCallback>:

int Librtmp_SetPropertiesCallback(void (*SetProp)(char *, char *), char *(* GetProp)(char *))
{
   1b6c4:	e59f2018 	ldr	r2, [pc, #24]	; 1b6e4 <Librtmp_SetPropertiesCallback+0x20>
    g_func_rtmpSetProc = SetProp;
   1b6c8:	e59f3018 	ldr	r3, [pc, #24]	; 1b6e8 <Librtmp_SetPropertiesCallback+0x24>
   1b6cc:	e79f2002 	ldr	r2, [pc, r2]
    g_func_rtmpGetProc = GetProp;
   1b6d0:	e79f3003 	ldr	r3, [pc, r3]
    pMetaData->nVideoDataRate=pParam->bitrate;
}

int Librtmp_SetPropertiesCallback(void (*SetProp)(char *, char *), char *(* GetProp)(char *))
{
    g_func_rtmpSetProc = SetProp;
   1b6d4:	e5820000 	str	r0, [r2]
    g_func_rtmpGetProc = GetProp;
   1b6d8:	e5831000 	str	r1, [r3]
	return TRUE;
}
   1b6dc:	e3a00001 	mov	r0, #1
   1b6e0:	e12fff1e 	bx	lr
   1b6e4:	000086a8 	.word	0x000086a8
   1b6e8:	000086a0 	.word	0x000086a0

0001b6ec <Librtmp_SetValueCallback>:

int Librtmp_SetValueCallback(void (*SetStatValue)(char *, char *))
{
   1b6ec:	e59f300c 	ldr	r3, [pc, #12]	; 1b700 <Librtmp_SetValueCallback+0x14>
	g_func_rtmpSetStatValue = SetStatValue;
   1b6f0:	e79f3003 	ldr	r3, [pc, r3]
   1b6f4:	e5830000 	str	r0, [r3]
	return TRUE;
}
   1b6f8:	e3a00001 	mov	r0, #1
   1b6fc:	e12fff1e 	bx	lr
   1b700:	000086ac 	.word	0x000086ac

0001b704 <Librtmp_start>:
#endif
{
#if defined(_LINUX_IOS_)
	pLibrtmp = (LIBRTMP *)calloc(1, sizeof(LIBRTMP));
#endif
    if(!pLibrtmp)
   1b704:	e3500000 	cmp	r0, #0
    void (*SetStatus)(int), RTMP_METADATA *pMetadata, void (*relievebind)(), int (*WantBitrate)(int))
#else
int Librtmp_start(LIBRTMP *pLibrtmp, char *sUrl, int max_delay, int wait_time, int discard_type, int send_window, int retrytime,
    void (*SetStatus)(int), RTMP_METADATA *pMetadata, void (*relievebind)(), int (*WantBitrate)(int))
#endif
{
   1b708:	e92d40f0 	push	{r4, r5, r6, r7, lr}
#if defined(_LINUX_IOS_)
	pLibrtmp = (LIBRTMP *)calloc(1, sizeof(LIBRTMP));
#endif
    if(!pLibrtmp)
        return FALSE;
   1b70c:	01a06000 	moveq	r6, r0
    void (*SetStatus)(int), RTMP_METADATA *pMetadata, void (*relievebind)(), int (*WantBitrate)(int))
#else
int Librtmp_start(LIBRTMP *pLibrtmp, char *sUrl, int max_delay, int wait_time, int discard_type, int send_window, int retrytime,
    void (*SetStatus)(int), RTMP_METADATA *pMetadata, void (*relievebind)(), int (*WantBitrate)(int))
#endif
{
   1b710:	e24dd00c 	sub	sp, sp, #12
#if defined(_LINUX_IOS_)
	pLibrtmp = (LIBRTMP *)calloc(1, sizeof(LIBRTMP));
#endif
    if(!pLibrtmp)
   1b714:	0a00002a 	beq	1b7c4 <Librtmp_start+0xc0>
   1b718:	e1a05001 	mov	r5, r1
        return FALSE;
    RTMP_Log(RTMP_LOGINFO, "push : Librtmp_start begin");
   1b71c:	e59f10e0 	ldr	r1, [pc, #224]	; 1b804 <Librtmp_start+0x100>
   1b720:	e1a04000 	mov	r4, r0
   1b724:	e08f1001 	add	r1, pc, r1
   1b728:	e3a00003 	mov	r0, #3
   1b72c:	e1a06003 	mov	r6, r3
   1b730:	e1a07002 	mov	r7, r2
   1b734:	ebffe89c 	bl	159ac <RTMP_Log>
    if(!Librtmp_InitBufferConfig(pLibrtmp, max_delay, wait_time, discard_type, send_window, retrytime))
   1b738:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
   1b73c:	e58d3000 	str	r3, [sp]
   1b740:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
   1b744:	e58d3004 	str	r3, [sp, #4]
   1b748:	e1a02006 	mov	r2, r6
   1b74c:	e1a01007 	mov	r1, r7
   1b750:	e1a00004 	mov	r0, r4
   1b754:	e59d3020 	ldr	r3, [sp, #32]
   1b758:	ebffff85 	bl	1b574 <Librtmp_InitBufferConfig>
   1b75c:	e2506000 	subs	r6, r0, #0
   1b760:	0a00001a 	beq	1b7d0 <Librtmp_start+0xcc>
    {
        RTMP_Log(RTMP_LOGINFO, "push : Librtmp_start init buffer config fail");
        return FALSE;
    }
    
    memcpy(pLibrtmp->sUrl, sUrl, strlen(sUrl));
   1b764:	e1a00005 	mov	r0, r5
   1b768:	ebffa664 	bl	5100 <strlen@plt>
   1b76c:	e1a01005 	mov	r1, r5
   1b770:	e1a02000 	mov	r2, r0
   1b774:	e1a00004 	mov	r0, r4
   1b778:	ebffa693 	bl	51cc <memcpy@plt>
   
    Librtmp_SetParam(pLibrtmp, pMetadata);
   1b77c:	e1a00004 	mov	r0, r4
   1b780:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
   1b784:	ebffffad 	bl	1b640 <Librtmp_SetParam>
   
    pLibrtmp->RTMPSetStatus = SetStatus;
   1b788:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
   1b78c:	e5843208 	str	r3, [r4, #520]	; 0x208
    pLibrtmp->relievebind = relievebind;
    pLibrtmp->WantBitrate = WantBitrate;
    int ret = pthread_create(&pLibrtmp->work_thread, NULL, start_send, pLibrtmp);//0:success
   1b790:	e59f2070 	ldr	r2, [pc, #112]	; 1b808 <Librtmp_start+0x104>
    memcpy(pLibrtmp->sUrl, sUrl, strlen(sUrl));
   
    Librtmp_SetParam(pLibrtmp, pMetadata);
   
    pLibrtmp->RTMPSetStatus = SetStatus;
    pLibrtmp->relievebind = relievebind;
   1b794:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
   1b798:	e584320c 	str	r3, [r4, #524]	; 0x20c
    pLibrtmp->WantBitrate = WantBitrate;
   1b79c:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
   1b7a0:	e5843210 	str	r3, [r4, #528]	; 0x210
    int ret = pthread_create(&pLibrtmp->work_thread, NULL, start_send, pLibrtmp);//0:success
   1b7a4:	e79f2002 	ldr	r2, [pc, r2]
   1b7a8:	e2840f81 	add	r0, r4, #516	; 0x204
   1b7ac:	e1a03004 	mov	r3, r4
   1b7b0:	e3a01000 	mov	r1, #0
   1b7b4:	ebffa79b 	bl	5628 <pthread_create@plt>
    
    if(ret)
   1b7b8:	e3500000 	cmp	r0, #0
    {
        RTMP_Log(RTMP_LOGINFO," create speed thread fail \n");
        return FALSE;
    }
    
    return TRUE;
   1b7bc:	03a06001 	moveq	r6, #1
    pLibrtmp->RTMPSetStatus = SetStatus;
    pLibrtmp->relievebind = relievebind;
    pLibrtmp->WantBitrate = WantBitrate;
    int ret = pthread_create(&pLibrtmp->work_thread, NULL, start_send, pLibrtmp);//0:success
    
    if(ret)
   1b7c0:	1a000009 	bne	1b7ec <Librtmp_start+0xe8>
        RTMP_Log(RTMP_LOGINFO," create speed thread fail \n");
        return FALSE;
    }
    
    return TRUE;
}
   1b7c4:	e1a00006 	mov	r0, r6
   1b7c8:	e28dd00c 	add	sp, sp, #12
   1b7cc:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    if(!pLibrtmp)
        return FALSE;
    RTMP_Log(RTMP_LOGINFO, "push : Librtmp_start begin");
    if(!Librtmp_InitBufferConfig(pLibrtmp, max_delay, wait_time, discard_type, send_window, retrytime))
    {
        RTMP_Log(RTMP_LOGINFO, "push : Librtmp_start init buffer config fail");
   1b7d0:	e59f1034 	ldr	r1, [pc, #52]	; 1b80c <Librtmp_start+0x108>
   1b7d4:	e3a00003 	mov	r0, #3
   1b7d8:	e08f1001 	add	r1, pc, r1
   1b7dc:	ebffe872 	bl	159ac <RTMP_Log>
        RTMP_Log(RTMP_LOGINFO," create speed thread fail \n");
        return FALSE;
    }
    
    return TRUE;
}
   1b7e0:	e1a00006 	mov	r0, r6
   1b7e4:	e28dd00c 	add	sp, sp, #12
   1b7e8:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    pLibrtmp->WantBitrate = WantBitrate;
    int ret = pthread_create(&pLibrtmp->work_thread, NULL, start_send, pLibrtmp);//0:success
    
    if(ret)
    {
        RTMP_Log(RTMP_LOGINFO," create work thread fail \n");
   1b7ec:	e59f101c 	ldr	r1, [pc, #28]	; 1b810 <Librtmp_start+0x10c>
   1b7f0:	e3a00003 	mov	r0, #3
   1b7f4:	e08f1001 	add	r1, pc, r1
   1b7f8:	ebffe86b 	bl	159ac <RTMP_Log>
        return FALSE;
   1b7fc:	e3a06000 	mov	r6, #0
   1b800:	eaffffef 	b	1b7c4 <Librtmp_start+0xc0>
   1b804:	00006244 	.word	0x00006244
   1b808:	00008610 	.word	0x00008610
   1b80c:	000061ac 	.word	0x000061ac
   1b810:	000061c0 	.word	0x000061c0

0001b814 <Librtmp_PutVideoBuffer>:
int Librtmp_PutVideoBuffer(char *data, int size, unsigned int pts, unsigned int dts)
#else
int Librtmp_PutVideoBuffer(LIBRTMP *pLibrtmp, char *data, int size, int time)
#endif
{
    if(!pLibrtmp)
   1b814:	e3500000 	cmp	r0, #0
   1b818:	0a000021 	beq	1b8a4 <Librtmp_PutVideoBuffer+0x90>
#if defined(_LINUX_IOS_)
int Librtmp_PutVideoBuffer(char *data, int size, unsigned int pts, unsigned int dts)
#else
int Librtmp_PutVideoBuffer(LIBRTMP *pLibrtmp, char *data, int size, int time)
#endif
{
   1b81c:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
    if(!pLibrtmp)
        return FALSE;
    
    BufferConfig *pConfig = pLibrtmp->pConfig;
   1b820:	e59041f4 	ldr	r4, [r0, #500]	; 0x1f4
#if defined(_LINUX_IOS_)
int Librtmp_PutVideoBuffer(char *data, int size, unsigned int pts, unsigned int dts)
#else
int Librtmp_PutVideoBuffer(LIBRTMP *pLibrtmp, char *data, int size, int time)
#endif
{
   1b824:	e24dd00c 	sub	sp, sp, #12
    if(!pLibrtmp)
        return FALSE;
    
    BufferConfig *pConfig = pLibrtmp->pConfig;
    if (!pConfig || !pConfig->pVideoBuffer || !pConfig->pRTMP)
   1b828:	e3540000 	cmp	r4, #0
   1b82c:	0a000010 	beq	1b874 <Librtmp_PutVideoBuffer+0x60>
   1b830:	e5946004 	ldr	r6, [r4, #4]
   1b834:	e3560000 	cmp	r6, #0
   1b838:	0a00000d 	beq	1b874 <Librtmp_PutVideoBuffer+0x60>
   1b83c:	e5940000 	ldr	r0, [r4]
   1b840:	e3500000 	cmp	r0, #0
   1b844:	0a00000a 	beq	1b874 <Librtmp_PutVideoBuffer+0x60>
        return FALSE;
    
    pthread_mutex_lock(&pConfig->lock);
   1b848:	e2846024 	add	r6, r4, #36	; 0x24
   1b84c:	e1a00006 	mov	r0, r6
   1b850:	e1a08003 	mov	r8, r3
   1b854:	e1a07002 	mov	r7, r2
   1b858:	e1a05001 	mov	r5, r1
   1b85c:	ebffa67e 	bl	525c <pthread_mutex_lock@plt>
    int status = pConfig->state;
   1b860:	e594900c 	ldr	r9, [r4, #12]
    pthread_mutex_unlock(&pConfig->lock);
   1b864:	e1a00006 	mov	r0, r6
   1b868:	ebffa67e 	bl	5268 <pthread_mutex_unlock@plt>

    int ret = FALSE;
	if (status == send_status)
   1b86c:	e3590002 	cmp	r9, #2
   1b870:	0a000002 	beq	1b880 <Librtmp_PutVideoBuffer+0x6c>
#else
int Librtmp_PutVideoBuffer(LIBRTMP *pLibrtmp, char *data, int size, int time)
#endif
{
    if(!pLibrtmp)
        return FALSE;
   1b874:	e3a00000 	mov	r0, #0
	{
		ret = FALSE;
	}
    
    return ret;
}
   1b878:	e28dd00c 	add	sp, sp, #12
   1b87c:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
	if (status == send_status)
	{
#if defined(_LINUX_IOS_)
		ret = RTMP_Packet_H264(pConfig->pRTMP, data, size, pts, dts, pConfig->pVideoBuffer);
#else
		ret = RTMP_Packet_H264(pConfig->pRTMP, data, size, time, time, pConfig->pVideoBuffer);
   1b880:	e5940000 	ldr	r0, [r4]
   1b884:	e58d8000 	str	r8, [sp]
   1b888:	e5943004 	ldr	r3, [r4, #4]
   1b88c:	e58d3004 	str	r3, [sp, #4]
   1b890:	e1a01005 	mov	r1, r5
   1b894:	e1a02007 	mov	r2, r7
   1b898:	e1a03008 	mov	r3, r8
   1b89c:	ebfff7f5 	bl	19878 <RTMP_Packet_H264>
   1b8a0:	eafffff4 	b	1b878 <Librtmp_PutVideoBuffer+0x64>
#else
int Librtmp_PutVideoBuffer(LIBRTMP *pLibrtmp, char *data, int size, int time)
#endif
{
    if(!pLibrtmp)
        return FALSE;
   1b8a4:	e3a00000 	mov	r0, #0
	{
		ret = FALSE;
	}
    
    return ret;
}
   1b8a8:	e12fff1e 	bx	lr

0001b8ac <Librtmp_PutAudioBuffer>:
int Librtmp_PutAudioBuffer(char * data, int size, int time)
#else
int Librtmp_PutAudioBuffer(LIBRTMP *pLibrtmp, char * data, int size, int time)
#endif
{
    if(!pLibrtmp)
   1b8ac:	e3500000 	cmp	r0, #0
   1b8b0:	0a000020 	beq	1b938 <Librtmp_PutAudioBuffer+0x8c>
#if defined(_LINUX_IOS_)
int Librtmp_PutAudioBuffer(char * data, int size, int time)
#else
int Librtmp_PutAudioBuffer(LIBRTMP *pLibrtmp, char * data, int size, int time)
#endif
{
   1b8b4:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
    if(!pLibrtmp)
        return FALSE;
    
    BufferConfig *pConfig=pLibrtmp->pConfig;
   1b8b8:	e59041f4 	ldr	r4, [r0, #500]	; 0x1f4
#if defined(_LINUX_IOS_)
int Librtmp_PutAudioBuffer(char * data, int size, int time)
#else
int Librtmp_PutAudioBuffer(LIBRTMP *pLibrtmp, char * data, int size, int time)
#endif
{
   1b8bc:	e24dd00c 	sub	sp, sp, #12
    if(!pLibrtmp)
        return FALSE;
    
    BufferConfig *pConfig=pLibrtmp->pConfig;
    
    if(!pConfig || !pConfig->pAudioBuffer || !pConfig->pRTMP)
   1b8c0:	e3540000 	cmp	r4, #0
   1b8c4:	0a000010 	beq	1b90c <Librtmp_PutAudioBuffer+0x60>
   1b8c8:	e5946008 	ldr	r6, [r4, #8]
   1b8cc:	e3560000 	cmp	r6, #0
   1b8d0:	0a00000d 	beq	1b90c <Librtmp_PutAudioBuffer+0x60>
   1b8d4:	e5940000 	ldr	r0, [r4]
   1b8d8:	e3500000 	cmp	r0, #0
   1b8dc:	0a00000a 	beq	1b90c <Librtmp_PutAudioBuffer+0x60>
        return FALSE;
    
    pthread_mutex_lock(&pConfig->lock);
   1b8e0:	e2846024 	add	r6, r4, #36	; 0x24
   1b8e4:	e1a00006 	mov	r0, r6
   1b8e8:	e1a08003 	mov	r8, r3
   1b8ec:	e1a07002 	mov	r7, r2
   1b8f0:	e1a05001 	mov	r5, r1
   1b8f4:	ebffa658 	bl	525c <pthread_mutex_lock@plt>
    
    int status = pConfig->state;
   1b8f8:	e594900c 	ldr	r9, [r4, #12]
    
    pthread_mutex_unlock(&pConfig->lock);
   1b8fc:	e1a00006 	mov	r0, r6
   1b900:	ebffa658 	bl	5268 <pthread_mutex_unlock@plt>
    int ret = 0;
    
    if (status == send_status)
   1b904:	e3590002 	cmp	r9, #2
   1b908:	0a000002 	beq	1b918 <Librtmp_PutAudioBuffer+0x6c>
#else
int Librtmp_PutAudioBuffer(LIBRTMP *pLibrtmp, char * data, int size, int time)
#endif
{
    if(!pLibrtmp)
        return FALSE;
   1b90c:	e3a00000 	mov	r0, #0
    
    if (status != send_status)
        ret = FALSE;

    return ret;
}
   1b910:	e28dd00c 	add	sp, sp, #12
   1b914:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
    int ret = 0;
    
    if (status == send_status)
    {
        
        ret = RTMP_Packet_AAC(pConfig->pRTMP,data,size,time,pConfig->pAudioBuffer);
   1b918:	e594c008 	ldr	ip, [r4, #8]
   1b91c:	e5940000 	ldr	r0, [r4]
   1b920:	e1a01005 	mov	r1, r5
   1b924:	e1a02007 	mov	r2, r7
   1b928:	e1a03008 	mov	r3, r8
   1b92c:	e58dc000 	str	ip, [sp]
   1b930:	ebfff670 	bl	192f8 <RTMP_Packet_AAC>
   1b934:	eafffff5 	b	1b910 <Librtmp_PutAudioBuffer+0x64>
#else
int Librtmp_PutAudioBuffer(LIBRTMP *pLibrtmp, char * data, int size, int time)
#endif
{
    if(!pLibrtmp)
        return FALSE;
   1b938:	e3a00000 	mov	r0, #0
    
    if (status != send_status)
        ret = FALSE;

    return ret;
}
   1b93c:	e12fff1e 	bx	lr

0001b940 <Librtmp_GetRTMPState>:
int Librtmp_GetRTMPState()
#else
int Librtmp_GetRTMPState(LIBRTMP *pLibrtmp)
#endif
{
    if(!pLibrtmp || !pLibrtmp->pConfig)
   1b940:	e2503000 	subs	r3, r0, #0
   1b944:	0a00000c 	beq	1b97c <Librtmp_GetRTMPState+0x3c>
   1b948:	e59301f4 	ldr	r0, [r3, #500]	; 0x1f4
   1b94c:	e3500000 	cmp	r0, #0
   1b950:	012fff1e 	bxeq	lr
#if defined(_LINUX_IOS_)
int Librtmp_GetRTMPState()
#else
int Librtmp_GetRTMPState(LIBRTMP *pLibrtmp)
#endif
{
   1b954:	e92d4010 	push	{r4, lr}
    if(!pLibrtmp || !pLibrtmp->pConfig)
        return FALSE;
    
    pthread_mutex_lock(&pLibrtmp->pConfig->lock);
   1b958:	e2800024 	add	r0, r0, #36	; 0x24
   1b95c:	e1a04003 	mov	r4, r3
   1b960:	ebffa63d 	bl	525c <pthread_mutex_lock@plt>
    int status = pLibrtmp->pConfig->state;
   1b964:	e59401f4 	ldr	r0, [r4, #500]	; 0x1f4
   1b968:	e590400c 	ldr	r4, [r0, #12]
    pthread_mutex_unlock(&pLibrtmp->pConfig->lock);
   1b96c:	e2800024 	add	r0, r0, #36	; 0x24
   1b970:	ebffa63c 	bl	5268 <pthread_mutex_unlock@plt>
    return status;
   1b974:	e1a00004 	mov	r0, r4
   1b978:	e8bd8010 	pop	{r4, pc}
#else
int Librtmp_GetRTMPState(LIBRTMP *pLibrtmp)
#endif
{
    if(!pLibrtmp || !pLibrtmp->pConfig)
        return FALSE;
   1b97c:	e1a00003 	mov	r0, r3
   1b980:	e12fff1e 	bx	lr

0001b984 <Librtmp_GetBufferCurrentTime>:
    return status;
}

int Librtmp_GetBufferCurrentTime(LIBRTMP *pLibrtmp)
{
    if(!pLibrtmp || !pLibrtmp->pConfig)
   1b984:	e3500000 	cmp	r0, #0
   1b988:	0a000003 	beq	1b99c <Librtmp_GetBufferCurrentTime+0x18>
   1b98c:	e59001f4 	ldr	r0, [r0, #500]	; 0x1f4
   1b990:	e3500000 	cmp	r0, #0
   1b994:	0a000000 	beq	1b99c <Librtmp_GetBufferCurrentTime+0x18>
        return FALSE;
    
    return GetBufferCurrentTime(pLibrtmp->pConfig);
   1b998:	eafffc1e 	b	1aa18 <GetBufferCurrentTime>
}
   1b99c:	e3a00000 	mov	r0, #0
   1b9a0:	e12fff1e 	bx	lr

0001b9a4 <Librtmp_SetNetChange>:
void Librtmp_SetNetChange()
#else
void Librtmp_SetNetChange(LIBRTMP *pLibrtmp)
#endif
{
    if (pLibrtmp && pLibrtmp->pConfig)
   1b9a4:	e3500000 	cmp	r0, #0
   1b9a8:	012fff1e 	bxeq	lr
   1b9ac:	e59031f4 	ldr	r3, [r0, #500]	; 0x1f4
   1b9b0:	e3530000 	cmp	r3, #0
   1b9b4:	012fff1e 	bxeq	lr
#if defined(_LINUX_IOS_)
void Librtmp_SetNetChange()
#else
void Librtmp_SetNetChange(LIBRTMP *pLibrtmp)
#endif
{
   1b9b8:	e92d4010 	push	{r4, lr}
   1b9bc:	e1a04000 	mov	r4, r0
    if (pLibrtmp && pLibrtmp->pConfig)
    {
        pthread_mutex_lock(&pLibrtmp->pConfig->lock_net_change);
   1b9c0:	e2830034 	add	r0, r3, #52	; 0x34
   1b9c4:	ebffa624 	bl	525c <pthread_mutex_lock@plt>
        pLibrtmp->pConfig->net_change = 1;
   1b9c8:	e59401f4 	ldr	r0, [r4, #500]	; 0x1f4
   1b9cc:	e3a03001 	mov	r3, #1
   1b9d0:	e5803030 	str	r3, [r0, #48]	; 0x30
        pthread_mutex_unlock(&pLibrtmp->pConfig->lock_net_change);
   1b9d4:	e2800034 	add	r0, r0, #52	; 0x34
   1b9d8:	ebffa622 	bl	5268 <pthread_mutex_unlock@plt>
        
        RTMP_Log(RTMP_LOGINFO," network is changed \n");
   1b9dc:	e59f100c 	ldr	r1, [pc, #12]	; 1b9f0 <Librtmp_SetNetChange+0x4c>
   1b9e0:	e3a00003 	mov	r0, #3
   1b9e4:	e08f1001 	add	r1, pc, r1
    }
}
   1b9e8:	e8bd4010 	pop	{r4, lr}
    {
        pthread_mutex_lock(&pLibrtmp->pConfig->lock_net_change);
        pLibrtmp->pConfig->net_change = 1;
        pthread_mutex_unlock(&pLibrtmp->pConfig->lock_net_change);
        
        RTMP_Log(RTMP_LOGINFO," network is changed \n");
   1b9ec:	eaffe7ee 	b	159ac <RTMP_Log>
   1b9f0:	00005fec 	.word	0x00005fec

0001b9f4 <__aeabi_idiv>:
   1b9f4:	e3510000 	cmp	r1, #0
   1b9f8:	0a000030 	beq	1bac0 <.divsi3_skip_div0_test+0xc4>

0001b9fc <.divsi3_skip_div0_test>:
   1b9fc:	e020c001 	eor	ip, r0, r1
   1ba00:	42611000 	rsbmi	r1, r1, #0
   1ba04:	e2512001 	subs	r2, r1, #1
   1ba08:	0a00001f 	beq	1ba8c <.divsi3_skip_div0_test+0x90>
   1ba0c:	e1b03000 	movs	r3, r0
   1ba10:	42603000 	rsbmi	r3, r0, #0
   1ba14:	e1530001 	cmp	r3, r1
   1ba18:	9a00001e 	bls	1ba98 <.divsi3_skip_div0_test+0x9c>
   1ba1c:	e1110002 	tst	r1, r2
   1ba20:	0a000020 	beq	1baa8 <.divsi3_skip_div0_test+0xac>
   1ba24:	e16f2f11 	clz	r2, r1
   1ba28:	e16f0f13 	clz	r0, r3
   1ba2c:	e0420000 	sub	r0, r2, r0
   1ba30:	e3a02001 	mov	r2, #1
   1ba34:	e1a01011 	lsl	r1, r1, r0
   1ba38:	e1a02012 	lsl	r2, r2, r0
   1ba3c:	e3a00000 	mov	r0, #0
   1ba40:	e1530001 	cmp	r3, r1
   1ba44:	20433001 	subcs	r3, r3, r1
   1ba48:	21800002 	orrcs	r0, r0, r2
   1ba4c:	e15300a1 	cmp	r3, r1, lsr #1
   1ba50:	204330a1 	subcs	r3, r3, r1, lsr #1
   1ba54:	218000a2 	orrcs	r0, r0, r2, lsr #1
   1ba58:	e1530121 	cmp	r3, r1, lsr #2
   1ba5c:	20433121 	subcs	r3, r3, r1, lsr #2
   1ba60:	21800122 	orrcs	r0, r0, r2, lsr #2
   1ba64:	e15301a1 	cmp	r3, r1, lsr #3
   1ba68:	204331a1 	subcs	r3, r3, r1, lsr #3
   1ba6c:	218001a2 	orrcs	r0, r0, r2, lsr #3
   1ba70:	e3530000 	cmp	r3, #0
   1ba74:	11b02222 	lsrsne	r2, r2, #4
   1ba78:	11a01221 	lsrne	r1, r1, #4
   1ba7c:	1affffef 	bne	1ba40 <.divsi3_skip_div0_test+0x44>
   1ba80:	e35c0000 	cmp	ip, #0
   1ba84:	42600000 	rsbmi	r0, r0, #0
   1ba88:	e12fff1e 	bx	lr
   1ba8c:	e13c0000 	teq	ip, r0
   1ba90:	42600000 	rsbmi	r0, r0, #0
   1ba94:	e12fff1e 	bx	lr
   1ba98:	33a00000 	movcc	r0, #0
   1ba9c:	01a00fcc 	asreq	r0, ip, #31
   1baa0:	03800001 	orreq	r0, r0, #1
   1baa4:	e12fff1e 	bx	lr
   1baa8:	e16f2f11 	clz	r2, r1
   1baac:	e262201f 	rsb	r2, r2, #31
   1bab0:	e35c0000 	cmp	ip, #0
   1bab4:	e1a00233 	lsr	r0, r3, r2
   1bab8:	42600000 	rsbmi	r0, r0, #0
   1babc:	e12fff1e 	bx	lr
   1bac0:	e3500000 	cmp	r0, #0
   1bac4:	c3e00102 	mvngt	r0, #-2147483648	; 0x80000000
   1bac8:	b3a00102 	movlt	r0, #-2147483648	; 0x80000000
   1bacc:	eaffa6ea 	b	567c <__aeabi_idiv0@plt>

0001bad0 <__aeabi_idivmod>:
   1bad0:	e3510000 	cmp	r1, #0
   1bad4:	0afffff9 	beq	1bac0 <.divsi3_skip_div0_test+0xc4>
   1bad8:	e92d4003 	push	{r0, r1, lr}
   1badc:	ebffffc6 	bl	1b9fc <.divsi3_skip_div0_test>
   1bae0:	e8bd4006 	pop	{r1, r2, lr}
   1bae4:	e0030092 	mul	r3, r2, r0
   1bae8:	e0411003 	sub	r1, r1, r3
   1baec:	e12fff1e 	bx	lr

0001baf0 <__aeabi_drsub>:
   1baf0:	e2211102 	eor	r1, r1, #-2147483648	; 0x80000000
   1baf4:	ea000000 	b	1bafc <__adddf3>

0001baf8 <__aeabi_dsub>:
   1baf8:	e2233102 	eor	r3, r3, #-2147483648	; 0x80000000

0001bafc <__adddf3>:
   1bafc:	e92d4030 	push	{r4, r5, lr}
   1bb00:	e1a04081 	lsl	r4, r1, #1
   1bb04:	e1a05083 	lsl	r5, r3, #1
   1bb08:	e1340005 	teq	r4, r5
   1bb0c:	01300002 	teqeq	r0, r2
   1bb10:	1194c000 	orrsne	ip, r4, r0
   1bb14:	1195c002 	orrsne	ip, r5, r2
   1bb18:	11f0cac4 	mvnsne	ip, r4, asr #21
   1bb1c:	11f0cac5 	mvnsne	ip, r5, asr #21
   1bb20:	0a000079 	beq	1bd0c <__adddf3+0x210>
   1bb24:	e1a04aa4 	lsr	r4, r4, #21
   1bb28:	e0745aa5 	rsbs	r5, r4, r5, lsr #21
   1bb2c:	b2655000 	rsblt	r5, r5, #0
   1bb30:	da000006 	ble	1bb50 <__adddf3+0x54>
   1bb34:	e0844005 	add	r4, r4, r5
   1bb38:	e0202002 	eor	r2, r0, r2
   1bb3c:	e0213003 	eor	r3, r1, r3
   1bb40:	e0220000 	eor	r0, r2, r0
   1bb44:	e0231001 	eor	r1, r3, r1
   1bb48:	e0202002 	eor	r2, r0, r2
   1bb4c:	e0213003 	eor	r3, r1, r3
   1bb50:	e3550036 	cmp	r5, #54	; 0x36
   1bb54:	88bd8030 	pophi	{r4, r5, pc}
   1bb58:	e3110102 	tst	r1, #-2147483648	; 0x80000000
   1bb5c:	e1a01601 	lsl	r1, r1, #12
   1bb60:	e3a0c601 	mov	ip, #1048576	; 0x100000
   1bb64:	e18c1621 	orr	r1, ip, r1, lsr #12
   1bb68:	0a000001 	beq	1bb74 <__adddf3+0x78>
   1bb6c:	e2700000 	rsbs	r0, r0, #0
   1bb70:	e2e11000 	rsc	r1, r1, #0
   1bb74:	e3130102 	tst	r3, #-2147483648	; 0x80000000
   1bb78:	e1a03603 	lsl	r3, r3, #12
   1bb7c:	e18c3623 	orr	r3, ip, r3, lsr #12
   1bb80:	0a000001 	beq	1bb8c <__adddf3+0x90>
   1bb84:	e2722000 	rsbs	r2, r2, #0
   1bb88:	e2e33000 	rsc	r3, r3, #0
   1bb8c:	e1340005 	teq	r4, r5
   1bb90:	0a000057 	beq	1bcf4 <__adddf3+0x1f8>
   1bb94:	e2444001 	sub	r4, r4, #1
   1bb98:	e275e020 	rsbs	lr, r5, #32
   1bb9c:	ba000005 	blt	1bbb8 <__adddf3+0xbc>
   1bba0:	e1a0ce12 	lsl	ip, r2, lr
   1bba4:	e0900532 	adds	r0, r0, r2, lsr r5
   1bba8:	e2a11000 	adc	r1, r1, #0
   1bbac:	e0900e13 	adds	r0, r0, r3, lsl lr
   1bbb0:	e0b11553 	adcs	r1, r1, r3, asr r5
   1bbb4:	ea000006 	b	1bbd4 <__adddf3+0xd8>
   1bbb8:	e2455020 	sub	r5, r5, #32
   1bbbc:	e28ee020 	add	lr, lr, #32
   1bbc0:	e3520001 	cmp	r2, #1
   1bbc4:	e1a0ce13 	lsl	ip, r3, lr
   1bbc8:	238cc002 	orrcs	ip, ip, #2
   1bbcc:	e0900553 	adds	r0, r0, r3, asr r5
   1bbd0:	e0b11fc3 	adcs	r1, r1, r3, asr #31
   1bbd4:	e2015102 	and	r5, r1, #-2147483648	; 0x80000000
   1bbd8:	5a000002 	bpl	1bbe8 <__adddf3+0xec>
   1bbdc:	e27cc000 	rsbs	ip, ip, #0
   1bbe0:	e2f00000 	rscs	r0, r0, #0
   1bbe4:	e2e11000 	rsc	r1, r1, #0
   1bbe8:	e3510601 	cmp	r1, #1048576	; 0x100000
   1bbec:	3a00000e 	bcc	1bc2c <__adddf3+0x130>
   1bbf0:	e3510602 	cmp	r1, #2097152	; 0x200000
   1bbf4:	3a000006 	bcc	1bc14 <__adddf3+0x118>
   1bbf8:	e1b010a1 	lsrs	r1, r1, #1
   1bbfc:	e1b00060 	rrxs	r0, r0
   1bc00:	e1a0c06c 	rrx	ip, ip
   1bc04:	e2844001 	add	r4, r4, #1
   1bc08:	e1a02a84 	lsl	r2, r4, #21
   1bc0c:	e3720501 	cmn	r2, #4194304	; 0x400000
   1bc10:	2a000055 	bcs	1bd6c <__adddf3+0x270>
   1bc14:	e35c0102 	cmp	ip, #-2147483648	; 0x80000000
   1bc18:	01b0c0a0 	lsrseq	ip, r0, #1
   1bc1c:	e2b00000 	adcs	r0, r0, #0
   1bc20:	e0a11a04 	adc	r1, r1, r4, lsl #20
   1bc24:	e1811005 	orr	r1, r1, r5
   1bc28:	e8bd8030 	pop	{r4, r5, pc}
   1bc2c:	e1b0c08c 	lsls	ip, ip, #1
   1bc30:	e0b00000 	adcs	r0, r0, r0
   1bc34:	e0a11001 	adc	r1, r1, r1
   1bc38:	e3110601 	tst	r1, #1048576	; 0x100000
   1bc3c:	e2444001 	sub	r4, r4, #1
   1bc40:	1afffff3 	bne	1bc14 <__adddf3+0x118>
   1bc44:	e3310000 	teq	r1, #0
   1bc48:	01a01000 	moveq	r1, r0
   1bc4c:	03a00000 	moveq	r0, #0
   1bc50:	e16f3f11 	clz	r3, r1
   1bc54:	02833020 	addeq	r3, r3, #32
   1bc58:	e243300b 	sub	r3, r3, #11
   1bc5c:	e2532020 	subs	r2, r3, #32
   1bc60:	aa000007 	bge	1bc84 <__adddf3+0x188>
   1bc64:	e292200c 	adds	r2, r2, #12
   1bc68:	da000004 	ble	1bc80 <__adddf3+0x184>
   1bc6c:	e282c014 	add	ip, r2, #20
   1bc70:	e262200c 	rsb	r2, r2, #12
   1bc74:	e1a00c11 	lsl	r0, r1, ip
   1bc78:	e1a01231 	lsr	r1, r1, r2
   1bc7c:	ea000004 	b	1bc94 <__adddf3+0x198>
   1bc80:	e2822014 	add	r2, r2, #20
   1bc84:	d262c020 	rsble	ip, r2, #32
   1bc88:	e1a01211 	lsl	r1, r1, r2
   1bc8c:	d1811c30 	orrle	r1, r1, r0, lsr ip
   1bc90:	d1a00210 	lslle	r0, r0, r2
   1bc94:	e0544003 	subs	r4, r4, r3
   1bc98:	a0811a04 	addge	r1, r1, r4, lsl #20
   1bc9c:	a1811005 	orrge	r1, r1, r5
   1bca0:	a8bd8030 	popge	{r4, r5, pc}
   1bca4:	e1e04004 	mvn	r4, r4
   1bca8:	e254401f 	subs	r4, r4, #31
   1bcac:	aa00000d 	bge	1bce8 <__adddf3+0x1ec>
   1bcb0:	e294400c 	adds	r4, r4, #12
   1bcb4:	ca000005 	bgt	1bcd0 <__adddf3+0x1d4>
   1bcb8:	e2844014 	add	r4, r4, #20
   1bcbc:	e2642020 	rsb	r2, r4, #32
   1bcc0:	e1a00430 	lsr	r0, r0, r4
   1bcc4:	e1800211 	orr	r0, r0, r1, lsl r2
   1bcc8:	e1851431 	orr	r1, r5, r1, lsr r4
   1bccc:	e8bd8030 	pop	{r4, r5, pc}
   1bcd0:	e264400c 	rsb	r4, r4, #12
   1bcd4:	e2642020 	rsb	r2, r4, #32
   1bcd8:	e1a00230 	lsr	r0, r0, r2
   1bcdc:	e1800411 	orr	r0, r0, r1, lsl r4
   1bce0:	e1a01005 	mov	r1, r5
   1bce4:	e8bd8030 	pop	{r4, r5, pc}
   1bce8:	e1a00431 	lsr	r0, r1, r4
   1bcec:	e1a01005 	mov	r1, r5
   1bcf0:	e8bd8030 	pop	{r4, r5, pc}
   1bcf4:	e3340000 	teq	r4, #0
   1bcf8:	e2233601 	eor	r3, r3, #1048576	; 0x100000
   1bcfc:	02211601 	eoreq	r1, r1, #1048576	; 0x100000
   1bd00:	02844001 	addeq	r4, r4, #1
   1bd04:	12455001 	subne	r5, r5, #1
   1bd08:	eaffffa1 	b	1bb94 <__adddf3+0x98>
   1bd0c:	e1f0cac4 	mvns	ip, r4, asr #21
   1bd10:	11f0cac5 	mvnsne	ip, r5, asr #21
   1bd14:	0a000018 	beq	1bd7c <__adddf3+0x280>
   1bd18:	e1340005 	teq	r4, r5
   1bd1c:	01300002 	teqeq	r0, r2
   1bd20:	0a000003 	beq	1bd34 <__adddf3+0x238>
   1bd24:	e194c000 	orrs	ip, r4, r0
   1bd28:	01a01003 	moveq	r1, r3
   1bd2c:	01a00002 	moveq	r0, r2
   1bd30:	e8bd8030 	pop	{r4, r5, pc}
   1bd34:	e1310003 	teq	r1, r3
   1bd38:	13a01000 	movne	r1, #0
   1bd3c:	13a00000 	movne	r0, #0
   1bd40:	18bd8030 	popne	{r4, r5, pc}
   1bd44:	e1b0caa4 	lsrs	ip, r4, #21
   1bd48:	1a000003 	bne	1bd5c <__adddf3+0x260>
   1bd4c:	e1b00080 	lsls	r0, r0, #1
   1bd50:	e0b11001 	adcs	r1, r1, r1
   1bd54:	23811102 	orrcs	r1, r1, #-2147483648	; 0x80000000
   1bd58:	e8bd8030 	pop	{r4, r5, pc}
   1bd5c:	e2944501 	adds	r4, r4, #4194304	; 0x400000
   1bd60:	32811601 	addcc	r1, r1, #1048576	; 0x100000
   1bd64:	38bd8030 	popcc	{r4, r5, pc}
   1bd68:	e2015102 	and	r5, r1, #-2147483648	; 0x80000000
   1bd6c:	e385147f 	orr	r1, r5, #2130706432	; 0x7f000000
   1bd70:	e381160f 	orr	r1, r1, #15728640	; 0xf00000
   1bd74:	e3a00000 	mov	r0, #0
   1bd78:	e8bd8030 	pop	{r4, r5, pc}
   1bd7c:	e1f0cac4 	mvns	ip, r4, asr #21
   1bd80:	11a01003 	movne	r1, r3
   1bd84:	11a00002 	movne	r0, r2
   1bd88:	01f0cac5 	mvnseq	ip, r5, asr #21
   1bd8c:	11a03001 	movne	r3, r1
   1bd90:	11a02000 	movne	r2, r0
   1bd94:	e1904601 	orrs	r4, r0, r1, lsl #12
   1bd98:	01925603 	orrseq	r5, r2, r3, lsl #12
   1bd9c:	01310003 	teqeq	r1, r3
   1bda0:	13811702 	orrne	r1, r1, #524288	; 0x80000
   1bda4:	e8bd8030 	pop	{r4, r5, pc}

0001bda8 <__aeabi_ui2d>:
   1bda8:	e3300000 	teq	r0, #0
   1bdac:	03a01000 	moveq	r1, #0
   1bdb0:	012fff1e 	bxeq	lr
   1bdb4:	e92d4030 	push	{r4, r5, lr}
   1bdb8:	e3a04b01 	mov	r4, #1024	; 0x400
   1bdbc:	e2844032 	add	r4, r4, #50	; 0x32
   1bdc0:	e3a05000 	mov	r5, #0
   1bdc4:	e3a01000 	mov	r1, #0
   1bdc8:	eaffff9d 	b	1bc44 <__adddf3+0x148>

0001bdcc <__aeabi_i2d>:
   1bdcc:	e3300000 	teq	r0, #0
   1bdd0:	03a01000 	moveq	r1, #0
   1bdd4:	012fff1e 	bxeq	lr
   1bdd8:	e92d4030 	push	{r4, r5, lr}
   1bddc:	e3a04b01 	mov	r4, #1024	; 0x400
   1bde0:	e2844032 	add	r4, r4, #50	; 0x32
   1bde4:	e2105102 	ands	r5, r0, #-2147483648	; 0x80000000
   1bde8:	42600000 	rsbmi	r0, r0, #0
   1bdec:	e3a01000 	mov	r1, #0
   1bdf0:	eaffff93 	b	1bc44 <__adddf3+0x148>

0001bdf4 <__aeabi_f2d>:
   1bdf4:	e1b02080 	lsls	r2, r0, #1
   1bdf8:	e1a011c2 	asr	r1, r2, #3
   1bdfc:	e1a01061 	rrx	r1, r1
   1be00:	e1a00e02 	lsl	r0, r2, #28
   1be04:	121234ff 	andsne	r3, r2, #-16777216	; 0xff000000
   1be08:	133304ff 	teqne	r3, #-16777216	; 0xff000000
   1be0c:	1221130e 	eorne	r1, r1, #939524096	; 0x38000000
   1be10:	112fff1e 	bxne	lr
   1be14:	e3320000 	teq	r2, #0
   1be18:	133304ff 	teqne	r3, #-16777216	; 0xff000000
   1be1c:	012fff1e 	bxeq	lr
   1be20:	e92d4030 	push	{r4, r5, lr}
   1be24:	e3a04d0e 	mov	r4, #896	; 0x380
   1be28:	e2015102 	and	r5, r1, #-2147483648	; 0x80000000
   1be2c:	e3c11102 	bic	r1, r1, #-2147483648	; 0x80000000
   1be30:	eaffff83 	b	1bc44 <__adddf3+0x148>

0001be34 <__aeabi_ul2d>:
   1be34:	e1902001 	orrs	r2, r0, r1
   1be38:	012fff1e 	bxeq	lr
   1be3c:	e92d4030 	push	{r4, r5, lr}
   1be40:	e3a05000 	mov	r5, #0
   1be44:	ea000006 	b	1be64 <__aeabi_l2d+0x1c>

0001be48 <__aeabi_l2d>:
   1be48:	e1902001 	orrs	r2, r0, r1
   1be4c:	012fff1e 	bxeq	lr
   1be50:	e92d4030 	push	{r4, r5, lr}
   1be54:	e2115102 	ands	r5, r1, #-2147483648	; 0x80000000
   1be58:	5a000001 	bpl	1be64 <__aeabi_l2d+0x1c>
   1be5c:	e2700000 	rsbs	r0, r0, #0
   1be60:	e2e11000 	rsc	r1, r1, #0
   1be64:	e3a04b01 	mov	r4, #1024	; 0x400
   1be68:	e2844032 	add	r4, r4, #50	; 0x32
   1be6c:	e1b0cb21 	lsrs	ip, r1, #22
   1be70:	0affff5c 	beq	1bbe8 <__adddf3+0xec>
   1be74:	e3a02003 	mov	r2, #3
   1be78:	e1b0c1ac 	lsrs	ip, ip, #3
   1be7c:	12822003 	addne	r2, r2, #3
   1be80:	e1b0c1ac 	lsrs	ip, ip, #3
   1be84:	12822003 	addne	r2, r2, #3
   1be88:	e08221ac 	add	r2, r2, ip, lsr #3
   1be8c:	e2623020 	rsb	r3, r2, #32
   1be90:	e1a0c310 	lsl	ip, r0, r3
   1be94:	e1a00230 	lsr	r0, r0, r2
   1be98:	e1800311 	orr	r0, r0, r1, lsl r3
   1be9c:	e1a01231 	lsr	r1, r1, r2
   1bea0:	e0844002 	add	r4, r4, r2
   1bea4:	eaffff4f 	b	1bbe8 <__adddf3+0xec>

0001bea8 <__aeabi_dmul>:
   1bea8:	e92d4070 	push	{r4, r5, r6, lr}
   1beac:	e3a0c0ff 	mov	ip, #255	; 0xff
   1beb0:	e38ccc07 	orr	ip, ip, #1792	; 0x700
   1beb4:	e01c4a21 	ands	r4, ip, r1, lsr #20
   1beb8:	101c5a23 	andsne	r5, ip, r3, lsr #20
   1bebc:	1134000c 	teqne	r4, ip
   1bec0:	1135000c 	teqne	r5, ip
   1bec4:	0b00006f 	bleq	1c088 <__aeabi_dmul+0x1e0>
   1bec8:	e0844005 	add	r4, r4, r5
   1becc:	e0216003 	eor	r6, r1, r3
   1bed0:	e1c11a8c 	bic	r1, r1, ip, lsl #21
   1bed4:	e1c33a8c 	bic	r3, r3, ip, lsl #21
   1bed8:	e1905601 	orrs	r5, r0, r1, lsl #12
   1bedc:	11925603 	orrsne	r5, r2, r3, lsl #12
   1bee0:	e3811601 	orr	r1, r1, #1048576	; 0x100000
   1bee4:	e3833601 	orr	r3, r3, #1048576	; 0x100000
   1bee8:	0a00001c 	beq	1bf60 <__aeabi_dmul+0xb8>
   1beec:	e08ec290 	umull	ip, lr, r0, r2
   1bef0:	e3a05000 	mov	r5, #0
   1bef4:	e0a5e291 	umlal	lr, r5, r1, r2
   1bef8:	e2062102 	and	r2, r6, #-2147483648	; 0x80000000
   1befc:	e0a5e390 	umlal	lr, r5, r0, r3
   1bf00:	e3a06000 	mov	r6, #0
   1bf04:	e0a65391 	umlal	r5, r6, r1, r3
   1bf08:	e33c0000 	teq	ip, #0
   1bf0c:	138ee001 	orrne	lr, lr, #1
   1bf10:	e24440ff 	sub	r4, r4, #255	; 0xff
   1bf14:	e3560c02 	cmp	r6, #512	; 0x200
   1bf18:	e2c44c03 	sbc	r4, r4, #768	; 0x300
   1bf1c:	2a000002 	bcs	1bf2c <__aeabi_dmul+0x84>
   1bf20:	e1b0e08e 	lsls	lr, lr, #1
   1bf24:	e0b55005 	adcs	r5, r5, r5
   1bf28:	e0a66006 	adc	r6, r6, r6
   1bf2c:	e1821586 	orr	r1, r2, r6, lsl #11
   1bf30:	e1811aa5 	orr	r1, r1, r5, lsr #21
   1bf34:	e1a00585 	lsl	r0, r5, #11
   1bf38:	e1800aae 	orr	r0, r0, lr, lsr #21
   1bf3c:	e1a0e58e 	lsl	lr, lr, #11
   1bf40:	e254c0fd 	subs	ip, r4, #253	; 0xfd
   1bf44:	835c0c07 	cmphi	ip, #1792	; 0x700
   1bf48:	8a00000f 	bhi	1bf8c <__aeabi_dmul+0xe4>
   1bf4c:	e35e0102 	cmp	lr, #-2147483648	; 0x80000000
   1bf50:	01b0e0a0 	lsrseq	lr, r0, #1
   1bf54:	e2b00000 	adcs	r0, r0, #0
   1bf58:	e0a11a04 	adc	r1, r1, r4, lsl #20
   1bf5c:	e8bd8070 	pop	{r4, r5, r6, pc}
   1bf60:	e2066102 	and	r6, r6, #-2147483648	; 0x80000000
   1bf64:	e1861001 	orr	r1, r6, r1
   1bf68:	e1800002 	orr	r0, r0, r2
   1bf6c:	e0211003 	eor	r1, r1, r3
   1bf70:	e05440ac 	subs	r4, r4, ip, lsr #1
   1bf74:	c074500c 	rsbsgt	r5, r4, ip
   1bf78:	c1811a04 	orrgt	r1, r1, r4, lsl #20
   1bf7c:	c8bd8070 	popgt	{r4, r5, r6, pc}
   1bf80:	e3811601 	orr	r1, r1, #1048576	; 0x100000
   1bf84:	e3a0e000 	mov	lr, #0
   1bf88:	e2544001 	subs	r4, r4, #1
   1bf8c:	ca000058 	bgt	1c0f4 <__aeabi_dmul+0x24c>
   1bf90:	e3740036 	cmn	r4, #54	; 0x36
   1bf94:	d3a00000 	movle	r0, #0
   1bf98:	d2011102 	andle	r1, r1, #-2147483648	; 0x80000000
   1bf9c:	d8bd8070 	pople	{r4, r5, r6, pc}
   1bfa0:	e2644000 	rsb	r4, r4, #0
   1bfa4:	e2544020 	subs	r4, r4, #32
   1bfa8:	aa000018 	bge	1c010 <__aeabi_dmul+0x168>
   1bfac:	e294400c 	adds	r4, r4, #12
   1bfb0:	ca00000b 	bgt	1bfe4 <__aeabi_dmul+0x13c>
   1bfb4:	e2844014 	add	r4, r4, #20
   1bfb8:	e2645020 	rsb	r5, r4, #32
   1bfbc:	e1a03510 	lsl	r3, r0, r5
   1bfc0:	e1a00430 	lsr	r0, r0, r4
   1bfc4:	e1800511 	orr	r0, r0, r1, lsl r5
   1bfc8:	e2012102 	and	r2, r1, #-2147483648	; 0x80000000
   1bfcc:	e3c11102 	bic	r1, r1, #-2147483648	; 0x80000000
   1bfd0:	e0900fa3 	adds	r0, r0, r3, lsr #31
   1bfd4:	e0a21431 	adc	r1, r2, r1, lsr r4
   1bfd8:	e19ee083 	orrs	lr, lr, r3, lsl #1
   1bfdc:	01c00fa3 	biceq	r0, r0, r3, lsr #31
   1bfe0:	e8bd8070 	pop	{r4, r5, r6, pc}
   1bfe4:	e264400c 	rsb	r4, r4, #12
   1bfe8:	e2645020 	rsb	r5, r4, #32
   1bfec:	e1a03410 	lsl	r3, r0, r4
   1bff0:	e1a00530 	lsr	r0, r0, r5
   1bff4:	e1800411 	orr	r0, r0, r1, lsl r4
   1bff8:	e2011102 	and	r1, r1, #-2147483648	; 0x80000000
   1bffc:	e0900fa3 	adds	r0, r0, r3, lsr #31
   1c000:	e2a11000 	adc	r1, r1, #0
   1c004:	e19ee083 	orrs	lr, lr, r3, lsl #1
   1c008:	01c00fa3 	biceq	r0, r0, r3, lsr #31
   1c00c:	e8bd8070 	pop	{r4, r5, r6, pc}
   1c010:	e2645020 	rsb	r5, r4, #32
   1c014:	e18ee510 	orr	lr, lr, r0, lsl r5
   1c018:	e1a03430 	lsr	r3, r0, r4
   1c01c:	e1833511 	orr	r3, r3, r1, lsl r5
   1c020:	e1a00431 	lsr	r0, r1, r4
   1c024:	e2011102 	and	r1, r1, #-2147483648	; 0x80000000
   1c028:	e1c00431 	bic	r0, r0, r1, lsr r4
   1c02c:	e0800fa3 	add	r0, r0, r3, lsr #31
   1c030:	e19ee083 	orrs	lr, lr, r3, lsl #1
   1c034:	01c00fa3 	biceq	r0, r0, r3, lsr #31
   1c038:	e8bd8070 	pop	{r4, r5, r6, pc}
   1c03c:	e3340000 	teq	r4, #0
   1c040:	1a000008 	bne	1c068 <__aeabi_dmul+0x1c0>
   1c044:	e2016102 	and	r6, r1, #-2147483648	; 0x80000000
   1c048:	e1b00080 	lsls	r0, r0, #1
   1c04c:	e0a11001 	adc	r1, r1, r1
   1c050:	e3110601 	tst	r1, #1048576	; 0x100000
   1c054:	02444001 	subeq	r4, r4, #1
   1c058:	0afffffa 	beq	1c048 <__aeabi_dmul+0x1a0>
   1c05c:	e1811006 	orr	r1, r1, r6
   1c060:	e3350000 	teq	r5, #0
   1c064:	112fff1e 	bxne	lr
   1c068:	e2036102 	and	r6, r3, #-2147483648	; 0x80000000
   1c06c:	e1b02082 	lsls	r2, r2, #1
   1c070:	e0a33003 	adc	r3, r3, r3
   1c074:	e3130601 	tst	r3, #1048576	; 0x100000
   1c078:	02455001 	subeq	r5, r5, #1
   1c07c:	0afffffa 	beq	1c06c <__aeabi_dmul+0x1c4>
   1c080:	e1833006 	orr	r3, r3, r6
   1c084:	e12fff1e 	bx	lr
   1c088:	e134000c 	teq	r4, ip
   1c08c:	e00c5a23 	and	r5, ip, r3, lsr #20
   1c090:	1135000c 	teqne	r5, ip
   1c094:	0a000006 	beq	1c0b4 <__aeabi_dmul+0x20c>
   1c098:	e1906081 	orrs	r6, r0, r1, lsl #1
   1c09c:	11926083 	orrsne	r6, r2, r3, lsl #1
   1c0a0:	1affffe5 	bne	1c03c <__aeabi_dmul+0x194>
   1c0a4:	e0211003 	eor	r1, r1, r3
   1c0a8:	e2011102 	and	r1, r1, #-2147483648	; 0x80000000
   1c0ac:	e3a00000 	mov	r0, #0
   1c0b0:	e8bd8070 	pop	{r4, r5, r6, pc}
   1c0b4:	e1906081 	orrs	r6, r0, r1, lsl #1
   1c0b8:	01a00002 	moveq	r0, r2
   1c0bc:	01a01003 	moveq	r1, r3
   1c0c0:	11926083 	orrsne	r6, r2, r3, lsl #1
   1c0c4:	0a00000f 	beq	1c108 <__aeabi_dmul+0x260>
   1c0c8:	e134000c 	teq	r4, ip
   1c0cc:	1a000001 	bne	1c0d8 <__aeabi_dmul+0x230>
   1c0d0:	e1906601 	orrs	r6, r0, r1, lsl #12
   1c0d4:	1a00000b 	bne	1c108 <__aeabi_dmul+0x260>
   1c0d8:	e135000c 	teq	r5, ip
   1c0dc:	1a000003 	bne	1c0f0 <__aeabi_dmul+0x248>
   1c0e0:	e1926603 	orrs	r6, r2, r3, lsl #12
   1c0e4:	11a00002 	movne	r0, r2
   1c0e8:	11a01003 	movne	r1, r3
   1c0ec:	1a000005 	bne	1c108 <__aeabi_dmul+0x260>
   1c0f0:	e0211003 	eor	r1, r1, r3
   1c0f4:	e2011102 	and	r1, r1, #-2147483648	; 0x80000000
   1c0f8:	e381147f 	orr	r1, r1, #2130706432	; 0x7f000000
   1c0fc:	e381160f 	orr	r1, r1, #15728640	; 0xf00000
   1c100:	e3a00000 	mov	r0, #0
   1c104:	e8bd8070 	pop	{r4, r5, r6, pc}
   1c108:	e381147f 	orr	r1, r1, #2130706432	; 0x7f000000
   1c10c:	e381173e 	orr	r1, r1, #16252928	; 0xf80000
   1c110:	e8bd8070 	pop	{r4, r5, r6, pc}

0001c114 <__aeabi_ddiv>:
   1c114:	e92d4070 	push	{r4, r5, r6, lr}
   1c118:	e3a0c0ff 	mov	ip, #255	; 0xff
   1c11c:	e38ccc07 	orr	ip, ip, #1792	; 0x700
   1c120:	e01c4a21 	ands	r4, ip, r1, lsr #20
   1c124:	101c5a23 	andsne	r5, ip, r3, lsr #20
   1c128:	1134000c 	teqne	r4, ip
   1c12c:	1135000c 	teqne	r5, ip
   1c130:	0b00005c 	bleq	1c2a8 <__aeabi_ddiv+0x194>
   1c134:	e0444005 	sub	r4, r4, r5
   1c138:	e021e003 	eor	lr, r1, r3
   1c13c:	e1925603 	orrs	r5, r2, r3, lsl #12
   1c140:	e1a01601 	lsl	r1, r1, #12
   1c144:	0a00004b 	beq	1c278 <__aeabi_ddiv+0x164>
   1c148:	e1a03603 	lsl	r3, r3, #12
   1c14c:	e3a05201 	mov	r5, #268435456	; 0x10000000
   1c150:	e1853223 	orr	r3, r5, r3, lsr #4
   1c154:	e1833c22 	orr	r3, r3, r2, lsr #24
   1c158:	e1a02402 	lsl	r2, r2, #8
   1c15c:	e1855221 	orr	r5, r5, r1, lsr #4
   1c160:	e1855c20 	orr	r5, r5, r0, lsr #24
   1c164:	e1a06400 	lsl	r6, r0, #8
   1c168:	e20e1102 	and	r1, lr, #-2147483648	; 0x80000000
   1c16c:	e1550003 	cmp	r5, r3
   1c170:	01560002 	cmpeq	r6, r2
   1c174:	e2a440fd 	adc	r4, r4, #253	; 0xfd
   1c178:	e2844c03 	add	r4, r4, #768	; 0x300
   1c17c:	2a000001 	bcs	1c188 <__aeabi_ddiv+0x74>
   1c180:	e1b030a3 	lsrs	r3, r3, #1
   1c184:	e1a02062 	rrx	r2, r2
   1c188:	e0566002 	subs	r6, r6, r2
   1c18c:	e0c55003 	sbc	r5, r5, r3
   1c190:	e1b030a3 	lsrs	r3, r3, #1
   1c194:	e1a02062 	rrx	r2, r2
   1c198:	e3a00601 	mov	r0, #1048576	; 0x100000
   1c19c:	e3a0c702 	mov	ip, #524288	; 0x80000
   1c1a0:	e056e002 	subs	lr, r6, r2
   1c1a4:	e0d5e003 	sbcs	lr, r5, r3
   1c1a8:	20466002 	subcs	r6, r6, r2
   1c1ac:	21a0500e 	movcs	r5, lr
   1c1b0:	2180000c 	orrcs	r0, r0, ip
   1c1b4:	e1b030a3 	lsrs	r3, r3, #1
   1c1b8:	e1a02062 	rrx	r2, r2
   1c1bc:	e056e002 	subs	lr, r6, r2
   1c1c0:	e0d5e003 	sbcs	lr, r5, r3
   1c1c4:	20466002 	subcs	r6, r6, r2
   1c1c8:	21a0500e 	movcs	r5, lr
   1c1cc:	218000ac 	orrcs	r0, r0, ip, lsr #1
   1c1d0:	e1b030a3 	lsrs	r3, r3, #1
   1c1d4:	e1a02062 	rrx	r2, r2
   1c1d8:	e056e002 	subs	lr, r6, r2
   1c1dc:	e0d5e003 	sbcs	lr, r5, r3
   1c1e0:	20466002 	subcs	r6, r6, r2
   1c1e4:	21a0500e 	movcs	r5, lr
   1c1e8:	2180012c 	orrcs	r0, r0, ip, lsr #2
   1c1ec:	e1b030a3 	lsrs	r3, r3, #1
   1c1f0:	e1a02062 	rrx	r2, r2
   1c1f4:	e056e002 	subs	lr, r6, r2
   1c1f8:	e0d5e003 	sbcs	lr, r5, r3
   1c1fc:	20466002 	subcs	r6, r6, r2
   1c200:	21a0500e 	movcs	r5, lr
   1c204:	218001ac 	orrcs	r0, r0, ip, lsr #3
   1c208:	e195e006 	orrs	lr, r5, r6
   1c20c:	0a00000d 	beq	1c248 <__aeabi_ddiv+0x134>
   1c210:	e1a05205 	lsl	r5, r5, #4
   1c214:	e1855e26 	orr	r5, r5, r6, lsr #28
   1c218:	e1a06206 	lsl	r6, r6, #4
   1c21c:	e1a03183 	lsl	r3, r3, #3
   1c220:	e1833ea2 	orr	r3, r3, r2, lsr #29
   1c224:	e1a02182 	lsl	r2, r2, #3
   1c228:	e1b0c22c 	lsrs	ip, ip, #4
   1c22c:	1affffdb 	bne	1c1a0 <__aeabi_ddiv+0x8c>
   1c230:	e3110601 	tst	r1, #1048576	; 0x100000
   1c234:	1a000006 	bne	1c254 <__aeabi_ddiv+0x140>
   1c238:	e1811000 	orr	r1, r1, r0
   1c23c:	e3a00000 	mov	r0, #0
   1c240:	e3a0c102 	mov	ip, #-2147483648	; 0x80000000
   1c244:	eaffffd5 	b	1c1a0 <__aeabi_ddiv+0x8c>
   1c248:	e3110601 	tst	r1, #1048576	; 0x100000
   1c24c:	01811000 	orreq	r1, r1, r0
   1c250:	03a00000 	moveq	r0, #0
   1c254:	e254c0fd 	subs	ip, r4, #253	; 0xfd
   1c258:	835c0c07 	cmphi	ip, #1792	; 0x700
   1c25c:	8affff4a 	bhi	1bf8c <__aeabi_dmul+0xe4>
   1c260:	e055c003 	subs	ip, r5, r3
   1c264:	0056c002 	subseq	ip, r6, r2
   1c268:	01b0c0a0 	lsrseq	ip, r0, #1
   1c26c:	e2b00000 	adcs	r0, r0, #0
   1c270:	e0a11a04 	adc	r1, r1, r4, lsl #20
   1c274:	e8bd8070 	pop	{r4, r5, r6, pc}
   1c278:	e20ee102 	and	lr, lr, #-2147483648	; 0x80000000
   1c27c:	e18e1621 	orr	r1, lr, r1, lsr #12
   1c280:	e09440ac 	adds	r4, r4, ip, lsr #1
   1c284:	c074500c 	rsbsgt	r5, r4, ip
   1c288:	c1811a04 	orrgt	r1, r1, r4, lsl #20
   1c28c:	c8bd8070 	popgt	{r4, r5, r6, pc}
   1c290:	e3811601 	orr	r1, r1, #1048576	; 0x100000
   1c294:	e3a0e000 	mov	lr, #0
   1c298:	e2544001 	subs	r4, r4, #1
   1c29c:	eaffff3a 	b	1bf8c <__aeabi_dmul+0xe4>
   1c2a0:	e185e006 	orr	lr, r5, r6
   1c2a4:	eaffff38 	b	1bf8c <__aeabi_dmul+0xe4>
   1c2a8:	e00c5a23 	and	r5, ip, r3, lsr #20
   1c2ac:	e134000c 	teq	r4, ip
   1c2b0:	0135000c 	teqeq	r5, ip
   1c2b4:	0affff93 	beq	1c108 <__aeabi_dmul+0x260>
   1c2b8:	e134000c 	teq	r4, ip
   1c2bc:	1a000006 	bne	1c2dc <__aeabi_ddiv+0x1c8>
   1c2c0:	e1904601 	orrs	r4, r0, r1, lsl #12
   1c2c4:	1affff8f 	bne	1c108 <__aeabi_dmul+0x260>
   1c2c8:	e135000c 	teq	r5, ip
   1c2cc:	1affff87 	bne	1c0f0 <__aeabi_dmul+0x248>
   1c2d0:	e1a00002 	mov	r0, r2
   1c2d4:	e1a01003 	mov	r1, r3
   1c2d8:	eaffff8a 	b	1c108 <__aeabi_dmul+0x260>
   1c2dc:	e135000c 	teq	r5, ip
   1c2e0:	1a000004 	bne	1c2f8 <__aeabi_ddiv+0x1e4>
   1c2e4:	e1925603 	orrs	r5, r2, r3, lsl #12
   1c2e8:	0affff6d 	beq	1c0a4 <__aeabi_dmul+0x1fc>
   1c2ec:	e1a00002 	mov	r0, r2
   1c2f0:	e1a01003 	mov	r1, r3
   1c2f4:	eaffff83 	b	1c108 <__aeabi_dmul+0x260>
   1c2f8:	e1906081 	orrs	r6, r0, r1, lsl #1
   1c2fc:	11926083 	orrsne	r6, r2, r3, lsl #1
   1c300:	1affff4d 	bne	1c03c <__aeabi_dmul+0x194>
   1c304:	e1904081 	orrs	r4, r0, r1, lsl #1
   1c308:	1affff78 	bne	1c0f0 <__aeabi_dmul+0x248>
   1c30c:	e1925083 	orrs	r5, r2, r3, lsl #1
   1c310:	1affff63 	bne	1c0a4 <__aeabi_dmul+0x1fc>
   1c314:	eaffff7b 	b	1c108 <__aeabi_dmul+0x260>

0001c318 <__gedf2>:
   1c318:	e3e0c000 	mvn	ip, #0
   1c31c:	ea000002 	b	1c32c <__cmpdf2+0x4>

0001c320 <__ledf2>:
   1c320:	e3a0c001 	mov	ip, #1
   1c324:	ea000000 	b	1c32c <__cmpdf2+0x4>

0001c328 <__cmpdf2>:
   1c328:	e3a0c001 	mov	ip, #1
   1c32c:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
   1c330:	e1a0c081 	lsl	ip, r1, #1
   1c334:	e1f0cacc 	mvns	ip, ip, asr #21
   1c338:	e1a0c083 	lsl	ip, r3, #1
   1c33c:	11f0cacc 	mvnsne	ip, ip, asr #21
   1c340:	0a00000e 	beq	1c380 <__cmpdf2+0x58>
   1c344:	e28dd004 	add	sp, sp, #4
   1c348:	e190c081 	orrs	ip, r0, r1, lsl #1
   1c34c:	0192c083 	orrseq	ip, r2, r3, lsl #1
   1c350:	11310003 	teqne	r1, r3
   1c354:	01300002 	teqeq	r0, r2
   1c358:	03a00000 	moveq	r0, #0
   1c35c:	012fff1e 	bxeq	lr
   1c360:	e3700000 	cmn	r0, #0
   1c364:	e1310003 	teq	r1, r3
   1c368:	51510003 	cmppl	r1, r3
   1c36c:	01500002 	cmpeq	r0, r2
   1c370:	21a00fc3 	asrcs	r0, r3, #31
   1c374:	31e00fc3 	mvncc	r0, r3, asr #31
   1c378:	e3800001 	orr	r0, r0, #1
   1c37c:	e12fff1e 	bx	lr
   1c380:	e1a0c081 	lsl	ip, r1, #1
   1c384:	e1f0cacc 	mvns	ip, ip, asr #21
   1c388:	1a000001 	bne	1c394 <__cmpdf2+0x6c>
   1c38c:	e190c601 	orrs	ip, r0, r1, lsl #12
   1c390:	1a000004 	bne	1c3a8 <__cmpdf2+0x80>
   1c394:	e1a0c083 	lsl	ip, r3, #1
   1c398:	e1f0cacc 	mvns	ip, ip, asr #21
   1c39c:	1affffe8 	bne	1c344 <__cmpdf2+0x1c>
   1c3a0:	e192c603 	orrs	ip, r2, r3, lsl #12
   1c3a4:	0affffe6 	beq	1c344 <__cmpdf2+0x1c>
   1c3a8:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
   1c3ac:	e12fff1e 	bx	lr

0001c3b0 <__aeabi_cdrcmple>:
   1c3b0:	e1a0c000 	mov	ip, r0
   1c3b4:	e1a00002 	mov	r0, r2
   1c3b8:	e1a0200c 	mov	r2, ip
   1c3bc:	e1a0c001 	mov	ip, r1
   1c3c0:	e1a01003 	mov	r1, r3
   1c3c4:	e1a0300c 	mov	r3, ip
   1c3c8:	eaffffff 	b	1c3cc <__aeabi_cdcmpeq>

0001c3cc <__aeabi_cdcmpeq>:
   1c3cc:	e92d4001 	push	{r0, lr}
   1c3d0:	ebffffd4 	bl	1c328 <__cmpdf2>
   1c3d4:	e3500000 	cmp	r0, #0
   1c3d8:	43700000 	cmnmi	r0, #0
   1c3dc:	e8bd8001 	pop	{r0, pc}

0001c3e0 <__aeabi_dcmpeq>:
   1c3e0:	e52de008 	str	lr, [sp, #-8]!
   1c3e4:	ebfffff8 	bl	1c3cc <__aeabi_cdcmpeq>
   1c3e8:	03a00001 	moveq	r0, #1
   1c3ec:	13a00000 	movne	r0, #0
   1c3f0:	e49df008 	ldr	pc, [sp], #8

0001c3f4 <__aeabi_dcmplt>:
   1c3f4:	e52de008 	str	lr, [sp, #-8]!
   1c3f8:	ebfffff3 	bl	1c3cc <__aeabi_cdcmpeq>
   1c3fc:	33a00001 	movcc	r0, #1
   1c400:	23a00000 	movcs	r0, #0
   1c404:	e49df008 	ldr	pc, [sp], #8

0001c408 <__aeabi_dcmple>:
   1c408:	e52de008 	str	lr, [sp, #-8]!
   1c40c:	ebffffee 	bl	1c3cc <__aeabi_cdcmpeq>
   1c410:	93a00001 	movls	r0, #1
   1c414:	83a00000 	movhi	r0, #0
   1c418:	e49df008 	ldr	pc, [sp], #8

0001c41c <__aeabi_dcmpge>:
   1c41c:	e52de008 	str	lr, [sp, #-8]!
   1c420:	ebffffe2 	bl	1c3b0 <__aeabi_cdrcmple>
   1c424:	93a00001 	movls	r0, #1
   1c428:	83a00000 	movhi	r0, #0
   1c42c:	e49df008 	ldr	pc, [sp], #8

0001c430 <__aeabi_dcmpgt>:
   1c430:	e52de008 	str	lr, [sp, #-8]!
   1c434:	ebffffdd 	bl	1c3b0 <__aeabi_cdrcmple>
   1c438:	33a00001 	movcc	r0, #1
   1c43c:	23a00000 	movcs	r0, #0
   1c440:	e49df008 	ldr	pc, [sp], #8

0001c444 <__aeabi_d2iz>:
   1c444:	e1a02081 	lsl	r2, r1, #1
   1c448:	e2922602 	adds	r2, r2, #2097152	; 0x200000
   1c44c:	2a00000c 	bcs	1c484 <__aeabi_d2iz+0x40>
   1c450:	5a000009 	bpl	1c47c <__aeabi_d2iz+0x38>
   1c454:	e3e03e3e 	mvn	r3, #992	; 0x3e0
   1c458:	e0532ac2 	subs	r2, r3, r2, asr #21
   1c45c:	9a00000a 	bls	1c48c <__aeabi_d2iz+0x48>
   1c460:	e1a03581 	lsl	r3, r1, #11
   1c464:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
   1c468:	e1833aa0 	orr	r3, r3, r0, lsr #21
   1c46c:	e3110102 	tst	r1, #-2147483648	; 0x80000000
   1c470:	e1a00233 	lsr	r0, r3, r2
   1c474:	12600000 	rsbne	r0, r0, #0
   1c478:	e12fff1e 	bx	lr
   1c47c:	e3a00000 	mov	r0, #0
   1c480:	e12fff1e 	bx	lr
   1c484:	e1900601 	orrs	r0, r0, r1, lsl #12
   1c488:	1a000002 	bne	1c498 <__aeabi_d2iz+0x54>
   1c48c:	e2110102 	ands	r0, r1, #-2147483648	; 0x80000000
   1c490:	03e00102 	mvneq	r0, #-2147483648	; 0x80000000
   1c494:	e12fff1e 	bx	lr
   1c498:	e3a00000 	mov	r0, #0
   1c49c:	e12fff1e 	bx	lr

0001c4a0 <__aeabi_frsub>:
   1c4a0:	e2200102 	eor	r0, r0, #-2147483648	; 0x80000000
   1c4a4:	ea000000 	b	1c4ac <__addsf3>

0001c4a8 <__aeabi_fsub>:
   1c4a8:	e2211102 	eor	r1, r1, #-2147483648	; 0x80000000

0001c4ac <__addsf3>:
   1c4ac:	e1b02080 	lsls	r2, r0, #1
   1c4b0:	11b03081 	lslsne	r3, r1, #1
   1c4b4:	11320003 	teqne	r2, r3
   1c4b8:	11f0cc42 	mvnsne	ip, r2, asr #24
   1c4bc:	11f0cc43 	mvnsne	ip, r3, asr #24
   1c4c0:	0a00003c 	beq	1c5b8 <__addsf3+0x10c>
   1c4c4:	e1a02c22 	lsr	r2, r2, #24
   1c4c8:	e0723c23 	rsbs	r3, r2, r3, lsr #24
   1c4cc:	c0822003 	addgt	r2, r2, r3
   1c4d0:	c0201001 	eorgt	r1, r0, r1
   1c4d4:	c0210000 	eorgt	r0, r1, r0
   1c4d8:	c0201001 	eorgt	r1, r0, r1
   1c4dc:	b2633000 	rsblt	r3, r3, #0
   1c4e0:	e3530019 	cmp	r3, #25
   1c4e4:	812fff1e 	bxhi	lr
   1c4e8:	e3100102 	tst	r0, #-2147483648	; 0x80000000
   1c4ec:	e3800502 	orr	r0, r0, #8388608	; 0x800000
   1c4f0:	e3c004ff 	bic	r0, r0, #-16777216	; 0xff000000
   1c4f4:	12600000 	rsbne	r0, r0, #0
   1c4f8:	e3110102 	tst	r1, #-2147483648	; 0x80000000
   1c4fc:	e3811502 	orr	r1, r1, #8388608	; 0x800000
   1c500:	e3c114ff 	bic	r1, r1, #-16777216	; 0xff000000
   1c504:	12611000 	rsbne	r1, r1, #0
   1c508:	e1320003 	teq	r2, r3
   1c50c:	0a000023 	beq	1c5a0 <__addsf3+0xf4>
   1c510:	e2422001 	sub	r2, r2, #1
   1c514:	e0900351 	adds	r0, r0, r1, asr r3
   1c518:	e2633020 	rsb	r3, r3, #32
   1c51c:	e1a01311 	lsl	r1, r1, r3
   1c520:	e2003102 	and	r3, r0, #-2147483648	; 0x80000000
   1c524:	5a000001 	bpl	1c530 <__addsf3+0x84>
   1c528:	e2711000 	rsbs	r1, r1, #0
   1c52c:	e2e00000 	rsc	r0, r0, #0
   1c530:	e3500502 	cmp	r0, #8388608	; 0x800000
   1c534:	3a00000b 	bcc	1c568 <__addsf3+0xbc>
   1c538:	e3500401 	cmp	r0, #16777216	; 0x1000000
   1c53c:	3a000004 	bcc	1c554 <__addsf3+0xa8>
   1c540:	e1b000a0 	lsrs	r0, r0, #1
   1c544:	e1a01061 	rrx	r1, r1
   1c548:	e2822001 	add	r2, r2, #1
   1c54c:	e35200fe 	cmp	r2, #254	; 0xfe
   1c550:	2a00002d 	bcs	1c60c <__addsf3+0x160>
   1c554:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
   1c558:	e0a00b82 	adc	r0, r0, r2, lsl #23
   1c55c:	03c00001 	biceq	r0, r0, #1
   1c560:	e1800003 	orr	r0, r0, r3
   1c564:	e12fff1e 	bx	lr
   1c568:	e1b01081 	lsls	r1, r1, #1
   1c56c:	e0a00000 	adc	r0, r0, r0
   1c570:	e3100502 	tst	r0, #8388608	; 0x800000
   1c574:	e2422001 	sub	r2, r2, #1
   1c578:	1afffff5 	bne	1c554 <__addsf3+0xa8>
   1c57c:	e16fcf10 	clz	ip, r0
   1c580:	e24cc008 	sub	ip, ip, #8
   1c584:	e052200c 	subs	r2, r2, ip
   1c588:	e1a00c10 	lsl	r0, r0, ip
   1c58c:	a0800b82 	addge	r0, r0, r2, lsl #23
   1c590:	b2622000 	rsblt	r2, r2, #0
   1c594:	a1800003 	orrge	r0, r0, r3
   1c598:	b1830230 	orrlt	r0, r3, r0, lsr r2
   1c59c:	e12fff1e 	bx	lr
   1c5a0:	e3320000 	teq	r2, #0
   1c5a4:	e2211502 	eor	r1, r1, #8388608	; 0x800000
   1c5a8:	02200502 	eoreq	r0, r0, #8388608	; 0x800000
   1c5ac:	02822001 	addeq	r2, r2, #1
   1c5b0:	12433001 	subne	r3, r3, #1
   1c5b4:	eaffffd5 	b	1c510 <__addsf3+0x64>
   1c5b8:	e1a03081 	lsl	r3, r1, #1
   1c5bc:	e1f0cc42 	mvns	ip, r2, asr #24
   1c5c0:	11f0cc43 	mvnsne	ip, r3, asr #24
   1c5c4:	0a000013 	beq	1c618 <__addsf3+0x16c>
   1c5c8:	e1320003 	teq	r2, r3
   1c5cc:	0a000002 	beq	1c5dc <__addsf3+0x130>
   1c5d0:	e3320000 	teq	r2, #0
   1c5d4:	01a00001 	moveq	r0, r1
   1c5d8:	e12fff1e 	bx	lr
   1c5dc:	e1300001 	teq	r0, r1
   1c5e0:	13a00000 	movne	r0, #0
   1c5e4:	112fff1e 	bxne	lr
   1c5e8:	e31204ff 	tst	r2, #-16777216	; 0xff000000
   1c5ec:	1a000002 	bne	1c5fc <__addsf3+0x150>
   1c5f0:	e1b00080 	lsls	r0, r0, #1
   1c5f4:	23800102 	orrcs	r0, r0, #-2147483648	; 0x80000000
   1c5f8:	e12fff1e 	bx	lr
   1c5fc:	e2922402 	adds	r2, r2, #33554432	; 0x2000000
   1c600:	32800502 	addcc	r0, r0, #8388608	; 0x800000
   1c604:	312fff1e 	bxcc	lr
   1c608:	e2003102 	and	r3, r0, #-2147483648	; 0x80000000
   1c60c:	e383047f 	orr	r0, r3, #2130706432	; 0x7f000000
   1c610:	e3800502 	orr	r0, r0, #8388608	; 0x800000
   1c614:	e12fff1e 	bx	lr
   1c618:	e1f02c42 	mvns	r2, r2, asr #24
   1c61c:	11a00001 	movne	r0, r1
   1c620:	01f03c43 	mvnseq	r3, r3, asr #24
   1c624:	11a01000 	movne	r1, r0
   1c628:	e1b02480 	lsls	r2, r0, #9
   1c62c:	01b03481 	lslseq	r3, r1, #9
   1c630:	01300001 	teqeq	r0, r1
   1c634:	13800501 	orrne	r0, r0, #4194304	; 0x400000
   1c638:	e12fff1e 	bx	lr

0001c63c <__aeabi_ui2f>:
   1c63c:	e3a03000 	mov	r3, #0
   1c640:	ea000001 	b	1c64c <__aeabi_i2f+0x8>

0001c644 <__aeabi_i2f>:
   1c644:	e2103102 	ands	r3, r0, #-2147483648	; 0x80000000
   1c648:	42600000 	rsbmi	r0, r0, #0
   1c64c:	e1b0c000 	movs	ip, r0
   1c650:	012fff1e 	bxeq	lr
   1c654:	e383344b 	orr	r3, r3, #1258291200	; 0x4b000000
   1c658:	e1a01000 	mov	r1, r0
   1c65c:	e3a00000 	mov	r0, #0
   1c660:	ea00000f 	b	1c6a4 <__aeabi_l2f+0x30>

0001c664 <__aeabi_ul2f>:
   1c664:	e1902001 	orrs	r2, r0, r1
   1c668:	012fff1e 	bxeq	lr
   1c66c:	e3a03000 	mov	r3, #0
   1c670:	ea000005 	b	1c68c <__aeabi_l2f+0x18>

0001c674 <__aeabi_l2f>:
   1c674:	e1902001 	orrs	r2, r0, r1
   1c678:	012fff1e 	bxeq	lr
   1c67c:	e2113102 	ands	r3, r1, #-2147483648	; 0x80000000
   1c680:	5a000001 	bpl	1c68c <__aeabi_l2f+0x18>
   1c684:	e2700000 	rsbs	r0, r0, #0
   1c688:	e2e11000 	rsc	r1, r1, #0
   1c68c:	e1b0c001 	movs	ip, r1
   1c690:	01a0c000 	moveq	ip, r0
   1c694:	01a01000 	moveq	r1, r0
   1c698:	03a00000 	moveq	r0, #0
   1c69c:	e383345b 	orr	r3, r3, #1526726656	; 0x5b000000
   1c6a0:	02433201 	subeq	r3, r3, #268435456	; 0x10000000
   1c6a4:	e2433502 	sub	r3, r3, #8388608	; 0x800000
   1c6a8:	e16f2f1c 	clz	r2, ip
   1c6ac:	e2522008 	subs	r2, r2, #8
   1c6b0:	e0433b82 	sub	r3, r3, r2, lsl #23
   1c6b4:	ba000006 	blt	1c6d4 <__aeabi_l2f+0x60>
   1c6b8:	e0833211 	add	r3, r3, r1, lsl r2
   1c6bc:	e1a0c210 	lsl	ip, r0, r2
   1c6c0:	e2622020 	rsb	r2, r2, #32
   1c6c4:	e35c0102 	cmp	ip, #-2147483648	; 0x80000000
   1c6c8:	e0a30230 	adc	r0, r3, r0, lsr r2
   1c6cc:	03c00001 	biceq	r0, r0, #1
   1c6d0:	e12fff1e 	bx	lr
   1c6d4:	e2822020 	add	r2, r2, #32
   1c6d8:	e1a0c211 	lsl	ip, r1, r2
   1c6dc:	e2622020 	rsb	r2, r2, #32
   1c6e0:	e190008c 	orrs	r0, r0, ip, lsl #1
   1c6e4:	e0a30231 	adc	r0, r3, r1, lsr r2
   1c6e8:	01c00fac 	biceq	r0, r0, ip, lsr #31
   1c6ec:	e12fff1e 	bx	lr

0001c6f0 <__gesf2>:
   1c6f0:	e3e0c000 	mvn	ip, #0
   1c6f4:	ea000002 	b	1c704 <__cmpsf2+0x4>

0001c6f8 <__lesf2>:
   1c6f8:	e3a0c001 	mov	ip, #1
   1c6fc:	ea000000 	b	1c704 <__cmpsf2+0x4>

0001c700 <__cmpsf2>:
   1c700:	e3a0c001 	mov	ip, #1
   1c704:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
   1c708:	e1a02080 	lsl	r2, r0, #1
   1c70c:	e1a03081 	lsl	r3, r1, #1
   1c710:	e1f0cc42 	mvns	ip, r2, asr #24
   1c714:	11f0cc43 	mvnsne	ip, r3, asr #24
   1c718:	0a000007 	beq	1c73c <__cmpsf2+0x3c>
   1c71c:	e28dd004 	add	sp, sp, #4
   1c720:	e192c0a3 	orrs	ip, r2, r3, lsr #1
   1c724:	11300001 	teqne	r0, r1
   1c728:	50520003 	subspl	r0, r2, r3
   1c72c:	81a00fc1 	asrhi	r0, r1, #31
   1c730:	31e00fc1 	mvncc	r0, r1, asr #31
   1c734:	13800001 	orrne	r0, r0, #1
   1c738:	e12fff1e 	bx	lr
   1c73c:	e1f0cc42 	mvns	ip, r2, asr #24
   1c740:	1a000001 	bne	1c74c <__cmpsf2+0x4c>
   1c744:	e1b0c480 	lsls	ip, r0, #9
   1c748:	1a000003 	bne	1c75c <__cmpsf2+0x5c>
   1c74c:	e1f0cc43 	mvns	ip, r3, asr #24
   1c750:	1afffff1 	bne	1c71c <__cmpsf2+0x1c>
   1c754:	e1b0c481 	lsls	ip, r1, #9
   1c758:	0affffef 	beq	1c71c <__cmpsf2+0x1c>
   1c75c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
   1c760:	e12fff1e 	bx	lr

0001c764 <__aeabi_cfrcmple>:
   1c764:	e1a0c000 	mov	ip, r0
   1c768:	e1a00001 	mov	r0, r1
   1c76c:	e1a0100c 	mov	r1, ip
   1c770:	eaffffff 	b	1c774 <__aeabi_cfcmpeq>

0001c774 <__aeabi_cfcmpeq>:
   1c774:	e92d400f 	push	{r0, r1, r2, r3, lr}
   1c778:	ebffffe0 	bl	1c700 <__cmpsf2>
   1c77c:	e3500000 	cmp	r0, #0
   1c780:	43700000 	cmnmi	r0, #0
   1c784:	e8bd800f 	pop	{r0, r1, r2, r3, pc}

0001c788 <__aeabi_fcmpeq>:
   1c788:	e52de008 	str	lr, [sp, #-8]!
   1c78c:	ebfffff8 	bl	1c774 <__aeabi_cfcmpeq>
   1c790:	03a00001 	moveq	r0, #1
   1c794:	13a00000 	movne	r0, #0
   1c798:	e49df008 	ldr	pc, [sp], #8

0001c79c <__aeabi_fcmplt>:
   1c79c:	e52de008 	str	lr, [sp, #-8]!
   1c7a0:	ebfffff3 	bl	1c774 <__aeabi_cfcmpeq>
   1c7a4:	33a00001 	movcc	r0, #1
   1c7a8:	23a00000 	movcs	r0, #0
   1c7ac:	e49df008 	ldr	pc, [sp], #8

0001c7b0 <__aeabi_fcmple>:
   1c7b0:	e52de008 	str	lr, [sp, #-8]!
   1c7b4:	ebffffee 	bl	1c774 <__aeabi_cfcmpeq>
   1c7b8:	93a00001 	movls	r0, #1
   1c7bc:	83a00000 	movhi	r0, #0
   1c7c0:	e49df008 	ldr	pc, [sp], #8

0001c7c4 <__aeabi_fcmpge>:
   1c7c4:	e52de008 	str	lr, [sp, #-8]!
   1c7c8:	ebffffe5 	bl	1c764 <__aeabi_cfrcmple>
   1c7cc:	93a00001 	movls	r0, #1
   1c7d0:	83a00000 	movhi	r0, #0
   1c7d4:	e49df008 	ldr	pc, [sp], #8

0001c7d8 <__aeabi_fcmpgt>:
   1c7d8:	e52de008 	str	lr, [sp, #-8]!
   1c7dc:	ebffffe0 	bl	1c764 <__aeabi_cfrcmple>
   1c7e0:	33a00001 	movcc	r0, #1
   1c7e4:	23a00000 	movcs	r0, #0
   1c7e8:	e49df008 	ldr	pc, [sp], #8
